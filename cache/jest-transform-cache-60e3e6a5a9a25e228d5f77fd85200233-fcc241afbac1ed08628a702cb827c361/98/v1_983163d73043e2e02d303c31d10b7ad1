ac77c531f39cc0abef7b1199c8f57f4a
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _rng = _interopRequireDefault(require("./rng.js"));
var _stringify = _interopRequireDefault(require("./stringify.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
let _nodeId;
let _clockseq; // Previous uuid creation time

let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng.default)();
    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.

  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval

  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested

  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }
  return buf || (0, _stringify.default)(b);
}
var _default = v1;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHQiLCJfcm5nIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfc3RyaW5naWZ5Iiwib2JqIiwiX19lc01vZHVsZSIsIl9ub2RlSWQiLCJfY2xvY2tzZXEiLCJfbGFzdE1TZWNzIiwiX2xhc3ROU2VjcyIsInYxIiwib3B0aW9ucyIsImJ1ZiIsIm9mZnNldCIsImkiLCJiIiwiQXJyYXkiLCJub2RlIiwiY2xvY2tzZXEiLCJ1bmRlZmluZWQiLCJzZWVkQnl0ZXMiLCJyYW5kb20iLCJybmciLCJtc2VjcyIsIkRhdGUiLCJub3ciLCJuc2VjcyIsImR0IiwiRXJyb3IiLCJ0bCIsInRtaCIsIm4iLCJfZGVmYXVsdCJdLCJzb3VyY2VzIjpbInYxLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3JuZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcm5nLmpzXCIpKTtcblxudmFyIF9zdHJpbmdpZnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3N0cmluZ2lmeS5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vICoqYHYxKClgIC0gR2VuZXJhdGUgdGltZS1iYXNlZCBVVUlEKipcbi8vXG4vLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vTGlvc0svVVVJRC5qc1xuLy8gYW5kIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS91dWlkLmh0bWxcbmxldCBfbm9kZUlkO1xuXG5sZXQgX2Nsb2Nrc2VxOyAvLyBQcmV2aW91cyB1dWlkIGNyZWF0aW9uIHRpbWVcblxuXG5sZXQgX2xhc3RNU2VjcyA9IDA7XG5sZXQgX2xhc3ROU2VjcyA9IDA7IC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQgZm9yIEFQSSBkZXRhaWxzXG5cbmZ1bmN0aW9uIHYxKG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGxldCBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuICBjb25zdCBiID0gYnVmIHx8IG5ldyBBcnJheSgxNik7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBsZXQgbm9kZSA9IG9wdGlvbnMubm9kZSB8fCBfbm9kZUlkO1xuICBsZXQgY2xvY2tzZXEgPSBvcHRpb25zLmNsb2Nrc2VxICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsb2Nrc2VxIDogX2Nsb2Nrc2VxOyAvLyBub2RlIGFuZCBjbG9ja3NlcSBuZWVkIHRvIGJlIGluaXRpYWxpemVkIHRvIHJhbmRvbSB2YWx1ZXMgaWYgdGhleSdyZSBub3RcbiAgLy8gc3BlY2lmaWVkLiAgV2UgZG8gdGhpcyBsYXppbHkgdG8gbWluaW1pemUgaXNzdWVzIHJlbGF0ZWQgdG8gaW5zdWZmaWNpZW50XG4gIC8vIHN5c3RlbSBlbnRyb3B5LiAgU2VlICMxODlcblxuICBpZiAobm9kZSA9PSBudWxsIHx8IGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICBjb25zdCBzZWVkQnl0ZXMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgX3JuZy5kZWZhdWx0KSgpO1xuXG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuNSwgY3JlYXRlIGFuZCA0OC1iaXQgbm9kZSBpZCwgKDQ3IHJhbmRvbSBiaXRzICsgbXVsdGljYXN0IGJpdCA9IDEpXG4gICAgICBub2RlID0gX25vZGVJZCA9IFtzZWVkQnl0ZXNbMF0gfCAweDAxLCBzZWVkQnl0ZXNbMV0sIHNlZWRCeXRlc1syXSwgc2VlZEJ5dGVzWzNdLCBzZWVkQnl0ZXNbNF0sIHNlZWRCeXRlc1s1XV07XG4gICAgfVxuXG4gICAgaWYgKGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjIuMiwgcmFuZG9taXplICgxNCBiaXQpIGNsb2Nrc2VxXG4gICAgICBjbG9ja3NlcSA9IF9jbG9ja3NlcSA9IChzZWVkQnl0ZXNbNl0gPDwgOCB8IHNlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG4gICAgfVxuICB9IC8vIFVVSUQgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gIC8vICgxNTgyLTEwLTE1IDAwOjAwKS4gIEpTTnVtYmVycyBhcmVuJ3QgcHJlY2lzZSBlbm91Z2ggZm9yIHRoaXMsIHNvXG4gIC8vIHRpbWUgaXMgaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuXG5cbiAgbGV0IG1zZWNzID0gb3B0aW9ucy5tc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tc2VjcyA6IERhdGUubm93KCk7IC8vIFBlciA0LjIuMS4yLCB1c2UgY291bnQgb2YgdXVpZCdzIGdlbmVyYXRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgY2xvY2tcbiAgLy8gY3ljbGUgdG8gc2ltdWxhdGUgaGlnaGVyIHJlc29sdXRpb24gY2xvY2tcblxuICBsZXQgbnNlY3MgPSBvcHRpb25zLm5zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5zZWNzIDogX2xhc3ROU2VjcyArIDE7IC8vIFRpbWUgc2luY2UgbGFzdCB1dWlkIGNyZWF0aW9uIChpbiBtc2VjcylcblxuICBjb25zdCBkdCA9IG1zZWNzIC0gX2xhc3RNU2VjcyArIChuc2VjcyAtIF9sYXN0TlNlY3MpIC8gMTAwMDA7IC8vIFBlciA0LjIuMS4yLCBCdW1wIGNsb2Nrc2VxIG9uIGNsb2NrIHJlZ3Jlc3Npb25cblxuICBpZiAoZHQgPCAwICYmIG9wdGlvbnMuY2xvY2tzZXEgPT09IHVuZGVmaW5lZCkge1xuICAgIGNsb2Nrc2VxID0gY2xvY2tzZXEgKyAxICYgMHgzZmZmO1xuICB9IC8vIFJlc2V0IG5zZWNzIGlmIGNsb2NrIHJlZ3Jlc3NlcyAobmV3IGNsb2Nrc2VxKSBvciB3ZSd2ZSBtb3ZlZCBvbnRvIGEgbmV3XG4gIC8vIHRpbWUgaW50ZXJ2YWxcblxuXG4gIGlmICgoZHQgPCAwIHx8IG1zZWNzID4gX2xhc3RNU2VjcykgJiYgb3B0aW9ucy5uc2VjcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbnNlY3MgPSAwO1xuICB9IC8vIFBlciA0LjIuMS4yIFRocm93IGVycm9yIGlmIHRvbyBtYW55IHV1aWRzIGFyZSByZXF1ZXN0ZWRcblxuXG4gIGlmIChuc2VjcyA+PSAxMDAwMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInV1aWQudjEoKTogQ2FuJ3QgY3JlYXRlIG1vcmUgdGhhbiAxME0gdXVpZHMvc2VjXCIpO1xuICB9XG5cbiAgX2xhc3RNU2VjcyA9IG1zZWNzO1xuICBfbGFzdE5TZWNzID0gbnNlY3M7XG4gIF9jbG9ja3NlcSA9IGNsb2Nrc2VxOyAvLyBQZXIgNC4xLjQgLSBDb252ZXJ0IGZyb20gdW5peCBlcG9jaCB0byBHcmVnb3JpYW4gZXBvY2hcblxuICBtc2VjcyArPSAxMjIxOTI5MjgwMDAwMDsgLy8gYHRpbWVfbG93YFxuXG4gIGNvbnN0IHRsID0gKChtc2VjcyAmIDB4ZmZmZmZmZikgKiAxMDAwMCArIG5zZWNzKSAlIDB4MTAwMDAwMDAwO1xuICBiW2krK10gPSB0bCA+Pj4gMjQgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gMTYgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsICYgMHhmZjsgLy8gYHRpbWVfbWlkYFxuXG4gIGNvbnN0IHRtaCA9IG1zZWNzIC8gMHgxMDAwMDAwMDAgKiAxMDAwMCAmIDB4ZmZmZmZmZjtcbiAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdG1oICYgMHhmZjsgLy8gYHRpbWVfaGlnaF9hbmRfdmVyc2lvbmBcblxuICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG5cbiAgYltpKytdID0gdG1oID4+PiAxNiAmIDB4ZmY7IC8vIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYCAoUGVyIDQuMi4yIC0gaW5jbHVkZSB2YXJpYW50KVxuXG4gIGJbaSsrXSA9IGNsb2Nrc2VxID4+PiA4IHwgMHg4MDsgLy8gYGNsb2NrX3NlcV9sb3dgXG5cbiAgYltpKytdID0gY2xvY2tzZXEgJiAweGZmOyAvLyBgbm9kZWBcblxuICBmb3IgKGxldCBuID0gMDsgbiA8IDY7ICsrbikge1xuICAgIGJbaSArIG5dID0gbm9kZVtuXTtcbiAgfVxuXG4gIHJldHVybiBidWYgfHwgKDAsIF9zdHJpbmdpZnkuZGVmYXVsdCkoYik7XG59XG5cbnZhciBfZGVmYXVsdCA9IHYxO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7Il0sIm1hcHBpbmdzIjoiQUFBQSxZQUFZOztBQUVaQSxNQUFNLENBQUNDLGNBQWMsQ0FBQ0MsT0FBTyxFQUFFLFlBQVksRUFBRTtFQUMzQ0MsS0FBSyxFQUFFO0FBQ1QsQ0FBQyxDQUFDO0FBQ0ZELE9BQU8sQ0FBQ0UsT0FBTyxHQUFHLEtBQUssQ0FBQztBQUV4QixJQUFJQyxJQUFJLEdBQUdDLHNCQUFzQixDQUFDQyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7QUFFdEQsSUFBSUMsVUFBVSxHQUFHRixzQkFBc0IsQ0FBQ0MsT0FBTyxDQUFDLGdCQUFnQixDQUFDLENBQUM7QUFFbEUsU0FBU0Qsc0JBQXNCQSxDQUFDRyxHQUFHLEVBQUU7RUFBRSxPQUFPQSxHQUFHLElBQUlBLEdBQUcsQ0FBQ0MsVUFBVSxHQUFHRCxHQUFHLEdBQUc7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