a7f21f74ed1f8e7a864477eb71cc7cae
/**
 * @remix-run/router v1.4.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

////////////////////////////////////////////////////////////////////////////////
//#region Types and Constants
////////////////////////////////////////////////////////////////////////////////

/**
 * Actions represent the type of change to a location value.
 */
exports.Action = void 0;
/**
 * The pathname, search, and hash values of a URL.
 */

(function (Action) {
  Action["Pop"] = "POP";
  Action["Push"] = "PUSH";
  Action["Replace"] = "REPLACE";
})(exports.Action || (exports.Action = {}));
const PopStateEventType = "popstate"; //#endregion
////////////////////////////////////////////////////////////////////////////////
//#region Memory History
////////////////////////////////////////////////////////////////////////////////

/**
 * A user-supplied object that describes a location. Used when providing
 * entries to `createMemoryHistory` via its `initialEntries` option.
 */

/**
 * Memory history stores the current location in memory. It is designed for use
 * in stateful non-browser environments like tests and React Native.
 */
function createMemoryHistory(options) {
  if (options === void 0) {
    options = {};
  }
  let {
    initialEntries = ["/"],
    initialIndex,
    v5Compat = false
  } = options;
  let entries; // Declare so we can access from createMemoryLocation

  entries = initialEntries.map((entry, index) => createMemoryLocation(entry, typeof entry === "string" ? null : entry.state, index === 0 ? "default" : undefined));
  let index = clampIndex(initialIndex == null ? entries.length - 1 : initialIndex);
  let action = exports.Action.Pop;
  let listener = null;
  function clampIndex(n) {
    return Math.min(Math.max(n, 0), entries.length - 1);
  }
  function getCurrentLocation() {
    return entries[index];
  }
  function createMemoryLocation(to, state, key) {
    if (state === void 0) {
      state = null;
    }
    let location = createLocation(entries ? getCurrentLocation().pathname : "/", to, state, key);
    warning(location.pathname.charAt(0) === "/", "relative pathnames are not supported in memory history: " + JSON.stringify(to));
    return location;
  }
  function createHref(to) {
    return typeof to === "string" ? to : createPath(to);
  }
  let history = {
    get index() {
      return index;
    },
    get action() {
      return action;
    },
    get location() {
      return getCurrentLocation();
    },
    createHref,
    createURL(to) {
      return new URL(createHref(to), "http://localhost");
    },
    encodeLocation(to) {
      let path = typeof to === "string" ? parsePath(to) : to;
      return {
        pathname: path.pathname || "",
        search: path.search || "",
        hash: path.hash || ""
      };
    },
    push(to, state) {
      action = exports.Action.Push;
      let nextLocation = createMemoryLocation(to, state);
      index += 1;
      entries.splice(index, entries.length, nextLocation);
      if (v5Compat && listener) {
        listener({
          action,
          location: nextLocation,
          delta: 1
        });
      }
    },
    replace(to, state) {
      action = exports.Action.Replace;
      let nextLocation = createMemoryLocation(to, state);
      entries[index] = nextLocation;
      if (v5Compat && listener) {
        listener({
          action,
          location: nextLocation,
          delta: 0
        });
      }
    },
    go(delta) {
      action = exports.Action.Pop;
      let nextIndex = clampIndex(index + delta);
      let nextLocation = entries[nextIndex];
      index = nextIndex;
      if (listener) {
        listener({
          action,
          location: nextLocation,
          delta
        });
      }
    },
    listen(fn) {
      listener = fn;
      return () => {
        listener = null;
      };
    }
  };
  return history;
} //#endregion
////////////////////////////////////////////////////////////////////////////////
//#region Browser History
////////////////////////////////////////////////////////////////////////////////

/**
 * A browser history stores the current location in regular URLs in a web
 * browser environment. This is the standard for most web apps and provides the
 * cleanest URLs the browser's address bar.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#browserhistory
 */

/**
 * Browser history stores the location in regular URLs. This is the standard for
 * most web apps, but it requires some configuration on the server to ensure you
 * serve the same app at multiple URLs.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory
 */
function createBrowserHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createBrowserLocation(window, globalHistory) {
    let {
      pathname,
      search,
      hash
    } = window.location;
    return createLocation("", {
      pathname,
      search,
      hash
    },
    // state defaults to `null` because `window.history.state` does
    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || "default");
  }
  function createBrowserHref(window, to) {
    return typeof to === "string" ? to : createPath(to);
  }
  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
} //#endregion
////////////////////////////////////////////////////////////////////////////////
//#region Hash History
////////////////////////////////////////////////////////////////////////////////

/**
 * A hash history stores the current location in the fragment identifier portion
 * of the URL in a web browser environment.
 *
 * This is ideal for apps that do not control the server for some reason
 * (because the fragment identifier is never sent to the server), including some
 * shared hosting environments that do not provide fine-grained controls over
 * which pages are served at which URLs.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#hashhistory
 */

/**
 * Hash history stores the location in window.location.hash. This makes it ideal
 * for situations where you don't want to send the location to the server for
 * some reason, either because you do cannot configure it or the URL space is
 * reserved for something else.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory
 */
function createHashHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createHashLocation(window, globalHistory) {
    let {
      pathname = "/",
      search = "",
      hash = ""
    } = parsePath(window.location.hash.substr(1));
    return createLocation("", {
      pathname,
      search,
      hash
    },
    // state defaults to `null` because `window.history.state` does
    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || "default");
  }
  function createHashHref(window, to) {
    let base = window.document.querySelector("base");
    let href = "";
    if (base && base.getAttribute("href")) {
      let url = window.location.href;
      let hashIndex = url.indexOf("#");
      href = hashIndex === -1 ? url : url.slice(0, hashIndex);
    }
    return href + "#" + (typeof to === "string" ? to : createPath(to));
  }
  function validateHashLocation(location, to) {
    warning(location.pathname.charAt(0) === "/", "relative pathnames are not supported in hash history.push(" + JSON.stringify(to) + ")");
  }
  return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);
} //#endregion
////////////////////////////////////////////////////////////////////////////////
//#region UTILS
////////////////////////////////////////////////////////////////////////////////

/**
 * @private
 */

function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function warning(cond, message) {
  if (!cond) {
    // eslint-disable-next-line no-console
    if (typeof console !== "undefined") console.warn(message);
    try {
      // Welcome to debugging history!
      //
      // This error is thrown as a convenience so you can more easily
      // find the source for a warning that appears in the console by
      // enabling "pause on exceptions" in your JavaScript debugger.
      throw new Error(message); // eslint-disable-next-line no-empty
    } catch (e) {}
  }
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
/**
 * For browser-based histories, we combine the state and key into an object
 */

function getHistoryState(location, index) {
  return {
    usr: location.state,
    key: location.key,
    idx: index
  };
}
/**
 * Creates a Location object with a unique key from the given Path
 */

function createLocation(current, to, state, key) {
  if (state === void 0) {
    state = null;
  }
  let location = _extends({
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to === "string" ? parsePath(to) : to, {
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to && to.key || key || createKey()
  });
  return location;
}
/**
 * Creates a string URL path from the given pathname, search, and hash components.
 */

function createPath(_ref) {
  let {
    pathname = "/",
    search = "",
    hash = ""
  } = _ref;
  if (search && search !== "?") pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash && hash !== "#") pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
  return pathname;
}
/**
 * Parses a string URL path into its separate pathname, search, and hash components.
 */

function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
  if (options === void 0) {
    options = {};
  }
  let {
    window = document.defaultView,
    v5Compat = false
  } = options;
  let globalHistory = window.history;
  let action = exports.Action.Pop;
  let listener = null;
  let index = getIndex(); // Index should only be null when we initialize. If not, it's because the
  // user called history.pushState or history.replaceState directly, in which
  // case we should log a warning as it will result in bugs.

  if (index == null) {
    index = 0;
    globalHistory.replaceState(_extends({}, globalHistory.state, {
      idx: index
    }), "");
  }
  function getIndex() {
    let state = globalHistory.state || {
      idx: null
    };
    return state.idx;
  }
  function handlePop() {
    action = exports.Action.Pop;
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index;
    index = nextIndex;
    if (listener) {
      listener({
        action,
        location: history.location,
        delta
      });
    }
  }
  function push(to, state) {
    action = exports.Action.Push;
    let location = createLocation(history.location, to, state);
    if (validateLocation) validateLocation(location, to);
    index = getIndex() + 1;
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location); // try...catch because iOS limits us to 100 pushState calls :/

    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error) {
      // They are going to lose state here, but there is no real
      // way to warn them about it since the page will refresh...
      window.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 1
      });
    }
  }
  function replace(to, state) {
    action = exports.Action.Replace;
    let location = createLocation(history.location, to, state);
    if (validateLocation) validateLocation(location, to);
    index = getIndex();
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 0
      });
    }
  }
  function createURL(to) {
    // window.location.origin is "null" (the literal string value) in Firefox
    // under certain conditions, notably when serving from a local HTML file
    // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297
    let base = window.location.origin !== "null" ? window.location.origin : window.location.href;
    let href = typeof to === "string" ? to : createPath(to);
    invariant(base, "No window.location.(origin|href) available to create URL for href: " + href);
    return new URL(href, base);
  }
  let history = {
    get action() {
      return action;
    },
    get location() {
      return getLocation(window, globalHistory);
    },
    listen(fn) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window.addEventListener(PopStateEventType, handlePop);
      listener = fn;
      return () => {
        window.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to) {
      return createHref(window, to);
    },
    createURL,
    encodeLocation(to) {
      // Encode a Location the same way window.location would
      let url = createURL(to);
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      };
    },
    push,
    replace,
    go(n) {
      return globalHistory.go(n);
    }
  };
  return history;
} //#endregion

/**
 * Map of routeId -> data returned from a loader/action/error
 */

let ResultType;
/**
 * Successful result from a loader or action
 */

(function (ResultType) {
  ResultType["data"] = "data";
  ResultType["deferred"] = "deferred";
  ResultType["redirect"] = "redirect";
  ResultType["error"] = "error";
})(ResultType || (ResultType = {}));
const immutableRouteKeys = new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);
/**
 * lazy() function to load a route definition, which can add non-matching
 * related properties to a route
 */

function isIndexRoute(route) {
  return route.index === true;
} // Walk the route tree generating unique IDs where necessary so we are working
// solely with AgnosticDataRouteObject's within the Router

function convertRoutesToDataRoutes(routes, detectErrorBoundary, parentPath, manifest) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  if (manifest === void 0) {
    manifest = {};
  }
  return routes.map((route, index) => {
    let treePath = [...parentPath, index];
    let id = typeof route.id === "string" ? route.id : treePath.join("-");
    invariant(route.index !== true || !route.children, "Cannot specify children on an index route");
    invariant(!manifest[id], "Found a route id collision on id \"" + id + "\".  Route " + "id's must be globally unique within Data Router usages");
    if (isIndexRoute(route)) {
      let indexRoute = _extends({}, route, {
        hasErrorBoundary: detectErrorBoundary(route),
        id
      });
      manifest[id] = indexRoute;
      return indexRoute;
    } else {
      let pathOrLayoutRoute = _extends({}, route, {
        id,
        hasErrorBoundary: detectErrorBoundary(route),
        children: undefined
      });
      manifest[id] = pathOrLayoutRoute;
      if (route.children) {
        pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, detectErrorBoundary, treePath, manifest);
      }
      return pathOrLayoutRoute;
    }
  });
}
/**
 * Matches the given routes to a location and returns the match data.
 *
 * @see https://reactrouter.com/utils/match-routes
 */

function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i = 0; matches == null && i < branches.length; ++i) {
    matches = matchRouteBranch(branches[i],
    // Incoming pathnames are generally encoded from either window.location
    // or from router.navigate, but we want to match against the unencoded
    // paths in the route definitions.  Memory router locations won't be
    // encoded here but there also shouldn't be anything to decode so this
    // should be a safe operation.  This avoids needing matchRoutes to be
    // history-aware.
    safelyDecodeURI(pathname));
  }
  return matches;
}
function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  let flattenRoute = (route, index, relativePath) => {
    let meta = {
      relativePath: relativePath === undefined ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      invariant(meta.relativePath.startsWith(parentPath), "Absolute route path \"" + meta.relativePath + "\" nested under path " + ("\"" + parentPath + "\" is not valid. An absolute child route path ") + "must start with the combined path of all its parent routes.");
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta); // Add the children before adding this route to the array so we traverse the
    // route tree depth-first and child routes appear before their parents in
    // the "flattened" version.

    if (route.children && route.children.length > 0) {
      invariant(
      // Our types know better, but runtime JS may not!
      // @ts-expect-error
      route.index !== true, "Index routes must not have child routes. Please remove " + ("all child routes from route path \"" + path + "\"."));
      flattenRoutes(route.children, branches, routesMeta, path);
    } // Routes without a path shouldn't ever match by themselves unless they are
    // index routes, so don't add them to the list of possible branches.

    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  };
  routes.forEach((route, index) => {
    var _route$path;

    // coarse-grain check for optional params
    if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {
      flattenRoute(route, index);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index, exploded);
      }
    }
  });
  return branches;
}
/**
 * Computes all combinations of optional path segments for a given path,
 * excluding combinations that are ambiguous and of lower priority.
 *
 * For example, `/one/:two?/three/:four?/:five?` explodes to:
 * - `/one/three`
 * - `/one/:two/three`
 * - `/one/three/:four`
 * - `/one/three/:five`
 * - `/one/:two/three/:four`
 * - `/one/:two/three/:five`
 * - `/one/three/:four/:five`
 * - `/one/:two/three/:four/:five`
 */

function explodeOptionalSegments(path) {
  let segments = path.split("/");
  if (segments.length === 0) return [];
  let [first, ...rest] = segments; // Optional path segments are denoted by a trailing `?`

  let isOptional = first.endsWith("?"); // Compute the corresponding required segment: `foo?` -> `foo`

  let required = first.replace(/\?$/, "");
  if (rest.length === 0) {
    // Intepret empty string as omitting an optional segment
    // `["one", "", "three"]` corresponds to omitting `:two` from `/one/:two?/three` -> `/one/three`
    return isOptional ? [required, ""] : [required];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = []; // All child paths with the prefix.  Do this for all children before the
  // optional version for all children so we get consistent ordering where the
  // parent optional aspect is preferred as required.  Otherwise, we can get
  // child sections interspersed where deeper optional segments are higher than
  // parent optional segments, where for example, /:two would explodes _earlier_
  // then /:one.  By always including the parent as required _for all children_
  // first, we avoid this issue

  result.push(...restExploded.map(subpath => subpath === "" ? required : [required, subpath].join("/"))); // Then if this is an optional value, add all child versions without

  if (isOptional) {
    result.push(...restExploded);
  } // for absolute paths, ensure `/` instead of empty segment

  return result.map(exploded => path.startsWith("/") && exploded === "" ? "/" : exploded);
}
function rankRouteBranches(branches) {
  branches.sort((a, b) => a.score !== b.score ? b.score - a.score // Higher score first
  : compareIndexes(a.routesMeta.map(meta => meta.childrenIndex), b.routesMeta.map(meta => meta.childrenIndex)));
}
const paramRe = /^:\w+$/;
const dynamicSegmentValue = 3;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;
const isSplat = s => s === "*";
function computeScore(path, index) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index) {
    initialScore += indexRouteValue;
  }
  return segments.filter(s => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a, b) {
  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
  return siblings ?
  // If two routes are siblings, we should try to match the earlier sibling
  // first. This allows people to have fine-grained control over the matching
  // behavior by simply putting routes with identical paths in the order they
  // want them tried.
  a[a.length - 1] - b[b.length - 1] :
  // Otherwise, it doesn't really make sense to rank non-siblings by index,
  // so they sort equally.
  0;
}
function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i = 0; i < routesMeta.length; ++i) {
    let meta = routesMeta[i];
    let end = i === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end
    }, remainingPathname);
    if (!match) return null;
    Object.assign(matchedParams, match.params);
    let route = meta.route;
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),
      route
    });
    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }
  return matches;
}
/**
 * Returns a path with params interpolated.
 *
 * @see https://reactrouter.com/utils/generate-path
 */

function generatePath(originalPath, params) {
  if (params === void 0) {
    params = {};
  }
  let path = originalPath;
  if (path.endsWith("*") && path !== "*" && !path.endsWith("/*")) {
    warning(false, "Route path \"" + path + "\" will be treated as if it were " + ("\"" + path.replace(/\*$/, "/*") + "\" because the `*` character must ") + "always follow a `/` in the pattern. To get rid of this warning, " + ("please change the route path to \"" + path.replace(/\*$/, "/*") + "\"."));
    path = path.replace(/\*$/, "/*");
  } // ensure `/` is added at the beginning if the path is absolute

  const prefix = path.startsWith("/") ? "/" : "";
  const segments = path.split(/\/+/).map((segment, index, array) => {
    const isLastSegment = index === array.length - 1; // only apply the splat if it's the last segment

    if (isLastSegment && segment === "*") {
      const star = "*";
      const starParam = params[star]; // Apply the splat

      return starParam;
    }
    const keyMatch = segment.match(/^:(\w+)(\??)$/);
    if (keyMatch) {
      const [, key, optional] = keyMatch;
      let param = params[key];
      if (optional === "?") {
        return param == null ? "" : param;
      }
      if (param == null) {
        invariant(false, "Missing \":" + key + "\" param");
      }
      return param;
    } // Remove any optional markers from optional static segments

    return segment.replace(/\?$/g, "");
  }) // Remove empty segments
  .filter(segment => !!segment);
  return prefix + segments.join("/");
}
/**
 * A PathPattern is used to match on some portion of a URL pathname.
 */

/**
 * Performs pattern matching on a URL pathname and returns information about
 * the match.
 *
 * @see https://reactrouter.com/utils/match-path
 */
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match = pathname.match(matcher);
  if (!match) return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = paramNames.reduce((memo, paramName, index) => {
    // We need to compute the pathnameBase here using the raw splat value
    // instead of using params["*"] later because it will be decoded then
    if (paramName === "*") {
      let splatValue = captureGroups[index] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    memo[paramName] = safelyDecodeURIComponent(captureGroups[index] || "", paramName);
    return memo;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive, end) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end === void 0) {
    end = true;
  }
  warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), "Route path \"" + path + "\" will be treated as if it were " + ("\"" + path.replace(/\*$/, "/*") + "\" because the `*` character must ") + "always follow a `/` in the pattern. To get rid of this warning, " + ("please change the route path to \"" + path.replace(/\*$/, "/*") + "\"."));
  let paramNames = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "") // Ignore trailing / and /*, we'll handle it below
  .replace(/^\/*/, "/") // Make sure it has a leading /
  .replace(/[\\.*+^$?{}|()[\]]/g, "\\$&") // Escape special regex chars
  .replace(/\/:(\w+)/g, (_, paramName) => {
    paramNames.push(paramName);
    return "/([^\\/]+)";
  });
  if (path.endsWith("*")) {
    paramNames.push("*");
    regexpSource += path === "*" || path === "/*" ? "(.*)$" // Already matched the initial /, just match the rest
    : "(?:\\/(.+)|\\/*)$"; // Don't include the / in params["*"]
  } else if (end) {
    // When matching to the end, ignore trailing slashes
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    // If our path is non-empty and contains anything beyond an initial slash,
    // then we have _some_ form of path in our regex so we should expect to
    // match only if we find the end of this path segment.  Look for an optional
    // non-captured trailing slash (to match a portion of the URL) or the end
    // of the path (if we've matched to the end).  We used to do this with a
    // word boundary but that gives false positives on routes like
    // /user-preferences since `-` counts as a word boundary.
    regexpSource += "(?:(?=\\/|$))";
  } else ;
  let matcher = new RegExp(regexpSource, caseSensitive ? undefined : "i");
  return [matcher, paramNames];
}
function safelyDecodeURI(value) {
  try {
    return decodeURI(value);
  } catch (error) {
    warning(false, "The URL path \"" + value + "\" could not be decoded because it is is a " + "malformed URL segment. This is probably due to a bad percent " + ("encoding (" + error + ")."));
    return value;
  }
}
function safelyDecodeURIComponent(value, paramName) {
  try {
    return decodeURIComponent(value);
  } catch (error) {
    warning(false, "The value for the URL param \"" + paramName + "\" will not be decoded because" + (" the string \"" + value + "\" is a malformed URL segment. This is probably") + (" due to a bad percent encoding (" + error + ")."));
    return value;
  }
}
/**
 * @private
 */

function stripBasename(pathname, basename) {
  if (basename === "/") return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  } // We want to leave trailing slash behavior in the user's control, so if they
  // specify a basename with a trailing slash, we should support it

  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    // pathname does not start with basename/
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
/**
 * Returns a resolved path object relative to the given pathname.
 *
 * @see https://reactrouter.com/utils/resolve-path
 */

function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach(segment => {
    if (segment === "..") {
      // Keep the root "" segment so the pathname starts at /
      if (segments.length > 1) segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char, field, dest, path) {
  return "Cannot include a '" + char + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + "a string in <Link to=\"...\"> and the router will parse it for you.";
}
/**
 * @private
 *
 * When processing relative navigation we want to ignore ancestor routes that
 * do not contribute to the path, such that index/pathless layout routes don't
 * interfere.
 *
 * For example, when moving a route element into an index route and/or a
 * pathless layout route, relative link behavior contained within should stay
 * the same.  Both of the following examples should link back to the root:
 *
 *   <Route path="/">
 *     <Route path="accounts" element={<Link to=".."}>
 *   </Route>
 *
 *   <Route path="/">
 *     <Route path="accounts">
 *       <Route element={<AccountsLayout />}>       // <-- Does not contribute
 *         <Route index element={<Link to=".."} />  // <-- Does not contribute
 *       </Route
 *     </Route>
 *   </Route>
 */

function getPathContributingMatches(matches) {
  return matches.filter((match, index) => index === 0 || match.route.path && match.route.path.length > 0);
}
/**
 * @private
 */

function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  if (isPathRelative === void 0) {
    isPathRelative = false;
  }
  let to;
  if (typeof toArg === "string") {
    to = parsePath(toArg);
  } else {
    to = _extends({}, toArg);
    invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
    invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
    invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
  }
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from; // Routing is relative to the current pathname if explicitly requested.
  //
  // If a pathname is explicitly provided in `to`, it should be relative to the
  // route context. This is explained in `Note on `<Link to>` values` in our
  // migration guide from v5 as a means of disambiguation between `to` values
  // that begin with `/` and those that do not. However, this is problematic for
  // `to` values that do not provide a pathname. `to` can simply be a search or
  // hash string, in which case we should assume that the navigation is relative
  // to the current location's pathname and *not* the route pathname.

  if (isPathRelative || toPathname == null) {
    from = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/"); // Each leading .. segment means "go up one route" instead of "go up one
      // URL segment".  This is a key difference from how <a href> works and a
      // major reason we call this a "to" value instead of a "href".

      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    } // If there are more ".." segments than parent routes, resolve relative to
    // the root / URL.

    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from); // Ensure the pathname has a trailing slash if the original "to" had one

  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/"); // Or if this was a link to the current path which has a trailing slash

  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}
/**
 * @private
 */

function getToPathname(to) {
  // Empty strings should be treated the same as / paths
  return to === "" || to.pathname === "" ? "/" : typeof to === "string" ? parsePath(to).pathname : to.pathname;
}
/**
 * @private
 */

const joinPaths = paths => paths.join("/").replace(/\/\/+/g, "/");
/**
 * @private
 */

const normalizePathname = pathname => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
/**
 * @private
 */

const normalizeSearch = search => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
/**
 * @private
 */

const normalizeHash = hash => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;

/**
 * This is a shortcut for creating `application/json` responses. Converts `data`
 * to JSON and sets the `Content-Type` header.
 */
const json = function json(data, init) {
  if (init === void 0) {
    init = {};
  }
  let responseInit = typeof init === "number" ? {
    status: init
  } : init;
  let headers = new Headers(responseInit.headers);
  if (!headers.has("Content-Type")) {
    headers.set("Content-Type", "application/json; charset=utf-8");
  }
  return new Response(JSON.stringify(data), _extends({}, responseInit, {
    headers
  }));
};
class AbortedDeferredError extends Error {}
class DeferredData {
  constructor(data, responseInit) {
    this.pendingKeysSet = new Set();
    this.subscribers = new Set();
    this.deferredKeys = [];
    invariant(data && typeof data === "object" && !Array.isArray(data), "defer() only accepts plain objects"); // Set up an AbortController + Promise we can race against to exit early
    // cancellation

    let reject;
    this.abortPromise = new Promise((_, r) => reject = r);
    this.controller = new AbortController();
    let onAbort = () => reject(new AbortedDeferredError("Deferred data aborted"));
    this.unlistenAbortSignal = () => this.controller.signal.removeEventListener("abort", onAbort);
    this.controller.signal.addEventListener("abort", onAbort);
    this.data = Object.entries(data).reduce((acc, _ref) => {
      let [key, value] = _ref;
      return Object.assign(acc, {
        [key]: this.trackPromise(key, value)
      });
    }, {});
    if (this.done) {
      // All incoming values were resolved
      this.unlistenAbortSignal();
    }
    this.init = responseInit;
  }
  trackPromise(key, value) {
    if (!(value instanceof Promise)) {
      return value;
    }
    this.deferredKeys.push(key);
    this.pendingKeysSet.add(key); // We store a little wrapper promise that will be extended with
    // _data/_error props upon resolve/reject

    let promise = Promise.race([value, this.abortPromise]).then(data => this.onSettle(promise, key, null, data), error => this.onSettle(promise, key, error)); // Register rejection listeners to avoid uncaught promise rejections on
    // errors or aborted deferred values

    promise.catch(() => {});
    Object.defineProperty(promise, "_tracked", {
      get: () => true
    });
    return promise;
  }
  onSettle(promise, key, error, data) {
    if (this.controller.signal.aborted && error instanceof AbortedDeferredError) {
      this.unlistenAbortSignal();
      Object.defineProperty(promise, "_error", {
        get: () => error
      });
      return Promise.reject(error);
    }
    this.pendingKeysSet.delete(key);
    if (this.done) {
      // Nothing left to abort!
      this.unlistenAbortSignal();
    }
    if (error) {
      Object.defineProperty(promise, "_error", {
        get: () => error
      });
      this.emit(false, key);
      return Promise.reject(error);
    }
    Object.defineProperty(promise, "_data", {
      get: () => data
    });
    this.emit(false, key);
    return data;
  }
  emit(aborted, settledKey) {
    this.subscribers.forEach(subscriber => subscriber(aborted, settledKey));
  }
  subscribe(fn) {
    this.subscribers.add(fn);
    return () => this.subscribers.delete(fn);
  }
  cancel() {
    this.controller.abort();
    this.pendingKeysSet.forEach((v, k) => this.pendingKeysSet.delete(k));
    this.emit(true);
  }
  async resolveData(signal) {
    let aborted = false;
    if (!this.done) {
      let onAbort = () => this.cancel();
      signal.addEventListener("abort", onAbort);
      aborted = await new Promise(resolve => {
        this.subscribe(aborted => {
          signal.removeEventListener("abort", onAbort);
          if (aborted || this.done) {
            resolve(aborted);
          }
        });
      });
    }
    return aborted;
  }
  get done() {
    return this.pendingKeysSet.size === 0;
  }
  get unwrappedData() {
    invariant(this.data !== null && this.done, "Can only unwrap data on initialized and settled deferreds");
    return Object.entries(this.data).reduce((acc, _ref2) => {
      let [key, value] = _ref2;
      return Object.assign(acc, {
        [key]: unwrapTrackedPromise(value)
      });
    }, {});
  }
  get pendingKeys() {
    return Array.from(this.pendingKeysSet);
  }
}
function isTrackedPromise(value) {
  return value instanceof Promise && value._tracked === true;
}
function unwrapTrackedPromise(value) {
  if (!isTrackedPromise(value)) {
    return value;
  }
  if (value._error) {
    throw value._error;
  }
  return value._data;
}
const defer = function defer(data, init) {
  if (init === void 0) {
    init = {};
  }
  let responseInit = typeof init === "number" ? {
    status: init
  } : init;
  return new DeferredData(data, responseInit);
};

/**
 * A redirect response. Sets the status code and the `Location` header.
 * Defaults to "302 Found".
 */
const redirect = function redirect(url, init) {
  if (init === void 0) {
    init = 302;
  }
  let responseInit = init;
  if (typeof responseInit === "number") {
    responseInit = {
      status: responseInit
    };
  } else if (typeof responseInit.status === "undefined") {
    responseInit.status = 302;
  }
  let headers = new Headers(responseInit.headers);
  headers.set("Location", url);
  return new Response(null, _extends({}, responseInit, {
    headers
  }));
};
/**
 * @private
 * Utility class we use to hold auto-unwrapped 4xx/5xx Response bodies
 */

class ErrorResponse {
  constructor(status, statusText, data, internal) {
    if (internal === void 0) {
      internal = false;
    }
    this.status = status;
    this.statusText = statusText || "";
    this.internal = internal;
    if (data instanceof Error) {
      this.data = data.toString();
      this.error = data;
    } else {
      this.data = data;
    }
  }
}
/**
 * Check if the given error is an ErrorResponse generated from a 4xx/5xx
 * Response thrown from an action/loader
 */

function isRouteErrorResponse(error) {
  return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
}

//#region Types and Constants
////////////////////////////////////////////////////////////////////////////////

/**
 * A Router instance manages all navigation and data loading/mutations
 */

const validMutationMethodsArr = ["post", "put", "patch", "delete"];
const validMutationMethods = new Set(validMutationMethodsArr);
const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
const validRequestMethods = new Set(validRequestMethodsArr);
const redirectStatusCodes = new Set([301, 302, 303, 307, 308]);
const redirectPreserveMethodStatusCodes = new Set([307, 308]);
const IDLE_NAVIGATION = {
  state: "idle",
  location: undefined,
  formMethod: undefined,
  formAction: undefined,
  formEncType: undefined,
  formData: undefined
};
const IDLE_FETCHER = {
  state: "idle",
  data: undefined,
  formMethod: undefined,
  formAction: undefined,
  formEncType: undefined,
  formData: undefined
};
const IDLE_BLOCKER = {
  state: "unblocked",
  proceed: undefined,
  reset: undefined,
  location: undefined
};
const ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
const isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
const isServer = !isBrowser;
const defaultDetectErrorBoundary = route => Boolean(route.hasErrorBoundary); //#endregion
////////////////////////////////////////////////////////////////////////////////
//#region createRouter
////////////////////////////////////////////////////////////////////////////////

/**
 * Create a router and listen to history POP navigations
 */

function createRouter(init) {
  invariant(init.routes.length > 0, "You must provide a non-empty routes array to createRouter");
  let detectErrorBoundary = init.detectErrorBoundary || defaultDetectErrorBoundary; // Routes keyed by ID

  let manifest = {}; // Routes in tree format for matching

  let dataRoutes = convertRoutesToDataRoutes(init.routes, detectErrorBoundary, undefined, manifest);
  let inFlightDataRoutes; // Cleanup function for history

  let unlistenHistory = null; // Externally-provided functions to call on all state changes

  let subscribers = new Set(); // Externally-provided object to hold scroll restoration locations during routing

  let savedScrollPositions = null; // Externally-provided function to get scroll restoration keys

  let getScrollRestorationKey = null; // Externally-provided function to get current scroll position

  let getScrollPosition = null; // One-time flag to control the initial hydration scroll restoration.  Because
  // we don't get the saved positions from <ScrollRestoration /> until _after_
  // the initial render, we need to manually trigger a separate updateState to
  // send along the restoreScrollPosition
  // Set to true if we have `hydrationData` since we assume we were SSR'd and that
  // SSR did the initial scroll restoration.

  let initialScrollRestored = init.hydrationData != null;
  let initialMatches = matchRoutes(dataRoutes, init.history.location, init.basename);
  let initialErrors = null;
  if (initialMatches == null) {
    // If we do not match a user-provided-route, fall back to the root
    // to allow the error boundary to take over
    let error = getInternalRouterError(404, {
      pathname: init.history.location.pathname
    });
    let {
      matches,
      route
    } = getShortCircuitMatches(dataRoutes);
    initialMatches = matches;
    initialErrors = {
      [route.id]: error
    };
  }
  let initialized =
  // All initialMatches need to be loaded before we're ready.  If we have lazy
  // functions around still then we'll need to run them in initialize()
  !initialMatches.some(m => m.route.lazy) && (
  // And we have to either have no loaders or have been provided hydrationData
  !initialMatches.some(m => m.route.loader) || init.hydrationData != null);
  let router;
  let state = {
    historyAction: init.history.action,
    location: init.history.location,
    matches: initialMatches,
    initialized,
    navigation: IDLE_NAVIGATION,
    // Don't restore on initial updateState() if we were SSR'd
    restoreScrollPosition: init.hydrationData != null ? false : null,
    preventScrollReset: false,
    revalidation: "idle",
    loaderData: init.hydrationData && init.hydrationData.loaderData || {},
    actionData: init.hydrationData && init.hydrationData.actionData || null,
    errors: init.hydrationData && init.hydrationData.errors || initialErrors,
    fetchers: new Map(),
    blockers: new Map()
  }; // -- Stateful internal variables to manage navigations --
  // Current navigation in progress (to be committed in completeNavigation)

  let pendingAction = exports.Action.Pop; // Should the current navigation prevent the scroll reset if scroll cannot
  // be restored?

  let pendingPreventScrollReset = false; // AbortController for the active navigation

  let pendingNavigationController; // We use this to avoid touching history in completeNavigation if a
  // revalidation is entirely uninterrupted

  let isUninterruptedRevalidation = false; // Use this internal flag to force revalidation of all loaders:
  //  - submissions (completed or interrupted)
  //  - useRevalidate()
  //  - X-Remix-Revalidate (from redirect)

  let isRevalidationRequired = false; // Use this internal array to capture routes that require revalidation due
  // to a cancelled deferred on action submission

  let cancelledDeferredRoutes = []; // Use this internal array to capture fetcher loads that were cancelled by an
  // action navigation and require revalidation

  let cancelledFetcherLoads = []; // AbortControllers for any in-flight fetchers

  let fetchControllers = new Map(); // Track loads based on the order in which they started

  let incrementingLoadId = 0; // Track the outstanding pending navigation data load to be compared against
  // the globally incrementing load when a fetcher load lands after a completed
  // navigation

  let pendingNavigationLoadId = -1; // Fetchers that triggered data reloads as a result of their actions

  let fetchReloadIds = new Map(); // Fetchers that triggered redirect navigations from their actions

  let fetchRedirectIds = new Set(); // Most recent href/match for fetcher.load calls for fetchers

  let fetchLoadMatches = new Map(); // Store DeferredData instances for active route matches.  When a
  // route loader returns defer() we stick one in here.  Then, when a nested
  // promise resolves we update loaderData.  If a new navigation starts we
  // cancel active deferreds for eliminated routes.

  let activeDeferreds = new Map(); // Store blocker functions in a separate Map outside of router state since
  // we don't need to update UI state if they change

  let blockerFunctions = new Map(); // Flag to ignore the next history update, so we can revert the URL change on
  // a POP navigation that was blocked by the user without touching router state

  let ignoreNextHistoryUpdate = false; // Initialize the router, all side effects should be kicked off from here.
  // Implemented as a Fluent API for ease of:
  //   let router = createRouter(init).initialize();

  function initialize() {
    // If history informs us of a POP navigation, start the navigation but do not update
    // state.  We'll update our own state once the navigation completes
    unlistenHistory = init.history.listen(_ref => {
      let {
        action: historyAction,
        location,
        delta
      } = _ref;

      // Ignore this event if it was just us resetting the URL from a
      // blocked POP navigation
      if (ignoreNextHistoryUpdate) {
        ignoreNextHistoryUpdate = false;
        return;
      }
      warning(blockerFunctions.size === 0 || delta != null, "You are trying to use a blocker on a POP navigation to a location " + "that was not created by @remix-run/router. This will fail silently in " + "production. This can happen if you are navigating outside the router " + "via `window.history.pushState`/`window.location.hash` instead of using " + "router navigation APIs.  This can also happen if you are using " + "createHashRouter and the user manually changes the URL.");
      let blockerKey = shouldBlockNavigation({
        currentLocation: state.location,
        nextLocation: location,
        historyAction
      });
      if (blockerKey && delta != null) {
        // Restore the URL to match the current UI, but don't update router state
        ignoreNextHistoryUpdate = true;
        init.history.go(delta * -1); // Put the blocker into a blocked state

        updateBlocker(blockerKey, {
          state: "blocked",
          location,
          proceed() {
            updateBlocker(blockerKey, {
              state: "proceeding",
              proceed: undefined,
              reset: undefined,
              location
            }); // Re-do the same POP navigation we just blocked

            init.history.go(delta);
          },
          reset() {
            deleteBlocker(blockerKey);
            updateState({
              blockers: new Map(router.state.blockers)
            });
          }
        });
        return;
      }
      return startNavigation(historyAction, location);
    });
    if (state.initialized) {
      return router;
    }
    let lazyMatches = state.matches.filter(m => m.route.lazy);
    if (lazyMatches.length === 0) {
      // Kick off initial data load if needed.  Use Pop to avoid modifying history
      startNavigation(exports.Action.Pop, state.location);
      return router;
    } // Load lazy modules, then kick off initial data load if needed

    let lazyPromises = lazyMatches.map(m => loadLazyRouteModule(m.route, detectErrorBoundary, manifest));
    Promise.all(lazyPromises).then(() => {
      let initialized = !state.matches.some(m => m.route.loader) || init.hydrationData != null;
      if (initialized) {
        // We already have required loaderData so we can just set initialized
        updateState({
          initialized: true
        });
      } else {
        // We still need to kick off initial data loads
        startNavigation(exports.Action.Pop, state.location);
      }
    });
    return router;
  } // Clean up a router and it's side effects

  function dispose() {
    if (unlistenHistory) {
      unlistenHistory();
    }
    subscribers.clear();
    pendingNavigationController && pendingNavigationController.abort();
    state.fetchers.forEach((_, key) => deleteFetcher(key));
    state.blockers.forEach((_, key) => deleteBlocker(key));
  } // Subscribe to state updates for the router

  function subscribe(fn) {
    subscribers.add(fn);
    return () => subscribers.delete(fn);
  } // Update our state and notify the calling context of the change

  function updateState(newState) {
    state = _extends({}, state, newState);
    subscribers.forEach(subscriber => subscriber(state));
  } // Complete a navigation returning the state.navigation back to the IDLE_NAVIGATION
  // and setting state.[historyAction/location/matches] to the new route.
  // - Location is a required param
  // - Navigation will always be set to IDLE_NAVIGATION
  // - Can pass any other state in newState

  function completeNavigation(location, newState) {
    var _location$state, _location$state2;

    // Deduce if we're in a loading/actionReload state:
    // - We have committed actionData in the store
    // - The current navigation was a mutation submission
    // - We're past the submitting state and into the loading state
    // - The location being loaded is not the result of a redirect
    let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === "loading" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== true;
    let actionData;
    if (newState.actionData) {
      if (Object.keys(newState.actionData).length > 0) {
        actionData = newState.actionData;
      } else {
        // Empty actionData -> clear prior actionData due to an action error
        actionData = null;
      }
    } else if (isActionReload) {
      // Keep the current data if we're wrapping up the action reload
      actionData = state.actionData;
    } else {
      // Clear actionData on any other completed navigations
      actionData = null;
    } // Always preserve any existing loaderData from re-used routes

    let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData; // On a successful navigation we can assume we got through all blockers
    // so we can start fresh

    for (let [key] of blockerFunctions) {
      deleteBlocker(key);
    } // Always respect the user flag.  Otherwise don't reset on mutation
    // submission navigations unless they redirect

    let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== true;
    if (inFlightDataRoutes) {
      dataRoutes = inFlightDataRoutes;
      inFlightDataRoutes = undefined;
    }
    updateState(_extends({}, newState, {
      // matches, errors, fetchers go through as-is
      actionData,
      loaderData,
      historyAction: pendingAction,
      location,
      initialized: true,
      navigation: IDLE_NAVIGATION,
      revalidation: "idle",
      restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),
      preventScrollReset,
      blockers: new Map(state.blockers)
    }));
    if (isUninterruptedRevalidation) ;else if (pendingAction === exports.Action.Pop) ;else if (pendingAction === exports.Action.Push) {
      init.history.push(location, location.state);
    } else if (pendingAction === exports.Action.Replace) {
      init.history.replace(location, location.state);
    } // Reset stateful navigation vars

    pendingAction = exports.Action.Pop;
    pendingPreventScrollReset = false;
    isUninterruptedRevalidation = false;
    isRevalidationRequired = false;
    cancelledDeferredRoutes = [];
    cancelledFetcherLoads = [];
  } // Trigger a navigation event, which can either be a numerical POP or a PUSH
  // replace with an optional submission

  async function navigate(to, opts) {
    if (typeof to === "number") {
      init.history.go(to);
      return;
    }
    let {
      path,
      submission,
      error
    } = normalizeNavigateOptions(to, opts);
    let currentLocation = state.location;
    let nextLocation = createLocation(state.location, path, opts && opts.state); // When using navigate as a PUSH/REPLACE we aren't reading an already-encoded
    // URL from window.location, so we need to encode it here so the behavior
    // remains the same as POP and non-data-router usages.  new URL() does all
    // the same encoding we'd get from a history.pushState/window.location read
    // without having to touch history

    nextLocation = _extends({}, nextLocation, init.history.encodeLocation(nextLocation));
    let userReplace = opts && opts.replace != null ? opts.replace : undefined;
    let historyAction = exports.Action.Push;
    if (userReplace === true) {
      historyAction = exports.Action.Replace;
    } else if (userReplace === false) ;else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {
      // By default on submissions to the current location we REPLACE so that
      // users don't have to double-click the back button to get to the prior
      // location.  If the user redirects to a different location from the
      // action/loader this will be ignored and the redirect will be a PUSH
      historyAction = exports.Action.Replace;
    }
    let preventScrollReset = opts && "preventScrollReset" in opts ? opts.preventScrollReset === true : undefined;
    let blockerKey = shouldBlockNavigation({
      currentLocation,
      nextLocation,
      historyAction
    });
    if (blockerKey) {
      // Put the blocker into a blocked state
      updateBlocker(blockerKey, {
        state: "blocked",
        location: nextLocation,
        proceed() {
          updateBlocker(blockerKey, {
            state: "proceeding",
            proceed: undefined,
            reset: undefined,
            location: nextLocation
          }); // Send the same navigation through

          navigate(to, opts);
        },
        reset() {
          deleteBlocker(blockerKey);
          updateState({
            blockers: new Map(state.blockers)
          });
        }
      });
      return;
    }
    return await startNavigation(historyAction, nextLocation, {
      submission,
      // Send through the formData serialization error if we have one so we can
      // render at the right error boundary after we match routes
      pendingError: error,
      preventScrollReset,
      replace: opts && opts.replace
    });
  } // Revalidate all current loaders.  If a navigation is in progress or if this
  // is interrupted by a navigation, allow this to "succeed" by calling all
  // loaders during the next loader round

  function revalidate() {
    interruptActiveLoads();
    updateState({
      revalidation: "loading"
    }); // If we're currently submitting an action, we don't need to start a new
    // navigation, we'll just let the follow up loader execution call all loaders

    if (state.navigation.state === "submitting") {
      return;
    } // If we're currently in an idle state, start a new navigation for the current
    // action/location and mark it as uninterrupted, which will skip the history
    // update in completeNavigation

    if (state.navigation.state === "idle") {
      startNavigation(state.historyAction, state.location, {
        startUninterruptedRevalidation: true
      });
      return;
    } // Otherwise, if we're currently in a loading state, just start a new
    // navigation to the navigation.location but do not trigger an uninterrupted
    // revalidation so that history correctly updates once the navigation completes

    startNavigation(pendingAction || state.historyAction, state.navigation.location, {
      overrideNavigation: state.navigation
    });
  } // Start a navigation to the given action/location.  Can optionally provide a
  // overrideNavigation which will override the normalLoad in the case of a redirect
  // navigation

  async function startNavigation(historyAction, location, opts) {
    // Abort any in-progress navigations and start a new one. Unset any ongoing
    // uninterrupted revalidations unless told otherwise, since we want this
    // new navigation to update history normally
    pendingNavigationController && pendingNavigationController.abort();
    pendingNavigationController = null;
    pendingAction = historyAction;
    isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true; // Save the current scroll position every time we start a new navigation,
    // and track whether we should reset scroll on completion

    saveScrollPosition(state.location, state.matches);
    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let loadingNavigation = opts && opts.overrideNavigation;
    let matches = matchRoutes(routesToUse, location, init.basename); // Short circuit with a 404 on the root error boundary if we match nothing

    if (!matches) {
      let error = getInternalRouterError(404, {
        pathname: location.pathname
      });
      let {
        matches: notFoundMatches,
        route
      } = getShortCircuitMatches(routesToUse); // Cancel all pending deferred on 404s since we don't keep any routes

      cancelActiveDeferreds();
      completeNavigation(location, {
        matches: notFoundMatches,
        loaderData: {},
        errors: {
          [route.id]: error
        }
      });
      return;
    } // Short circuit if it's only a hash change and not a mutation submission
    // For example, on /page#hash and submit a <Form method="post"> which will
    // default to a navigation to /page

    if (isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {
      completeNavigation(location, {
        matches
      });
      return;
    } // Create a controller/Request for this navigation

    pendingNavigationController = new AbortController();
    let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);
    let pendingActionData;
    let pendingError;
    if (opts && opts.pendingError) {
      // If we have a pendingError, it means the user attempted a GET submission
      // with binary FormData so assign here and skip to handleLoaders.  That
      // way we handle calling loaders above the boundary etc.  It's not really
      // different from an actionError in that sense.
      pendingError = {
        [findNearestBoundary(matches).route.id]: opts.pendingError
      };
    } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {
      // Call action if we received an action submission
      let actionOutput = await handleAction(request, location, opts.submission, matches, {
        replace: opts.replace
      });
      if (actionOutput.shortCircuited) {
        return;
      }
      pendingActionData = actionOutput.pendingActionData;
      pendingError = actionOutput.pendingActionError;
      let navigation = _extends({
        state: "loading",
        location
      }, opts.submission);
      loadingNavigation = navigation; // Create a GET request for the loaders

      request = new Request(request.url, {
        signal: request.signal
      });
    } // Call loaders

    let {
      shortCircuited,
      loaderData,
      errors
    } = await handleLoaders(request, location, matches, loadingNavigation, opts && opts.submission, opts && opts.replace, pendingActionData, pendingError);
    if (shortCircuited) {
      return;
    } // Clean up now that the action/loaders have completed.  Don't clean up if
    // we short circuited because pendingNavigationController will have already
    // been assigned to a new controller for the next navigation

    pendingNavigationController = null;
    completeNavigation(location, _extends({
      matches
    }, pendingActionData ? {
      actionData: pendingActionData
    } : {}, {
      loaderData,
      errors
    }));
  } // Call the action matched by the leaf route for this navigation and handle
  // redirects/errors

  async function handleAction(request, location, submission, matches, opts) {
    interruptActiveLoads(); // Put us in a submitting state

    let navigation = _extends({
      state: "submitting",
      location
    }, submission);
    updateState({
      navigation
    }); // Call our action and get the result

    let result;
    let actionMatch = getTargetMatch(matches, location);
    if (!actionMatch.route.action && !actionMatch.route.lazy) {
      result = {
        type: ResultType.error,
        error: getInternalRouterError(405, {
          method: request.method,
          pathname: location.pathname,
          routeId: actionMatch.route.id
        })
      };
    } else {
      result = await callLoaderOrAction("action", request, actionMatch, matches, manifest, detectErrorBoundary, router.basename);
      if (request.signal.aborted) {
        return {
          shortCircuited: true
        };
      }
    }
    if (isRedirectResult(result)) {
      let replace;
      if (opts && opts.replace != null) {
        replace = opts.replace;
      } else {
        // If the user didn't explicity indicate replace behavior, replace if
        // we redirected to the exact same location we're currently at to avoid
        // double back-buttons
        replace = result.location === state.location.pathname + state.location.search;
      }
      await startRedirectNavigation(state, result, {
        submission,
        replace
      });
      return {
        shortCircuited: true
      };
    }
    if (isErrorResult(result)) {
      // Store off the pending error - we use it to determine which loaders
      // to call and will commit it when we complete the navigation
      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id); // By default, all submissions are REPLACE navigations, but if the
      // action threw an error that'll be rendered in an errorElement, we fall
      // back to PUSH so that the user can use the back button to get back to
      // the pre-submission form location to try again

      if ((opts && opts.replace) !== true) {
        pendingAction = exports.Action.Push;
      }
      return {
        // Send back an empty object we can use to clear out any prior actionData
        pendingActionData: {},
        pendingActionError: {
          [boundaryMatch.route.id]: result.error
        }
      };
    }
    if (isDeferredResult(result)) {
      throw getInternalRouterError(400, {
        type: "defer-action"
      });
    }
    return {
      pendingActionData: {
        [actionMatch.route.id]: result.data
      }
    };
  } // Call all applicable loaders for the given matches, handling redirects,
  // errors, etc.

  async function handleLoaders(request, location, matches, overrideNavigation, submission, replace, pendingActionData, pendingError) {
    // Figure out the right navigation we want to use for data loading
    let loadingNavigation = overrideNavigation;
    if (!loadingNavigation) {
      let navigation = _extends({
        state: "loading",
        location,
        formMethod: undefined,
        formAction: undefined,
        formEncType: undefined,
        formData: undefined
      }, submission);
      loadingNavigation = navigation;
    } // If this was a redirect from an action we don't have a "submission" but
    // we have it on the loading navigation so use that if available

    let activeSubmission = submission ? submission : loadingNavigation.formMethod && loadingNavigation.formAction && loadingNavigation.formData && loadingNavigation.formEncType ? {
      formMethod: loadingNavigation.formMethod,
      formAction: loadingNavigation.formAction,
      formData: loadingNavigation.formData,
      formEncType: loadingNavigation.formEncType
    } : undefined;
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, activeSubmission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, fetchLoadMatches, routesToUse, init.basename, pendingActionData, pendingError); // Cancel pending deferreds for no-longer-matched routes or routes we're
    // about to reload.  Note that if this is an action reload we would have
    // already cancelled all pending deferreds so this would be a no-op

    cancelActiveDeferreds(routeId => !(matches && matches.some(m => m.route.id === routeId)) || matchesToLoad && matchesToLoad.some(m => m.route.id === routeId)); // Short circuit if we have no loaders to run

    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {
      completeNavigation(location, _extends({
        matches,
        loaderData: {},
        // Commit pending error if we're short circuiting
        errors: pendingError || null
      }, pendingActionData ? {
        actionData: pendingActionData
      } : {}));
      return {
        shortCircuited: true
      };
    } // If this is an uninterrupted revalidation, we remain in our current idle
    // state.  If not, we need to switch to our loading state and load data,
    // preserving any new action data or existing action data (in the case of
    // a revalidation interrupting an actionReload)

    if (!isUninterruptedRevalidation) {
      revalidatingFetchers.forEach(rf => {
        let fetcher = state.fetchers.get(rf.key);
        let revalidatingFetcher = {
          state: "loading",
          data: fetcher && fetcher.data,
          formMethod: undefined,
          formAction: undefined,
          formEncType: undefined,
          formData: undefined,
          " _hasFetcherDoneAnything ": true
        };
        state.fetchers.set(rf.key, revalidatingFetcher);
      });
      let actionData = pendingActionData || state.actionData;
      updateState(_extends({
        navigation: loadingNavigation
      }, actionData ? Object.keys(actionData).length === 0 ? {
        actionData: null
      } : {
        actionData
      } : {}, revalidatingFetchers.length > 0 ? {
        fetchers: new Map(state.fetchers)
      } : {}));
    }
    pendingNavigationLoadId = ++incrementingLoadId;
    revalidatingFetchers.forEach(rf => fetchControllers.set(rf.key, pendingNavigationController));
    let {
      results,
      loaderResults,
      fetcherResults
    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request);
    if (request.signal.aborted) {
      return {
        shortCircuited: true
      };
    } // Clean up _after_ loaders have completed.  Don't clean up if we short
    // circuited because fetchControllers would have been aborted and
    // reassigned to new controllers for the next navigation

    revalidatingFetchers.forEach(rf => fetchControllers.delete(rf.key)); // If any loaders returned a redirect Response, start a new REPLACE navigation

    let redirect = findRedirect(results);
    if (redirect) {
      await startRedirectNavigation(state, redirect, {
        replace
      });
      return {
        shortCircuited: true
      };
    } // Process and commit output from loaders

    let {
      loaderData,
      errors
    } = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds); // Wire up subscribers to update loaderData as promises settle

    activeDeferreds.forEach((deferredData, routeId) => {
      deferredData.subscribe(aborted => {
        // Note: No need to updateState here since the TrackedPromise on
        // loaderData is stable across resolve/reject
        // Remove this instance if we were aborted or if promises have settled
        if (aborted || deferredData.done) {
          activeDeferreds.delete(routeId);
        }
      });
    });
    markFetchRedirectsDone();
    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);
    return _extends({
      loaderData,
      errors
    }, didAbortFetchLoads || revalidatingFetchers.length > 0 ? {
      fetchers: new Map(state.fetchers)
    } : {});
  }
  function getFetcher(key) {
    return state.fetchers.get(key) || IDLE_FETCHER;
  } // Trigger a fetcher load/submit for the given fetcher key

  function fetch(key, routeId, href, opts) {
    if (isServer) {
      throw new Error("router.fetch() was called during the server render, but it shouldn't be. " + "You are likely calling a useFetcher() method in the body of your component. " + "Try moving it to a useEffect or a callback.");
    }
    if (fetchControllers.has(key)) abortFetcher(key);
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let matches = matchRoutes(routesToUse, href, init.basename);
    if (!matches) {
      setFetcherError(key, routeId, getInternalRouterError(404, {
        pathname: href
      }));
      return;
    }
    let {
      path,
      submission
    } = normalizeNavigateOptions(href, opts, true);
    let match = getTargetMatch(matches, path);
    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
    if (submission && isMutationMethod(submission.formMethod)) {
      handleFetcherAction(key, routeId, path, match, matches, submission);
      return;
    } // Store off the match so we can call it's shouldRevalidate on subsequent
    // revalidations

    fetchLoadMatches.set(key, {
      routeId,
      path
    });
    handleFetcherLoader(key, routeId, path, match, matches, submission);
  } // Call the action for the matched fetcher.submit(), and then handle redirects,
  // errors, and revalidation

  async function handleFetcherAction(key, routeId, path, match, requestMatches, submission) {
    interruptActiveLoads();
    fetchLoadMatches.delete(key);
    if (!match.route.action && !match.route.lazy) {
      let error = getInternalRouterError(405, {
        method: submission.formMethod,
        pathname: path,
        routeId: routeId
      });
      setFetcherError(key, routeId, error);
      return;
    } // Put this fetcher into it's submitting state

    let existingFetcher = state.fetchers.get(key);
    let fetcher = _extends({
      state: "submitting"
    }, submission, {
      data: existingFetcher && existingFetcher.data,
      " _hasFetcherDoneAnything ": true
    });
    state.fetchers.set(key, fetcher);
    updateState({
      fetchers: new Map(state.fetchers)
    }); // Call the action for the fetcher

    let abortController = new AbortController();
    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);
    fetchControllers.set(key, abortController);
    let actionResult = await callLoaderOrAction("action", fetchRequest, match, requestMatches, manifest, detectErrorBoundary, router.basename);
    if (fetchRequest.signal.aborted) {
      // We can delete this so long as we weren't aborted by ou our own fetcher
      // re-submit which would have put _new_ controller is in fetchControllers
      if (fetchControllers.get(key) === abortController) {
        fetchControllers.delete(key);
      }
      return;
    }
    if (isRedirectResult(actionResult)) {
      fetchControllers.delete(key);
      fetchRedirectIds.add(key);
      let loadingFetcher = _extends({
        state: "loading"
      }, submission, {
        data: undefined,
        " _hasFetcherDoneAnything ": true
      });
      state.fetchers.set(key, loadingFetcher);
      updateState({
        fetchers: new Map(state.fetchers)
      });
      return startRedirectNavigation(state, actionResult, {
        isFetchActionRedirect: true
      });
    } // Process any non-redirect errors thrown

    if (isErrorResult(actionResult)) {
      setFetcherError(key, routeId, actionResult.error);
      return;
    }
    if (isDeferredResult(actionResult)) {
      throw getInternalRouterError(400, {
        type: "defer-action"
      });
    } // Start the data load for current matches, or the next location if we're
    // in the middle of a navigation

    let nextLocation = state.navigation.location || state.location;
    let revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let matches = state.navigation.state !== "idle" ? matchRoutes(routesToUse, state.navigation.location, init.basename) : state.matches;
    invariant(matches, "Didn't find any matches after fetcher action");
    let loadId = ++incrementingLoadId;
    fetchReloadIds.set(key, loadId);
    let loadFetcher = _extends({
      state: "loading",
      data: actionResult.data
    }, submission, {
      " _hasFetcherDoneAnything ": true
    });
    state.fetchers.set(key, loadFetcher);
    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, submission, nextLocation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, fetchLoadMatches, routesToUse, init.basename, {
      [match.route.id]: actionResult.data
    }, undefined // No need to send through errors since we short circuit above
    ); // Put all revalidating fetchers into the loading state, except for the
    // current fetcher which we want to keep in it's current loading state which
    // contains it's action submission info + action data

    revalidatingFetchers.filter(rf => rf.key !== key).forEach(rf => {
      let staleKey = rf.key;
      let existingFetcher = state.fetchers.get(staleKey);
      let revalidatingFetcher = {
        state: "loading",
        data: existingFetcher && existingFetcher.data,
        formMethod: undefined,
        formAction: undefined,
        formEncType: undefined,
        formData: undefined,
        " _hasFetcherDoneAnything ": true
      };
      state.fetchers.set(staleKey, revalidatingFetcher);
      fetchControllers.set(staleKey, abortController);
    });
    updateState({
      fetchers: new Map(state.fetchers)
    });
    let {
      results,
      loaderResults,
      fetcherResults
    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);
    if (abortController.signal.aborted) {
      return;
    }
    fetchReloadIds.delete(key);
    fetchControllers.delete(key);
    revalidatingFetchers.forEach(r => fetchControllers.delete(r.key));
    let redirect = findRedirect(results);
    if (redirect) {
      return startRedirectNavigation(state, redirect);
    } // Process and commit output from loaders

    let {
      loaderData,
      errors
    } = processLoaderData(state, state.matches, matchesToLoad, loaderResults, undefined, revalidatingFetchers, fetcherResults, activeDeferreds);
    let doneFetcher = {
      state: "idle",
      data: actionResult.data,
      formMethod: undefined,
      formAction: undefined,
      formEncType: undefined,
      formData: undefined,
      " _hasFetcherDoneAnything ": true
    };
    state.fetchers.set(key, doneFetcher);
    let didAbortFetchLoads = abortStaleFetchLoads(loadId); // If we are currently in a navigation loading state and this fetcher is
    // more recent than the navigation, we want the newer data so abort the
    // navigation and complete it with the fetcher data

    if (state.navigation.state === "loading" && loadId > pendingNavigationLoadId) {
      invariant(pendingAction, "Expected pending action");
      pendingNavigationController && pendingNavigationController.abort();
      completeNavigation(state.navigation.location, {
        matches,
        loaderData,
        errors,
        fetchers: new Map(state.fetchers)
      });
    } else {
      // otherwise just update with the fetcher data, preserving any existing
      // loaderData for loaders that did not need to reload.  We have to
      // manually merge here since we aren't going through completeNavigation
      updateState(_extends({
        errors,
        loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors)
      }, didAbortFetchLoads ? {
        fetchers: new Map(state.fetchers)
      } : {}));
      isRevalidationRequired = false;
    }
  } // Call the matched loader for fetcher.load(), handling redirects, errors, etc.

  async function handleFetcherLoader(key, routeId, path, match, matches, submission) {
    let existingFetcher = state.fetchers.get(key); // Put this fetcher into it's loading state

    let loadingFetcher = _extends({
      state: "loading",
      formMethod: undefined,
      formAction: undefined,
      formEncType: undefined,
      formData: undefined
    }, submission, {
      data: existingFetcher && existingFetcher.data,
      " _hasFetcherDoneAnything ": true
    });
    state.fetchers.set(key, loadingFetcher);
    updateState({
      fetchers: new Map(state.fetchers)
    }); // Call the loader for this fetcher route match

    let abortController = new AbortController();
    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal);
    fetchControllers.set(key, abortController);
    let result = await callLoaderOrAction("loader", fetchRequest, match, matches, manifest, detectErrorBoundary, router.basename); // Deferred isn't supported for fetcher loads, await everything and treat it
    // as a normal load.  resolveDeferredData will return undefined if this
    // fetcher gets aborted, so we just leave result untouched and short circuit
    // below if that happens

    if (isDeferredResult(result)) {
      result = (await resolveDeferredData(result, fetchRequest.signal, true)) || result;
    } // We can delete this so long as we weren't aborted by ou our own fetcher
    // re-load which would have put _new_ controller is in fetchControllers

    if (fetchControllers.get(key) === abortController) {
      fetchControllers.delete(key);
    }
    if (fetchRequest.signal.aborted) {
      return;
    } // If the loader threw a redirect Response, start a new REPLACE navigation

    if (isRedirectResult(result)) {
      await startRedirectNavigation(state, result);
      return;
    } // Process any non-redirect errors thrown

    if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(state.matches, routeId);
      state.fetchers.delete(key); // TODO: In remix, this would reset to IDLE_NAVIGATION if it was a catch -
      // do we need to behave any differently with our non-redirect errors?
      // What if it was a non-redirect Response?

      updateState({
        fetchers: new Map(state.fetchers),
        errors: {
          [boundaryMatch.route.id]: result.error
        }
      });
      return;
    }
    invariant(!isDeferredResult(result), "Unhandled fetcher deferred data"); // Put the fetcher back into an idle state

    let doneFetcher = {
      state: "idle",
      data: result.data,
      formMethod: undefined,
      formAction: undefined,
      formEncType: undefined,
      formData: undefined,
      " _hasFetcherDoneAnything ": true
    };
    state.fetchers.set(key, doneFetcher);
    updateState({
      fetchers: new Map(state.fetchers)
    });
  }
  /**
   * Utility function to handle redirects returned from an action or loader.
   * Normally, a redirect "replaces" the navigation that triggered it.  So, for
   * example:
   *
   *  - user is on /a
   *  - user clicks a link to /b
   *  - loader for /b redirects to /c
   *
   * In a non-JS app the browser would track the in-flight navigation to /b and
   * then replace it with /c when it encountered the redirect response.  In
   * the end it would only ever update the URL bar with /c.
   *
   * In client-side routing using pushState/replaceState, we aim to emulate
   * this behavior and we also do not update history until the end of the
   * navigation (including processed redirects).  This means that we never
   * actually touch history until we've processed redirects, so we just use
   * the history action from the original navigation (PUSH or REPLACE).
   */

  async function startRedirectNavigation(state, redirect, _temp) {
    var _window;
    let {
      submission,
      replace,
      isFetchActionRedirect
    } = _temp === void 0 ? {} : _temp;
    if (redirect.revalidate) {
      isRevalidationRequired = true;
    }
    let redirectLocation = createLocation(state.location, redirect.location,
    // TODO: This can be removed once we get rid of useTransition in Remix v2
    _extends({
      _isRedirect: true
    }, isFetchActionRedirect ? {
      _isFetchActionRedirect: true
    } : {}));
    invariant(redirectLocation, "Expected a location on the redirect navigation"); // Check if this an absolute external redirect that goes to a new origin

    if (ABSOLUTE_URL_REGEX.test(redirect.location) && isBrowser && typeof ((_window = window) == null ? void 0 : _window.location) !== "undefined") {
      let url = init.history.createURL(redirect.location);
      let isDifferentBasename = stripBasename(url.pathname, init.basename || "/") == null;
      if (window.location.origin !== url.origin || isDifferentBasename) {
        if (replace) {
          window.location.replace(redirect.location);
        } else {
          window.location.assign(redirect.location);
        }
        return;
      }
    } // There's no need to abort on redirects, since we don't detect the
    // redirect until the action/loaders have settled

    pendingNavigationController = null;
    let redirectHistoryAction = replace === true ? exports.Action.Replace : exports.Action.Push; // Use the incoming submission if provided, fallback on the active one in
    // state.navigation

    let {
      formMethod,
      formAction,
      formEncType,
      formData
    } = state.navigation;
    if (!submission && formMethod && formAction && formData && formEncType) {
      submission = {
        formMethod,
        formAction,
        formEncType,
        formData
      };
    } // If this was a 307/308 submission we want to preserve the HTTP method and
    // re-submit the GET/POST/PUT/PATCH/DELETE as a submission navigation to the
    // redirected location

    if (redirectPreserveMethodStatusCodes.has(redirect.status) && submission && isMutationMethod(submission.formMethod)) {
      await startNavigation(redirectHistoryAction, redirectLocation, {
        submission: _extends({}, submission, {
          formAction: redirect.location
        }),
        // Preserve this flag across redirects
        preventScrollReset: pendingPreventScrollReset
      });
    } else {
      // Otherwise, we kick off a new loading navigation, preserving the
      // submission info for the duration of this navigation
      await startNavigation(redirectHistoryAction, redirectLocation, {
        overrideNavigation: {
          state: "loading",
          location: redirectLocation,
          formMethod: submission ? submission.formMethod : undefined,
          formAction: submission ? submission.formAction : undefined,
          formEncType: submission ? submission.formEncType : undefined,
          formData: submission ? submission.formData : undefined
        },
        // Preserve this flag across redirects
        preventScrollReset: pendingPreventScrollReset
      });
    }
  }
  async function callLoadersAndMaybeResolveData(currentMatches, matches, matchesToLoad, fetchersToLoad, request) {
    // Call all navigation loaders and revalidating fetcher loaders in parallel,
    // then slice off the results into separate arrays so we can handle them
    // accordingly
    let results = await Promise.all([...matchesToLoad.map(match => callLoaderOrAction("loader", request, match, matches, manifest, detectErrorBoundary, router.basename)), ...fetchersToLoad.map(f => {
      if (f.matches && f.match) {
        return callLoaderOrAction("loader", createClientSideRequest(init.history, f.path, request.signal), f.match, f.matches, manifest, detectErrorBoundary, router.basename);
      } else {
        let error = {
          type: ResultType.error,
          error: getInternalRouterError(404, {
            pathname: f.path
          })
        };
        return error;
      }
    })]);
    let loaderResults = results.slice(0, matchesToLoad.length);
    let fetcherResults = results.slice(matchesToLoad.length);
    await Promise.all([resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, request.signal, false, state.loaderData), resolveDeferredResults(currentMatches, fetchersToLoad.map(f => f.match), fetcherResults, request.signal, true)]);
    return {
      results,
      loaderResults,
      fetcherResults
    };
  }
  function interruptActiveLoads() {
    // Every interruption triggers a revalidation
    isRevalidationRequired = true; // Cancel pending route-level deferreds and mark cancelled routes for
    // revalidation

    cancelledDeferredRoutes.push(...cancelActiveDeferreds()); // Abort in-flight fetcher loads

    fetchLoadMatches.forEach((_, key) => {
      if (fetchControllers.has(key)) {
        cancelledFetcherLoads.push(key);
        abortFetcher(key);
      }
    });
  }
  function setFetcherError(key, routeId, error) {
    let boundaryMatch = findNearestBoundary(state.matches, routeId);
    deleteFetcher(key);
    updateState({
      errors: {
        [boundaryMatch.route.id]: error
      },
      fetchers: new Map(state.fetchers)
    });
  }
  function deleteFetcher(key) {
    if (fetchControllers.has(key)) abortFetcher(key);
    fetchLoadMatches.delete(key);
    fetchReloadIds.delete(key);
    fetchRedirectIds.delete(key);
    state.fetchers.delete(key);
  }
  function abortFetcher(key) {
    let controller = fetchControllers.get(key);
    invariant(controller, "Expected fetch controller: " + key);
    controller.abort();
    fetchControllers.delete(key);
  }
  function markFetchersDone(keys) {
    for (let key of keys) {
      let fetcher = getFetcher(key);
      let doneFetcher = {
        state: "idle",
        data: fetcher.data,
        formMethod: undefined,
        formAction: undefined,
        formEncType: undefined,
        formData: undefined,
        " _hasFetcherDoneAnything ": true
      };
      state.fetchers.set(key, doneFetcher);
    }
  }
  function markFetchRedirectsDone() {
    let doneKeys = [];
    for (let key of fetchRedirectIds) {
      let fetcher = state.fetchers.get(key);
      invariant(fetcher, "Expected fetcher: " + key);
      if (fetcher.state === "loading") {
        fetchRedirectIds.delete(key);
        doneKeys.push(key);
      }
    }
    markFetchersDone(doneKeys);
  }
  function abortStaleFetchLoads(landedId) {
    let yeetedKeys = [];
    for (let [key, id] of fetchReloadIds) {
      if (id < landedId) {
        let fetcher = state.fetchers.get(key);
        invariant(fetcher, "Expected fetcher: " + key);
        if (fetcher.state === "loading") {
          abortFetcher(key);
          fetchReloadIds.delete(key);
          yeetedKeys.push(key);
        }
      }
    }
    markFetchersDone(yeetedKeys);
    return yeetedKeys.length > 0;
  }
  function getBlocker(key, fn) {
    let blocker = state.blockers.get(key) || IDLE_BLOCKER;
    if (blockerFunctions.get(key) !== fn) {
      blockerFunctions.set(key, fn);
    }
    return blocker;
  }
  function deleteBlocker(key) {
    state.blockers.delete(key);
    blockerFunctions.delete(key);
  } // Utility function to update blockers, ensuring valid state transitions

  function updateBlocker(key, newBlocker) {
    let blocker = state.blockers.get(key) || IDLE_BLOCKER; // Poor mans state machine :)
    // https://mermaid.live/edit#pako:eNqVkc9OwzAMxl8l8nnjAYrEtDIOHEBIgwvKJTReGy3_lDpIqO27k6awMG0XcrLlnz87nwdonESogKXXBuE79rq75XZO3-yHds0RJVuv70YrPlUrCEe2HfrORS3rubqZfuhtpg5C9wk5tZ4VKcRUq88q9Z8RS0-48cE1iHJkL0ugbHuFLus9L6spZy8nX9MP2CNdomVaposqu3fGayT8T8-jJQwhepo_UtpgBQaDEUom04dZhAN1aJBDlUKJBxE1ceB2Smj0Mln-IBW5AFU2dwUiktt_2Qaq2dBfaKdEup85UV7Yd-dKjlnkabl2Pvr0DTkTreM

    invariant(blocker.state === "unblocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "proceeding" || blocker.state === "blocked" && newBlocker.state === "unblocked" || blocker.state === "proceeding" && newBlocker.state === "unblocked", "Invalid blocker state transition: " + blocker.state + " -> " + newBlocker.state);
    state.blockers.set(key, newBlocker);
    updateState({
      blockers: new Map(state.blockers)
    });
  }
  function shouldBlockNavigation(_ref2) {
    let {
      currentLocation,
      nextLocation,
      historyAction
    } = _ref2;
    if (blockerFunctions.size === 0) {
      return;
    } // We ony support a single active blocker at the moment since we don't have
    // any compelling use cases for multi-blocker yet

    if (blockerFunctions.size > 1) {
      warning(false, "A router only supports one blocker at a time");
    }
    let entries = Array.from(blockerFunctions.entries());
    let [blockerKey, blockerFunction] = entries[entries.length - 1];
    let blocker = state.blockers.get(blockerKey);
    if (blocker && blocker.state === "proceeding") {
      // If the blocker is currently proceeding, we don't need to re-check
      // it and can let this navigation continue
      return;
    } // At this point, we know we're unblocked/blocked so we need to check the
    // user-provided blocker function

    if (blockerFunction({
      currentLocation,
      nextLocation,
      historyAction
    })) {
      return blockerKey;
    }
  }
  function cancelActiveDeferreds(predicate) {
    let cancelledRouteIds = [];
    activeDeferreds.forEach((dfd, routeId) => {
      if (!predicate || predicate(routeId)) {
        // Cancel the deferred - but do not remove from activeDeferreds here -
        // we rely on the subscribers to do that so our tests can assert proper
        // cleanup via _internalActiveDeferreds
        dfd.cancel();
        cancelledRouteIds.push(routeId);
        activeDeferreds.delete(routeId);
      }
    });
    return cancelledRouteIds;
  } // Opt in to capturing and reporting scroll positions during navigations,
  // used by the <ScrollRestoration> component

  function enableScrollRestoration(positions, getPosition, getKey) {
    savedScrollPositions = positions;
    getScrollPosition = getPosition;
    getScrollRestorationKey = getKey || (location => location.key); // Perform initial hydration scroll restoration, since we miss the boat on
    // the initial updateState() because we've not yet rendered <ScrollRestoration/>
    // and therefore have no savedScrollPositions available

    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {
      initialScrollRestored = true;
      let y = getSavedScrollPosition(state.location, state.matches);
      if (y != null) {
        updateState({
          restoreScrollPosition: y
        });
      }
    }
    return () => {
      savedScrollPositions = null;
      getScrollPosition = null;
      getScrollRestorationKey = null;
    };
  }
  function saveScrollPosition(location, matches) {
    if (savedScrollPositions && getScrollRestorationKey && getScrollPosition) {
      let userMatches = matches.map(m => createUseMatchesMatch(m, state.loaderData));
      let key = getScrollRestorationKey(location, userMatches) || location.key;
      savedScrollPositions[key] = getScrollPosition();
    }
  }
  function getSavedScrollPosition(location, matches) {
    if (savedScrollPositions && getScrollRestorationKey && getScrollPosition) {
      let userMatches = matches.map(m => createUseMatchesMatch(m, state.loaderData));
      let key = getScrollRestorationKey(location, userMatches) || location.key;
      let y = savedScrollPositions[key];
      if (typeof y === "number") {
        return y;
      }
    }
    return null;
  }
  function _internalSetRoutes(newRoutes) {
    inFlightDataRoutes = newRoutes;
  }
  router = {
    get basename() {
      return init.basename;
    },
    get state() {
      return state;
    },
    get routes() {
      return dataRoutes;
    },
    initialize,
    subscribe,
    enableScrollRestoration,
    navigate,
    fetch,
    revalidate,
    // Passthrough to history-aware createHref used by useHref so we get proper
    // hash-aware URLs in DOM paths
    createHref: to => init.history.createHref(to),
    encodeLocation: to => init.history.encodeLocation(to),
    getFetcher,
    deleteFetcher,
    dispose,
    getBlocker,
    deleteBlocker,
    _internalFetchControllers: fetchControllers,
    _internalActiveDeferreds: activeDeferreds,
    // TODO: Remove setRoutes, it's temporary to avoid dealing with
    // updating the tree while validating the update algorithm.
    _internalSetRoutes
  };
  return router;
} //#endregion
////////////////////////////////////////////////////////////////////////////////
//#region createStaticHandler
////////////////////////////////////////////////////////////////////////////////

const UNSAFE_DEFERRED_SYMBOL = Symbol("deferred");
function createStaticHandler(routes, opts) {
  invariant(routes.length > 0, "You must provide a non-empty routes array to createStaticHandler");
  let manifest = {};
  let detectErrorBoundary = (opts == null ? void 0 : opts.detectErrorBoundary) || defaultDetectErrorBoundary;
  let dataRoutes = convertRoutesToDataRoutes(routes, detectErrorBoundary, undefined, manifest);
  let basename = (opts ? opts.basename : null) || "/";
  /**
   * The query() method is intended for document requests, in which we want to
   * call an optional action and potentially multiple loaders for all nested
   * routes.  It returns a StaticHandlerContext object, which is very similar
   * to the router state (location, loaderData, actionData, errors, etc.) and
   * also adds SSR-specific information such as the statusCode and headers
   * from action/loaders Responses.
   *
   * It _should_ never throw and should report all errors through the
   * returned context.errors object, properly associating errors to their error
   * boundary.  Additionally, it tracks _deepestRenderedBoundaryId which can be
   * used to emulate React error boundaries during SSr by performing a second
   * pass only down to the boundaryId.
   *
   * The one exception where we do not return a StaticHandlerContext is when a
   * redirect response is returned or thrown from any action/loader.  We
   * propagate that out and return the raw Response so the HTTP server can
   * return it directly.
   */

  async function query(request, _temp2) {
    let {
      requestContext
    } = _temp2 === void 0 ? {} : _temp2;
    let url = new URL(request.url);
    let method = request.method.toLowerCase();
    let location = createLocation("", createPath(url), null, "default");
    let matches = matchRoutes(dataRoutes, location, basename); // SSR supports HEAD requests while SPA doesn't

    if (!isValidMethod(method) && method !== "head") {
      let error = getInternalRouterError(405, {
        method
      });
      let {
        matches: methodNotAllowedMatches,
        route
      } = getShortCircuitMatches(dataRoutes);
      return {
        basename,
        location,
        matches: methodNotAllowedMatches,
        loaderData: {},
        actionData: null,
        errors: {
          [route.id]: error
        },
        statusCode: error.status,
        loaderHeaders: {},
        actionHeaders: {},
        activeDeferreds: null
      };
    } else if (!matches) {
      let error = getInternalRouterError(404, {
        pathname: location.pathname
      });
      let {
        matches: notFoundMatches,
        route
      } = getShortCircuitMatches(dataRoutes);
      return {
        basename,
        location,
        matches: notFoundMatches,
        loaderData: {},
        actionData: null,
        errors: {
          [route.id]: error
        },
        statusCode: error.status,
        loaderHeaders: {},
        actionHeaders: {},
        activeDeferreds: null
      };
    }
    let result = await queryImpl(request, location, matches, requestContext);
    if (isResponse(result)) {
      return result;
    } // When returning StaticHandlerContext, we patch back in the location here
    // since we need it for React Context.  But this helps keep our submit and
    // loadRouteData operating on a Request instead of a Location

    return _extends({
      location,
      basename
    }, result);
  }
  /**
   * The queryRoute() method is intended for targeted route requests, either
   * for fetch ?_data requests or resource route requests.  In this case, we
   * are only ever calling a single action or loader, and we are returning the
   * returned value directly.  In most cases, this will be a Response returned
   * from the action/loader, but it may be a primitive or other value as well -
   * and in such cases the calling context should handle that accordingly.
   *
   * We do respect the throw/return differentiation, so if an action/loader
   * throws, then this method will throw the value.  This is important so we
   * can do proper boundary identification in Remix where a thrown Response
   * must go to the Catch Boundary but a returned Response is happy-path.
   *
   * One thing to note is that any Router-initiated Errors that make sense
   * to associate with a status code will be thrown as an ErrorResponse
   * instance which include the raw Error, such that the calling context can
   * serialize the error as they see fit while including the proper response
   * code.  Examples here are 404 and 405 errors that occur prior to reaching
   * any user-defined loaders.
   */

  async function queryRoute(request, _temp3) {
    let {
      routeId,
      requestContext
    } = _temp3 === void 0 ? {} : _temp3;
    let url = new URL(request.url);
    let method = request.method.toLowerCase();
    let location = createLocation("", createPath(url), null, "default");
    let matches = matchRoutes(dataRoutes, location, basename); // SSR supports HEAD requests while SPA doesn't

    if (!isValidMethod(method) && method !== "head" && method !== "options") {
      throw getInternalRouterError(405, {
        method
      });
    } else if (!matches) {
      throw getInternalRouterError(404, {
        pathname: location.pathname
      });
    }
    let match = routeId ? matches.find(m => m.route.id === routeId) : getTargetMatch(matches, location);
    if (routeId && !match) {
      throw getInternalRouterError(403, {
        pathname: location.pathname,
        routeId
      });
    } else if (!match) {
      // This should never hit I don't think?
      throw getInternalRouterError(404, {
        pathname: location.pathname
      });
    }
    let result = await queryImpl(request, location, matches, requestContext, match);
    if (isResponse(result)) {
      return result;
    }
    let error = result.errors ? Object.values(result.errors)[0] : undefined;
    if (error !== undefined) {
      // If we got back result.errors, that means the loader/action threw
      // _something_ that wasn't a Response, but it's not guaranteed/required
      // to be an `instanceof Error` either, so we have to use throw here to
      // preserve the "error" state outside of queryImpl.
      throw error;
    } // Pick off the right state value to return

    if (result.actionData) {
      return Object.values(result.actionData)[0];
    }
    if (result.loaderData) {
      var _result$activeDeferre;
      let data = Object.values(result.loaderData)[0];
      if ((_result$activeDeferre = result.activeDeferreds) != null && _result$activeDeferre[match.route.id]) {
        data[UNSAFE_DEFERRED_SYMBOL] = result.activeDeferreds[match.route.id];
      }
      return data;
    }
    return undefined;
  }
  async function queryImpl(request, location, matches, requestContext, routeMatch) {
    invariant(request.signal, "query()/queryRoute() requests must contain an AbortController signal");
    try {
      if (isMutationMethod(request.method.toLowerCase())) {
        let result = await submit(request, matches, routeMatch || getTargetMatch(matches, location), requestContext, routeMatch != null);
        return result;
      }
      let result = await loadRouteData(request, matches, requestContext, routeMatch);
      return isResponse(result) ? result : _extends({}, result, {
        actionData: null,
        actionHeaders: {}
      });
    } catch (e) {
      // If the user threw/returned a Response in callLoaderOrAction, we throw
      // it to bail out and then return or throw here based on whether the user
      // returned or threw
      if (isQueryRouteResponse(e)) {
        if (e.type === ResultType.error && !isRedirectResponse(e.response)) {
          throw e.response;
        }
        return e.response;
      } // Redirects are always returned since they don't propagate to catch
      // boundaries

      if (isRedirectResponse(e)) {
        return e;
      }
      throw e;
    }
  }
  async function submit(request, matches, actionMatch, requestContext, isRouteRequest) {
    let result;
    if (!actionMatch.route.action && !actionMatch.route.lazy) {
      let error = getInternalRouterError(405, {
        method: request.method,
        pathname: new URL(request.url).pathname,
        routeId: actionMatch.route.id
      });
      if (isRouteRequest) {
        throw error;
      }
      result = {
        type: ResultType.error,
        error
      };
    } else {
      result = await callLoaderOrAction("action", request, actionMatch, matches, manifest, detectErrorBoundary, basename, true, isRouteRequest, requestContext);
      if (request.signal.aborted) {
        let method = isRouteRequest ? "queryRoute" : "query";
        throw new Error(method + "() call aborted");
      }
    }
    if (isRedirectResult(result)) {
      // Uhhhh - this should never happen, we should always throw these from
      // callLoaderOrAction, but the type narrowing here keeps TS happy and we
      // can get back on the "throw all redirect responses" train here should
      // this ever happen :/
      throw new Response(null, {
        status: result.status,
        headers: {
          Location: result.location
        }
      });
    }
    if (isDeferredResult(result)) {
      let error = getInternalRouterError(400, {
        type: "defer-action"
      });
      if (isRouteRequest) {
        throw error;
      }
      result = {
        type: ResultType.error,
        error
      };
    }
    if (isRouteRequest) {
      // Note: This should only be non-Response values if we get here, since
      // isRouteRequest should throw any Response received in callLoaderOrAction
      if (isErrorResult(result)) {
        throw result.error;
      }
      return {
        matches: [actionMatch],
        loaderData: {},
        actionData: {
          [actionMatch.route.id]: result.data
        },
        errors: null,
        // Note: statusCode + headers are unused here since queryRoute will
        // return the raw Response or value
        statusCode: 200,
        loaderHeaders: {},
        actionHeaders: {},
        activeDeferreds: null
      };
    }
    if (isErrorResult(result)) {
      // Store off the pending error - we use it to determine which loaders
      // to call and will commit it when we complete the navigation
      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);
      let context = await loadRouteData(request, matches, requestContext, undefined, {
        [boundaryMatch.route.id]: result.error
      }); // action status codes take precedence over loader status codes

      return _extends({}, context, {
        statusCode: isRouteErrorResponse(result.error) ? result.error.status : 500,
        actionData: null,
        actionHeaders: _extends({}, result.headers ? {
          [actionMatch.route.id]: result.headers
        } : {})
      });
    } // Create a GET request for the loaders

    let loaderRequest = new Request(request.url, {
      headers: request.headers,
      redirect: request.redirect,
      signal: request.signal
    });
    let context = await loadRouteData(loaderRequest, matches, requestContext);
    return _extends({}, context, result.statusCode ? {
      statusCode: result.statusCode
    } : {}, {
      actionData: {
        [actionMatch.route.id]: result.data
      },
      actionHeaders: _extends({}, result.headers ? {
        [actionMatch.route.id]: result.headers
      } : {})
    });
  }
  async function loadRouteData(request, matches, requestContext, routeMatch, pendingActionError) {
    let isRouteRequest = routeMatch != null; // Short circuit if we have no loaders to run (queryRoute())

    if (isRouteRequest && !(routeMatch != null && routeMatch.route.loader) && !(routeMatch != null && routeMatch.route.lazy)) {
      throw getInternalRouterError(400, {
        method: request.method,
        pathname: new URL(request.url).pathname,
        routeId: routeMatch == null ? void 0 : routeMatch.route.id
      });
    }
    let requestMatches = routeMatch ? [routeMatch] : getLoaderMatchesUntilBoundary(matches, Object.keys(pendingActionError || {})[0]);
    let matchesToLoad = requestMatches.filter(m => m.route.loader || m.route.lazy); // Short circuit if we have no loaders to run (query())

    if (matchesToLoad.length === 0) {
      return {
        matches,
        // Add a null for all matched routes for proper revalidation on the client
        loaderData: matches.reduce((acc, m) => Object.assign(acc, {
          [m.route.id]: null
        }), {}),
        errors: pendingActionError || null,
        statusCode: 200,
        loaderHeaders: {},
        activeDeferreds: null
      };
    }
    let results = await Promise.all([...matchesToLoad.map(match => callLoaderOrAction("loader", request, match, matches, manifest, detectErrorBoundary, basename, true, isRouteRequest, requestContext))]);
    if (request.signal.aborted) {
      let method = isRouteRequest ? "queryRoute" : "query";
      throw new Error(method + "() call aborted");
    } // Process and commit output from loaders

    let activeDeferreds = new Map();
    let context = processRouteLoaderData(matches, matchesToLoad, results, pendingActionError, activeDeferreds); // Add a null for any non-loader matches for proper revalidation on the client

    let executedLoaders = new Set(matchesToLoad.map(match => match.route.id));
    matches.forEach(match => {
      if (!executedLoaders.has(match.route.id)) {
        context.loaderData[match.route.id] = null;
      }
    });
    return _extends({}, context, {
      matches,
      activeDeferreds: activeDeferreds.size > 0 ? Object.fromEntries(activeDeferreds.entries()) : null
    });
  }
  return {
    dataRoutes,
    query,
    queryRoute
  };
} //#endregion
////////////////////////////////////////////////////////////////////////////////
//#region Helpers
////////////////////////////////////////////////////////////////////////////////

/**
 * Given an existing StaticHandlerContext and an error thrown at render time,
 * provide an updated StaticHandlerContext suitable for a second SSR render
 */

function getStaticContextFromError(routes, context, error) {
  let newContext = _extends({}, context, {
    statusCode: 500,
    errors: {
      [context._deepestRenderedBoundaryId || routes[0].id]: error
    }
  });
  return newContext;
}
function isSubmissionNavigation(opts) {
  return opts != null && "formData" in opts;
} // Normalize navigation options by converting formMethod=GET formData objects to
// URLSearchParams so they behave identically to links with query params

function normalizeNavigateOptions(to, opts, isFetcher) {
  if (isFetcher === void 0) {
    isFetcher = false;
  }
  let path = typeof to === "string" ? to : createPath(to); // Return location verbatim on non-submission navigations

  if (!opts || !isSubmissionNavigation(opts)) {
    return {
      path
    };
  }
  if (opts.formMethod && !isValidMethod(opts.formMethod)) {
    return {
      path,
      error: getInternalRouterError(405, {
        method: opts.formMethod
      })
    };
  } // Create a Submission on non-GET navigations

  let submission;
  if (opts.formData) {
    submission = {
      formMethod: opts.formMethod || "get",
      formAction: stripHashFromPath(path),
      formEncType: opts && opts.formEncType || "application/x-www-form-urlencoded",
      formData: opts.formData
    };
    if (isMutationMethod(submission.formMethod)) {
      return {
        path,
        submission
      };
    }
  } // Flatten submission onto URLSearchParams for GET submissions

  let parsedPath = parsePath(path);
  let searchParams = convertFormDataToSearchParams(opts.formData); // Since fetcher GET submissions only run a single loader (as opposed to
  // navigation GET submissions which run all loaders), we need to preserve
  // any incoming ?index params

  if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {
    searchParams.append("index", "");
  }
  parsedPath.search = "?" + searchParams;
  return {
    path: createPath(parsedPath),
    submission
  };
} // Filter out all routes below any caught error as they aren't going to
// render so we don't need to load them

function getLoaderMatchesUntilBoundary(matches, boundaryId) {
  let boundaryMatches = matches;
  if (boundaryId) {
    let index = matches.findIndex(m => m.route.id === boundaryId);
    if (index >= 0) {
      boundaryMatches = matches.slice(0, index);
    }
  }
  return boundaryMatches;
}
function getMatchesToLoad(history, state, matches, submission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, fetchLoadMatches, routesToUse, basename, pendingActionData, pendingError) {
  let actionResult = pendingError ? Object.values(pendingError)[0] : pendingActionData ? Object.values(pendingActionData)[0] : undefined;
  let currentUrl = history.createURL(state.location);
  let nextUrl = history.createURL(location);
  let defaultShouldRevalidate =
  // Forced revalidation due to submission, useRevalidate, or X-Remix-Revalidate
  isRevalidationRequired ||
  // Clicked the same link, resubmitted a GET form
  currentUrl.toString() === nextUrl.toString() ||
  // Search params affect all loaders
  currentUrl.search !== nextUrl.search; // Pick navigation matches that are net-new or qualify for revalidation

  let boundaryId = pendingError ? Object.keys(pendingError)[0] : undefined;
  let boundaryMatches = getLoaderMatchesUntilBoundary(matches, boundaryId);
  let navigationMatches = boundaryMatches.filter((match, index) => {
    if (match.route.lazy) {
      // We haven't loaded this route yet so we don't know if it's got a loader!
      return true;
    }
    if (match.route.loader == null) {
      return false;
    } // Always call the loader on new route instances and pending defer cancellations

    if (isNewLoader(state.loaderData, state.matches[index], match) || cancelledDeferredRoutes.some(id => id === match.route.id)) {
      return true;
    } // This is the default implementation for when we revalidate.  If the route
    // provides it's own implementation, then we give them full control but
    // provide this value so they can leverage it if needed after they check
    // their own specific use cases

    let currentRouteMatch = state.matches[index];
    let nextRouteMatch = match;
    return shouldRevalidateLoader(match, _extends({
      currentUrl,
      currentParams: currentRouteMatch.params,
      nextUrl,
      nextParams: nextRouteMatch.params
    }, submission, {
      actionResult,
      defaultShouldRevalidate: defaultShouldRevalidate || isNewRouteInstance(currentRouteMatch, nextRouteMatch)
    }));
  }); // Pick fetcher.loads that need to be revalidated

  let revalidatingFetchers = [];
  fetchLoadMatches.forEach((f, key) => {
    // Don't revalidate if fetcher won't be present in the subsequent render
    if (!matches.some(m => m.route.id === f.routeId)) {
      return;
    }
    let fetcherMatches = matchRoutes(routesToUse, f.path, basename); // If the fetcher path no longer matches, push it in with null matches so
    // we can trigger a 404 in callLoadersAndMaybeResolveData

    if (!fetcherMatches) {
      revalidatingFetchers.push(_extends({
        key
      }, f, {
        matches: null,
        match: null
      }));
      return;
    }
    let fetcherMatch = getTargetMatch(fetcherMatches, f.path);
    if (cancelledFetcherLoads.includes(key)) {
      revalidatingFetchers.push(_extends({
        key,
        matches: fetcherMatches,
        match: fetcherMatch
      }, f));
      return;
    } // Revalidating fetchers are decoupled from the route matches since they
    // hit a static href, so they _always_ check shouldRevalidate and the
    // default is strictly if a revalidation is explicitly required (action
    // submissions, useRevalidator, X-Remix-Revalidate).

    let shouldRevalidate = shouldRevalidateLoader(fetcherMatch, _extends({
      currentUrl,
      currentParams: state.matches[state.matches.length - 1].params,
      nextUrl,
      nextParams: matches[matches.length - 1].params
    }, submission, {
      actionResult,
      defaultShouldRevalidate
    }));
    if (shouldRevalidate) {
      revalidatingFetchers.push(_extends({
        key,
        matches: fetcherMatches,
        match: fetcherMatch
      }, f));
    }
  });
  return [navigationMatches, revalidatingFetchers];
}
function isNewLoader(currentLoaderData, currentMatch, match) {
  let isNew =
  // [a] -> [a, b]
  !currentMatch ||
  // [a, b] -> [a, c]
  match.route.id !== currentMatch.route.id; // Handle the case that we don't have data for a re-used route, potentially
  // from a prior error or from a cancelled pending deferred

  let isMissingData = currentLoaderData[match.route.id] === undefined; // Always load if this is a net-new route or we don't yet have data

  return isNew || isMissingData;
}
function isNewRouteInstance(currentMatch, match) {
  let currentPath = currentMatch.route.path;
  return (
    // param change for this match, /users/123 -> /users/456
    currentMatch.pathname !== match.pathname ||
    // splat param changed, which is not present in match.path
    // e.g. /files/images/avatar.jpg -> files/finances.xls
    currentPath != null && currentPath.endsWith("*") && currentMatch.params["*"] !== match.params["*"]
  );
}
function shouldRevalidateLoader(loaderMatch, arg) {
  if (loaderMatch.route.shouldRevalidate) {
    let routeChoice = loaderMatch.route.shouldRevalidate(arg);
    if (typeof routeChoice === "boolean") {
      return routeChoice;
    }
  }
  return arg.defaultShouldRevalidate;
}
/**
 * Execute route.lazy() methods to lazily load route modules (loader, action,
 * shouldRevalidate) and update the routeManifest in place which shares objects
 * with dataRoutes so those get updated as well.
 */

async function loadLazyRouteModule(route, detectErrorBoundary, manifest) {
  if (!route.lazy) {
    return;
  }
  let lazyRoute = await route.lazy(); // If the lazy route function was executed and removed by another parallel
  // call then we can return - first lazy() to finish wins because the return
  // value of lazy is expected to be static

  if (!route.lazy) {
    return;
  }
  let routeToUpdate = manifest[route.id];
  invariant(routeToUpdate, "No route found in manifest"); // Update the route in place.  This should be safe because there's no way
  // we could yet be sitting on this route as we can't get there without
  // resolving lazy() first.
  //
  // This is different than the HMR "update" use-case where we may actively be
  // on the route being updated.  The main concern boils down to "does this
  // mutation affect any ongoing navigations or any current state.matches
  // values?".  If not, it should be safe to update in place.

  let routeUpdates = {};
  for (let lazyRouteProperty in lazyRoute) {
    let staticRouteValue = routeToUpdate[lazyRouteProperty];
    let isPropertyStaticallyDefined = staticRouteValue !== undefined &&
    // This property isn't static since it should always be updated based
    // on the route updates
    lazyRouteProperty !== "hasErrorBoundary";
    warning(!isPropertyStaticallyDefined, "Route \"" + routeToUpdate.id + "\" has a static property \"" + lazyRouteProperty + "\" " + "defined but its lazy function is also returning a value for this property. " + ("The lazy route property \"" + lazyRouteProperty + "\" will be ignored."));
    if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {
      routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];
    }
  } // Mutate the route with the provided updates.  Do this first so we pass
  // the updated version to detectErrorBoundary

  Object.assign(routeToUpdate, routeUpdates); // Mutate the `hasErrorBoundary` property on the route based on the route
  // updates and remove the `lazy` function so we don't resolve the lazy
  // route again.

  Object.assign(routeToUpdate, {
    // To keep things framework agnostic, we use the provided
    // `detectErrorBoundary` function to set the `hasErrorBoundary` route
    // property since the logic will differ between frameworks.
    hasErrorBoundary: detectErrorBoundary(_extends({}, routeToUpdate)),
    lazy: undefined
  });
}
async function callLoaderOrAction(type, request, match, matches, manifest, detectErrorBoundary, basename, isStaticRequest, isRouteRequest, requestContext) {
  if (basename === void 0) {
    basename = "/";
  }
  if (isStaticRequest === void 0) {
    isStaticRequest = false;
  }
  if (isRouteRequest === void 0) {
    isRouteRequest = false;
  }
  let resultType;
  let result;
  let onReject;
  let runHandler = handler => {
    // Setup a promise we can race against so that abort signals short circuit
    let reject;
    let abortPromise = new Promise((_, r) => reject = r);
    onReject = () => reject();
    request.signal.addEventListener("abort", onReject);
    return Promise.race([handler({
      request,
      params: match.params,
      context: requestContext
    }), abortPromise]);
  };
  try {
    let handler = match.route[type];
    if (match.route.lazy) {
      if (handler) {
        // Run statically defined handler in parallel with lazy()
        let values = await Promise.all([runHandler(handler), loadLazyRouteModule(match.route, detectErrorBoundary, manifest)]);
        result = values[0];
      } else {
        // Load lazy route module, then run any returned handler
        await loadLazyRouteModule(match.route, detectErrorBoundary, manifest);
        handler = match.route[type];
        if (handler) {
          // Handler still run even if we got interrupted to maintain consistency
          // with un-abortable behavior of handler execution on non-lazy or
          // previously-lazy-loaded routes
          result = await runHandler(handler);
        } else if (type === "action") {
          throw getInternalRouterError(405, {
            method: request.method,
            pathname: new URL(request.url).pathname,
            routeId: match.route.id
          });
        } else {
          // lazy() route has no loader to run.  Short circuit here so we don't
          // hit the invariant below that errors on returning undefined.
          return {
            type: ResultType.data,
            data: undefined
          };
        }
      }
    } else {
      invariant(handler, "Could not find the " + type + " to run on the \"" + match.route.id + "\" route");
      result = await runHandler(handler);
    }
    invariant(result !== undefined, "You defined " + (type === "action" ? "an action" : "a loader") + " for route " + ("\"" + match.route.id + "\" but didn't return anything from your `" + type + "` ") + "function. Please return a value or `null`.");
  } catch (e) {
    resultType = ResultType.error;
    result = e;
  } finally {
    if (onReject) {
      request.signal.removeEventListener("abort", onReject);
    }
  }
  if (isResponse(result)) {
    let status = result.status; // Process redirects

    if (redirectStatusCodes.has(status)) {
      let location = result.headers.get("Location");
      invariant(location, "Redirects returned/thrown from loaders/actions must have a Location header"); // Support relative routing in internal redirects

      if (!ABSOLUTE_URL_REGEX.test(location)) {
        let activeMatches = matches.slice(0, matches.indexOf(match) + 1);
        let routePathnames = getPathContributingMatches(activeMatches).map(match => match.pathnameBase);
        let resolvedLocation = resolveTo(location, routePathnames, new URL(request.url).pathname);
        invariant(createPath(resolvedLocation), "Unable to resolve redirect location: " + location); // Prepend the basename to the redirect location if we have one

        if (basename) {
          let path = resolvedLocation.pathname;
          resolvedLocation.pathname = path === "/" ? basename : joinPaths([basename, path]);
        }
        location = createPath(resolvedLocation);
      } else if (!isStaticRequest) {
        // Strip off the protocol+origin for same-origin + same-basename absolute
        // redirects. If this is a static request, we can let it go back to the
        // browser as-is
        let currentUrl = new URL(request.url);
        let url = location.startsWith("//") ? new URL(currentUrl.protocol + location) : new URL(location);
        let isSameBasename = stripBasename(url.pathname, basename) != null;
        if (url.origin === currentUrl.origin && isSameBasename) {
          location = url.pathname + url.search + url.hash;
        }
      } // Don't process redirects in the router during static requests requests.
      // Instead, throw the Response and let the server handle it with an HTTP
      // redirect.  We also update the Location header in place in this flow so
      // basename and relative routing is taken into account

      if (isStaticRequest) {
        result.headers.set("Location", location);
        throw result;
      }
      return {
        type: ResultType.redirect,
        status,
        location,
        revalidate: result.headers.get("X-Remix-Revalidate") !== null
      };
    } // For SSR single-route requests, we want to hand Responses back directly
    // without unwrapping.  We do this with the QueryRouteResponse wrapper
    // interface so we can know whether it was returned or thrown

    if (isRouteRequest) {
      // eslint-disable-next-line no-throw-literal
      throw {
        type: resultType || ResultType.data,
        response: result
      };
    }
    let data;
    let contentType = result.headers.get("Content-Type"); // Check between word boundaries instead of startsWith() due to the last
    // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type

    if (contentType && /\bapplication\/json\b/.test(contentType)) {
      data = await result.json();
    } else {
      data = await result.text();
    }
    if (resultType === ResultType.error) {
      return {
        type: resultType,
        error: new ErrorResponse(status, result.statusText, data),
        headers: result.headers
      };
    }
    return {
      type: ResultType.data,
      data,
      statusCode: result.status,
      headers: result.headers
    };
  }
  if (resultType === ResultType.error) {
    return {
      type: resultType,
      error: result
    };
  }
  if (result instanceof DeferredData) {
    var _result$init, _result$init2;
    return {
      type: ResultType.deferred,
      deferredData: result,
      statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status,
      headers: ((_result$init2 = result.init) == null ? void 0 : _result$init2.headers) && new Headers(result.init.headers)
    };
  }
  return {
    type: ResultType.data,
    data: result
  };
} // Utility method for creating the Request instances for loaders/actions during
// client-side navigations and fetches.  During SSR we will always have a
// Request instance from the static handler (query/queryRoute)

function createClientSideRequest(history, location, signal, submission) {
  let url = history.createURL(stripHashFromPath(location)).toString();
  let init = {
    signal
  };
  if (submission && isMutationMethod(submission.formMethod)) {
    let {
      formMethod,
      formEncType,
      formData
    } = submission;
    init.method = formMethod.toUpperCase();
    init.body = formEncType === "application/x-www-form-urlencoded" ? convertFormDataToSearchParams(formData) : formData;
  } // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)

  return new Request(url, init);
}
function convertFormDataToSearchParams(formData) {
  let searchParams = new URLSearchParams();
  for (let [key, value] of formData.entries()) {
    // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#converting-an-entry-list-to-a-list-of-name-value-pairs
    searchParams.append(key, value instanceof File ? value.name : value);
  }
  return searchParams;
}
function processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds) {
  // Fill in loaderData/errors from our loaders
  let loaderData = {};
  let errors = null;
  let statusCode;
  let foundError = false;
  let loaderHeaders = {}; // Process loader results into state.loaderData/state.errors

  results.forEach((result, index) => {
    let id = matchesToLoad[index].route.id;
    invariant(!isRedirectResult(result), "Cannot handle redirect results in processLoaderData");
    if (isErrorResult(result)) {
      // Look upwards from the matched route for the closest ancestor
      // error boundary, defaulting to the root match
      let boundaryMatch = findNearestBoundary(matches, id);
      let error = result.error; // If we have a pending action error, we report it at the highest-route
      // that throws a loader error, and then clear it out to indicate that
      // it was consumed

      if (pendingError) {
        error = Object.values(pendingError)[0];
        pendingError = undefined;
      }
      errors = errors || {}; // Prefer higher error values if lower errors bubble to the same boundary

      if (errors[boundaryMatch.route.id] == null) {
        errors[boundaryMatch.route.id] = error;
      } // Clear our any prior loaderData for the throwing route

      loaderData[id] = undefined; // Once we find our first (highest) error, we set the status code and
      // prevent deeper status codes from overriding

      if (!foundError) {
        foundError = true;
        statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;
      }
      if (result.headers) {
        loaderHeaders[id] = result.headers;
      }
    } else {
      if (isDeferredResult(result)) {
        activeDeferreds.set(id, result.deferredData);
        loaderData[id] = result.deferredData.data;
      } else {
        loaderData[id] = result.data;
      } // Error status codes always override success status codes, but if all
      // loaders are successful we take the deepest status code.

      if (result.statusCode != null && result.statusCode !== 200 && !foundError) {
        statusCode = result.statusCode;
      }
      if (result.headers) {
        loaderHeaders[id] = result.headers;
      }
    }
  }); // If we didn't consume the pending action error (i.e., all loaders
  // resolved), then consume it here.  Also clear out any loaderData for the
  // throwing route

  if (pendingError) {
    errors = pendingError;
    loaderData[Object.keys(pendingError)[0]] = undefined;
  }
  return {
    loaderData,
    errors,
    statusCode: statusCode || 200,
    loaderHeaders
  };
}
function processLoaderData(state, matches, matchesToLoad, results, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds) {
  let {
    loaderData,
    errors
  } = processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds); // Process results from our revalidating fetchers

  for (let index = 0; index < revalidatingFetchers.length; index++) {
    let {
      key,
      match
    } = revalidatingFetchers[index];
    invariant(fetcherResults !== undefined && fetcherResults[index] !== undefined, "Did not find corresponding fetcher result");
    let result = fetcherResults[index]; // Process fetcher non-redirect errors

    if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(state.matches, match == null ? void 0 : match.route.id);
      if (!(errors && errors[boundaryMatch.route.id])) {
        errors = _extends({}, errors, {
          [boundaryMatch.route.id]: result.error
        });
      }
      state.fetchers.delete(key);
    } else if (isRedirectResult(result)) {
      // Should never get here, redirects should get processed above, but we
      // keep this to type narrow to a success result in the else
      invariant(false, "Unhandled fetcher revalidation redirect");
    } else if (isDeferredResult(result)) {
      // Should never get here, deferred data should be awaited for fetchers
      // in resolveDeferredResults
      invariant(false, "Unhandled fetcher deferred data");
    } else {
      let doneFetcher = {
        state: "idle",
        data: result.data,
        formMethod: undefined,
        formAction: undefined,
        formEncType: undefined,
        formData: undefined,
        " _hasFetcherDoneAnything ": true
      };
      state.fetchers.set(key, doneFetcher);
    }
  }
  return {
    loaderData,
    errors
  };
}
function mergeLoaderData(loaderData, newLoaderData, matches, errors) {
  let mergedLoaderData = _extends({}, newLoaderData);
  for (let match of matches) {
    let id = match.route.id;
    if (newLoaderData.hasOwnProperty(id)) {
      if (newLoaderData[id] !== undefined) {
        mergedLoaderData[id] = newLoaderData[id];
      }
    } else if (loaderData[id] !== undefined && match.route.loader) {
      // Preserve existing keys not included in newLoaderData and where a loader
      // wasn't removed by HMR
      mergedLoaderData[id] = loaderData[id];
    }
    if (errors && errors.hasOwnProperty(id)) {
      // Don't keep any loader data below the boundary
      break;
    }
  }
  return mergedLoaderData;
} // Find the nearest error boundary, looking upwards from the leaf route (or the
// route specified by routeId) for the closest ancestor error boundary,
// defaulting to the root match

function findNearestBoundary(matches, routeId) {
  let eligibleMatches = routeId ? matches.slice(0, matches.findIndex(m => m.route.id === routeId) + 1) : [...matches];
  return eligibleMatches.reverse().find(m => m.route.hasErrorBoundary === true) || matches[0];
}
function getShortCircuitMatches(routes) {
  // Prefer a root layout route if present, otherwise shim in a route object
  let route = routes.find(r => r.index || !r.path || r.path === "/") || {
    id: "__shim-error-route__"
  };
  return {
    matches: [{
      params: {},
      pathname: "",
      pathnameBase: "",
      route
    }],
    route
  };
}
function getInternalRouterError(status, _temp4) {
  let {
    pathname,
    routeId,
    method,
    type
  } = _temp4 === void 0 ? {} : _temp4;
  let statusText = "Unknown Server Error";
  let errorMessage = "Unknown @remix-run/router error";
  if (status === 400) {
    statusText = "Bad Request";
    if (method && pathname && routeId) {
      errorMessage = "You made a " + method + " request to \"" + pathname + "\" but " + ("did not provide a `loader` for route \"" + routeId + "\", ") + "so there is no way to handle the request.";
    } else if (type === "defer-action") {
      errorMessage = "defer() is not supported in actions";
    }
  } else if (status === 403) {
    statusText = "Forbidden";
    errorMessage = "Route \"" + routeId + "\" does not match URL \"" + pathname + "\"";
  } else if (status === 404) {
    statusText = "Not Found";
    errorMessage = "No route matches URL \"" + pathname + "\"";
  } else if (status === 405) {
    statusText = "Method Not Allowed";
    if (method && pathname && routeId) {
      errorMessage = "You made a " + method.toUpperCase() + " request to \"" + pathname + "\" but " + ("did not provide an `action` for route \"" + routeId + "\", ") + "so there is no way to handle the request.";
    } else if (method) {
      errorMessage = "Invalid request method \"" + method.toUpperCase() + "\"";
    }
  }
  return new ErrorResponse(status || 500, statusText, new Error(errorMessage), true);
} // Find any returned redirect errors, starting from the lowest match

function findRedirect(results) {
  for (let i = results.length - 1; i >= 0; i--) {
    let result = results[i];
    if (isRedirectResult(result)) {
      return result;
    }
  }
}
function stripHashFromPath(path) {
  let parsedPath = typeof path === "string" ? parsePath(path) : path;
  return createPath(_extends({}, parsedPath, {
    hash: ""
  }));
}
function isHashChangeOnly(a, b) {
  return a.pathname === b.pathname && a.search === b.search && a.hash !== b.hash;
}
function isDeferredResult(result) {
  return result.type === ResultType.deferred;
}
function isErrorResult(result) {
  return result.type === ResultType.error;
}
function isRedirectResult(result) {
  return (result && result.type) === ResultType.redirect;
}
function isResponse(value) {
  return value != null && typeof value.status === "number" && typeof value.statusText === "string" && typeof value.headers === "object" && typeof value.body !== "undefined";
}
function isRedirectResponse(result) {
  if (!isResponse(result)) {
    return false;
  }
  let status = result.status;
  let location = result.headers.get("Location");
  return status >= 300 && status <= 399 && location != null;
}
function isQueryRouteResponse(obj) {
  return obj && isResponse(obj.response) && (obj.type === ResultType.data || ResultType.error);
}
function isValidMethod(method) {
  return validRequestMethods.has(method);
}
function isMutationMethod(method) {
  return validMutationMethods.has(method);
}
async function resolveDeferredResults(currentMatches, matchesToLoad, results, signal, isFetcher, currentLoaderData) {
  for (let index = 0; index < results.length; index++) {
    let result = results[index];
    let match = matchesToLoad[index]; // If we don't have a match, then we can have a deferred result to do
    // anything with.  This is for revalidating fetchers where the route was
    // removed during HMR

    if (!match) {
      continue;
    }
    let currentMatch = currentMatches.find(m => m.route.id === match.route.id);
    let isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== undefined;
    if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {
      // Note: we do not have to touch activeDeferreds here since we race them
      // against the signal in resolveDeferredData and they'll get aborted
      // there if needed
      await resolveDeferredData(result, signal, isFetcher).then(result => {
        if (result) {
          results[index] = result || results[index];
        }
      });
    }
  }
}
async function resolveDeferredData(result, signal, unwrap) {
  if (unwrap === void 0) {
    unwrap = false;
  }
  let aborted = await result.deferredData.resolveData(signal);
  if (aborted) {
    return;
  }
  if (unwrap) {
    try {
      return {
        type: ResultType.data,
        data: result.deferredData.unwrappedData
      };
    } catch (e) {
      // Handle any TrackedPromise._error values encountered while unwrapping
      return {
        type: ResultType.error,
        error: e
      };
    }
  }
  return {
    type: ResultType.data,
    data: result.deferredData.data
  };
}
function hasNakedIndexQuery(search) {
  return new URLSearchParams(search).getAll("index").some(v => v === "");
} // Note: This should match the format exported by useMatches, so if you change
// this please also change that :)  Eventually we'll DRY this up

function createUseMatchesMatch(match, loaderData) {
  let {
    route,
    pathname,
    params
  } = match;
  return {
    id: route.id,
    pathname,
    params,
    data: loaderData[route.id],
    handle: route.handle
  };
}
function getTargetMatch(matches, location) {
  let search = typeof location === "string" ? parsePath(location).search : location.search;
  if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || "")) {
    // Return the leaf index route when index is present
    return matches[matches.length - 1];
  } // Otherwise grab the deepest "path contributing" match (ignoring index and
  // pathless layout routes)

  let pathMatches = getPathContributingMatches(matches);
  return pathMatches[pathMatches.length - 1];
} //#endregion

exports.AbortedDeferredError = AbortedDeferredError;
exports.ErrorResponse = ErrorResponse;
exports.IDLE_BLOCKER = IDLE_BLOCKER;
exports.IDLE_FETCHER = IDLE_FETCHER;
exports.IDLE_NAVIGATION = IDLE_NAVIGATION;
exports.UNSAFE_DEFERRED_SYMBOL = UNSAFE_DEFERRED_SYMBOL;
exports.UNSAFE_DeferredData = DeferredData;
exports.UNSAFE_convertRoutesToDataRoutes = convertRoutesToDataRoutes;
exports.UNSAFE_getPathContributingMatches = getPathContributingMatches;
exports.UNSAFE_invariant = invariant;
exports.UNSAFE_warning = warning;
exports.createBrowserHistory = createBrowserHistory;
exports.createHashHistory = createHashHistory;
exports.createMemoryHistory = createMemoryHistory;
exports.createPath = createPath;
exports.createRouter = createRouter;
exports.createStaticHandler = createStaticHandler;
exports.defer = defer;
exports.generatePath = generatePath;
exports.getStaticContextFromError = getStaticContextFromError;
exports.getToPathname = getToPathname;
exports.isRouteErrorResponse = isRouteErrorResponse;
exports.joinPaths = joinPaths;
exports.json = json;
exports.matchPath = matchPath;
exports.matchRoutes = matchRoutes;
exports.normalizePathname = normalizePathname;
exports.parsePath = parsePath;
exports.redirect = redirect;
exports.resolvePath = resolvePath;
exports.resolveTo = resolveTo;
exports.stripBasename = stripBasename;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJleHBvcnRzIiwiQWN0aW9uIiwiUG9wU3RhdGVFdmVudFR5cGUiLCJjcmVhdGVNZW1vcnlIaXN0b3J5Iiwib3B0aW9ucyIsImluaXRpYWxFbnRyaWVzIiwiaW5pdGlhbEluZGV4IiwidjVDb21wYXQiLCJlbnRyaWVzIiwibWFwIiwiZW50cnkiLCJpbmRleCIsImNyZWF0ZU1lbW9yeUxvY2F0aW9uIiwic3RhdGUiLCJ1bmRlZmluZWQiLCJjbGFtcEluZGV4IiwibGVuZ3RoIiwiYWN0aW9uIiwiUG9wIiwibGlzdGVuZXIiLCJuIiwiTWF0aCIsIm1pbiIsIm1heCIsImdldEN1cnJlbnRMb2NhdGlvbiIsInRvIiwia2V5IiwibG9jYXRpb24iLCJjcmVhdGVMb2NhdGlvbiIsInBhdGhuYW1lIiwid2FybmluZyIsImNoYXJBdCIsIkpTT04iLCJzdHJpbmdpZnkiLCJjcmVhdGVIcmVmIiwiY3JlYXRlUGF0aCIsImhpc3RvcnkiLCJjcmVhdGVVUkwiLCJVUkwiLCJlbmNvZGVMb2NhdGlvbiIsInBhdGgiLCJwYXJzZVBhdGgiLCJzZWFyY2giLCJoYXNoIiwicHVzaCIsIlB1c2giLCJuZXh0TG9jYXRpb24iLCJzcGxpY2UiLCJkZWx0YSIsInJlcGxhY2UiLCJSZXBsYWNlIiwiZ28iLCJuZXh0SW5kZXgiLCJsaXN0ZW4iLCJmbiIsImNyZWF0ZUJyb3dzZXJIaXN0b3J5IiwiY3JlYXRlQnJvd3NlckxvY2F0aW9uIiwid2luZG93IiwiZ2xvYmFsSGlzdG9yeSIsInVzciIsImNyZWF0ZUJyb3dzZXJIcmVmIiwiZ2V0VXJsQmFzZWRIaXN0b3J5IiwiY3JlYXRlSGFzaEhpc3RvcnkiLCJjcmVhdGVIYXNoTG9jYXRpb24iLCJzdWJzdHIiLCJjcmVhdGVIYXNoSHJlZiIsImJhc2UiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJocmVmIiwiZ2V0QXR0cmlidXRlIiwidXJsIiwiaGFzaEluZGV4IiwiaW5kZXhPZiIsInNsaWNlIiwidmFsaWRhdGVIYXNoTG9jYXRpb24iLCJpbnZhcmlhbnQiLCJ2YWx1ZSIsIm1lc3NhZ2UiLCJFcnJvciIsImNvbmQiLCJjb25zb2xlIiwid2FybiIsImUiLCJjcmVhdGVLZXkiLCJyYW5kb20iLCJ0b1N0cmluZyIsImdldEhpc3RvcnlTdGF0ZSIsImlkeCIsImN1cnJlbnQiLCJfZXh0ZW5kcyIsIl9yZWYiLCJwYXJzZWRQYXRoIiwic2VhcmNoSW5kZXgiLCJnZXRMb2NhdGlvbiIsInZhbGlkYXRlTG9jYXRpb24iLCJkZWZhdWx0VmlldyIsImdldEluZGV4IiwicmVwbGFjZVN0YXRlIiwiaGFuZGxlUG9wIiwiaGlzdG9yeVN0YXRlIiwicHVzaFN0YXRlIiwiZXJyb3IiLCJhc3NpZ24iLCJvcmlnaW4iLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIlJlc3VsdFR5cGUiLCJpbW11dGFibGVSb3V0ZUtleXMiLCJTZXQiLCJpc0luZGV4Um91dGUiLCJyb3V0ZSIsImNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMiLCJyb3V0ZXMiLCJkZXRlY3RFcnJvckJvdW5kYXJ5IiwicGFyZW50UGF0aCIsIm1hbmlmZXN0IiwidHJlZVBhdGgiLCJpZCIsImpvaW4iLCJjaGlsZHJlbiIsImluZGV4Um91dGUiLCJoYXNFcnJvckJvdW5kYXJ5IiwicGF0aE9yTGF5b3V0Um91dGUiLCJtYXRjaFJvdXRlcyIsImxvY2F0aW9uQXJnIiwiYmFzZW5hbWUiLCJzdHJpcEJhc2VuYW1lIiwiYnJhbmNoZXMiLCJmbGF0dGVuUm91dGVzIiwicmFua1JvdXRlQnJhbmNoZXMiLCJtYXRjaGVzIiwiaSIsIm1hdGNoUm91dGVCcmFuY2giLCJzYWZlbHlEZWNvZGVVUkkiLCJwYXJlbnRzTWV0YSIsImZsYXR0ZW5Sb3V0ZSIsInJlbGF0aXZlUGF0aCIsIm1ldGEiLCJjYXNlU2Vuc2l0aXZlIiwiY2hpbGRyZW5JbmRleCIsInN0YXJ0c1dpdGgiLCJqb2luUGF0aHMiLCJyb3V0ZXNNZXRhIiwiY29uY2F0Iiwic2NvcmUiLCJjb21wdXRlU2NvcmUiLCJmb3JFYWNoIiwiX3JvdXRlJHBhdGgiLCJpbmNsdWRlcyIsImV4cGxvZGVkIiwiZXhwbG9kZU9wdGlvbmFsU2VnbWVudHMiLCJzZWdtZW50cyIsInNwbGl0IiwiZmlyc3QiLCJyZXN0IiwiaXNPcHRpb25hbCIsImVuZHNXaXRoIiwicmVxdWlyZWQiLCJyZXN0RXhwbG9kZWQiLCJyZXN1bHQiLCJzdWJwYXRoIiwic29ydCIsImEiLCJiIiwiY29tcGFyZUluZGV4ZXMiLCJwYXJhbVJlIiwiZHluYW1pY1NlZ21lbnRWYWx1ZSIsImluZGV4Um91dGVWYWx1ZSIsImVtcHR5U2VnbWVudFZhbHVlIiwic3RhdGljU2VnbWVudFZhbHVlIiwic3BsYXRQZW5hbHR5IiwiaXNTcGxhdCIsInMiLCJpbml0aWFsU2NvcmUiLCJzb21lIiwiZmlsdGVyIiwicmVkdWNlIiwic2VnbWVudCIsInRlc3QiLCJzaWJsaW5ncyIsImV2ZXJ5IiwiYnJhbmNoIiwibWF0Y2hlZFBhcmFtcyIsIm1hdGNoZWRQYXRobmFtZSIsImVuZCIsInJlbWFpbmluZ1BhdGhuYW1lIiwibWF0Y2giLCJtYXRjaFBhdGgiLCJPYmplY3QiLCJwYXJhbXMiLCJwYXRobmFtZUJhc2UiLCJub3JtYWxpemVQYXRobmFtZSIsImdlbmVyYXRlUGF0aCIsIm9yaWdpbmFsUGF0aCIsInByZWZpeCIsImFycmF5IiwiaXNMYXN0U2VnbWVudCIsInN0YXIiLCJzdGFyUGFyYW0iLCJrZXlNYXRjaCIsIm9wdGlvbmFsIiwicGFyYW0iLCJwYXR0ZXJuIiwibWF0Y2hlciIsInBhcmFtTmFtZXMiLCJjb21waWxlUGF0aCIsImNhcHR1cmVHcm91cHMiLCJtZW1vIiwicGFyYW1OYW1lIiwic3BsYXRWYWx1ZSIsInNhZmVseURlY29kZVVSSUNvbXBvbmVudCIsInJlZ2V4cFNvdXJjZSIsIl8iLCJSZWdFeHAiLCJkZWNvZGVVUkkiLCJkZWNvZGVVUklDb21wb25lbnQiLCJ0b0xvd2VyQ2FzZSIsInN0YXJ0SW5kZXgiLCJuZXh0Q2hhciIsInJlc29sdmVQYXRoIiwiZnJvbVBhdGhuYW1lIiwidG9QYXRobmFtZSIsInJlc29sdmVQYXRobmFtZSIsIm5vcm1hbGl6ZVNlYXJjaCIsIm5vcm1hbGl6ZUhhc2giLCJyZWxhdGl2ZVNlZ21lbnRzIiwicG9wIiwiZ2V0SW52YWxpZFBhdGhFcnJvciIsImNoYXIiLCJmaWVsZCIsImRlc3QiLCJnZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyIsInJlc29sdmVUbyIsInRvQXJnIiwicm91dGVQYXRobmFtZXMiLCJsb2NhdGlvblBhdGhuYW1lIiwiaXNQYXRoUmVsYXRpdmUiLCJpc0VtcHR5UGF0aCIsImZyb20iLCJyb3V0ZVBhdGhuYW1lSW5kZXgiLCJ0b1NlZ21lbnRzIiwic2hpZnQiLCJoYXNFeHBsaWNpdFRyYWlsaW5nU2xhc2giLCJoYXNDdXJyZW50VHJhaWxpbmdTbGFzaCIsImdldFRvUGF0aG5hbWUiLCJwYXRocyIsImpzb24iLCJkYXRhIiwiaW5pdCIsInJlc3BvbnNlSW5pdCIsInN0YXR1cyIsImhlYWRlcnMiLCJIZWFkZXJzIiwiaGFzIiwic2V0IiwiUmVzcG9uc2UiLCJBYm9ydGVkRGVmZXJyZWRFcnJvciIsIkRlZmVycmVkRGF0YSIsImNvbnN0cnVjdG9yIiwicGVuZGluZ0tleXNTZXQiLCJzdWJzY3JpYmVycyIsImRlZmVycmVkS2V5cyIsIkFycmF5IiwiaXNBcnJheSIsInJlamVjdCIsImFib3J0UHJvbWlzZSIsIlByb21pc2UiLCJyIiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsIm9uQWJvcnQiLCJ1bmxpc3RlbkFib3J0U2lnbmFsIiwic2lnbmFsIiwiYWNjIiwidHJhY2tQcm9taXNlIiwiZG9uZSIsImFkZCIsInByb21pc2UiLCJyYWNlIiwidGhlbiIsIm9uU2V0dGxlIiwiY2F0Y2giLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsImFib3J0ZWQiLCJkZWxldGUiLCJlbWl0Iiwic2V0dGxlZEtleSIsInN1YnNjcmliZXIiLCJzdWJzY3JpYmUiLCJjYW5jZWwiLCJhYm9ydCIsInYiLCJrIiwicmVzb2x2ZURhdGEiLCJyZXNvbHZlIiwic2l6ZSIsInVud3JhcHBlZERhdGEiLCJfcmVmMiIsInVud3JhcFRyYWNrZWRQcm9taXNlIiwicGVuZGluZ0tleXMiLCJpc1RyYWNrZWRQcm9taXNlIiwiX3RyYWNrZWQiLCJfZXJyb3IiLCJfZGF0YSIsImRlZmVyIiwicmVkaXJlY3QiLCJFcnJvclJlc3BvbnNlIiwic3RhdHVzVGV4dCIsImludGVybmFsIiwiaXNSb3V0ZUVycm9yUmVzcG9uc2UiLCJ2YWxpZE11dGF0aW9uTWV0aG9kc0FyciIsInZhbGlkTXV0YXRpb25NZXRob2RzIiwidmFsaWRSZXF1ZXN0TWV0aG9kc0FyciIsInZhbGlkUmVxdWVzdE1ldGhvZHMiLCJyZWRpcmVjdFN0YXR1c0NvZGVzIiwicmVkaXJlY3RQcmVzZXJ2ZU1ldGhvZFN0YXR1c0NvZGVzIiwiSURMRV9OQVZJR0FUSU9OIiwiZm9ybU1ldGhvZCIsImZvcm1BY3Rpb24iLCJmb3JtRW5jVHlwZSIsImZvcm1EYXRhIiwiSURMRV9GRVRDSEVSIiwiSURMRV9CTE9DS0VSIiwicHJvY2VlZCIsInJlc2V0IiwiQUJTT0xVVEVfVVJMX1JFR0VYIiwiaXNCcm93c2VyIiwiY3JlYXRlRWxlbWVudCIsImlzU2VydmVyIiwiZGVmYXVsdERldGVjdEVycm9yQm91bmRhcnkiLCJCb29sZWFuIiwiY3JlYXRlUm91dGVyIiwiZGF0YVJvdXRlcyIsImluRmxpZ2h0RGF0YVJvdXRlcyIsInVubGlzdGVuSGlzdG9yeSIsInNhdmVkU2Nyb2xsUG9zaXRpb25zIiwiZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkiLCJnZXRTY3JvbGxQb3NpdGlvbiIsImluaXRpYWxTY3JvbGxSZXN0b3JlZCIsImh5ZHJhdGlvbkRhdGEiLCJpbml0aWFsTWF0Y2hlcyIsImluaXRpYWxFcnJvcnMiLCJnZXRJbnRlcm5hbFJvdXRlckVycm9yIiwiZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyIsImluaXRpYWxpemVkIiwibSIsImxhenkiLCJsb2FkZXIiLCJyb3V0ZXIiLCJoaXN0b3J5QWN0aW9uIiwibmF2aWdhdGlvbiIsInJlc3RvcmVTY3JvbGxQb3NpdGlvbiIsInByZXZlbnRTY3JvbGxSZXNldCIsInJldmFsaWRhdGlvbiIsImxvYWRlckRhdGEiLCJhY3Rpb25EYXRhIiwiZXJyb3JzIiwiZmV0Y2hlcnMiLCJNYXAiLCJibG9ja2VycyIsInBlbmRpbmdBY3Rpb24iLCJwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0IiwicGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyIiwiaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uIiwiaXNSZXZhbGlkYXRpb25SZXF1aXJlZCIsImNhbmNlbGxlZERlZmVycmVkUm91dGVzIiwiY2FuY2VsbGVkRmV0Y2hlckxvYWRzIiwiZmV0Y2hDb250cm9sbGVycyIsImluY3JlbWVudGluZ0xvYWRJZCIsInBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkIiwiZmV0Y2hSZWxvYWRJZHMiLCJmZXRjaFJlZGlyZWN0SWRzIiwiZmV0Y2hMb2FkTWF0Y2hlcyIsImFjdGl2ZURlZmVycmVkcyIsImJsb2NrZXJGdW5jdGlvbnMiLCJpZ25vcmVOZXh0SGlzdG9yeVVwZGF0ZSIsImluaXRpYWxpemUiLCJibG9ja2VyS2V5Iiwic2hvdWxkQmxvY2tOYXZpZ2F0aW9uIiwiY3VycmVudExvY2F0aW9uIiwidXBkYXRlQmxvY2tlciIsImRlbGV0ZUJsb2NrZXIiLCJ1cGRhdGVTdGF0ZSIsInN0YXJ0TmF2aWdhdGlvbiIsImxhenlNYXRjaGVzIiwibGF6eVByb21pc2VzIiwibG9hZExhenlSb3V0ZU1vZHVsZSIsImFsbCIsImRpc3Bvc2UiLCJjbGVhciIsImRlbGV0ZUZldGNoZXIiLCJuZXdTdGF0ZSIsImNvbXBsZXRlTmF2aWdhdGlvbiIsIl9sb2NhdGlvbiRzdGF0ZSIsIl9sb2NhdGlvbiRzdGF0ZTIiLCJpc0FjdGlvblJlbG9hZCIsImlzTXV0YXRpb25NZXRob2QiLCJfaXNSZWRpcmVjdCIsImtleXMiLCJtZXJnZUxvYWRlckRhdGEiLCJnZXRTYXZlZFNjcm9sbFBvc2l0aW9uIiwibmF2aWdhdGUiLCJvcHRzIiwic3VibWlzc2lvbiIsIm5vcm1hbGl6ZU5hdmlnYXRlT3B0aW9ucyIsInVzZXJSZXBsYWNlIiwicGVuZGluZ0Vycm9yIiwicmV2YWxpZGF0ZSIsImludGVycnVwdEFjdGl2ZUxvYWRzIiwic3RhcnRVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uIiwib3ZlcnJpZGVOYXZpZ2F0aW9uIiwic2F2ZVNjcm9sbFBvc2l0aW9uIiwicm91dGVzVG9Vc2UiLCJsb2FkaW5nTmF2aWdhdGlvbiIsIm5vdEZvdW5kTWF0Y2hlcyIsImNhbmNlbEFjdGl2ZURlZmVycmVkcyIsImlzSGFzaENoYW5nZU9ubHkiLCJyZXF1ZXN0IiwiY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QiLCJwZW5kaW5nQWN0aW9uRGF0YSIsImZpbmROZWFyZXN0Qm91bmRhcnkiLCJhY3Rpb25PdXRwdXQiLCJoYW5kbGVBY3Rpb24iLCJzaG9ydENpcmN1aXRlZCIsInBlbmRpbmdBY3Rpb25FcnJvciIsIlJlcXVlc3QiLCJoYW5kbGVMb2FkZXJzIiwiYWN0aW9uTWF0Y2giLCJnZXRUYXJnZXRNYXRjaCIsInR5cGUiLCJtZXRob2QiLCJyb3V0ZUlkIiwiY2FsbExvYWRlck9yQWN0aW9uIiwiaXNSZWRpcmVjdFJlc3VsdCIsInN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uIiwiaXNFcnJvclJlc3VsdCIsImJvdW5kYXJ5TWF0Y2giLCJpc0RlZmVycmVkUmVzdWx0IiwiYWN0aXZlU3VibWlzc2lvbiIsIm1hdGNoZXNUb0xvYWQiLCJyZXZhbGlkYXRpbmdGZXRjaGVycyIsImdldE1hdGNoZXNUb0xvYWQiLCJyZiIsImZldGNoZXIiLCJyZXZhbGlkYXRpbmdGZXRjaGVyIiwicmVzdWx0cyIsImxvYWRlclJlc3VsdHMiLCJmZXRjaGVyUmVzdWx0cyIsImNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YSIsImZpbmRSZWRpcmVjdCIsInByb2Nlc3NMb2FkZXJEYXRhIiwiZGVmZXJyZWREYXRhIiwibWFya0ZldGNoUmVkaXJlY3RzRG9uZSIsImRpZEFib3J0RmV0Y2hMb2FkcyIsImFib3J0U3RhbGVGZXRjaExvYWRzIiwiZ2V0RmV0Y2hlciIsImZldGNoIiwiYWJvcnRGZXRjaGVyIiwic2V0RmV0Y2hlckVycm9yIiwiaGFuZGxlRmV0Y2hlckFjdGlvbiIsImhhbmRsZUZldGNoZXJMb2FkZXIiLCJyZXF1ZXN0TWF0Y2hlcyIsImV4aXN0aW5nRmV0Y2hlciIsImFib3J0Q29udHJvbGxlciIsImZldGNoUmVxdWVzdCIsImFjdGlvblJlc3VsdCIsImxvYWRpbmdGZXRjaGVyIiwiaXNGZXRjaEFjdGlvblJlZGlyZWN0IiwicmV2YWxpZGF0aW9uUmVxdWVzdCIsImxvYWRJZCIsImxvYWRGZXRjaGVyIiwic3RhbGVLZXkiLCJkb25lRmV0Y2hlciIsInJlc29sdmVEZWZlcnJlZERhdGEiLCJfdGVtcCIsIl93aW5kb3ciLCJyZWRpcmVjdExvY2F0aW9uIiwiX2lzRmV0Y2hBY3Rpb25SZWRpcmVjdCIsImlzRGlmZmVyZW50QmFzZW5hbWUiLCJyZWRpcmVjdEhpc3RvcnlBY3Rpb24iLCJjdXJyZW50TWF0Y2hlcyIsImZldGNoZXJzVG9Mb2FkIiwiZiIsInJlc29sdmVEZWZlcnJlZFJlc3VsdHMiLCJtYXJrRmV0Y2hlcnNEb25lIiwiZG9uZUtleXMiLCJsYW5kZWRJZCIsInllZXRlZEtleXMiLCJnZXRCbG9ja2VyIiwiYmxvY2tlciIsIm5ld0Jsb2NrZXIiLCJibG9ja2VyRnVuY3Rpb24iLCJwcmVkaWNhdGUiLCJjYW5jZWxsZWRSb3V0ZUlkcyIsImRmZCIsImVuYWJsZVNjcm9sbFJlc3RvcmF0aW9uIiwicG9zaXRpb25zIiwiZ2V0UG9zaXRpb24iLCJnZXRLZXkiLCJ5IiwidXNlck1hdGNoZXMiLCJjcmVhdGVVc2VNYXRjaGVzTWF0Y2giLCJfaW50ZXJuYWxTZXRSb3V0ZXMiLCJuZXdSb3V0ZXMiLCJfaW50ZXJuYWxGZXRjaENvbnRyb2xsZXJzIiwiX2ludGVybmFsQWN0aXZlRGVmZXJyZWRzIiwiVU5TQUZFX0RFRkVSUkVEX1NZTUJPTCIsIlN5bWJvbCIsImNyZWF0ZVN0YXRpY0hhbmRsZXIiLCJxdWVyeSIsIl90ZW1wMiIsInJlcXVlc3RDb250ZXh0IiwiaXNWYWxpZE1ldGhvZCIsIm1ldGhvZE5vdEFsbG93ZWRNYXRjaGVzIiwic3RhdHVzQ29kZSIsImxvYWRlckhlYWRlcnMiLCJhY3Rpb25IZWFkZXJzIiwicXVlcnlJbXBsIiwiaXNSZXNwb25zZSIsInF1ZXJ5Um91dGUiLCJfdGVtcDMiLCJmaW5kIiwidmFsdWVzIiwiX3Jlc3VsdCRhY3RpdmVEZWZlcnJlIiwicm91dGVNYXRjaCIsInN1Ym1pdCIsImxvYWRSb3V0ZURhdGEiLCJpc1F1ZXJ5Um91dGVSZXNwb25zZSIsImlzUmVkaXJlY3RSZXNwb25zZSIsInJlc3BvbnNlIiwiaXNSb3V0ZVJlcXVlc3QiLCJMb2NhdGlvbiIsImNvbnRleHQiLCJsb2FkZXJSZXF1ZXN0IiwiZ2V0TG9hZGVyTWF0Y2hlc1VudGlsQm91bmRhcnkiLCJwcm9jZXNzUm91dGVMb2FkZXJEYXRhIiwiZXhlY3V0ZWRMb2FkZXJzIiwiZnJvbUVudHJpZXMiLCJnZXRTdGF0aWNDb250ZXh0RnJvbUVycm9yIiwibmV3Q29udGV4dCIsIl9kZWVwZXN0UmVuZGVyZWRCb3VuZGFyeUlkIiwiaXNTdWJtaXNzaW9uTmF2aWdhdGlvbiIsImlzRmV0Y2hlciIsInN0cmlwSGFzaEZyb21QYXRoIiwic2VhcmNoUGFyYW1zIiwiY29udmVydEZvcm1EYXRhVG9TZWFyY2hQYXJhbXMiLCJoYXNOYWtlZEluZGV4UXVlcnkiLCJhcHBlbmQiLCJib3VuZGFyeUlkIiwiYm91bmRhcnlNYXRjaGVzIiwiZmluZEluZGV4IiwiY3VycmVudFVybCIsIm5leHRVcmwiLCJkZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZSIsIm5hdmlnYXRpb25NYXRjaGVzIiwiaXNOZXdMb2FkZXIiLCJjdXJyZW50Um91dGVNYXRjaCIsIm5leHRSb3V0ZU1hdGNoIiwic2hvdWxkUmV2YWxpZGF0ZUxvYWRlciIsImN1cnJlbnRQYXJhbXMiLCJuZXh0UGFyYW1zIiwiaXNOZXdSb3V0ZUluc3RhbmNlIiwiZmV0Y2hlck1hdGNoZXMiLCJmZXRjaGVyTWF0Y2giLCJzaG91bGRSZXZhbGlkYXRlIiwiY3VycmVudExvYWRlckRhdGEiLCJjdXJyZW50TWF0Y2giLCJpc05ldyIsImlzTWlzc2luZ0RhdGEiLCJjdXJyZW50UGF0aCIsImxvYWRlck1hdGNoIiwiYXJnIiwicm91dGVDaG9pY2UiLCJsYXp5Um91dGUiLCJyb3V0ZVRvVXBkYXRlIiwicm91dGVVcGRhdGVzIiwibGF6eVJvdXRlUHJvcGVydHkiLCJzdGF0aWNSb3V0ZVZhbHVlIiwiaXNQcm9wZXJ0eVN0YXRpY2FsbHlEZWZpbmVkIiwiaXNTdGF0aWNSZXF1ZXN0IiwicmVzdWx0VHlwZSIsIm9uUmVqZWN0IiwicnVuSGFuZGxlciIsImhhbmRsZXIiLCJhY3RpdmVNYXRjaGVzIiwicmVzb2x2ZWRMb2NhdGlvbiIsInByb3RvY29sIiwiaXNTYW1lQmFzZW5hbWUiLCJjb250ZW50VHlwZSIsInRleHQiLCJfcmVzdWx0JGluaXQiLCJfcmVzdWx0JGluaXQyIiwiZGVmZXJyZWQiLCJ0b1VwcGVyQ2FzZSIsImJvZHkiLCJVUkxTZWFyY2hQYXJhbXMiLCJGaWxlIiwibmFtZSIsImZvdW5kRXJyb3IiLCJuZXdMb2FkZXJEYXRhIiwibWVyZ2VkTG9hZGVyRGF0YSIsImhhc093blByb3BlcnR5IiwiZWxpZ2libGVNYXRjaGVzIiwicmV2ZXJzZSIsIl90ZW1wNCIsImVycm9yTWVzc2FnZSIsIm9iaiIsImlzUmV2YWxpZGF0aW5nTG9hZGVyIiwidW53cmFwIiwiZ2V0QWxsIiwiaGFuZGxlIiwicGF0aE1hdGNoZXMiXSwic291cmNlcyI6WyIuLi9oaXN0b3J5LnRzIiwiLi4vdXRpbHMudHMiLCIuLi9yb3V0ZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBUeXBlcyBhbmQgQ29uc3RhbnRzXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEFjdGlvbnMgcmVwcmVzZW50IHRoZSB0eXBlIG9mIGNoYW5nZSB0byBhIGxvY2F0aW9uIHZhbHVlLlxuICovXG5leHBvcnQgZW51bSBBY3Rpb24ge1xuICAvKipcbiAgICogQSBQT1AgaW5kaWNhdGVzIGEgY2hhbmdlIHRvIGFuIGFyYml0cmFyeSBpbmRleCBpbiB0aGUgaGlzdG9yeSBzdGFjaywgc3VjaFxuICAgKiBhcyBhIGJhY2sgb3IgZm9yd2FyZCBuYXZpZ2F0aW9uLiBJdCBkb2VzIG5vdCBkZXNjcmliZSB0aGUgZGlyZWN0aW9uIG9mIHRoZVxuICAgKiBuYXZpZ2F0aW9uLCBvbmx5IHRoYXQgdGhlIGN1cnJlbnQgaW5kZXggY2hhbmdlZC5cbiAgICpcbiAgICogTm90ZTogVGhpcyBpcyB0aGUgZGVmYXVsdCBhY3Rpb24gZm9yIG5ld2x5IGNyZWF0ZWQgaGlzdG9yeSBvYmplY3RzLlxuICAgKi9cbiAgUG9wID0gXCJQT1BcIixcblxuICAvKipcbiAgICogQSBQVVNIIGluZGljYXRlcyBhIG5ldyBlbnRyeSBiZWluZyBhZGRlZCB0byB0aGUgaGlzdG9yeSBzdGFjaywgc3VjaCBhcyB3aGVuXG4gICAqIGEgbGluayBpcyBjbGlja2VkIGFuZCBhIG5ldyBwYWdlIGxvYWRzLiBXaGVuIHRoaXMgaGFwcGVucywgYWxsIHN1YnNlcXVlbnRcbiAgICogZW50cmllcyBpbiB0aGUgc3RhY2sgYXJlIGxvc3QuXG4gICAqL1xuICBQdXNoID0gXCJQVVNIXCIsXG5cbiAgLyoqXG4gICAqIEEgUkVQTEFDRSBpbmRpY2F0ZXMgdGhlIGVudHJ5IGF0IHRoZSBjdXJyZW50IGluZGV4IGluIHRoZSBoaXN0b3J5IHN0YWNrXG4gICAqIGJlaW5nIHJlcGxhY2VkIGJ5IGEgbmV3IG9uZS5cbiAgICovXG4gIFJlcGxhY2UgPSBcIlJFUExBQ0VcIixcbn1cblxuLyoqXG4gKiBUaGUgcGF0aG5hbWUsIHNlYXJjaCwgYW5kIGhhc2ggdmFsdWVzIG9mIGEgVVJMLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBhdGgge1xuICAvKipcbiAgICogQSBVUkwgcGF0aG5hbWUsIGJlZ2lubmluZyB3aXRoIGEgLy5cbiAgICovXG4gIHBhdGhuYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEEgVVJMIHNlYXJjaCBzdHJpbmcsIGJlZ2lubmluZyB3aXRoIGEgPy5cbiAgICovXG4gIHNlYXJjaDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBIFVSTCBmcmFnbWVudCBpZGVudGlmaWVyLCBiZWdpbm5pbmcgd2l0aCBhICMuXG4gICAqL1xuICBoYXNoOiBzdHJpbmc7XG59XG5cbi8qKlxuICogQW4gZW50cnkgaW4gYSBoaXN0b3J5IHN0YWNrLiBBIGxvY2F0aW9uIGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZVxuICogVVJMIHBhdGgsIGFzIHdlbGwgYXMgcG9zc2libHkgc29tZSBhcmJpdHJhcnkgc3RhdGUgYW5kIGEga2V5LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIExvY2F0aW9uIGV4dGVuZHMgUGF0aCB7XG4gIC8qKlxuICAgKiBBIHZhbHVlIG9mIGFyYml0cmFyeSBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGxvY2F0aW9uLlxuICAgKi9cbiAgc3RhdGU6IGFueTtcblxuICAvKipcbiAgICogQSB1bmlxdWUgc3RyaW5nIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGxvY2F0aW9uLiBNYXkgYmUgdXNlZCB0byBzYWZlbHkgc3RvcmVcbiAgICogYW5kIHJldHJpZXZlIGRhdGEgaW4gc29tZSBvdGhlciBzdG9yYWdlIEFQSSwgbGlrZSBgbG9jYWxTdG9yYWdlYC5cbiAgICpcbiAgICogTm90ZTogVGhpcyB2YWx1ZSBpcyBhbHdheXMgXCJkZWZhdWx0XCIgb24gdGhlIGluaXRpYWwgbG9jYXRpb24uXG4gICAqL1xuICBrZXk6IHN0cmluZztcbn1cblxuLyoqXG4gKiBBIGNoYW5nZSB0byB0aGUgY3VycmVudCBsb2NhdGlvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVcGRhdGUge1xuICAvKipcbiAgICogVGhlIGFjdGlvbiB0aGF0IHRyaWdnZXJlZCB0aGUgY2hhbmdlLlxuICAgKi9cbiAgYWN0aW9uOiBBY3Rpb247XG5cbiAgLyoqXG4gICAqIFRoZSBuZXcgbG9jYXRpb24uXG4gICAqL1xuICBsb2NhdGlvbjogTG9jYXRpb247XG5cbiAgLyoqXG4gICAqIFRoZSBkZWx0YSBiZXR3ZWVuIHRoaXMgbG9jYXRpb24gYW5kIHRoZSBmb3JtZXIgbG9jYXRpb24gaW4gdGhlIGhpc3Rvcnkgc3RhY2tcbiAgICovXG4gIGRlbHRhOiBudW1iZXIgfCBudWxsO1xufVxuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCByZWNlaXZlcyBub3RpZmljYXRpb25zIGFib3V0IGxvY2F0aW9uIGNoYW5nZXMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTGlzdGVuZXIge1xuICAodXBkYXRlOiBVcGRhdGUpOiB2b2lkO1xufVxuXG4vKipcbiAqIERlc2NyaWJlcyBhIGxvY2F0aW9uIHRoYXQgaXMgdGhlIGRlc3RpbmF0aW9uIG9mIHNvbWUgbmF2aWdhdGlvbiwgZWl0aGVyIHZpYVxuICogYGhpc3RvcnkucHVzaGAgb3IgYGhpc3RvcnkucmVwbGFjZWAuIE1heSBiZSBlaXRoZXIgYSBVUkwgb3IgdGhlIHBpZWNlcyBvZiBhXG4gKiBVUkwgcGF0aC5cbiAqL1xuZXhwb3J0IHR5cGUgVG8gPSBzdHJpbmcgfCBQYXJ0aWFsPFBhdGg+O1xuXG4vKipcbiAqIEEgaGlzdG9yeSBpcyBhbiBpbnRlcmZhY2UgdG8gdGhlIG5hdmlnYXRpb24gc3RhY2suIFRoZSBoaXN0b3J5IHNlcnZlcyBhcyB0aGVcbiAqIHNvdXJjZSBvZiB0cnV0aCBmb3IgdGhlIGN1cnJlbnQgbG9jYXRpb24sIGFzIHdlbGwgYXMgcHJvdmlkZXMgYSBzZXQgb2ZcbiAqIG1ldGhvZHMgdGhhdCBtYXkgYmUgdXNlZCB0byBjaGFuZ2UgaXQuXG4gKlxuICogSXQgaXMgc2ltaWxhciB0byB0aGUgRE9NJ3MgYHdpbmRvdy5oaXN0b3J5YCBvYmplY3QsIGJ1dCB3aXRoIGEgc21hbGxlciwgbW9yZVxuICogZm9jdXNlZCBBUEkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSGlzdG9yeSB7XG4gIC8qKlxuICAgKiBUaGUgbGFzdCBhY3Rpb24gdGhhdCBtb2RpZmllZCB0aGUgY3VycmVudCBsb2NhdGlvbi4gVGhpcyB3aWxsIGFsd2F5cyBiZVxuICAgKiBBY3Rpb24uUG9wIHdoZW4gYSBoaXN0b3J5IGluc3RhbmNlIGlzIGZpcnN0IGNyZWF0ZWQuIFRoaXMgdmFsdWUgaXMgbXV0YWJsZS5cbiAgICovXG4gIHJlYWRvbmx5IGFjdGlvbjogQWN0aW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBsb2NhdGlvbi4gVGhpcyB2YWx1ZSBpcyBtdXRhYmxlLlxuICAgKi9cbiAgcmVhZG9ubHkgbG9jYXRpb246IExvY2F0aW9uO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmFsaWQgaHJlZiBmb3IgdGhlIGdpdmVuIGB0b2AgdmFsdWUgdGhhdCBtYXkgYmUgdXNlZCBhc1xuICAgKiB0aGUgdmFsdWUgb2YgYW4gPGEgaHJlZj4gYXR0cmlidXRlLlxuICAgKlxuICAgKiBAcGFyYW0gdG8gLSBUaGUgZGVzdGluYXRpb24gVVJMXG4gICAqL1xuICBjcmVhdGVIcmVmKHRvOiBUbyk6IHN0cmluZztcblxuICAvKipcbiAgICogUmV0dXJucyBhIFVSTCBmb3IgdGhlIGdpdmVuIGB0b2AgdmFsdWVcbiAgICpcbiAgICogQHBhcmFtIHRvIC0gVGhlIGRlc3RpbmF0aW9uIFVSTFxuICAgKi9cbiAgY3JlYXRlVVJMKHRvOiBUbyk6IFVSTDtcblxuICAvKipcbiAgICogRW5jb2RlIGEgbG9jYXRpb24gdGhlIHNhbWUgd2F5IHdpbmRvdy5oaXN0b3J5IHdvdWxkIGRvIChuby1vcCBmb3IgbWVtb3J5XG4gICAqIGhpc3RvcnkpIHNvIHdlIGVuc3VyZSBvdXIgUFVTSC9SRVBMQUNFIG5hdmlnYXRpb25zIGZvciBkYXRhIHJvdXRlcnNcbiAgICogYmVoYXZlIHRoZSBzYW1lIGFzIFBPUFxuICAgKlxuICAgKiBAcGFyYW0gdG8gVW5lbmNvZGVkIHBhdGhcbiAgICovXG4gIGVuY29kZUxvY2F0aW9uKHRvOiBUbyk6IFBhdGg7XG5cbiAgLyoqXG4gICAqIFB1c2hlcyBhIG5ldyBsb2NhdGlvbiBvbnRvIHRoZSBoaXN0b3J5IHN0YWNrLCBpbmNyZWFzaW5nIGl0cyBsZW5ndGggYnkgb25lLlxuICAgKiBJZiB0aGVyZSB3ZXJlIGFueSBlbnRyaWVzIGluIHRoZSBzdGFjayBhZnRlciB0aGUgY3VycmVudCBvbmUsIHRoZXkgYXJlXG4gICAqIGxvc3QuXG4gICAqXG4gICAqIEBwYXJhbSB0byAtIFRoZSBuZXcgVVJMXG4gICAqIEBwYXJhbSBzdGF0ZSAtIERhdGEgdG8gYXNzb2NpYXRlIHdpdGggdGhlIG5ldyBsb2NhdGlvblxuICAgKi9cbiAgcHVzaCh0bzogVG8sIHN0YXRlPzogYW55KTogdm9pZDtcblxuICAvKipcbiAgICogUmVwbGFjZXMgdGhlIGN1cnJlbnQgbG9jYXRpb24gaW4gdGhlIGhpc3Rvcnkgc3RhY2sgd2l0aCBhIG5ldyBvbmUuICBUaGVcbiAgICogbG9jYXRpb24gdGhhdCB3YXMgcmVwbGFjZWQgd2lsbCBubyBsb25nZXIgYmUgYXZhaWxhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gdG8gLSBUaGUgbmV3IFVSTFxuICAgKiBAcGFyYW0gc3RhdGUgLSBEYXRhIHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBuZXcgbG9jYXRpb25cbiAgICovXG4gIHJlcGxhY2UodG86IFRvLCBzdGF0ZT86IGFueSk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIE5hdmlnYXRlcyBgbmAgZW50cmllcyBiYWNrd2FyZC9mb3J3YXJkIGluIHRoZSBoaXN0b3J5IHN0YWNrIHJlbGF0aXZlIHRvIHRoZVxuICAgKiBjdXJyZW50IGluZGV4LiBGb3IgZXhhbXBsZSwgYSBcImJhY2tcIiBuYXZpZ2F0aW9uIHdvdWxkIHVzZSBnbygtMSkuXG4gICAqXG4gICAqIEBwYXJhbSBkZWx0YSAtIFRoZSBkZWx0YSBpbiB0aGUgc3RhY2sgaW5kZXhcbiAgICovXG4gIGdvKGRlbHRhOiBudW1iZXIpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBTZXRzIHVwIGEgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciB0aGUgY3VycmVudCBsb2NhdGlvblxuICAgKiBjaGFuZ2VzLlxuICAgKlxuICAgKiBAcGFyYW0gbGlzdGVuZXIgLSBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgbG9jYXRpb24gY2hhbmdlc1xuICAgKiBAcmV0dXJucyB1bmxpc3RlbiAtIEEgZnVuY3Rpb24gdGhhdCBtYXkgYmUgdXNlZCB0byBzdG9wIGxpc3RlbmluZ1xuICAgKi9cbiAgbGlzdGVuKGxpc3RlbmVyOiBMaXN0ZW5lcik6ICgpID0+IHZvaWQ7XG59XG5cbnR5cGUgSGlzdG9yeVN0YXRlID0ge1xuICB1c3I6IGFueTtcbiAga2V5Pzogc3RyaW5nO1xuICBpZHg6IG51bWJlcjtcbn07XG5cbmNvbnN0IFBvcFN0YXRlRXZlbnRUeXBlID0gXCJwb3BzdGF0ZVwiO1xuLy8jZW5kcmVnaW9uXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gTWVtb3J5IEhpc3Rvcnlcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQSB1c2VyLXN1cHBsaWVkIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBhIGxvY2F0aW9uLiBVc2VkIHdoZW4gcHJvdmlkaW5nXG4gKiBlbnRyaWVzIHRvIGBjcmVhdGVNZW1vcnlIaXN0b3J5YCB2aWEgaXRzIGBpbml0aWFsRW50cmllc2Agb3B0aW9uLlxuICovXG5leHBvcnQgdHlwZSBJbml0aWFsRW50cnkgPSBzdHJpbmcgfCBQYXJ0aWFsPExvY2F0aW9uPjtcblxuZXhwb3J0IHR5cGUgTWVtb3J5SGlzdG9yeU9wdGlvbnMgPSB7XG4gIGluaXRpYWxFbnRyaWVzPzogSW5pdGlhbEVudHJ5W107XG4gIGluaXRpYWxJbmRleD86IG51bWJlcjtcbiAgdjVDb21wYXQ/OiBib29sZWFuO1xufTtcblxuLyoqXG4gKiBBIG1lbW9yeSBoaXN0b3J5IHN0b3JlcyBsb2NhdGlvbnMgaW4gbWVtb3J5LiBUaGlzIGlzIHVzZWZ1bCBpbiBzdGF0ZWZ1bFxuICogZW52aXJvbm1lbnRzIHdoZXJlIHRoZXJlIGlzIG5vIHdlYiBicm93c2VyLCBzdWNoIGFzIG5vZGUgdGVzdHMgb3IgUmVhY3RcbiAqIE5hdGl2ZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNZW1vcnlIaXN0b3J5IGV4dGVuZHMgSGlzdG9yeSB7XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBpbmRleCBpbiB0aGUgaGlzdG9yeSBzdGFjay5cbiAgICovXG4gIHJlYWRvbmx5IGluZGV4OiBudW1iZXI7XG59XG5cbi8qKlxuICogTWVtb3J5IGhpc3Rvcnkgc3RvcmVzIHRoZSBjdXJyZW50IGxvY2F0aW9uIGluIG1lbW9yeS4gSXQgaXMgZGVzaWduZWQgZm9yIHVzZVxuICogaW4gc3RhdGVmdWwgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRzIGxpa2UgdGVzdHMgYW5kIFJlYWN0IE5hdGl2ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1lbW9yeUhpc3RvcnkoXG4gIG9wdGlvbnM6IE1lbW9yeUhpc3RvcnlPcHRpb25zID0ge31cbik6IE1lbW9yeUhpc3Rvcnkge1xuICBsZXQgeyBpbml0aWFsRW50cmllcyA9IFtcIi9cIl0sIGluaXRpYWxJbmRleCwgdjVDb21wYXQgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgbGV0IGVudHJpZXM6IExvY2F0aW9uW107IC8vIERlY2xhcmUgc28gd2UgY2FuIGFjY2VzcyBmcm9tIGNyZWF0ZU1lbW9yeUxvY2F0aW9uXG4gIGVudHJpZXMgPSBpbml0aWFsRW50cmllcy5tYXAoKGVudHJ5LCBpbmRleCkgPT5cbiAgICBjcmVhdGVNZW1vcnlMb2NhdGlvbihcbiAgICAgIGVudHJ5LFxuICAgICAgdHlwZW9mIGVudHJ5ID09PSBcInN0cmluZ1wiID8gbnVsbCA6IGVudHJ5LnN0YXRlLFxuICAgICAgaW5kZXggPT09IDAgPyBcImRlZmF1bHRcIiA6IHVuZGVmaW5lZFxuICAgIClcbiAgKTtcbiAgbGV0IGluZGV4ID0gY2xhbXBJbmRleChcbiAgICBpbml0aWFsSW5kZXggPT0gbnVsbCA/IGVudHJpZXMubGVuZ3RoIC0gMSA6IGluaXRpYWxJbmRleFxuICApO1xuICBsZXQgYWN0aW9uID0gQWN0aW9uLlBvcDtcbiAgbGV0IGxpc3RlbmVyOiBMaXN0ZW5lciB8IG51bGwgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGNsYW1wSW5kZXgobjogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobiwgMCksIGVudHJpZXMubGVuZ3RoIC0gMSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uKCk6IExvY2F0aW9uIHtcbiAgICByZXR1cm4gZW50cmllc1tpbmRleF07XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlTWVtb3J5TG9jYXRpb24oXG4gICAgdG86IFRvLFxuICAgIHN0YXRlOiBhbnkgPSBudWxsLFxuICAgIGtleT86IHN0cmluZ1xuICApOiBMb2NhdGlvbiB7XG4gICAgbGV0IGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oXG4gICAgICBlbnRyaWVzID8gZ2V0Q3VycmVudExvY2F0aW9uKCkucGF0aG5hbWUgOiBcIi9cIixcbiAgICAgIHRvLFxuICAgICAgc3RhdGUsXG4gICAgICBrZXlcbiAgICApO1xuICAgIHdhcm5pbmcoXG4gICAgICBsb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgPT09IFwiL1wiLFxuICAgICAgYHJlbGF0aXZlIHBhdGhuYW1lcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBtZW1vcnkgaGlzdG9yeTogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgdG9cbiAgICAgICl9YFxuICAgICk7XG4gICAgcmV0dXJuIGxvY2F0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSHJlZih0bzogVG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gdG8gOiBjcmVhdGVQYXRoKHRvKTtcbiAgfVxuXG4gIGxldCBoaXN0b3J5OiBNZW1vcnlIaXN0b3J5ID0ge1xuICAgIGdldCBpbmRleCgpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9LFxuICAgIGdldCBhY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYWN0aW9uO1xuICAgIH0sXG4gICAgZ2V0IGxvY2F0aW9uKCkge1xuICAgICAgcmV0dXJuIGdldEN1cnJlbnRMb2NhdGlvbigpO1xuICAgIH0sXG4gICAgY3JlYXRlSHJlZixcbiAgICBjcmVhdGVVUkwodG8pIHtcbiAgICAgIHJldHVybiBuZXcgVVJMKGNyZWF0ZUhyZWYodG8pLCBcImh0dHA6Ly9sb2NhbGhvc3RcIik7XG4gICAgfSxcbiAgICBlbmNvZGVMb2NhdGlvbih0bzogVG8pIHtcbiAgICAgIGxldCBwYXRoID0gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHRvKSA6IHRvO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aG5hbWU6IHBhdGgucGF0aG5hbWUgfHwgXCJcIixcbiAgICAgICAgc2VhcmNoOiBwYXRoLnNlYXJjaCB8fCBcIlwiLFxuICAgICAgICBoYXNoOiBwYXRoLmhhc2ggfHwgXCJcIixcbiAgICAgIH07XG4gICAgfSxcbiAgICBwdXNoKHRvLCBzdGF0ZSkge1xuICAgICAgYWN0aW9uID0gQWN0aW9uLlB1c2g7XG4gICAgICBsZXQgbmV4dExvY2F0aW9uID0gY3JlYXRlTWVtb3J5TG9jYXRpb24odG8sIHN0YXRlKTtcbiAgICAgIGluZGV4ICs9IDE7XG4gICAgICBlbnRyaWVzLnNwbGljZShpbmRleCwgZW50cmllcy5sZW5ndGgsIG5leHRMb2NhdGlvbik7XG4gICAgICBpZiAodjVDb21wYXQgJiYgbGlzdGVuZXIpIHtcbiAgICAgICAgbGlzdGVuZXIoeyBhY3Rpb24sIGxvY2F0aW9uOiBuZXh0TG9jYXRpb24sIGRlbHRhOiAxIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVwbGFjZSh0bywgc3RhdGUpIHtcbiAgICAgIGFjdGlvbiA9IEFjdGlvbi5SZXBsYWNlO1xuICAgICAgbGV0IG5leHRMb2NhdGlvbiA9IGNyZWF0ZU1lbW9yeUxvY2F0aW9uKHRvLCBzdGF0ZSk7XG4gICAgICBlbnRyaWVzW2luZGV4XSA9IG5leHRMb2NhdGlvbjtcbiAgICAgIGlmICh2NUNvbXBhdCAmJiBsaXN0ZW5lcikge1xuICAgICAgICBsaXN0ZW5lcih7IGFjdGlvbiwgbG9jYXRpb246IG5leHRMb2NhdGlvbiwgZGVsdGE6IDAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnbyhkZWx0YSkge1xuICAgICAgYWN0aW9uID0gQWN0aW9uLlBvcDtcbiAgICAgIGxldCBuZXh0SW5kZXggPSBjbGFtcEluZGV4KGluZGV4ICsgZGVsdGEpO1xuICAgICAgbGV0IG5leHRMb2NhdGlvbiA9IGVudHJpZXNbbmV4dEluZGV4XTtcbiAgICAgIGluZGV4ID0gbmV4dEluZGV4O1xuICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVyKHsgYWN0aW9uLCBsb2NhdGlvbjogbmV4dExvY2F0aW9uLCBkZWx0YSB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGxpc3RlbihmbjogTGlzdGVuZXIpIHtcbiAgICAgIGxpc3RlbmVyID0gZm47XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBsaXN0ZW5lciA9IG51bGw7XG4gICAgICB9O1xuICAgIH0sXG4gIH07XG5cbiAgcmV0dXJuIGhpc3Rvcnk7XG59XG4vLyNlbmRyZWdpb25cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBCcm93c2VyIEhpc3Rvcnlcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQSBicm93c2VyIGhpc3Rvcnkgc3RvcmVzIHRoZSBjdXJyZW50IGxvY2F0aW9uIGluIHJlZ3VsYXIgVVJMcyBpbiBhIHdlYlxuICogYnJvd3NlciBlbnZpcm9ubWVudC4gVGhpcyBpcyB0aGUgc3RhbmRhcmQgZm9yIG1vc3Qgd2ViIGFwcHMgYW5kIHByb3ZpZGVzIHRoZVxuICogY2xlYW5lc3QgVVJMcyB0aGUgYnJvd3NlcidzIGFkZHJlc3MgYmFyLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9oaXN0b3J5L3RyZWUvbWFpbi9kb2NzL2FwaS1yZWZlcmVuY2UubWQjYnJvd3Nlcmhpc3RvcnlcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBCcm93c2VySGlzdG9yeSBleHRlbmRzIFVybEhpc3Rvcnkge31cblxuZXhwb3J0IHR5cGUgQnJvd3Nlckhpc3RvcnlPcHRpb25zID0gVXJsSGlzdG9yeU9wdGlvbnM7XG5cbi8qKlxuICogQnJvd3NlciBoaXN0b3J5IHN0b3JlcyB0aGUgbG9jYXRpb24gaW4gcmVndWxhciBVUkxzLiBUaGlzIGlzIHRoZSBzdGFuZGFyZCBmb3JcbiAqIG1vc3Qgd2ViIGFwcHMsIGJ1dCBpdCByZXF1aXJlcyBzb21lIGNvbmZpZ3VyYXRpb24gb24gdGhlIHNlcnZlciB0byBlbnN1cmUgeW91XG4gKiBzZXJ2ZSB0aGUgc2FtZSBhcHAgYXQgbXVsdGlwbGUgVVJMcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vaGlzdG9yeS90cmVlL21haW4vZG9jcy9hcGktcmVmZXJlbmNlLm1kI2NyZWF0ZWJyb3dzZXJoaXN0b3J5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVCcm93c2VySGlzdG9yeShcbiAgb3B0aW9uczogQnJvd3Nlckhpc3RvcnlPcHRpb25zID0ge31cbik6IEJyb3dzZXJIaXN0b3J5IHtcbiAgZnVuY3Rpb24gY3JlYXRlQnJvd3NlckxvY2F0aW9uKFxuICAgIHdpbmRvdzogV2luZG93LFxuICAgIGdsb2JhbEhpc3Rvcnk6IFdpbmRvd1tcImhpc3RvcnlcIl1cbiAgKSB7XG4gICAgbGV0IHsgcGF0aG5hbWUsIHNlYXJjaCwgaGFzaCB9ID0gd2luZG93LmxvY2F0aW9uO1xuICAgIHJldHVybiBjcmVhdGVMb2NhdGlvbihcbiAgICAgIFwiXCIsXG4gICAgICB7IHBhdGhuYW1lLCBzZWFyY2gsIGhhc2ggfSxcbiAgICAgIC8vIHN0YXRlIGRlZmF1bHRzIHRvIGBudWxsYCBiZWNhdXNlIGB3aW5kb3cuaGlzdG9yeS5zdGF0ZWAgZG9lc1xuICAgICAgKGdsb2JhbEhpc3Rvcnkuc3RhdGUgJiYgZ2xvYmFsSGlzdG9yeS5zdGF0ZS51c3IpIHx8IG51bGwsXG4gICAgICAoZ2xvYmFsSGlzdG9yeS5zdGF0ZSAmJiBnbG9iYWxIaXN0b3J5LnN0YXRlLmtleSkgfHwgXCJkZWZhdWx0XCJcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQnJvd3NlckhyZWYod2luZG93OiBXaW5kb3csIHRvOiBUbykge1xuICAgIHJldHVybiB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyB0byA6IGNyZWF0ZVBhdGgodG8pO1xuICB9XG5cbiAgcmV0dXJuIGdldFVybEJhc2VkSGlzdG9yeShcbiAgICBjcmVhdGVCcm93c2VyTG9jYXRpb24sXG4gICAgY3JlYXRlQnJvd3NlckhyZWYsXG4gICAgbnVsbCxcbiAgICBvcHRpb25zXG4gICk7XG59XG4vLyNlbmRyZWdpb25cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBIYXNoIEhpc3Rvcnlcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQSBoYXNoIGhpc3Rvcnkgc3RvcmVzIHRoZSBjdXJyZW50IGxvY2F0aW9uIGluIHRoZSBmcmFnbWVudCBpZGVudGlmaWVyIHBvcnRpb25cbiAqIG9mIHRoZSBVUkwgaW4gYSB3ZWIgYnJvd3NlciBlbnZpcm9ubWVudC5cbiAqXG4gKiBUaGlzIGlzIGlkZWFsIGZvciBhcHBzIHRoYXQgZG8gbm90IGNvbnRyb2wgdGhlIHNlcnZlciBmb3Igc29tZSByZWFzb25cbiAqIChiZWNhdXNlIHRoZSBmcmFnbWVudCBpZGVudGlmaWVyIGlzIG5ldmVyIHNlbnQgdG8gdGhlIHNlcnZlciksIGluY2x1ZGluZyBzb21lXG4gKiBzaGFyZWQgaG9zdGluZyBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgcHJvdmlkZSBmaW5lLWdyYWluZWQgY29udHJvbHMgb3ZlclxuICogd2hpY2ggcGFnZXMgYXJlIHNlcnZlZCBhdCB3aGljaCBVUkxzLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9oaXN0b3J5L3RyZWUvbWFpbi9kb2NzL2FwaS1yZWZlcmVuY2UubWQjaGFzaGhpc3RvcnlcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBIYXNoSGlzdG9yeSBleHRlbmRzIFVybEhpc3Rvcnkge31cblxuZXhwb3J0IHR5cGUgSGFzaEhpc3RvcnlPcHRpb25zID0gVXJsSGlzdG9yeU9wdGlvbnM7XG5cbi8qKlxuICogSGFzaCBoaXN0b3J5IHN0b3JlcyB0aGUgbG9jYXRpb24gaW4gd2luZG93LmxvY2F0aW9uLmhhc2guIFRoaXMgbWFrZXMgaXQgaWRlYWxcbiAqIGZvciBzaXR1YXRpb25zIHdoZXJlIHlvdSBkb24ndCB3YW50IHRvIHNlbmQgdGhlIGxvY2F0aW9uIHRvIHRoZSBzZXJ2ZXIgZm9yXG4gKiBzb21lIHJlYXNvbiwgZWl0aGVyIGJlY2F1c2UgeW91IGRvIGNhbm5vdCBjb25maWd1cmUgaXQgb3IgdGhlIFVSTCBzcGFjZSBpc1xuICogcmVzZXJ2ZWQgZm9yIHNvbWV0aGluZyBlbHNlLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9oaXN0b3J5L3RyZWUvbWFpbi9kb2NzL2FwaS1yZWZlcmVuY2UubWQjY3JlYXRlaGFzaGhpc3RvcnlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhhc2hIaXN0b3J5KFxuICBvcHRpb25zOiBIYXNoSGlzdG9yeU9wdGlvbnMgPSB7fVxuKTogSGFzaEhpc3Rvcnkge1xuICBmdW5jdGlvbiBjcmVhdGVIYXNoTG9jYXRpb24oXG4gICAgd2luZG93OiBXaW5kb3csXG4gICAgZ2xvYmFsSGlzdG9yeTogV2luZG93W1wiaGlzdG9yeVwiXVxuICApIHtcbiAgICBsZXQge1xuICAgICAgcGF0aG5hbWUgPSBcIi9cIixcbiAgICAgIHNlYXJjaCA9IFwiXCIsXG4gICAgICBoYXNoID0gXCJcIixcbiAgICB9ID0gcGFyc2VQYXRoKHdpbmRvdy5sb2NhdGlvbi5oYXNoLnN1YnN0cigxKSk7XG4gICAgcmV0dXJuIGNyZWF0ZUxvY2F0aW9uKFxuICAgICAgXCJcIixcbiAgICAgIHsgcGF0aG5hbWUsIHNlYXJjaCwgaGFzaCB9LFxuICAgICAgLy8gc3RhdGUgZGVmYXVsdHMgdG8gYG51bGxgIGJlY2F1c2UgYHdpbmRvdy5oaXN0b3J5LnN0YXRlYCBkb2VzXG4gICAgICAoZ2xvYmFsSGlzdG9yeS5zdGF0ZSAmJiBnbG9iYWxIaXN0b3J5LnN0YXRlLnVzcikgfHwgbnVsbCxcbiAgICAgIChnbG9iYWxIaXN0b3J5LnN0YXRlICYmIGdsb2JhbEhpc3Rvcnkuc3RhdGUua2V5KSB8fCBcImRlZmF1bHRcIlxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVIYXNoSHJlZih3aW5kb3c6IFdpbmRvdywgdG86IFRvKSB7XG4gICAgbGV0IGJhc2UgPSB3aW5kb3cuZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImJhc2VcIik7XG4gICAgbGV0IGhyZWYgPSBcIlwiO1xuXG4gICAgaWYgKGJhc2UgJiYgYmFzZS5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpKSB7XG4gICAgICBsZXQgdXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gICAgICBsZXQgaGFzaEluZGV4ID0gdXJsLmluZGV4T2YoXCIjXCIpO1xuICAgICAgaHJlZiA9IGhhc2hJbmRleCA9PT0gLTEgPyB1cmwgOiB1cmwuc2xpY2UoMCwgaGFzaEluZGV4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaHJlZiArIFwiI1wiICsgKHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0bykpO1xuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVIYXNoTG9jYXRpb24obG9jYXRpb246IExvY2F0aW9uLCB0bzogVG8pIHtcbiAgICB3YXJuaW5nKFxuICAgICAgbG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApID09PSBcIi9cIixcbiAgICAgIGByZWxhdGl2ZSBwYXRobmFtZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gaGFzaCBoaXN0b3J5LnB1c2goJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgdG9cbiAgICAgICl9KWBcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGdldFVybEJhc2VkSGlzdG9yeShcbiAgICBjcmVhdGVIYXNoTG9jYXRpb24sXG4gICAgY3JlYXRlSGFzaEhyZWYsXG4gICAgdmFsaWRhdGVIYXNoTG9jYXRpb24sXG4gICAgb3B0aW9uc1xuICApO1xufVxuLy8jZW5kcmVnaW9uXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gVVRJTFNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmFyaWFudCh2YWx1ZTogYm9vbGVhbiwgbWVzc2FnZT86IHN0cmluZyk6IGFzc2VydHMgdmFsdWU7XG5leHBvcnQgZnVuY3Rpb24gaW52YXJpYW50PFQ+KFxuICB2YWx1ZTogVCB8IG51bGwgfCB1bmRlZmluZWQsXG4gIG1lc3NhZ2U/OiBzdHJpbmdcbik6IGFzc2VydHMgdmFsdWUgaXMgVDtcbmV4cG9ydCBmdW5jdGlvbiBpbnZhcmlhbnQodmFsdWU6IGFueSwgbWVzc2FnZT86IHN0cmluZykge1xuICBpZiAodmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gd2FybmluZyhjb25kOiBhbnksIG1lc3NhZ2U6IHN0cmluZykge1xuICBpZiAoIWNvbmQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIikgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFdlbGNvbWUgdG8gZGVidWdnaW5nIGhpc3RvcnkhXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBlcnJvciBpcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB5b3UgY2FuIG1vcmUgZWFzaWx5XG4gICAgICAvLyBmaW5kIHRoZSBzb3VyY2UgZm9yIGEgd2FybmluZyB0aGF0IGFwcGVhcnMgaW4gdGhlIGNvbnNvbGUgYnlcbiAgICAgIC8vIGVuYWJsaW5nIFwicGF1c2Ugb24gZXhjZXB0aW9uc1wiIGluIHlvdXIgSmF2YVNjcmlwdCBkZWJ1Z2dlci5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDgpO1xufVxuXG4vKipcbiAqIEZvciBicm93c2VyLWJhc2VkIGhpc3Rvcmllcywgd2UgY29tYmluZSB0aGUgc3RhdGUgYW5kIGtleSBpbnRvIGFuIG9iamVjdFxuICovXG5mdW5jdGlvbiBnZXRIaXN0b3J5U3RhdGUobG9jYXRpb246IExvY2F0aW9uLCBpbmRleDogbnVtYmVyKTogSGlzdG9yeVN0YXRlIHtcbiAgcmV0dXJuIHtcbiAgICB1c3I6IGxvY2F0aW9uLnN0YXRlLFxuICAgIGtleTogbG9jYXRpb24ua2V5LFxuICAgIGlkeDogaW5kZXgsXG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIExvY2F0aW9uIG9iamVjdCB3aXRoIGEgdW5pcXVlIGtleSBmcm9tIHRoZSBnaXZlbiBQYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMb2NhdGlvbihcbiAgY3VycmVudDogc3RyaW5nIHwgTG9jYXRpb24sXG4gIHRvOiBUbyxcbiAgc3RhdGU6IGFueSA9IG51bGwsXG4gIGtleT86IHN0cmluZ1xuKTogUmVhZG9ubHk8TG9jYXRpb24+IHtcbiAgbGV0IGxvY2F0aW9uOiBSZWFkb25seTxMb2NhdGlvbj4gPSB7XG4gICAgcGF0aG5hbWU6IHR5cGVvZiBjdXJyZW50ID09PSBcInN0cmluZ1wiID8gY3VycmVudCA6IGN1cnJlbnQucGF0aG5hbWUsXG4gICAgc2VhcmNoOiBcIlwiLFxuICAgIGhhc2g6IFwiXCIsXG4gICAgLi4uKHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aCh0bykgOiB0byksXG4gICAgc3RhdGUsXG4gICAgLy8gVE9ETzogVGhpcyBjb3VsZCBiZSBjbGVhbmVkIHVwLiAgcHVzaC9yZXBsYWNlIHNob3VsZCBwcm9iYWJseSBqdXN0IHRha2VcbiAgICAvLyBmdWxsIExvY2F0aW9ucyBub3cgYW5kIGF2b2lkIHRoZSBuZWVkIHRvIHJ1biB0aHJvdWdoIHRoaXMgZmxvdyBhdCBhbGxcbiAgICAvLyBCdXQgdGhhdCdzIGEgcHJldHR5IGJpZyByZWZhY3RvciB0byB0aGUgY3VycmVudCB0ZXN0IHN1aXRlIHNvIGdvaW5nIHRvXG4gICAgLy8ga2VlcCBhcyBpcyBmb3IgdGhlIHRpbWUgYmVpbmcgYW5kIGp1c3QgbGV0IGFueSBpbmNvbWluZyBrZXlzIHRha2UgcHJlY2VkZW5jZVxuICAgIGtleTogKHRvICYmICh0byBhcyBMb2NhdGlvbikua2V5KSB8fCBrZXkgfHwgY3JlYXRlS2V5KCksXG4gIH07XG4gIHJldHVybiBsb2NhdGlvbjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RyaW5nIFVSTCBwYXRoIGZyb20gdGhlIGdpdmVuIHBhdGhuYW1lLCBzZWFyY2gsIGFuZCBoYXNoIGNvbXBvbmVudHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQYXRoKHtcbiAgcGF0aG5hbWUgPSBcIi9cIixcbiAgc2VhcmNoID0gXCJcIixcbiAgaGFzaCA9IFwiXCIsXG59OiBQYXJ0aWFsPFBhdGg+KSB7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoICE9PSBcIj9cIilcbiAgICBwYXRobmFtZSArPSBzZWFyY2guY2hhckF0KDApID09PSBcIj9cIiA/IHNlYXJjaCA6IFwiP1wiICsgc2VhcmNoO1xuICBpZiAoaGFzaCAmJiBoYXNoICE9PSBcIiNcIilcbiAgICBwYXRobmFtZSArPSBoYXNoLmNoYXJBdCgwKSA9PT0gXCIjXCIgPyBoYXNoIDogXCIjXCIgKyBoYXNoO1xuICByZXR1cm4gcGF0aG5hbWU7XG59XG5cbi8qKlxuICogUGFyc2VzIGEgc3RyaW5nIFVSTCBwYXRoIGludG8gaXRzIHNlcGFyYXRlIHBhdGhuYW1lLCBzZWFyY2gsIGFuZCBoYXNoIGNvbXBvbmVudHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVBhdGgocGF0aDogc3RyaW5nKTogUGFydGlhbDxQYXRoPiB7XG4gIGxldCBwYXJzZWRQYXRoOiBQYXJ0aWFsPFBhdGg+ID0ge307XG5cbiAgaWYgKHBhdGgpIHtcbiAgICBsZXQgaGFzaEluZGV4ID0gcGF0aC5pbmRleE9mKFwiI1wiKTtcbiAgICBpZiAoaGFzaEluZGV4ID49IDApIHtcbiAgICAgIHBhcnNlZFBhdGguaGFzaCA9IHBhdGguc3Vic3RyKGhhc2hJbmRleCk7XG4gICAgICBwYXRoID0gcGF0aC5zdWJzdHIoMCwgaGFzaEluZGV4KTtcbiAgICB9XG5cbiAgICBsZXQgc2VhcmNoSW5kZXggPSBwYXRoLmluZGV4T2YoXCI/XCIpO1xuICAgIGlmIChzZWFyY2hJbmRleCA+PSAwKSB7XG4gICAgICBwYXJzZWRQYXRoLnNlYXJjaCA9IHBhdGguc3Vic3RyKHNlYXJjaEluZGV4KTtcbiAgICAgIHBhdGggPSBwYXRoLnN1YnN0cigwLCBzZWFyY2hJbmRleCk7XG4gICAgfVxuXG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHBhcnNlZFBhdGgucGF0aG5hbWUgPSBwYXRoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJzZWRQYXRoO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVybEhpc3RvcnkgZXh0ZW5kcyBIaXN0b3J5IHt9XG5cbmV4cG9ydCB0eXBlIFVybEhpc3RvcnlPcHRpb25zID0ge1xuICB3aW5kb3c/OiBXaW5kb3c7XG4gIHY1Q29tcGF0PzogYm9vbGVhbjtcbn07XG5cbmZ1bmN0aW9uIGdldFVybEJhc2VkSGlzdG9yeShcbiAgZ2V0TG9jYXRpb246ICh3aW5kb3c6IFdpbmRvdywgZ2xvYmFsSGlzdG9yeTogV2luZG93W1wiaGlzdG9yeVwiXSkgPT4gTG9jYXRpb24sXG4gIGNyZWF0ZUhyZWY6ICh3aW5kb3c6IFdpbmRvdywgdG86IFRvKSA9PiBzdHJpbmcsXG4gIHZhbGlkYXRlTG9jYXRpb246ICgobG9jYXRpb246IExvY2F0aW9uLCB0bzogVG8pID0+IHZvaWQpIHwgbnVsbCxcbiAgb3B0aW9uczogVXJsSGlzdG9yeU9wdGlvbnMgPSB7fVxuKTogVXJsSGlzdG9yeSB7XG4gIGxldCB7IHdpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3ISwgdjVDb21wYXQgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgbGV0IGdsb2JhbEhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgbGV0IGFjdGlvbiA9IEFjdGlvbi5Qb3A7XG4gIGxldCBsaXN0ZW5lcjogTGlzdGVuZXIgfCBudWxsID0gbnVsbDtcblxuICBsZXQgaW5kZXggPSBnZXRJbmRleCgpITtcbiAgLy8gSW5kZXggc2hvdWxkIG9ubHkgYmUgbnVsbCB3aGVuIHdlIGluaXRpYWxpemUuIElmIG5vdCwgaXQncyBiZWNhdXNlIHRoZVxuICAvLyB1c2VyIGNhbGxlZCBoaXN0b3J5LnB1c2hTdGF0ZSBvciBoaXN0b3J5LnJlcGxhY2VTdGF0ZSBkaXJlY3RseSwgaW4gd2hpY2hcbiAgLy8gY2FzZSB3ZSBzaG91bGQgbG9nIGEgd2FybmluZyBhcyBpdCB3aWxsIHJlc3VsdCBpbiBidWdzLlxuICBpZiAoaW5kZXggPT0gbnVsbCkge1xuICAgIGluZGV4ID0gMDtcbiAgICBnbG9iYWxIaXN0b3J5LnJlcGxhY2VTdGF0ZSh7IC4uLmdsb2JhbEhpc3Rvcnkuc3RhdGUsIGlkeDogaW5kZXggfSwgXCJcIik7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJbmRleCgpOiBudW1iZXIge1xuICAgIGxldCBzdGF0ZSA9IGdsb2JhbEhpc3Rvcnkuc3RhdGUgfHwgeyBpZHg6IG51bGwgfTtcbiAgICByZXR1cm4gc3RhdGUuaWR4O1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlUG9wKCkge1xuICAgIGFjdGlvbiA9IEFjdGlvbi5Qb3A7XG4gICAgbGV0IG5leHRJbmRleCA9IGdldEluZGV4KCk7XG4gICAgbGV0IGRlbHRhID0gbmV4dEluZGV4ID09IG51bGwgPyBudWxsIDogbmV4dEluZGV4IC0gaW5kZXg7XG4gICAgaW5kZXggPSBuZXh0SW5kZXg7XG4gICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICBsaXN0ZW5lcih7IGFjdGlvbiwgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb24sIGRlbHRhIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2godG86IFRvLCBzdGF0ZT86IGFueSkge1xuICAgIGFjdGlvbiA9IEFjdGlvbi5QdXNoO1xuICAgIGxldCBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKGhpc3RvcnkubG9jYXRpb24sIHRvLCBzdGF0ZSk7XG4gICAgaWYgKHZhbGlkYXRlTG9jYXRpb24pIHZhbGlkYXRlTG9jYXRpb24obG9jYXRpb24sIHRvKTtcblxuICAgIGluZGV4ID0gZ2V0SW5kZXgoKSArIDE7XG4gICAgbGV0IGhpc3RvcnlTdGF0ZSA9IGdldEhpc3RvcnlTdGF0ZShsb2NhdGlvbiwgaW5kZXgpO1xuICAgIGxldCB1cmwgPSBoaXN0b3J5LmNyZWF0ZUhyZWYobG9jYXRpb24pO1xuXG4gICAgLy8gdHJ5Li4uY2F0Y2ggYmVjYXVzZSBpT1MgbGltaXRzIHVzIHRvIDEwMCBwdXNoU3RhdGUgY2FsbHMgOi9cbiAgICB0cnkge1xuICAgICAgZ2xvYmFsSGlzdG9yeS5wdXNoU3RhdGUoaGlzdG9yeVN0YXRlLCBcIlwiLCB1cmwpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBUaGV5IGFyZSBnb2luZyB0byBsb3NlIHN0YXRlIGhlcmUsIGJ1dCB0aGVyZSBpcyBubyByZWFsXG4gICAgICAvLyB3YXkgdG8gd2FybiB0aGVtIGFib3V0IGl0IHNpbmNlIHRoZSBwYWdlIHdpbGwgcmVmcmVzaC4uLlxuICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbih1cmwpO1xuICAgIH1cblxuICAgIGlmICh2NUNvbXBhdCAmJiBsaXN0ZW5lcikge1xuICAgICAgbGlzdGVuZXIoeyBhY3Rpb24sIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uLCBkZWx0YTogMSB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlKHRvOiBUbywgc3RhdGU/OiBhbnkpIHtcbiAgICBhY3Rpb24gPSBBY3Rpb24uUmVwbGFjZTtcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihoaXN0b3J5LmxvY2F0aW9uLCB0bywgc3RhdGUpO1xuICAgIGlmICh2YWxpZGF0ZUxvY2F0aW9uKSB2YWxpZGF0ZUxvY2F0aW9uKGxvY2F0aW9uLCB0byk7XG5cbiAgICBpbmRleCA9IGdldEluZGV4KCk7XG4gICAgbGV0IGhpc3RvcnlTdGF0ZSA9IGdldEhpc3RvcnlTdGF0ZShsb2NhdGlvbiwgaW5kZXgpO1xuICAgIGxldCB1cmwgPSBoaXN0b3J5LmNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgIGdsb2JhbEhpc3RvcnkucmVwbGFjZVN0YXRlKGhpc3RvcnlTdGF0ZSwgXCJcIiwgdXJsKTtcblxuICAgIGlmICh2NUNvbXBhdCAmJiBsaXN0ZW5lcikge1xuICAgICAgbGlzdGVuZXIoeyBhY3Rpb24sIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uLCBkZWx0YTogMCB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVVUkwodG86IFRvKTogVVJMIHtcbiAgICAvLyB3aW5kb3cubG9jYXRpb24ub3JpZ2luIGlzIFwibnVsbFwiICh0aGUgbGl0ZXJhbCBzdHJpbmcgdmFsdWUpIGluIEZpcmVmb3hcbiAgICAvLyB1bmRlciBjZXJ0YWluIGNvbmRpdGlvbnMsIG5vdGFibHkgd2hlbiBzZXJ2aW5nIGZyb20gYSBsb2NhbCBIVE1MIGZpbGVcbiAgICAvLyBTZWUgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODc4Mjk3XG4gICAgbGV0IGJhc2UgPVxuICAgICAgd2luZG93LmxvY2F0aW9uLm9yaWdpbiAhPT0gXCJudWxsXCJcbiAgICAgICAgPyB3aW5kb3cubG9jYXRpb24ub3JpZ2luXG4gICAgICAgIDogd2luZG93LmxvY2F0aW9uLmhyZWY7XG5cbiAgICBsZXQgaHJlZiA9IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG4gICAgaW52YXJpYW50KFxuICAgICAgYmFzZSxcbiAgICAgIGBObyB3aW5kb3cubG9jYXRpb24uKG9yaWdpbnxocmVmKSBhdmFpbGFibGUgdG8gY3JlYXRlIFVSTCBmb3IgaHJlZjogJHtocmVmfWBcbiAgICApO1xuICAgIHJldHVybiBuZXcgVVJMKGhyZWYsIGJhc2UpO1xuICB9XG5cbiAgbGV0IGhpc3Rvcnk6IEhpc3RvcnkgPSB7XG4gICAgZ2V0IGFjdGlvbigpIHtcbiAgICAgIHJldHVybiBhY3Rpb247XG4gICAgfSxcbiAgICBnZXQgbG9jYXRpb24oKSB7XG4gICAgICByZXR1cm4gZ2V0TG9jYXRpb24od2luZG93LCBnbG9iYWxIaXN0b3J5KTtcbiAgICB9LFxuICAgIGxpc3RlbihmbjogTGlzdGVuZXIpIHtcbiAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIGhpc3Rvcnkgb25seSBhY2NlcHRzIG9uZSBhY3RpdmUgbGlzdGVuZXJcIik7XG4gICAgICB9XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihQb3BTdGF0ZUV2ZW50VHlwZSwgaGFuZGxlUG9wKTtcbiAgICAgIGxpc3RlbmVyID0gZm47XG5cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFBvcFN0YXRlRXZlbnRUeXBlLCBoYW5kbGVQb3ApO1xuICAgICAgICBsaXN0ZW5lciA9IG51bGw7XG4gICAgICB9O1xuICAgIH0sXG4gICAgY3JlYXRlSHJlZih0bykge1xuICAgICAgcmV0dXJuIGNyZWF0ZUhyZWYod2luZG93LCB0byk7XG4gICAgfSxcbiAgICBjcmVhdGVVUkwsXG4gICAgZW5jb2RlTG9jYXRpb24odG8pIHtcbiAgICAgIC8vIEVuY29kZSBhIExvY2F0aW9uIHRoZSBzYW1lIHdheSB3aW5kb3cubG9jYXRpb24gd291bGRcbiAgICAgIGxldCB1cmwgPSBjcmVhdGVVUkwodG8pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aG5hbWU6IHVybC5wYXRobmFtZSxcbiAgICAgICAgc2VhcmNoOiB1cmwuc2VhcmNoLFxuICAgICAgICBoYXNoOiB1cmwuaGFzaCxcbiAgICAgIH07XG4gICAgfSxcbiAgICBwdXNoLFxuICAgIHJlcGxhY2UsXG4gICAgZ28obikge1xuICAgICAgcmV0dXJuIGdsb2JhbEhpc3RvcnkuZ28obik7XG4gICAgfSxcbiAgfTtcblxuICByZXR1cm4gaGlzdG9yeTtcbn1cblxuLy8jZW5kcmVnaW9uXG4iLCJpbXBvcnQgdHlwZSB7IExvY2F0aW9uLCBQYXRoLCBUbyB9IGZyb20gXCIuL2hpc3RvcnlcIjtcbmltcG9ydCB7IHdhcm5pbmcsIGludmFyaWFudCwgcGFyc2VQYXRoIH0gZnJvbSBcIi4vaGlzdG9yeVwiO1xuXG4vKipcbiAqIE1hcCBvZiByb3V0ZUlkIC0+IGRhdGEgcmV0dXJuZWQgZnJvbSBhIGxvYWRlci9hY3Rpb24vZXJyb3JcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSb3V0ZURhdGEge1xuICBbcm91dGVJZDogc3RyaW5nXTogYW55O1xufVxuXG5leHBvcnQgZW51bSBSZXN1bHRUeXBlIHtcbiAgZGF0YSA9IFwiZGF0YVwiLFxuICBkZWZlcnJlZCA9IFwiZGVmZXJyZWRcIixcbiAgcmVkaXJlY3QgPSBcInJlZGlyZWN0XCIsXG4gIGVycm9yID0gXCJlcnJvclwiLFxufVxuXG4vKipcbiAqIFN1Y2Nlc3NmdWwgcmVzdWx0IGZyb20gYSBsb2FkZXIgb3IgYWN0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3VjY2Vzc1Jlc3VsdCB7XG4gIHR5cGU6IFJlc3VsdFR5cGUuZGF0YTtcbiAgZGF0YTogYW55O1xuICBzdGF0dXNDb2RlPzogbnVtYmVyO1xuICBoZWFkZXJzPzogSGVhZGVycztcbn1cblxuLyoqXG4gKiBTdWNjZXNzZnVsIGRlZmVyKCkgcmVzdWx0IGZyb20gYSBsb2FkZXIgb3IgYWN0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRGVmZXJyZWRSZXN1bHQge1xuICB0eXBlOiBSZXN1bHRUeXBlLmRlZmVycmVkO1xuICBkZWZlcnJlZERhdGE6IERlZmVycmVkRGF0YTtcbiAgc3RhdHVzQ29kZT86IG51bWJlcjtcbiAgaGVhZGVycz86IEhlYWRlcnM7XG59XG5cbi8qKlxuICogUmVkaXJlY3QgcmVzdWx0IGZyb20gYSBsb2FkZXIgb3IgYWN0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVkaXJlY3RSZXN1bHQge1xuICB0eXBlOiBSZXN1bHRUeXBlLnJlZGlyZWN0O1xuICBzdGF0dXM6IG51bWJlcjtcbiAgbG9jYXRpb246IHN0cmluZztcbiAgcmV2YWxpZGF0ZTogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBVbnN1Y2Nlc3NmdWwgcmVzdWx0IGZyb20gYSBsb2FkZXIgb3IgYWN0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRXJyb3JSZXN1bHQge1xuICB0eXBlOiBSZXN1bHRUeXBlLmVycm9yO1xuICBlcnJvcjogYW55O1xuICBoZWFkZXJzPzogSGVhZGVycztcbn1cblxuLyoqXG4gKiBSZXN1bHQgZnJvbSBhIGxvYWRlciBvciBhY3Rpb24gLSBwb3RlbnRpYWxseSBzdWNjZXNzZnVsIG9yIHVuc3VjY2Vzc2Z1bFxuICovXG5leHBvcnQgdHlwZSBEYXRhUmVzdWx0ID1cbiAgfCBTdWNjZXNzUmVzdWx0XG4gIHwgRGVmZXJyZWRSZXN1bHRcbiAgfCBSZWRpcmVjdFJlc3VsdFxuICB8IEVycm9yUmVzdWx0O1xuXG5leHBvcnQgdHlwZSBNdXRhdGlvbkZvcm1NZXRob2QgPSBcInBvc3RcIiB8IFwicHV0XCIgfCBcInBhdGNoXCIgfCBcImRlbGV0ZVwiO1xuZXhwb3J0IHR5cGUgRm9ybU1ldGhvZCA9IFwiZ2V0XCIgfCBNdXRhdGlvbkZvcm1NZXRob2Q7XG5cbmV4cG9ydCB0eXBlIEZvcm1FbmNUeXBlID1cbiAgfCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiXG4gIHwgXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCI7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEludGVybmFsIGludGVyZmFjZSB0byBwYXNzIGFyb3VuZCBmb3IgYWN0aW9uIHN1Ym1pc3Npb25zLCBub3QgaW50ZW5kZWQgZm9yXG4gKiBleHRlcm5hbCBjb25zdW1wdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN1Ym1pc3Npb24ge1xuICBmb3JtTWV0aG9kOiBGb3JtTWV0aG9kO1xuICBmb3JtQWN0aW9uOiBzdHJpbmc7XG4gIGZvcm1FbmNUeXBlOiBGb3JtRW5jVHlwZTtcbiAgZm9ybURhdGE6IEZvcm1EYXRhO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBBcmd1bWVudHMgcGFzc2VkIHRvIHJvdXRlIGxvYWRlci9hY3Rpb24gZnVuY3Rpb25zLiAgU2FtZSBmb3Igbm93IGJ1dCB3ZSBrZWVwXG4gKiB0aGlzIGFzIGEgcHJpdmF0ZSBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgaW4gY2FzZSB0aGV5IGRpdmVyZ2UgaW4gdGhlIGZ1dHVyZS5cbiAqL1xuaW50ZXJmYWNlIERhdGFGdW5jdGlvbkFyZ3Mge1xuICByZXF1ZXN0OiBSZXF1ZXN0O1xuICBwYXJhbXM6IFBhcmFtcztcbiAgY29udGV4dD86IGFueTtcbn1cblxuLyoqXG4gKiBBcmd1bWVudHMgcGFzc2VkIHRvIGxvYWRlciBmdW5jdGlvbnNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMb2FkZXJGdW5jdGlvbkFyZ3MgZXh0ZW5kcyBEYXRhRnVuY3Rpb25BcmdzIHt9XG5cbi8qKlxuICogQXJndW1lbnRzIHBhc3NlZCB0byBhY3Rpb24gZnVuY3Rpb25zXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQWN0aW9uRnVuY3Rpb25BcmdzIGV4dGVuZHMgRGF0YUZ1bmN0aW9uQXJncyB7fVxuXG4vKipcbiAqIFJvdXRlIGxvYWRlciBmdW5jdGlvbiBzaWduYXR1cmVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMb2FkZXJGdW5jdGlvbiB7XG4gIChhcmdzOiBMb2FkZXJGdW5jdGlvbkFyZ3MpOiBQcm9taXNlPFJlc3BvbnNlPiB8IFJlc3BvbnNlIHwgUHJvbWlzZTxhbnk+IHwgYW55O1xufVxuXG4vKipcbiAqIFJvdXRlIGFjdGlvbiBmdW5jdGlvbiBzaWduYXR1cmVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBY3Rpb25GdW5jdGlvbiB7XG4gIChhcmdzOiBBY3Rpb25GdW5jdGlvbkFyZ3MpOiBQcm9taXNlPFJlc3BvbnNlPiB8IFJlc3BvbnNlIHwgUHJvbWlzZTxhbnk+IHwgYW55O1xufVxuXG4vKipcbiAqIFJvdXRlIHNob3VsZFJldmFsaWRhdGUgZnVuY3Rpb24gc2lnbmF0dXJlLiAgVGhpcyBydW5zIGFmdGVyIGFueSBzdWJtaXNzaW9uXG4gKiAobmF2aWdhdGlvbiBvciBmZXRjaGVyKSwgc28gd2UgZmxhdHRlbiB0aGUgbmF2aWdhdGlvbi9mZXRjaGVyIHN1Ym1pc3Npb25cbiAqIG9udG8gdGhlIGFyZ3VtZW50cy4gIEl0IHNob3VsZG4ndCBtYXR0ZXIgd2hldGhlciBpdCBjYW1lIGZyb20gYSBuYXZpZ2F0aW9uXG4gKiBvciBhIGZldGNoZXIsIHdoYXQgcmVhbGx5IG1hdHRlcnMgaXMgdGhlIFVSTHMgYW5kIHRoZSBmb3JtRGF0YSBzaW5jZSBsb2FkZXJzXG4gKiBoYXZlIHRvIHJlLXJ1biBiYXNlZCBvbiB0aGUgZGF0YSBtb2RlbHMgdGhhdCB3ZXJlIHBvdGVudGlhbGx5IG11dGF0ZWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2hvdWxkUmV2YWxpZGF0ZUZ1bmN0aW9uIHtcbiAgKGFyZ3M6IHtcbiAgICBjdXJyZW50VXJsOiBVUkw7XG4gICAgY3VycmVudFBhcmFtczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtcInBhcmFtc1wiXTtcbiAgICBuZXh0VXJsOiBVUkw7XG4gICAgbmV4dFBhcmFtczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtcInBhcmFtc1wiXTtcbiAgICBmb3JtTWV0aG9kPzogU3VibWlzc2lvbltcImZvcm1NZXRob2RcIl07XG4gICAgZm9ybUFjdGlvbj86IFN1Ym1pc3Npb25bXCJmb3JtQWN0aW9uXCJdO1xuICAgIGZvcm1FbmNUeXBlPzogU3VibWlzc2lvbltcImZvcm1FbmNUeXBlXCJdO1xuICAgIGZvcm1EYXRhPzogU3VibWlzc2lvbltcImZvcm1EYXRhXCJdO1xuICAgIGFjdGlvblJlc3VsdD86IERhdGFSZXN1bHQ7XG4gICAgZGVmYXVsdFNob3VsZFJldmFsaWRhdGU6IGJvb2xlYW47XG4gIH0pOiBib29sZWFuO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHByb3ZpZGVkIGJ5IHRoZSBmcmFtZXdvcmstYXdhcmUgbGF5ZXJzIHRvIHNldCBgaGFzRXJyb3JCb3VuZGFyeWBcbiAqIGZyb20gdGhlIGZyYW1ld29yay1hd2FyZSBgZXJyb3JFbGVtZW50YCBwcm9wXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRGV0ZWN0RXJyb3JCb3VuZGFyeUZ1bmN0aW9uIHtcbiAgKHJvdXRlOiBBZ25vc3RpY1JvdXRlT2JqZWN0KTogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBLZXlzIHdlIGNhbm5vdCBjaGFuZ2UgZnJvbSB3aXRoaW4gYSBsYXp5KCkgZnVuY3Rpb24uIFdlIHNwcmVhZCBhbGwgb3RoZXIga2V5c1xuICogb250byB0aGUgcm91dGUuIEVpdGhlciB0aGV5J3JlIG1lYW5pbmdmdWwgdG8gdGhlIHJvdXRlciwgb3IgdGhleSdsbCBnZXRcbiAqIGlnbm9yZWQuXG4gKi9cbmV4cG9ydCB0eXBlIEltbXV0YWJsZVJvdXRlS2V5ID1cbiAgfCBcImxhenlcIlxuICB8IFwiY2FzZVNlbnNpdGl2ZVwiXG4gIHwgXCJwYXRoXCJcbiAgfCBcImlkXCJcbiAgfCBcImluZGV4XCJcbiAgfCBcImNoaWxkcmVuXCI7XG5cbmV4cG9ydCBjb25zdCBpbW11dGFibGVSb3V0ZUtleXMgPSBuZXcgU2V0PEltbXV0YWJsZVJvdXRlS2V5PihbXG4gIFwibGF6eVwiLFxuICBcImNhc2VTZW5zaXRpdmVcIixcbiAgXCJwYXRoXCIsXG4gIFwiaWRcIixcbiAgXCJpbmRleFwiLFxuICBcImNoaWxkcmVuXCIsXG5dKTtcblxuLyoqXG4gKiBsYXp5KCkgZnVuY3Rpb24gdG8gbG9hZCBhIHJvdXRlIGRlZmluaXRpb24sIHdoaWNoIGNhbiBhZGQgbm9uLW1hdGNoaW5nXG4gKiByZWxhdGVkIHByb3BlcnRpZXMgdG8gYSByb3V0ZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIExhenlSb3V0ZUZ1bmN0aW9uPFIgZXh0ZW5kcyBBZ25vc3RpY1JvdXRlT2JqZWN0PiB7XG4gICgpOiBQcm9taXNlPE9taXQ8UiwgSW1tdXRhYmxlUm91dGVLZXk+Pjtcbn1cblxuLyoqXG4gKiBCYXNlIFJvdXRlT2JqZWN0IHdpdGggY29tbW9uIHByb3BzIHNoYXJlZCBieSBhbGwgdHlwZXMgb2Ygcm91dGVzXG4gKi9cbnR5cGUgQWdub3N0aWNCYXNlUm91dGVPYmplY3QgPSB7XG4gIGNhc2VTZW5zaXRpdmU/OiBib29sZWFuO1xuICBwYXRoPzogc3RyaW5nO1xuICBpZD86IHN0cmluZztcbiAgbG9hZGVyPzogTG9hZGVyRnVuY3Rpb247XG4gIGFjdGlvbj86IEFjdGlvbkZ1bmN0aW9uO1xuICBoYXNFcnJvckJvdW5kYXJ5PzogYm9vbGVhbjtcbiAgc2hvdWxkUmV2YWxpZGF0ZT86IFNob3VsZFJldmFsaWRhdGVGdW5jdGlvbjtcbiAgaGFuZGxlPzogYW55O1xuICBsYXp5PzogTGF6eVJvdXRlRnVuY3Rpb248QWdub3N0aWNCYXNlUm91dGVPYmplY3Q+O1xufTtcblxuLyoqXG4gKiBJbmRleCByb3V0ZXMgbXVzdCBub3QgaGF2ZSBjaGlsZHJlblxuICovXG5leHBvcnQgdHlwZSBBZ25vc3RpY0luZGV4Um91dGVPYmplY3QgPSBBZ25vc3RpY0Jhc2VSb3V0ZU9iamVjdCAmIHtcbiAgY2hpbGRyZW4/OiB1bmRlZmluZWQ7XG4gIGluZGV4OiB0cnVlO1xufTtcblxuLyoqXG4gKiBOb24taW5kZXggcm91dGVzIG1heSBoYXZlIGNoaWxkcmVuLCBidXQgY2Fubm90IGhhdmUgaW5kZXhcbiAqL1xuZXhwb3J0IHR5cGUgQWdub3N0aWNOb25JbmRleFJvdXRlT2JqZWN0ID0gQWdub3N0aWNCYXNlUm91dGVPYmplY3QgJiB7XG4gIGNoaWxkcmVuPzogQWdub3N0aWNSb3V0ZU9iamVjdFtdO1xuICBpbmRleD86IGZhbHNlO1xufTtcblxuLyoqXG4gKiBBIHJvdXRlIG9iamVjdCByZXByZXNlbnRzIGEgbG9naWNhbCByb3V0ZSwgd2l0aCAob3B0aW9uYWxseSkgaXRzIGNoaWxkXG4gKiByb3V0ZXMgb3JnYW5pemVkIGluIGEgdHJlZS1saWtlIHN0cnVjdHVyZS5cbiAqL1xuZXhwb3J0IHR5cGUgQWdub3N0aWNSb3V0ZU9iamVjdCA9XG4gIHwgQWdub3N0aWNJbmRleFJvdXRlT2JqZWN0XG4gIHwgQWdub3N0aWNOb25JbmRleFJvdXRlT2JqZWN0O1xuXG5leHBvcnQgdHlwZSBBZ25vc3RpY0RhdGFJbmRleFJvdXRlT2JqZWN0ID0gQWdub3N0aWNJbmRleFJvdXRlT2JqZWN0ICYge1xuICBpZDogc3RyaW5nO1xufTtcblxuZXhwb3J0IHR5cGUgQWdub3N0aWNEYXRhTm9uSW5kZXhSb3V0ZU9iamVjdCA9IEFnbm9zdGljTm9uSW5kZXhSb3V0ZU9iamVjdCAmIHtcbiAgY2hpbGRyZW4/OiBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdFtdO1xuICBpZDogc3RyaW5nO1xufTtcblxuLyoqXG4gKiBBIGRhdGEgcm91dGUgb2JqZWN0LCB3aGljaCBpcyBqdXN0IGEgUm91dGVPYmplY3Qgd2l0aCBhIHJlcXVpcmVkIHVuaXF1ZSBJRFxuICovXG5leHBvcnQgdHlwZSBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdCA9XG4gIHwgQWdub3N0aWNEYXRhSW5kZXhSb3V0ZU9iamVjdFxuICB8IEFnbm9zdGljRGF0YU5vbkluZGV4Um91dGVPYmplY3Q7XG5cbmV4cG9ydCB0eXBlIFJvdXRlTWFuaWZlc3QgPSBSZWNvcmQ8c3RyaW5nLCBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdCB8IHVuZGVmaW5lZD47XG5cbi8vIFJlY3Vyc2l2ZSBoZWxwZXIgZm9yIGZpbmRpbmcgcGF0aCBwYXJhbWV0ZXJzIGluIHRoZSBhYnNlbmNlIG9mIHdpbGRjYXJkc1xudHlwZSBfUGF0aFBhcmFtPFBhdGggZXh0ZW5kcyBzdHJpbmc+ID1cbiAgLy8gc3BsaXQgcGF0aCBpbnRvIGluZGl2aWR1YWwgcGF0aCBzZWdtZW50c1xuICBQYXRoIGV4dGVuZHMgYCR7aW5mZXIgTH0vJHtpbmZlciBSfWBcbiAgICA/IF9QYXRoUGFyYW08TD4gfCBfUGF0aFBhcmFtPFI+XG4gICAgOiAvLyBmaW5kIHBhcmFtcyBhZnRlciBgOmBcbiAgICBQYXRoIGV4dGVuZHMgYDoke2luZmVyIFBhcmFtfWBcbiAgICA/IFBhcmFtIGV4dGVuZHMgYCR7aW5mZXIgT3B0aW9uYWx9P2BcbiAgICAgID8gT3B0aW9uYWxcbiAgICAgIDogUGFyYW1cbiAgICA6IC8vIG90aGVyd2lzZSwgdGhlcmUgYXJlbid0IGFueSBwYXJhbXMgcHJlc2VudFxuICAgICAgbmV2ZXI7XG5cbi8qKlxuICogRXhhbXBsZXM6XG4gKiBcIi9hL2IvKlwiIC0+IFwiKlwiXG4gKiBcIjphXCIgLT4gXCJhXCJcbiAqIFwiL2EvOmJcIiAtPiBcImJcIlxuICogXCIvYS9ibGFoYmxhaGJsYWg6YlwiIC0+IFwiYlwiXG4gKiBcIi86YS86YlwiIC0+IFwiYVwiIHwgXCJiXCJcbiAqIFwiLzphL2IvOmMvKlwiIC0+IFwiYVwiIHwgXCJjXCIgfCBcIipcIlxuICovXG50eXBlIFBhdGhQYXJhbTxQYXRoIGV4dGVuZHMgc3RyaW5nPiA9XG4gIC8vIGNoZWNrIGlmIHBhdGggaXMganVzdCBhIHdpbGRjYXJkXG4gIFBhdGggZXh0ZW5kcyBcIipcIiB8IFwiLypcIlxuICAgID8gXCIqXCJcbiAgICA6IC8vIGxvb2sgZm9yIHdpbGRjYXJkIGF0IHRoZSBlbmQgb2YgdGhlIHBhdGhcbiAgICBQYXRoIGV4dGVuZHMgYCR7aW5mZXIgUmVzdH0vKmBcbiAgICA/IFwiKlwiIHwgX1BhdGhQYXJhbTxSZXN0PlxuICAgIDogLy8gbG9vayBmb3IgcGFyYW1zIGluIHRoZSBhYnNlbmNlIG9mIHdpbGRjYXJkc1xuICAgICAgX1BhdGhQYXJhbTxQYXRoPjtcblxuLy8gQXR0ZW1wdCB0byBwYXJzZSB0aGUgZ2l2ZW4gc3RyaW5nIHNlZ21lbnQuIElmIGl0IGZhaWxzLCB0aGVuIGp1c3QgcmV0dXJuIHRoZVxuLy8gcGxhaW4gc3RyaW5nIHR5cGUgYXMgYSBkZWZhdWx0IGZhbGxiYWNrLiBPdGhlcndpc2UgcmV0dXJuIHRoZSB1bmlvbiBvZiB0aGVcbi8vIHBhcnNlZCBzdHJpbmcgbGl0ZXJhbHMgdGhhdCB3ZXJlIHJlZmVyZW5jZWQgYXMgZHluYW1pYyBzZWdtZW50cyBpbiB0aGUgcm91dGUuXG5leHBvcnQgdHlwZSBQYXJhbVBhcnNlS2V5PFNlZ21lbnQgZXh0ZW5kcyBzdHJpbmc+ID1cbiAgLy8gaWYgY291bGQgbm90IGZpbmQgcGF0aCBwYXJhbXMsIGZhbGxiYWNrIHRvIGBzdHJpbmdgXG4gIFtQYXRoUGFyYW08U2VnbWVudD5dIGV4dGVuZHMgW25ldmVyXSA/IHN0cmluZyA6IFBhdGhQYXJhbTxTZWdtZW50PjtcblxuLyoqXG4gKiBUaGUgcGFyYW1ldGVycyB0aGF0IHdlcmUgcGFyc2VkIGZyb20gdGhlIFVSTCBwYXRoLlxuICovXG5leHBvcnQgdHlwZSBQYXJhbXM8S2V5IGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiA9IHtcbiAgcmVhZG9ubHkgW2tleSBpbiBLZXldOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIEEgUm91dGVNYXRjaCBjb250YWlucyBpbmZvIGFib3V0IGhvdyBhIHJvdXRlIG1hdGNoZWQgYSBVUkwuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQWdub3N0aWNSb3V0ZU1hdGNoPFxuICBQYXJhbUtleSBleHRlbmRzIHN0cmluZyA9IHN0cmluZyxcbiAgUm91dGVPYmplY3RUeXBlIGV4dGVuZHMgQWdub3N0aWNSb3V0ZU9iamVjdCA9IEFnbm9zdGljUm91dGVPYmplY3Rcbj4ge1xuICAvKipcbiAgICogVGhlIG5hbWVzIGFuZCB2YWx1ZXMgb2YgZHluYW1pYyBwYXJhbWV0ZXJzIGluIHRoZSBVUkwuXG4gICAqL1xuICBwYXJhbXM6IFBhcmFtczxQYXJhbUtleT47XG4gIC8qKlxuICAgKiBUaGUgcG9ydGlvbiBvZiB0aGUgVVJMIHBhdGhuYW1lIHRoYXQgd2FzIG1hdGNoZWQuXG4gICAqL1xuICBwYXRobmFtZTogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHBvcnRpb24gb2YgdGhlIFVSTCBwYXRobmFtZSB0aGF0IHdhcyBtYXRjaGVkIGJlZm9yZSBjaGlsZCByb3V0ZXMuXG4gICAqL1xuICBwYXRobmFtZUJhc2U6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSByb3V0ZSBvYmplY3QgdGhhdCB3YXMgdXNlZCB0byBtYXRjaC5cbiAgICovXG4gIHJvdXRlOiBSb3V0ZU9iamVjdFR5cGU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWdub3N0aWNEYXRhUm91dGVNYXRjaFxuICBleHRlbmRzIEFnbm9zdGljUm91dGVNYXRjaDxzdHJpbmcsIEFnbm9zdGljRGF0YVJvdXRlT2JqZWN0PiB7fVxuXG5mdW5jdGlvbiBpc0luZGV4Um91dGUoXG4gIHJvdXRlOiBBZ25vc3RpY1JvdXRlT2JqZWN0XG4pOiByb3V0ZSBpcyBBZ25vc3RpY0luZGV4Um91dGVPYmplY3Qge1xuICByZXR1cm4gcm91dGUuaW5kZXggPT09IHRydWU7XG59XG5cbi8vIFdhbGsgdGhlIHJvdXRlIHRyZWUgZ2VuZXJhdGluZyB1bmlxdWUgSURzIHdoZXJlIG5lY2Vzc2FyeSBzbyB3ZSBhcmUgd29ya2luZ1xuLy8gc29sZWx5IHdpdGggQWdub3N0aWNEYXRhUm91dGVPYmplY3QncyB3aXRoaW4gdGhlIFJvdXRlclxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMoXG4gIHJvdXRlczogQWdub3N0aWNSb3V0ZU9iamVjdFtdLFxuICBkZXRlY3RFcnJvckJvdW5kYXJ5OiBEZXRlY3RFcnJvckJvdW5kYXJ5RnVuY3Rpb24sXG4gIHBhcmVudFBhdGg6IG51bWJlcltdID0gW10sXG4gIG1hbmlmZXN0OiBSb3V0ZU1hbmlmZXN0ID0ge31cbik6IEFnbm9zdGljRGF0YVJvdXRlT2JqZWN0W10ge1xuICByZXR1cm4gcm91dGVzLm1hcCgocm91dGUsIGluZGV4KSA9PiB7XG4gICAgbGV0IHRyZWVQYXRoID0gWy4uLnBhcmVudFBhdGgsIGluZGV4XTtcbiAgICBsZXQgaWQgPSB0eXBlb2Ygcm91dGUuaWQgPT09IFwic3RyaW5nXCIgPyByb3V0ZS5pZCA6IHRyZWVQYXRoLmpvaW4oXCItXCIpO1xuICAgIGludmFyaWFudChcbiAgICAgIHJvdXRlLmluZGV4ICE9PSB0cnVlIHx8ICFyb3V0ZS5jaGlsZHJlbixcbiAgICAgIGBDYW5ub3Qgc3BlY2lmeSBjaGlsZHJlbiBvbiBhbiBpbmRleCByb3V0ZWBcbiAgICApO1xuICAgIGludmFyaWFudChcbiAgICAgICFtYW5pZmVzdFtpZF0sXG4gICAgICBgRm91bmQgYSByb3V0ZSBpZCBjb2xsaXNpb24gb24gaWQgXCIke2lkfVwiLiAgUm91dGUgYCArXG4gICAgICAgIFwiaWQncyBtdXN0IGJlIGdsb2JhbGx5IHVuaXF1ZSB3aXRoaW4gRGF0YSBSb3V0ZXIgdXNhZ2VzXCJcbiAgICApO1xuXG4gICAgaWYgKGlzSW5kZXhSb3V0ZShyb3V0ZSkpIHtcbiAgICAgIGxldCBpbmRleFJvdXRlOiBBZ25vc3RpY0RhdGFJbmRleFJvdXRlT2JqZWN0ID0ge1xuICAgICAgICAuLi5yb3V0ZSxcbiAgICAgICAgaGFzRXJyb3JCb3VuZGFyeTogZGV0ZWN0RXJyb3JCb3VuZGFyeShyb3V0ZSksXG4gICAgICAgIGlkLFxuICAgICAgfTtcbiAgICAgIG1hbmlmZXN0W2lkXSA9IGluZGV4Um91dGU7XG4gICAgICByZXR1cm4gaW5kZXhSb3V0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHBhdGhPckxheW91dFJvdXRlOiBBZ25vc3RpY0RhdGFOb25JbmRleFJvdXRlT2JqZWN0ID0ge1xuICAgICAgICAuLi5yb3V0ZSxcbiAgICAgICAgaWQsXG4gICAgICAgIGhhc0Vycm9yQm91bmRhcnk6IGRldGVjdEVycm9yQm91bmRhcnkocm91dGUpLFxuICAgICAgICBjaGlsZHJlbjogdW5kZWZpbmVkLFxuICAgICAgfTtcbiAgICAgIG1hbmlmZXN0W2lkXSA9IHBhdGhPckxheW91dFJvdXRlO1xuXG4gICAgICBpZiAocm91dGUuY2hpbGRyZW4pIHtcbiAgICAgICAgcGF0aE9yTGF5b3V0Um91dGUuY2hpbGRyZW4gPSBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKFxuICAgICAgICAgIHJvdXRlLmNoaWxkcmVuLFxuICAgICAgICAgIGRldGVjdEVycm9yQm91bmRhcnksXG4gICAgICAgICAgdHJlZVBhdGgsXG4gICAgICAgICAgbWFuaWZlc3RcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhdGhPckxheW91dFJvdXRlO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogTWF0Y2hlcyB0aGUgZ2l2ZW4gcm91dGVzIHRvIGEgbG9jYXRpb24gYW5kIHJldHVybnMgdGhlIG1hdGNoIGRhdGEuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS91dGlscy9tYXRjaC1yb3V0ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoUm91dGVzPFxuICBSb3V0ZU9iamVjdFR5cGUgZXh0ZW5kcyBBZ25vc3RpY1JvdXRlT2JqZWN0ID0gQWdub3N0aWNSb3V0ZU9iamVjdFxuPihcbiAgcm91dGVzOiBSb3V0ZU9iamVjdFR5cGVbXSxcbiAgbG9jYXRpb25Bcmc6IFBhcnRpYWw8TG9jYXRpb24+IHwgc3RyaW5nLFxuICBiYXNlbmFtZSA9IFwiL1wiXG4pOiBBZ25vc3RpY1JvdXRlTWF0Y2g8c3RyaW5nLCBSb3V0ZU9iamVjdFR5cGU+W10gfCBudWxsIHtcbiAgbGV0IGxvY2F0aW9uID1cbiAgICB0eXBlb2YgbG9jYXRpb25BcmcgPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgobG9jYXRpb25BcmcpIDogbG9jYXRpb25Bcmc7XG5cbiAgbGV0IHBhdGhuYW1lID0gc3RyaXBCYXNlbmFtZShsb2NhdGlvbi5wYXRobmFtZSB8fCBcIi9cIiwgYmFzZW5hbWUpO1xuXG4gIGlmIChwYXRobmFtZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBsZXQgYnJhbmNoZXMgPSBmbGF0dGVuUm91dGVzKHJvdXRlcyk7XG4gIHJhbmtSb3V0ZUJyYW5jaGVzKGJyYW5jaGVzKTtcblxuICBsZXQgbWF0Y2hlcyA9IG51bGw7XG4gIGZvciAobGV0IGkgPSAwOyBtYXRjaGVzID09IG51bGwgJiYgaSA8IGJyYW5jaGVzLmxlbmd0aDsgKytpKSB7XG4gICAgbWF0Y2hlcyA9IG1hdGNoUm91dGVCcmFuY2g8c3RyaW5nLCBSb3V0ZU9iamVjdFR5cGU+KFxuICAgICAgYnJhbmNoZXNbaV0sXG4gICAgICAvLyBJbmNvbWluZyBwYXRobmFtZXMgYXJlIGdlbmVyYWxseSBlbmNvZGVkIGZyb20gZWl0aGVyIHdpbmRvdy5sb2NhdGlvblxuICAgICAgLy8gb3IgZnJvbSByb3V0ZXIubmF2aWdhdGUsIGJ1dCB3ZSB3YW50IHRvIG1hdGNoIGFnYWluc3QgdGhlIHVuZW5jb2RlZFxuICAgICAgLy8gcGF0aHMgaW4gdGhlIHJvdXRlIGRlZmluaXRpb25zLiAgTWVtb3J5IHJvdXRlciBsb2NhdGlvbnMgd29uJ3QgYmVcbiAgICAgIC8vIGVuY29kZWQgaGVyZSBidXQgdGhlcmUgYWxzbyBzaG91bGRuJ3QgYmUgYW55dGhpbmcgdG8gZGVjb2RlIHNvIHRoaXNcbiAgICAgIC8vIHNob3VsZCBiZSBhIHNhZmUgb3BlcmF0aW9uLiAgVGhpcyBhdm9pZHMgbmVlZGluZyBtYXRjaFJvdXRlcyB0byBiZVxuICAgICAgLy8gaGlzdG9yeS1hd2FyZS5cbiAgICAgIHNhZmVseURlY29kZVVSSShwYXRobmFtZSlcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXM7XG59XG5cbmludGVyZmFjZSBSb3V0ZU1ldGE8XG4gIFJvdXRlT2JqZWN0VHlwZSBleHRlbmRzIEFnbm9zdGljUm91dGVPYmplY3QgPSBBZ25vc3RpY1JvdXRlT2JqZWN0XG4+IHtcbiAgcmVsYXRpdmVQYXRoOiBzdHJpbmc7XG4gIGNhc2VTZW5zaXRpdmU6IGJvb2xlYW47XG4gIGNoaWxkcmVuSW5kZXg6IG51bWJlcjtcbiAgcm91dGU6IFJvdXRlT2JqZWN0VHlwZTtcbn1cblxuaW50ZXJmYWNlIFJvdXRlQnJhbmNoPFxuICBSb3V0ZU9iamVjdFR5cGUgZXh0ZW5kcyBBZ25vc3RpY1JvdXRlT2JqZWN0ID0gQWdub3N0aWNSb3V0ZU9iamVjdFxuPiB7XG4gIHBhdGg6IHN0cmluZztcbiAgc2NvcmU6IG51bWJlcjtcbiAgcm91dGVzTWV0YTogUm91dGVNZXRhPFJvdXRlT2JqZWN0VHlwZT5bXTtcbn1cblxuZnVuY3Rpb24gZmxhdHRlblJvdXRlczxcbiAgUm91dGVPYmplY3RUeXBlIGV4dGVuZHMgQWdub3N0aWNSb3V0ZU9iamVjdCA9IEFnbm9zdGljUm91dGVPYmplY3Rcbj4oXG4gIHJvdXRlczogUm91dGVPYmplY3RUeXBlW10sXG4gIGJyYW5jaGVzOiBSb3V0ZUJyYW5jaDxSb3V0ZU9iamVjdFR5cGU+W10gPSBbXSxcbiAgcGFyZW50c01ldGE6IFJvdXRlTWV0YTxSb3V0ZU9iamVjdFR5cGU+W10gPSBbXSxcbiAgcGFyZW50UGF0aCA9IFwiXCJcbik6IFJvdXRlQnJhbmNoPFJvdXRlT2JqZWN0VHlwZT5bXSB7XG4gIGxldCBmbGF0dGVuUm91dGUgPSAoXG4gICAgcm91dGU6IFJvdXRlT2JqZWN0VHlwZSxcbiAgICBpbmRleDogbnVtYmVyLFxuICAgIHJlbGF0aXZlUGF0aD86IHN0cmluZ1xuICApID0+IHtcbiAgICBsZXQgbWV0YTogUm91dGVNZXRhPFJvdXRlT2JqZWN0VHlwZT4gPSB7XG4gICAgICByZWxhdGl2ZVBhdGg6XG4gICAgICAgIHJlbGF0aXZlUGF0aCA9PT0gdW5kZWZpbmVkID8gcm91dGUucGF0aCB8fCBcIlwiIDogcmVsYXRpdmVQYXRoLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogcm91dGUuY2FzZVNlbnNpdGl2ZSA9PT0gdHJ1ZSxcbiAgICAgIGNoaWxkcmVuSW5kZXg6IGluZGV4LFxuICAgICAgcm91dGUsXG4gICAgfTtcblxuICAgIGlmIChtZXRhLnJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICBtZXRhLnJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKHBhcmVudFBhdGgpLFxuICAgICAgICBgQWJzb2x1dGUgcm91dGUgcGF0aCBcIiR7bWV0YS5yZWxhdGl2ZVBhdGh9XCIgbmVzdGVkIHVuZGVyIHBhdGggYCArXG4gICAgICAgICAgYFwiJHtwYXJlbnRQYXRofVwiIGlzIG5vdCB2YWxpZC4gQW4gYWJzb2x1dGUgY2hpbGQgcm91dGUgcGF0aCBgICtcbiAgICAgICAgICBgbXVzdCBzdGFydCB3aXRoIHRoZSBjb21iaW5lZCBwYXRoIG9mIGFsbCBpdHMgcGFyZW50IHJvdXRlcy5gXG4gICAgICApO1xuXG4gICAgICBtZXRhLnJlbGF0aXZlUGF0aCA9IG1ldGEucmVsYXRpdmVQYXRoLnNsaWNlKHBhcmVudFBhdGgubGVuZ3RoKTtcbiAgICB9XG5cbiAgICBsZXQgcGF0aCA9IGpvaW5QYXRocyhbcGFyZW50UGF0aCwgbWV0YS5yZWxhdGl2ZVBhdGhdKTtcbiAgICBsZXQgcm91dGVzTWV0YSA9IHBhcmVudHNNZXRhLmNvbmNhdChtZXRhKTtcblxuICAgIC8vIEFkZCB0aGUgY2hpbGRyZW4gYmVmb3JlIGFkZGluZyB0aGlzIHJvdXRlIHRvIHRoZSBhcnJheSBzbyB3ZSB0cmF2ZXJzZSB0aGVcbiAgICAvLyByb3V0ZSB0cmVlIGRlcHRoLWZpcnN0IGFuZCBjaGlsZCByb3V0ZXMgYXBwZWFyIGJlZm9yZSB0aGVpciBwYXJlbnRzIGluXG4gICAgLy8gdGhlIFwiZmxhdHRlbmVkXCIgdmVyc2lvbi5cbiAgICBpZiAocm91dGUuY2hpbGRyZW4gJiYgcm91dGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICAvLyBPdXIgdHlwZXMga25vdyBiZXR0ZXIsIGJ1dCBydW50aW1lIEpTIG1heSBub3QhXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgcm91dGUuaW5kZXggIT09IHRydWUsXG4gICAgICAgIGBJbmRleCByb3V0ZXMgbXVzdCBub3QgaGF2ZSBjaGlsZCByb3V0ZXMuIFBsZWFzZSByZW1vdmUgYCArXG4gICAgICAgICAgYGFsbCBjaGlsZCByb3V0ZXMgZnJvbSByb3V0ZSBwYXRoIFwiJHtwYXRofVwiLmBcbiAgICAgICk7XG5cbiAgICAgIGZsYXR0ZW5Sb3V0ZXMocm91dGUuY2hpbGRyZW4sIGJyYW5jaGVzLCByb3V0ZXNNZXRhLCBwYXRoKTtcbiAgICB9XG5cbiAgICAvLyBSb3V0ZXMgd2l0aG91dCBhIHBhdGggc2hvdWxkbid0IGV2ZXIgbWF0Y2ggYnkgdGhlbXNlbHZlcyB1bmxlc3MgdGhleSBhcmVcbiAgICAvLyBpbmRleCByb3V0ZXMsIHNvIGRvbid0IGFkZCB0aGVtIHRvIHRoZSBsaXN0IG9mIHBvc3NpYmxlIGJyYW5jaGVzLlxuICAgIGlmIChyb3V0ZS5wYXRoID09IG51bGwgJiYgIXJvdXRlLmluZGV4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYnJhbmNoZXMucHVzaCh7XG4gICAgICBwYXRoLFxuICAgICAgc2NvcmU6IGNvbXB1dGVTY29yZShwYXRoLCByb3V0ZS5pbmRleCksXG4gICAgICByb3V0ZXNNZXRhLFxuICAgIH0pO1xuICB9O1xuICByb3V0ZXMuZm9yRWFjaCgocm91dGUsIGluZGV4KSA9PiB7XG4gICAgLy8gY29hcnNlLWdyYWluIGNoZWNrIGZvciBvcHRpb25hbCBwYXJhbXNcbiAgICBpZiAocm91dGUucGF0aCA9PT0gXCJcIiB8fCAhcm91dGUucGF0aD8uaW5jbHVkZXMoXCI/XCIpKSB7XG4gICAgICBmbGF0dGVuUm91dGUocm91dGUsIGluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgZXhwbG9kZWQgb2YgZXhwbG9kZU9wdGlvbmFsU2VnbWVudHMocm91dGUucGF0aCkpIHtcbiAgICAgICAgZmxhdHRlblJvdXRlKHJvdXRlLCBpbmRleCwgZXhwbG9kZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGJyYW5jaGVzO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIGFsbCBjb21iaW5hdGlvbnMgb2Ygb3B0aW9uYWwgcGF0aCBzZWdtZW50cyBmb3IgYSBnaXZlbiBwYXRoLFxuICogZXhjbHVkaW5nIGNvbWJpbmF0aW9ucyB0aGF0IGFyZSBhbWJpZ3VvdXMgYW5kIG9mIGxvd2VyIHByaW9yaXR5LlxuICpcbiAqIEZvciBleGFtcGxlLCBgL29uZS86dHdvPy90aHJlZS86Zm91cj8vOmZpdmU/YCBleHBsb2RlcyB0bzpcbiAqIC0gYC9vbmUvdGhyZWVgXG4gKiAtIGAvb25lLzp0d28vdGhyZWVgXG4gKiAtIGAvb25lL3RocmVlLzpmb3VyYFxuICogLSBgL29uZS90aHJlZS86Zml2ZWBcbiAqIC0gYC9vbmUvOnR3by90aHJlZS86Zm91cmBcbiAqIC0gYC9vbmUvOnR3by90aHJlZS86Zml2ZWBcbiAqIC0gYC9vbmUvdGhyZWUvOmZvdXIvOmZpdmVgXG4gKiAtIGAvb25lLzp0d28vdGhyZWUvOmZvdXIvOmZpdmVgXG4gKi9cbmZ1bmN0aW9uIGV4cGxvZGVPcHRpb25hbFNlZ21lbnRzKHBhdGg6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgbGV0IHNlZ21lbnRzID0gcGF0aC5zcGxpdChcIi9cIik7XG4gIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDApIHJldHVybiBbXTtcblxuICBsZXQgW2ZpcnN0LCAuLi5yZXN0XSA9IHNlZ21lbnRzO1xuXG4gIC8vIE9wdGlvbmFsIHBhdGggc2VnbWVudHMgYXJlIGRlbm90ZWQgYnkgYSB0cmFpbGluZyBgP2BcbiAgbGV0IGlzT3B0aW9uYWwgPSBmaXJzdC5lbmRzV2l0aChcIj9cIik7XG4gIC8vIENvbXB1dGUgdGhlIGNvcnJlc3BvbmRpbmcgcmVxdWlyZWQgc2VnbWVudDogYGZvbz9gIC0+IGBmb29gXG4gIGxldCByZXF1aXJlZCA9IGZpcnN0LnJlcGxhY2UoL1xcPyQvLCBcIlwiKTtcblxuICBpZiAocmVzdC5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJbnRlcHJldCBlbXB0eSBzdHJpbmcgYXMgb21pdHRpbmcgYW4gb3B0aW9uYWwgc2VnbWVudFxuICAgIC8vIGBbXCJvbmVcIiwgXCJcIiwgXCJ0aHJlZVwiXWAgY29ycmVzcG9uZHMgdG8gb21pdHRpbmcgYDp0d29gIGZyb20gYC9vbmUvOnR3bz8vdGhyZWVgIC0+IGAvb25lL3RocmVlYFxuICAgIHJldHVybiBpc09wdGlvbmFsID8gW3JlcXVpcmVkLCBcIlwiXSA6IFtyZXF1aXJlZF07XG4gIH1cblxuICBsZXQgcmVzdEV4cGxvZGVkID0gZXhwbG9kZU9wdGlvbmFsU2VnbWVudHMocmVzdC5qb2luKFwiL1wiKSk7XG5cbiAgbGV0IHJlc3VsdDogc3RyaW5nW10gPSBbXTtcblxuICAvLyBBbGwgY2hpbGQgcGF0aHMgd2l0aCB0aGUgcHJlZml4LiAgRG8gdGhpcyBmb3IgYWxsIGNoaWxkcmVuIGJlZm9yZSB0aGVcbiAgLy8gb3B0aW9uYWwgdmVyc2lvbiBmb3IgYWxsIGNoaWxkcmVuIHNvIHdlIGdldCBjb25zaXN0ZW50IG9yZGVyaW5nIHdoZXJlIHRoZVxuICAvLyBwYXJlbnQgb3B0aW9uYWwgYXNwZWN0IGlzIHByZWZlcnJlZCBhcyByZXF1aXJlZC4gIE90aGVyd2lzZSwgd2UgY2FuIGdldFxuICAvLyBjaGlsZCBzZWN0aW9ucyBpbnRlcnNwZXJzZWQgd2hlcmUgZGVlcGVyIG9wdGlvbmFsIHNlZ21lbnRzIGFyZSBoaWdoZXIgdGhhblxuICAvLyBwYXJlbnQgb3B0aW9uYWwgc2VnbWVudHMsIHdoZXJlIGZvciBleGFtcGxlLCAvOnR3byB3b3VsZCBleHBsb2RlcyBfZWFybGllcl9cbiAgLy8gdGhlbiAvOm9uZS4gIEJ5IGFsd2F5cyBpbmNsdWRpbmcgdGhlIHBhcmVudCBhcyByZXF1aXJlZCBfZm9yIGFsbCBjaGlsZHJlbl9cbiAgLy8gZmlyc3QsIHdlIGF2b2lkIHRoaXMgaXNzdWVcbiAgcmVzdWx0LnB1c2goXG4gICAgLi4ucmVzdEV4cGxvZGVkLm1hcCgoc3VicGF0aCkgPT5cbiAgICAgIHN1YnBhdGggPT09IFwiXCIgPyByZXF1aXJlZCA6IFtyZXF1aXJlZCwgc3VicGF0aF0uam9pbihcIi9cIilcbiAgICApXG4gICk7XG5cbiAgLy8gVGhlbiBpZiB0aGlzIGlzIGFuIG9wdGlvbmFsIHZhbHVlLCBhZGQgYWxsIGNoaWxkIHZlcnNpb25zIHdpdGhvdXRcbiAgaWYgKGlzT3B0aW9uYWwpIHtcbiAgICByZXN1bHQucHVzaCguLi5yZXN0RXhwbG9kZWQpO1xuICB9XG5cbiAgLy8gZm9yIGFic29sdXRlIHBhdGhzLCBlbnN1cmUgYC9gIGluc3RlYWQgb2YgZW1wdHkgc2VnbWVudFxuICByZXR1cm4gcmVzdWx0Lm1hcCgoZXhwbG9kZWQpID0+XG4gICAgcGF0aC5zdGFydHNXaXRoKFwiL1wiKSAmJiBleHBsb2RlZCA9PT0gXCJcIiA/IFwiL1wiIDogZXhwbG9kZWRcbiAgKTtcbn1cblxuZnVuY3Rpb24gcmFua1JvdXRlQnJhbmNoZXMoYnJhbmNoZXM6IFJvdXRlQnJhbmNoW10pOiB2b2lkIHtcbiAgYnJhbmNoZXMuc29ydCgoYSwgYikgPT5cbiAgICBhLnNjb3JlICE9PSBiLnNjb3JlXG4gICAgICA/IGIuc2NvcmUgLSBhLnNjb3JlIC8vIEhpZ2hlciBzY29yZSBmaXJzdFxuICAgICAgOiBjb21wYXJlSW5kZXhlcyhcbiAgICAgICAgICBhLnJvdXRlc01ldGEubWFwKChtZXRhKSA9PiBtZXRhLmNoaWxkcmVuSW5kZXgpLFxuICAgICAgICAgIGIucm91dGVzTWV0YS5tYXAoKG1ldGEpID0+IG1ldGEuY2hpbGRyZW5JbmRleClcbiAgICAgICAgKVxuICApO1xufVxuXG5jb25zdCBwYXJhbVJlID0gL146XFx3KyQvO1xuY29uc3QgZHluYW1pY1NlZ21lbnRWYWx1ZSA9IDM7XG5jb25zdCBpbmRleFJvdXRlVmFsdWUgPSAyO1xuY29uc3QgZW1wdHlTZWdtZW50VmFsdWUgPSAxO1xuY29uc3Qgc3RhdGljU2VnbWVudFZhbHVlID0gMTA7XG5jb25zdCBzcGxhdFBlbmFsdHkgPSAtMjtcbmNvbnN0IGlzU3BsYXQgPSAoczogc3RyaW5nKSA9PiBzID09PSBcIipcIjtcblxuZnVuY3Rpb24gY29tcHV0ZVNjb3JlKHBhdGg6IHN0cmluZywgaW5kZXg6IGJvb2xlYW4gfCB1bmRlZmluZWQpOiBudW1iZXIge1xuICBsZXQgc2VnbWVudHMgPSBwYXRoLnNwbGl0KFwiL1wiKTtcbiAgbGV0IGluaXRpYWxTY29yZSA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgaWYgKHNlZ21lbnRzLnNvbWUoaXNTcGxhdCkpIHtcbiAgICBpbml0aWFsU2NvcmUgKz0gc3BsYXRQZW5hbHR5O1xuICB9XG5cbiAgaWYgKGluZGV4KSB7XG4gICAgaW5pdGlhbFNjb3JlICs9IGluZGV4Um91dGVWYWx1ZTtcbiAgfVxuXG4gIHJldHVybiBzZWdtZW50c1xuICAgIC5maWx0ZXIoKHMpID0+ICFpc1NwbGF0KHMpKVxuICAgIC5yZWR1Y2UoXG4gICAgICAoc2NvcmUsIHNlZ21lbnQpID0+XG4gICAgICAgIHNjb3JlICtcbiAgICAgICAgKHBhcmFtUmUudGVzdChzZWdtZW50KVxuICAgICAgICAgID8gZHluYW1pY1NlZ21lbnRWYWx1ZVxuICAgICAgICAgIDogc2VnbWVudCA9PT0gXCJcIlxuICAgICAgICAgID8gZW1wdHlTZWdtZW50VmFsdWVcbiAgICAgICAgICA6IHN0YXRpY1NlZ21lbnRWYWx1ZSksXG4gICAgICBpbml0aWFsU2NvcmVcbiAgICApO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlSW5kZXhlcyhhOiBudW1iZXJbXSwgYjogbnVtYmVyW10pOiBudW1iZXIge1xuICBsZXQgc2libGluZ3MgPVxuICAgIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLnNsaWNlKDAsIC0xKS5ldmVyeSgobiwgaSkgPT4gbiA9PT0gYltpXSk7XG5cbiAgcmV0dXJuIHNpYmxpbmdzXG4gICAgPyAvLyBJZiB0d28gcm91dGVzIGFyZSBzaWJsaW5ncywgd2Ugc2hvdWxkIHRyeSB0byBtYXRjaCB0aGUgZWFybGllciBzaWJsaW5nXG4gICAgICAvLyBmaXJzdC4gVGhpcyBhbGxvd3MgcGVvcGxlIHRvIGhhdmUgZmluZS1ncmFpbmVkIGNvbnRyb2wgb3ZlciB0aGUgbWF0Y2hpbmdcbiAgICAgIC8vIGJlaGF2aW9yIGJ5IHNpbXBseSBwdXR0aW5nIHJvdXRlcyB3aXRoIGlkZW50aWNhbCBwYXRocyBpbiB0aGUgb3JkZXIgdGhleVxuICAgICAgLy8gd2FudCB0aGVtIHRyaWVkLlxuICAgICAgYVthLmxlbmd0aCAtIDFdIC0gYltiLmxlbmd0aCAtIDFdXG4gICAgOiAvLyBPdGhlcndpc2UsIGl0IGRvZXNuJ3QgcmVhbGx5IG1ha2Ugc2Vuc2UgdG8gcmFuayBub24tc2libGluZ3MgYnkgaW5kZXgsXG4gICAgICAvLyBzbyB0aGV5IHNvcnQgZXF1YWxseS5cbiAgICAgIDA7XG59XG5cbmZ1bmN0aW9uIG1hdGNoUm91dGVCcmFuY2g8XG4gIFBhcmFtS2V5IGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nLFxuICBSb3V0ZU9iamVjdFR5cGUgZXh0ZW5kcyBBZ25vc3RpY1JvdXRlT2JqZWN0ID0gQWdub3N0aWNSb3V0ZU9iamVjdFxuPihcbiAgYnJhbmNoOiBSb3V0ZUJyYW5jaDxSb3V0ZU9iamVjdFR5cGU+LFxuICBwYXRobmFtZTogc3RyaW5nXG4pOiBBZ25vc3RpY1JvdXRlTWF0Y2g8UGFyYW1LZXksIFJvdXRlT2JqZWN0VHlwZT5bXSB8IG51bGwge1xuICBsZXQgeyByb3V0ZXNNZXRhIH0gPSBicmFuY2g7XG5cbiAgbGV0IG1hdGNoZWRQYXJhbXMgPSB7fTtcbiAgbGV0IG1hdGNoZWRQYXRobmFtZSA9IFwiL1wiO1xuICBsZXQgbWF0Y2hlczogQWdub3N0aWNSb3V0ZU1hdGNoPFBhcmFtS2V5LCBSb3V0ZU9iamVjdFR5cGU+W10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3V0ZXNNZXRhLmxlbmd0aDsgKytpKSB7XG4gICAgbGV0IG1ldGEgPSByb3V0ZXNNZXRhW2ldO1xuICAgIGxldCBlbmQgPSBpID09PSByb3V0ZXNNZXRhLmxlbmd0aCAtIDE7XG4gICAgbGV0IHJlbWFpbmluZ1BhdGhuYW1lID1cbiAgICAgIG1hdGNoZWRQYXRobmFtZSA9PT0gXCIvXCJcbiAgICAgICAgPyBwYXRobmFtZVxuICAgICAgICA6IHBhdGhuYW1lLnNsaWNlKG1hdGNoZWRQYXRobmFtZS5sZW5ndGgpIHx8IFwiL1wiO1xuICAgIGxldCBtYXRjaCA9IG1hdGNoUGF0aChcbiAgICAgIHsgcGF0aDogbWV0YS5yZWxhdGl2ZVBhdGgsIGNhc2VTZW5zaXRpdmU6IG1ldGEuY2FzZVNlbnNpdGl2ZSwgZW5kIH0sXG4gICAgICByZW1haW5pbmdQYXRobmFtZVxuICAgICk7XG5cbiAgICBpZiAoIW1hdGNoKSByZXR1cm4gbnVsbDtcblxuICAgIE9iamVjdC5hc3NpZ24obWF0Y2hlZFBhcmFtcywgbWF0Y2gucGFyYW1zKTtcblxuICAgIGxldCByb3V0ZSA9IG1ldGEucm91dGU7XG5cbiAgICBtYXRjaGVzLnB1c2goe1xuICAgICAgLy8gVE9ETzogQ2FuIHRoaXMgYXMgYmUgYXZvaWRlZD9cbiAgICAgIHBhcmFtczogbWF0Y2hlZFBhcmFtcyBhcyBQYXJhbXM8UGFyYW1LZXk+LFxuICAgICAgcGF0aG5hbWU6IGpvaW5QYXRocyhbbWF0Y2hlZFBhdGhuYW1lLCBtYXRjaC5wYXRobmFtZV0pLFxuICAgICAgcGF0aG5hbWVCYXNlOiBub3JtYWxpemVQYXRobmFtZShcbiAgICAgICAgam9pblBhdGhzKFttYXRjaGVkUGF0aG5hbWUsIG1hdGNoLnBhdGhuYW1lQmFzZV0pXG4gICAgICApLFxuICAgICAgcm91dGUsXG4gICAgfSk7XG5cbiAgICBpZiAobWF0Y2gucGF0aG5hbWVCYXNlICE9PSBcIi9cIikge1xuICAgICAgbWF0Y2hlZFBhdGhuYW1lID0gam9pblBhdGhzKFttYXRjaGVkUGF0aG5hbWUsIG1hdGNoLnBhdGhuYW1lQmFzZV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXRjaGVzO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBwYXRoIHdpdGggcGFyYW1zIGludGVycG9sYXRlZC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3V0aWxzL2dlbmVyYXRlLXBhdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUGF0aDxQYXRoIGV4dGVuZHMgc3RyaW5nPihcbiAgb3JpZ2luYWxQYXRoOiBQYXRoLFxuICBwYXJhbXM6IHtcbiAgICBba2V5IGluIFBhdGhQYXJhbTxQYXRoPl06IHN0cmluZyB8IG51bGw7XG4gIH0gPSB7fSBhcyBhbnlcbik6IHN0cmluZyB7XG4gIGxldCBwYXRoOiBzdHJpbmcgPSBvcmlnaW5hbFBhdGg7XG4gIGlmIChwYXRoLmVuZHNXaXRoKFwiKlwiKSAmJiBwYXRoICE9PSBcIipcIiAmJiAhcGF0aC5lbmRzV2l0aChcIi8qXCIpKSB7XG4gICAgd2FybmluZyhcbiAgICAgIGZhbHNlLFxuICAgICAgYFJvdXRlIHBhdGggXCIke3BhdGh9XCIgd2lsbCBiZSB0cmVhdGVkIGFzIGlmIGl0IHdlcmUgYCArXG4gICAgICAgIGBcIiR7cGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKX1cIiBiZWNhdXNlIHRoZSBcXGAqXFxgIGNoYXJhY3RlciBtdXN0IGAgK1xuICAgICAgICBgYWx3YXlzIGZvbGxvdyBhIFxcYC9cXGAgaW4gdGhlIHBhdHRlcm4uIFRvIGdldCByaWQgb2YgdGhpcyB3YXJuaW5nLCBgICtcbiAgICAgICAgYHBsZWFzZSBjaGFuZ2UgdGhlIHJvdXRlIHBhdGggdG8gXCIke3BhdGgucmVwbGFjZSgvXFwqJC8sIFwiLypcIil9XCIuYFxuICAgICk7XG4gICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFwqJC8sIFwiLypcIikgYXMgUGF0aDtcbiAgfVxuXG4gIC8vIGVuc3VyZSBgL2AgaXMgYWRkZWQgYXQgdGhlIGJlZ2lubmluZyBpZiB0aGUgcGF0aCBpcyBhYnNvbHV0ZVxuICBjb25zdCBwcmVmaXggPSBwYXRoLnN0YXJ0c1dpdGgoXCIvXCIpID8gXCIvXCIgOiBcIlwiO1xuXG4gIGNvbnN0IHNlZ21lbnRzID0gcGF0aFxuICAgIC5zcGxpdCgvXFwvKy8pXG4gICAgLm1hcCgoc2VnbWVudCwgaW5kZXgsIGFycmF5KSA9PiB7XG4gICAgICBjb25zdCBpc0xhc3RTZWdtZW50ID0gaW5kZXggPT09IGFycmF5Lmxlbmd0aCAtIDE7XG5cbiAgICAgIC8vIG9ubHkgYXBwbHkgdGhlIHNwbGF0IGlmIGl0J3MgdGhlIGxhc3Qgc2VnbWVudFxuICAgICAgaWYgKGlzTGFzdFNlZ21lbnQgJiYgc2VnbWVudCA9PT0gXCIqXCIpIHtcbiAgICAgICAgY29uc3Qgc3RhciA9IFwiKlwiIGFzIFBhdGhQYXJhbTxQYXRoPjtcbiAgICAgICAgY29uc3Qgc3RhclBhcmFtID0gcGFyYW1zW3N0YXJdO1xuXG4gICAgICAgIC8vIEFwcGx5IHRoZSBzcGxhdFxuICAgICAgICByZXR1cm4gc3RhclBhcmFtO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBrZXlNYXRjaCA9IHNlZ21lbnQubWF0Y2goL146KFxcdyspKFxcPz8pJC8pO1xuICAgICAgaWYgKGtleU1hdGNoKSB7XG4gICAgICAgIGNvbnN0IFssIGtleSwgb3B0aW9uYWxdID0ga2V5TWF0Y2g7XG4gICAgICAgIGxldCBwYXJhbSA9IHBhcmFtc1trZXkgYXMgUGF0aFBhcmFtPFBhdGg+XTtcblxuICAgICAgICBpZiAob3B0aW9uYWwgPT09IFwiP1wiKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcmFtID09IG51bGwgPyBcIlwiIDogcGFyYW07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyYW0gPT0gbnVsbCkge1xuICAgICAgICAgIGludmFyaWFudChmYWxzZSwgYE1pc3NpbmcgXCI6JHtrZXl9XCIgcGFyYW1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJhbTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIGFueSBvcHRpb25hbCBtYXJrZXJzIGZyb20gb3B0aW9uYWwgc3RhdGljIHNlZ21lbnRzXG4gICAgICByZXR1cm4gc2VnbWVudC5yZXBsYWNlKC9cXD8kL2csIFwiXCIpO1xuICAgIH0pXG4gICAgLy8gUmVtb3ZlIGVtcHR5IHNlZ21lbnRzXG4gICAgLmZpbHRlcigoc2VnbWVudCkgPT4gISFzZWdtZW50KTtcblxuICByZXR1cm4gcHJlZml4ICsgc2VnbWVudHMuam9pbihcIi9cIik7XG59XG5cbi8qKlxuICogQSBQYXRoUGF0dGVybiBpcyB1c2VkIHRvIG1hdGNoIG9uIHNvbWUgcG9ydGlvbiBvZiBhIFVSTCBwYXRobmFtZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQYXRoUGF0dGVybjxQYXRoIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiB7XG4gIC8qKlxuICAgKiBBIHN0cmluZyB0byBtYXRjaCBhZ2FpbnN0IGEgVVJMIHBhdGhuYW1lLiBNYXkgY29udGFpbiBgOmlkYC1zdHlsZSBzZWdtZW50c1xuICAgKiB0byBpbmRpY2F0ZSBwbGFjZWhvbGRlcnMgZm9yIGR5bmFtaWMgcGFyYW1ldGVycy4gTWF5IGFsc28gZW5kIHdpdGggYC8qYCB0b1xuICAgKiBpbmRpY2F0ZSBtYXRjaGluZyB0aGUgcmVzdCBvZiB0aGUgVVJMIHBhdGhuYW1lLlxuICAgKi9cbiAgcGF0aDogUGF0aDtcbiAgLyoqXG4gICAqIFNob3VsZCBiZSBgdHJ1ZWAgaWYgdGhlIHN0YXRpYyBwb3J0aW9ucyBvZiB0aGUgYHBhdGhgIHNob3VsZCBiZSBtYXRjaGVkIGluXG4gICAqIHRoZSBzYW1lIGNhc2UuXG4gICAqL1xuICBjYXNlU2Vuc2l0aXZlPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIFNob3VsZCBiZSBgdHJ1ZWAgaWYgdGhpcyBwYXR0ZXJuIHNob3VsZCBtYXRjaCB0aGUgZW50aXJlIFVSTCBwYXRobmFtZS5cbiAgICovXG4gIGVuZD86IGJvb2xlYW47XG59XG5cbi8qKlxuICogQSBQYXRoTWF0Y2ggY29udGFpbnMgaW5mbyBhYm91dCBob3cgYSBQYXRoUGF0dGVybiBtYXRjaGVkIG9uIGEgVVJMIHBhdGhuYW1lLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBhdGhNYXRjaDxQYXJhbUtleSBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4ge1xuICAvKipcbiAgICogVGhlIG5hbWVzIGFuZCB2YWx1ZXMgb2YgZHluYW1pYyBwYXJhbWV0ZXJzIGluIHRoZSBVUkwuXG4gICAqL1xuICBwYXJhbXM6IFBhcmFtczxQYXJhbUtleT47XG4gIC8qKlxuICAgKiBUaGUgcG9ydGlvbiBvZiB0aGUgVVJMIHBhdGhuYW1lIHRoYXQgd2FzIG1hdGNoZWQuXG4gICAqL1xuICBwYXRobmFtZTogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHBvcnRpb24gb2YgdGhlIFVSTCBwYXRobmFtZSB0aGF0IHdhcyBtYXRjaGVkIGJlZm9yZSBjaGlsZCByb3V0ZXMuXG4gICAqL1xuICBwYXRobmFtZUJhc2U6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBwYXR0ZXJuIHRoYXQgd2FzIHVzZWQgdG8gbWF0Y2guXG4gICAqL1xuICBwYXR0ZXJuOiBQYXRoUGF0dGVybjtcbn1cblxudHlwZSBNdXRhYmxlPFQ+ID0ge1xuICAtcmVhZG9ubHkgW1AgaW4ga2V5b2YgVF06IFRbUF07XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIHBhdHRlcm4gbWF0Y2hpbmcgb24gYSBVUkwgcGF0aG5hbWUgYW5kIHJldHVybnMgaW5mb3JtYXRpb24gYWJvdXRcbiAqIHRoZSBtYXRjaC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3V0aWxzL21hdGNoLXBhdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoUGF0aDxcbiAgUGFyYW1LZXkgZXh0ZW5kcyBQYXJhbVBhcnNlS2V5PFBhdGg+LFxuICBQYXRoIGV4dGVuZHMgc3RyaW5nXG4+KFxuICBwYXR0ZXJuOiBQYXRoUGF0dGVybjxQYXRoPiB8IFBhdGgsXG4gIHBhdGhuYW1lOiBzdHJpbmdcbik6IFBhdGhNYXRjaDxQYXJhbUtleT4gfCBudWxsIHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSBcInN0cmluZ1wiKSB7XG4gICAgcGF0dGVybiA9IHsgcGF0aDogcGF0dGVybiwgY2FzZVNlbnNpdGl2ZTogZmFsc2UsIGVuZDogdHJ1ZSB9O1xuICB9XG5cbiAgbGV0IFttYXRjaGVyLCBwYXJhbU5hbWVzXSA9IGNvbXBpbGVQYXRoKFxuICAgIHBhdHRlcm4ucGF0aCxcbiAgICBwYXR0ZXJuLmNhc2VTZW5zaXRpdmUsXG4gICAgcGF0dGVybi5lbmRcbiAgKTtcblxuICBsZXQgbWF0Y2ggPSBwYXRobmFtZS5tYXRjaChtYXRjaGVyKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG5cbiAgbGV0IG1hdGNoZWRQYXRobmFtZSA9IG1hdGNoWzBdO1xuICBsZXQgcGF0aG5hbWVCYXNlID0gbWF0Y2hlZFBhdGhuYW1lLnJlcGxhY2UoLyguKVxcLyskLywgXCIkMVwiKTtcbiAgbGV0IGNhcHR1cmVHcm91cHMgPSBtYXRjaC5zbGljZSgxKTtcbiAgbGV0IHBhcmFtczogUGFyYW1zID0gcGFyYW1OYW1lcy5yZWR1Y2U8TXV0YWJsZTxQYXJhbXM+PihcbiAgICAobWVtbywgcGFyYW1OYW1lLCBpbmRleCkgPT4ge1xuICAgICAgLy8gV2UgbmVlZCB0byBjb21wdXRlIHRoZSBwYXRobmFtZUJhc2UgaGVyZSB1c2luZyB0aGUgcmF3IHNwbGF0IHZhbHVlXG4gICAgICAvLyBpbnN0ZWFkIG9mIHVzaW5nIHBhcmFtc1tcIipcIl0gbGF0ZXIgYmVjYXVzZSBpdCB3aWxsIGJlIGRlY29kZWQgdGhlblxuICAgICAgaWYgKHBhcmFtTmFtZSA9PT0gXCIqXCIpIHtcbiAgICAgICAgbGV0IHNwbGF0VmFsdWUgPSBjYXB0dXJlR3JvdXBzW2luZGV4XSB8fCBcIlwiO1xuICAgICAgICBwYXRobmFtZUJhc2UgPSBtYXRjaGVkUGF0aG5hbWVcbiAgICAgICAgICAuc2xpY2UoMCwgbWF0Y2hlZFBhdGhuYW1lLmxlbmd0aCAtIHNwbGF0VmFsdWUubGVuZ3RoKVxuICAgICAgICAgIC5yZXBsYWNlKC8oLilcXC8rJC8sIFwiJDFcIik7XG4gICAgICB9XG5cbiAgICAgIG1lbW9bcGFyYW1OYW1lXSA9IHNhZmVseURlY29kZVVSSUNvbXBvbmVudChcbiAgICAgICAgY2FwdHVyZUdyb3Vwc1tpbmRleF0gfHwgXCJcIixcbiAgICAgICAgcGFyYW1OYW1lXG4gICAgICApO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfSxcbiAgICB7fVxuICApO1xuXG4gIHJldHVybiB7XG4gICAgcGFyYW1zLFxuICAgIHBhdGhuYW1lOiBtYXRjaGVkUGF0aG5hbWUsXG4gICAgcGF0aG5hbWVCYXNlLFxuICAgIHBhdHRlcm4sXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVQYXRoKFxuICBwYXRoOiBzdHJpbmcsXG4gIGNhc2VTZW5zaXRpdmUgPSBmYWxzZSxcbiAgZW5kID0gdHJ1ZVxuKTogW1JlZ0V4cCwgc3RyaW5nW11dIHtcbiAgd2FybmluZyhcbiAgICBwYXRoID09PSBcIipcIiB8fCAhcGF0aC5lbmRzV2l0aChcIipcIikgfHwgcGF0aC5lbmRzV2l0aChcIi8qXCIpLFxuICAgIGBSb3V0ZSBwYXRoIFwiJHtwYXRofVwiIHdpbGwgYmUgdHJlYXRlZCBhcyBpZiBpdCB3ZXJlIGAgK1xuICAgICAgYFwiJHtwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpfVwiIGJlY2F1c2UgdGhlIFxcYCpcXGAgY2hhcmFjdGVyIG11c3QgYCArXG4gICAgICBgYWx3YXlzIGZvbGxvdyBhIFxcYC9cXGAgaW4gdGhlIHBhdHRlcm4uIFRvIGdldCByaWQgb2YgdGhpcyB3YXJuaW5nLCBgICtcbiAgICAgIGBwbGVhc2UgY2hhbmdlIHRoZSByb3V0ZSBwYXRoIHRvIFwiJHtwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpfVwiLmBcbiAgKTtcblxuICBsZXQgcGFyYW1OYW1lczogc3RyaW5nW10gPSBbXTtcbiAgbGV0IHJlZ2V4cFNvdXJjZSA9XG4gICAgXCJeXCIgK1xuICAgIHBhdGhcbiAgICAgIC5yZXBsYWNlKC9cXC8qXFwqPyQvLCBcIlwiKSAvLyBJZ25vcmUgdHJhaWxpbmcgLyBhbmQgLyosIHdlJ2xsIGhhbmRsZSBpdCBiZWxvd1xuICAgICAgLnJlcGxhY2UoL15cXC8qLywgXCIvXCIpIC8vIE1ha2Ugc3VyZSBpdCBoYXMgYSBsZWFkaW5nIC9cbiAgICAgIC5yZXBsYWNlKC9bXFxcXC4qK14kP3t9fCgpW1xcXV0vZywgXCJcXFxcJCZcIikgLy8gRXNjYXBlIHNwZWNpYWwgcmVnZXggY2hhcnNcbiAgICAgIC5yZXBsYWNlKC9cXC86KFxcdyspL2csIChfOiBzdHJpbmcsIHBhcmFtTmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIHBhcmFtTmFtZXMucHVzaChwYXJhbU5hbWUpO1xuICAgICAgICByZXR1cm4gXCIvKFteXFxcXC9dKylcIjtcbiAgICAgIH0pO1xuXG4gIGlmIChwYXRoLmVuZHNXaXRoKFwiKlwiKSkge1xuICAgIHBhcmFtTmFtZXMucHVzaChcIipcIik7XG4gICAgcmVnZXhwU291cmNlICs9XG4gICAgICBwYXRoID09PSBcIipcIiB8fCBwYXRoID09PSBcIi8qXCJcbiAgICAgICAgPyBcIiguKikkXCIgLy8gQWxyZWFkeSBtYXRjaGVkIHRoZSBpbml0aWFsIC8sIGp1c3QgbWF0Y2ggdGhlIHJlc3RcbiAgICAgICAgOiBcIig/OlxcXFwvKC4rKXxcXFxcLyopJFwiOyAvLyBEb24ndCBpbmNsdWRlIHRoZSAvIGluIHBhcmFtc1tcIipcIl1cbiAgfSBlbHNlIGlmIChlbmQpIHtcbiAgICAvLyBXaGVuIG1hdGNoaW5nIHRvIHRoZSBlbmQsIGlnbm9yZSB0cmFpbGluZyBzbGFzaGVzXG4gICAgcmVnZXhwU291cmNlICs9IFwiXFxcXC8qJFwiO1xuICB9IGVsc2UgaWYgKHBhdGggIT09IFwiXCIgJiYgcGF0aCAhPT0gXCIvXCIpIHtcbiAgICAvLyBJZiBvdXIgcGF0aCBpcyBub24tZW1wdHkgYW5kIGNvbnRhaW5zIGFueXRoaW5nIGJleW9uZCBhbiBpbml0aWFsIHNsYXNoLFxuICAgIC8vIHRoZW4gd2UgaGF2ZSBfc29tZV8gZm9ybSBvZiBwYXRoIGluIG91ciByZWdleCBzbyB3ZSBzaG91bGQgZXhwZWN0IHRvXG4gICAgLy8gbWF0Y2ggb25seSBpZiB3ZSBmaW5kIHRoZSBlbmQgb2YgdGhpcyBwYXRoIHNlZ21lbnQuICBMb29rIGZvciBhbiBvcHRpb25hbFxuICAgIC8vIG5vbi1jYXB0dXJlZCB0cmFpbGluZyBzbGFzaCAodG8gbWF0Y2ggYSBwb3J0aW9uIG9mIHRoZSBVUkwpIG9yIHRoZSBlbmRcbiAgICAvLyBvZiB0aGUgcGF0aCAoaWYgd2UndmUgbWF0Y2hlZCB0byB0aGUgZW5kKS4gIFdlIHVzZWQgdG8gZG8gdGhpcyB3aXRoIGFcbiAgICAvLyB3b3JkIGJvdW5kYXJ5IGJ1dCB0aGF0IGdpdmVzIGZhbHNlIHBvc2l0aXZlcyBvbiByb3V0ZXMgbGlrZVxuICAgIC8vIC91c2VyLXByZWZlcmVuY2VzIHNpbmNlIGAtYCBjb3VudHMgYXMgYSB3b3JkIGJvdW5kYXJ5LlxuICAgIHJlZ2V4cFNvdXJjZSArPSBcIig/Oig/PVxcXFwvfCQpKVwiO1xuICB9IGVsc2Uge1xuICAgIC8vIE5vdGhpbmcgdG8gbWF0Y2ggZm9yIFwiXCIgb3IgXCIvXCJcbiAgfVxuXG4gIGxldCBtYXRjaGVyID0gbmV3IFJlZ0V4cChyZWdleHBTb3VyY2UsIGNhc2VTZW5zaXRpdmUgPyB1bmRlZmluZWQgOiBcImlcIik7XG5cbiAgcmV0dXJuIFttYXRjaGVyLCBwYXJhbU5hbWVzXTtcbn1cblxuZnVuY3Rpb24gc2FmZWx5RGVjb2RlVVJJKHZhbHVlOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJKHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB3YXJuaW5nKFxuICAgICAgZmFsc2UsXG4gICAgICBgVGhlIFVSTCBwYXRoIFwiJHt2YWx1ZX1cIiBjb3VsZCBub3QgYmUgZGVjb2RlZCBiZWNhdXNlIGl0IGlzIGlzIGEgYCArXG4gICAgICAgIGBtYWxmb3JtZWQgVVJMIHNlZ21lbnQuIFRoaXMgaXMgcHJvYmFibHkgZHVlIHRvIGEgYmFkIHBlcmNlbnQgYCArXG4gICAgICAgIGBlbmNvZGluZyAoJHtlcnJvcn0pLmBcbiAgICApO1xuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNhZmVseURlY29kZVVSSUNvbXBvbmVudCh2YWx1ZTogc3RyaW5nLCBwYXJhbU5hbWU6IHN0cmluZykge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHdhcm5pbmcoXG4gICAgICBmYWxzZSxcbiAgICAgIGBUaGUgdmFsdWUgZm9yIHRoZSBVUkwgcGFyYW0gXCIke3BhcmFtTmFtZX1cIiB3aWxsIG5vdCBiZSBkZWNvZGVkIGJlY2F1c2VgICtcbiAgICAgICAgYCB0aGUgc3RyaW5nIFwiJHt2YWx1ZX1cIiBpcyBhIG1hbGZvcm1lZCBVUkwgc2VnbWVudC4gVGhpcyBpcyBwcm9iYWJseWAgK1xuICAgICAgICBgIGR1ZSB0byBhIGJhZCBwZXJjZW50IGVuY29kaW5nICgke2Vycm9yfSkuYFxuICAgICk7XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaXBCYXNlbmFtZShcbiAgcGF0aG5hbWU6IHN0cmluZyxcbiAgYmFzZW5hbWU6IHN0cmluZ1xuKTogc3RyaW5nIHwgbnVsbCB7XG4gIGlmIChiYXNlbmFtZSA9PT0gXCIvXCIpIHJldHVybiBwYXRobmFtZTtcblxuICBpZiAoIXBhdGhuYW1lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChiYXNlbmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gV2Ugd2FudCB0byBsZWF2ZSB0cmFpbGluZyBzbGFzaCBiZWhhdmlvciBpbiB0aGUgdXNlcidzIGNvbnRyb2wsIHNvIGlmIHRoZXlcbiAgLy8gc3BlY2lmeSBhIGJhc2VuYW1lIHdpdGggYSB0cmFpbGluZyBzbGFzaCwgd2Ugc2hvdWxkIHN1cHBvcnQgaXRcbiAgbGV0IHN0YXJ0SW5kZXggPSBiYXNlbmFtZS5lbmRzV2l0aChcIi9cIilcbiAgICA/IGJhc2VuYW1lLmxlbmd0aCAtIDFcbiAgICA6IGJhc2VuYW1lLmxlbmd0aDtcbiAgbGV0IG5leHRDaGFyID0gcGF0aG5hbWUuY2hhckF0KHN0YXJ0SW5kZXgpO1xuICBpZiAobmV4dENoYXIgJiYgbmV4dENoYXIgIT09IFwiL1wiKSB7XG4gICAgLy8gcGF0aG5hbWUgZG9lcyBub3Qgc3RhcnQgd2l0aCBiYXNlbmFtZS9cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBwYXRobmFtZS5zbGljZShzdGFydEluZGV4KSB8fCBcIi9cIjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcmVzb2x2ZWQgcGF0aCBvYmplY3QgcmVsYXRpdmUgdG8gdGhlIGdpdmVuIHBhdGhuYW1lLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vdXRpbHMvcmVzb2x2ZS1wYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlUGF0aCh0bzogVG8sIGZyb21QYXRobmFtZSA9IFwiL1wiKTogUGF0aCB7XG4gIGxldCB7XG4gICAgcGF0aG5hbWU6IHRvUGF0aG5hbWUsXG4gICAgc2VhcmNoID0gXCJcIixcbiAgICBoYXNoID0gXCJcIixcbiAgfSA9IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aCh0bykgOiB0bztcblxuICBsZXQgcGF0aG5hbWUgPSB0b1BhdGhuYW1lXG4gICAgPyB0b1BhdGhuYW1lLnN0YXJ0c1dpdGgoXCIvXCIpXG4gICAgICA/IHRvUGF0aG5hbWVcbiAgICAgIDogcmVzb2x2ZVBhdGhuYW1lKHRvUGF0aG5hbWUsIGZyb21QYXRobmFtZSlcbiAgICA6IGZyb21QYXRobmFtZTtcblxuICByZXR1cm4ge1xuICAgIHBhdGhuYW1lLFxuICAgIHNlYXJjaDogbm9ybWFsaXplU2VhcmNoKHNlYXJjaCksXG4gICAgaGFzaDogbm9ybWFsaXplSGFzaChoYXNoKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVBhdGhuYW1lKHJlbGF0aXZlUGF0aDogc3RyaW5nLCBmcm9tUGF0aG5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIGxldCBzZWdtZW50cyA9IGZyb21QYXRobmFtZS5yZXBsYWNlKC9cXC8rJC8sIFwiXCIpLnNwbGl0KFwiL1wiKTtcbiAgbGV0IHJlbGF0aXZlU2VnbWVudHMgPSByZWxhdGl2ZVBhdGguc3BsaXQoXCIvXCIpO1xuXG4gIHJlbGF0aXZlU2VnbWVudHMuZm9yRWFjaCgoc2VnbWVudCkgPT4ge1xuICAgIGlmIChzZWdtZW50ID09PSBcIi4uXCIpIHtcbiAgICAgIC8vIEtlZXAgdGhlIHJvb3QgXCJcIiBzZWdtZW50IHNvIHRoZSBwYXRobmFtZSBzdGFydHMgYXQgL1xuICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA+IDEpIHNlZ21lbnRzLnBvcCgpO1xuICAgIH0gZWxzZSBpZiAoc2VnbWVudCAhPT0gXCIuXCIpIHtcbiAgICAgIHNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gc2VnbWVudHMubGVuZ3RoID4gMSA/IHNlZ21lbnRzLmpvaW4oXCIvXCIpIDogXCIvXCI7XG59XG5cbmZ1bmN0aW9uIGdldEludmFsaWRQYXRoRXJyb3IoXG4gIGNoYXI6IHN0cmluZyxcbiAgZmllbGQ6IHN0cmluZyxcbiAgZGVzdDogc3RyaW5nLFxuICBwYXRoOiBQYXJ0aWFsPFBhdGg+XG4pIHtcbiAgcmV0dXJuIChcbiAgICBgQ2Fubm90IGluY2x1ZGUgYSAnJHtjaGFyfScgY2hhcmFjdGVyIGluIGEgbWFudWFsbHkgc3BlY2lmaWVkIGAgK1xuICAgIGBcXGB0by4ke2ZpZWxkfVxcYCBmaWVsZCBbJHtKU09OLnN0cmluZ2lmeShcbiAgICAgIHBhdGhcbiAgICApfV0uICBQbGVhc2Ugc2VwYXJhdGUgaXQgb3V0IHRvIHRoZSBgICtcbiAgICBgXFxgdG8uJHtkZXN0fVxcYCBmaWVsZC4gQWx0ZXJuYXRpdmVseSB5b3UgbWF5IHByb3ZpZGUgdGhlIGZ1bGwgcGF0aCBhcyBgICtcbiAgICBgYSBzdHJpbmcgaW4gPExpbmsgdG89XCIuLi5cIj4gYW5kIHRoZSByb3V0ZXIgd2lsbCBwYXJzZSBpdCBmb3IgeW91LmBcbiAgKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIFdoZW4gcHJvY2Vzc2luZyByZWxhdGl2ZSBuYXZpZ2F0aW9uIHdlIHdhbnQgdG8gaWdub3JlIGFuY2VzdG9yIHJvdXRlcyB0aGF0XG4gKiBkbyBub3QgY29udHJpYnV0ZSB0byB0aGUgcGF0aCwgc3VjaCB0aGF0IGluZGV4L3BhdGhsZXNzIGxheW91dCByb3V0ZXMgZG9uJ3RcbiAqIGludGVyZmVyZS5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgd2hlbiBtb3ZpbmcgYSByb3V0ZSBlbGVtZW50IGludG8gYW4gaW5kZXggcm91dGUgYW5kL29yIGFcbiAqIHBhdGhsZXNzIGxheW91dCByb3V0ZSwgcmVsYXRpdmUgbGluayBiZWhhdmlvciBjb250YWluZWQgd2l0aGluIHNob3VsZCBzdGF5XG4gKiB0aGUgc2FtZS4gIEJvdGggb2YgdGhlIGZvbGxvd2luZyBleGFtcGxlcyBzaG91bGQgbGluayBiYWNrIHRvIHRoZSByb290OlxuICpcbiAqICAgPFJvdXRlIHBhdGg9XCIvXCI+XG4gKiAgICAgPFJvdXRlIHBhdGg9XCJhY2NvdW50c1wiIGVsZW1lbnQ9ezxMaW5rIHRvPVwiLi5cIn0+XG4gKiAgIDwvUm91dGU+XG4gKlxuICogICA8Um91dGUgcGF0aD1cIi9cIj5cbiAqICAgICA8Um91dGUgcGF0aD1cImFjY291bnRzXCI+XG4gKiAgICAgICA8Um91dGUgZWxlbWVudD17PEFjY291bnRzTGF5b3V0IC8+fT4gICAgICAgLy8gPC0tIERvZXMgbm90IGNvbnRyaWJ1dGVcbiAqICAgICAgICAgPFJvdXRlIGluZGV4IGVsZW1lbnQ9ezxMaW5rIHRvPVwiLi5cIn0gLz4gIC8vIDwtLSBEb2VzIG5vdCBjb250cmlidXRlXG4gKiAgICAgICA8L1JvdXRlXG4gKiAgICAgPC9Sb3V0ZT5cbiAqICAgPC9Sb3V0ZT5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBhdGhDb250cmlidXRpbmdNYXRjaGVzPFxuICBUIGV4dGVuZHMgQWdub3N0aWNSb3V0ZU1hdGNoID0gQWdub3N0aWNSb3V0ZU1hdGNoXG4+KG1hdGNoZXM6IFRbXSkge1xuICByZXR1cm4gbWF0Y2hlcy5maWx0ZXIoXG4gICAgKG1hdGNoLCBpbmRleCkgPT5cbiAgICAgIGluZGV4ID09PSAwIHx8IChtYXRjaC5yb3V0ZS5wYXRoICYmIG1hdGNoLnJvdXRlLnBhdGgubGVuZ3RoID4gMClcbiAgKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZVRvKFxuICB0b0FyZzogVG8sXG4gIHJvdXRlUGF0aG5hbWVzOiBzdHJpbmdbXSxcbiAgbG9jYXRpb25QYXRobmFtZTogc3RyaW5nLFxuICBpc1BhdGhSZWxhdGl2ZSA9IGZhbHNlXG4pOiBQYXRoIHtcbiAgbGV0IHRvOiBQYXJ0aWFsPFBhdGg+O1xuICBpZiAodHlwZW9mIHRvQXJnID09PSBcInN0cmluZ1wiKSB7XG4gICAgdG8gPSBwYXJzZVBhdGgodG9BcmcpO1xuICB9IGVsc2Uge1xuICAgIHRvID0geyAuLi50b0FyZyB9O1xuXG4gICAgaW52YXJpYW50KFxuICAgICAgIXRvLnBhdGhuYW1lIHx8ICF0by5wYXRobmFtZS5pbmNsdWRlcyhcIj9cIiksXG4gICAgICBnZXRJbnZhbGlkUGF0aEVycm9yKFwiP1wiLCBcInBhdGhuYW1lXCIsIFwic2VhcmNoXCIsIHRvKVxuICAgICk7XG4gICAgaW52YXJpYW50KFxuICAgICAgIXRvLnBhdGhuYW1lIHx8ICF0by5wYXRobmFtZS5pbmNsdWRlcyhcIiNcIiksXG4gICAgICBnZXRJbnZhbGlkUGF0aEVycm9yKFwiI1wiLCBcInBhdGhuYW1lXCIsIFwiaGFzaFwiLCB0bylcbiAgICApO1xuICAgIGludmFyaWFudChcbiAgICAgICF0by5zZWFyY2ggfHwgIXRvLnNlYXJjaC5pbmNsdWRlcyhcIiNcIiksXG4gICAgICBnZXRJbnZhbGlkUGF0aEVycm9yKFwiI1wiLCBcInNlYXJjaFwiLCBcImhhc2hcIiwgdG8pXG4gICAgKTtcbiAgfVxuXG4gIGxldCBpc0VtcHR5UGF0aCA9IHRvQXJnID09PSBcIlwiIHx8IHRvLnBhdGhuYW1lID09PSBcIlwiO1xuICBsZXQgdG9QYXRobmFtZSA9IGlzRW1wdHlQYXRoID8gXCIvXCIgOiB0by5wYXRobmFtZTtcblxuICBsZXQgZnJvbTogc3RyaW5nO1xuXG4gIC8vIFJvdXRpbmcgaXMgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcGF0aG5hbWUgaWYgZXhwbGljaXRseSByZXF1ZXN0ZWQuXG4gIC8vXG4gIC8vIElmIGEgcGF0aG5hbWUgaXMgZXhwbGljaXRseSBwcm92aWRlZCBpbiBgdG9gLCBpdCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlXG4gIC8vIHJvdXRlIGNvbnRleHQuIFRoaXMgaXMgZXhwbGFpbmVkIGluIGBOb3RlIG9uIGA8TGluayB0bz5gIHZhbHVlc2AgaW4gb3VyXG4gIC8vIG1pZ3JhdGlvbiBndWlkZSBmcm9tIHY1IGFzIGEgbWVhbnMgb2YgZGlzYW1iaWd1YXRpb24gYmV0d2VlbiBgdG9gIHZhbHVlc1xuICAvLyB0aGF0IGJlZ2luIHdpdGggYC9gIGFuZCB0aG9zZSB0aGF0IGRvIG5vdC4gSG93ZXZlciwgdGhpcyBpcyBwcm9ibGVtYXRpYyBmb3JcbiAgLy8gYHRvYCB2YWx1ZXMgdGhhdCBkbyBub3QgcHJvdmlkZSBhIHBhdGhuYW1lLiBgdG9gIGNhbiBzaW1wbHkgYmUgYSBzZWFyY2ggb3JcbiAgLy8gaGFzaCBzdHJpbmcsIGluIHdoaWNoIGNhc2Ugd2Ugc2hvdWxkIGFzc3VtZSB0aGF0IHRoZSBuYXZpZ2F0aW9uIGlzIHJlbGF0aXZlXG4gIC8vIHRvIHRoZSBjdXJyZW50IGxvY2F0aW9uJ3MgcGF0aG5hbWUgYW5kICpub3QqIHRoZSByb3V0ZSBwYXRobmFtZS5cbiAgaWYgKGlzUGF0aFJlbGF0aXZlIHx8IHRvUGF0aG5hbWUgPT0gbnVsbCkge1xuICAgIGZyb20gPSBsb2NhdGlvblBhdGhuYW1lO1xuICB9IGVsc2Uge1xuICAgIGxldCByb3V0ZVBhdGhuYW1lSW5kZXggPSByb3V0ZVBhdGhuYW1lcy5sZW5ndGggLSAxO1xuXG4gICAgaWYgKHRvUGF0aG5hbWUuc3RhcnRzV2l0aChcIi4uXCIpKSB7XG4gICAgICBsZXQgdG9TZWdtZW50cyA9IHRvUGF0aG5hbWUuc3BsaXQoXCIvXCIpO1xuXG4gICAgICAvLyBFYWNoIGxlYWRpbmcgLi4gc2VnbWVudCBtZWFucyBcImdvIHVwIG9uZSByb3V0ZVwiIGluc3RlYWQgb2YgXCJnbyB1cCBvbmVcbiAgICAgIC8vIFVSTCBzZWdtZW50XCIuICBUaGlzIGlzIGEga2V5IGRpZmZlcmVuY2UgZnJvbSBob3cgPGEgaHJlZj4gd29ya3MgYW5kIGFcbiAgICAgIC8vIG1ham9yIHJlYXNvbiB3ZSBjYWxsIHRoaXMgYSBcInRvXCIgdmFsdWUgaW5zdGVhZCBvZiBhIFwiaHJlZlwiLlxuICAgICAgd2hpbGUgKHRvU2VnbWVudHNbMF0gPT09IFwiLi5cIikge1xuICAgICAgICB0b1NlZ21lbnRzLnNoaWZ0KCk7XG4gICAgICAgIHJvdXRlUGF0aG5hbWVJbmRleCAtPSAxO1xuICAgICAgfVxuXG4gICAgICB0by5wYXRobmFtZSA9IHRvU2VnbWVudHMuam9pbihcIi9cIik7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgYXJlIG1vcmUgXCIuLlwiIHNlZ21lbnRzIHRoYW4gcGFyZW50IHJvdXRlcywgcmVzb2x2ZSByZWxhdGl2ZSB0b1xuICAgIC8vIHRoZSByb290IC8gVVJMLlxuICAgIGZyb20gPSByb3V0ZVBhdGhuYW1lSW5kZXggPj0gMCA/IHJvdXRlUGF0aG5hbWVzW3JvdXRlUGF0aG5hbWVJbmRleF0gOiBcIi9cIjtcbiAgfVxuXG4gIGxldCBwYXRoID0gcmVzb2x2ZVBhdGgodG8sIGZyb20pO1xuXG4gIC8vIEVuc3VyZSB0aGUgcGF0aG5hbWUgaGFzIGEgdHJhaWxpbmcgc2xhc2ggaWYgdGhlIG9yaWdpbmFsIFwidG9cIiBoYWQgb25lXG4gIGxldCBoYXNFeHBsaWNpdFRyYWlsaW5nU2xhc2ggPVxuICAgIHRvUGF0aG5hbWUgJiYgdG9QYXRobmFtZSAhPT0gXCIvXCIgJiYgdG9QYXRobmFtZS5lbmRzV2l0aChcIi9cIik7XG4gIC8vIE9yIGlmIHRoaXMgd2FzIGEgbGluayB0byB0aGUgY3VycmVudCBwYXRoIHdoaWNoIGhhcyBhIHRyYWlsaW5nIHNsYXNoXG4gIGxldCBoYXNDdXJyZW50VHJhaWxpbmdTbGFzaCA9XG4gICAgKGlzRW1wdHlQYXRoIHx8IHRvUGF0aG5hbWUgPT09IFwiLlwiKSAmJiBsb2NhdGlvblBhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKTtcbiAgaWYgKFxuICAgICFwYXRoLnBhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKSAmJlxuICAgIChoYXNFeHBsaWNpdFRyYWlsaW5nU2xhc2ggfHwgaGFzQ3VycmVudFRyYWlsaW5nU2xhc2gpXG4gICkge1xuICAgIHBhdGgucGF0aG5hbWUgKz0gXCIvXCI7XG4gIH1cblxuICByZXR1cm4gcGF0aDtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VG9QYXRobmFtZSh0bzogVG8pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAvLyBFbXB0eSBzdHJpbmdzIHNob3VsZCBiZSB0cmVhdGVkIHRoZSBzYW1lIGFzIC8gcGF0aHNcbiAgcmV0dXJuIHRvID09PSBcIlwiIHx8ICh0byBhcyBQYXRoKS5wYXRobmFtZSA9PT0gXCJcIlxuICAgID8gXCIvXCJcbiAgICA6IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIlxuICAgID8gcGFyc2VQYXRoKHRvKS5wYXRobmFtZVxuICAgIDogdG8ucGF0aG5hbWU7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IGpvaW5QYXRocyA9IChwYXRoczogc3RyaW5nW10pOiBzdHJpbmcgPT5cbiAgcGF0aHMuam9pbihcIi9cIikucmVwbGFjZSgvXFwvXFwvKy9nLCBcIi9cIik7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZVBhdGhuYW1lID0gKHBhdGhuYW1lOiBzdHJpbmcpOiBzdHJpbmcgPT5cbiAgcGF0aG5hbWUucmVwbGFjZSgvXFwvKyQvLCBcIlwiKS5yZXBsYWNlKC9eXFwvKi8sIFwiL1wiKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3Qgbm9ybWFsaXplU2VhcmNoID0gKHNlYXJjaDogc3RyaW5nKTogc3RyaW5nID0+XG4gICFzZWFyY2ggfHwgc2VhcmNoID09PSBcIj9cIlxuICAgID8gXCJcIlxuICAgIDogc2VhcmNoLnN0YXJ0c1dpdGgoXCI/XCIpXG4gICAgPyBzZWFyY2hcbiAgICA6IFwiP1wiICsgc2VhcmNoO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBub3JtYWxpemVIYXNoID0gKGhhc2g6IHN0cmluZyk6IHN0cmluZyA9PlxuICAhaGFzaCB8fCBoYXNoID09PSBcIiNcIiA/IFwiXCIgOiBoYXNoLnN0YXJ0c1dpdGgoXCIjXCIpID8gaGFzaCA6IFwiI1wiICsgaGFzaDtcblxuZXhwb3J0IHR5cGUgSnNvbkZ1bmN0aW9uID0gPERhdGE+KFxuICBkYXRhOiBEYXRhLFxuICBpbml0PzogbnVtYmVyIHwgUmVzcG9uc2VJbml0XG4pID0+IFJlc3BvbnNlO1xuXG4vKipcbiAqIFRoaXMgaXMgYSBzaG9ydGN1dCBmb3IgY3JlYXRpbmcgYGFwcGxpY2F0aW9uL2pzb25gIHJlc3BvbnNlcy4gQ29udmVydHMgYGRhdGFgXG4gKiB0byBKU09OIGFuZCBzZXRzIHRoZSBgQ29udGVudC1UeXBlYCBoZWFkZXIuXG4gKi9cbmV4cG9ydCBjb25zdCBqc29uOiBKc29uRnVuY3Rpb24gPSAoZGF0YSwgaW5pdCA9IHt9KSA9PiB7XG4gIGxldCByZXNwb25zZUluaXQgPSB0eXBlb2YgaW5pdCA9PT0gXCJudW1iZXJcIiA/IHsgc3RhdHVzOiBpbml0IH0gOiBpbml0O1xuXG4gIGxldCBoZWFkZXJzID0gbmV3IEhlYWRlcnMocmVzcG9uc2VJbml0LmhlYWRlcnMpO1xuICBpZiAoIWhlYWRlcnMuaGFzKFwiQ29udGVudC1UeXBlXCIpKSB7XG4gICAgaGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeShkYXRhKSwge1xuICAgIC4uLnJlc3BvbnNlSW5pdCxcbiAgICBoZWFkZXJzLFxuICB9KTtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhY2tlZFByb21pc2UgZXh0ZW5kcyBQcm9taXNlPGFueT4ge1xuICBfdHJhY2tlZD86IGJvb2xlYW47XG4gIF9kYXRhPzogYW55O1xuICBfZXJyb3I/OiBhbnk7XG59XG5cbmV4cG9ydCBjbGFzcyBBYm9ydGVkRGVmZXJyZWRFcnJvciBleHRlbmRzIEVycm9yIHt9XG5cbmV4cG9ydCBjbGFzcyBEZWZlcnJlZERhdGEge1xuICBwcml2YXRlIHBlbmRpbmdLZXlzU2V0OiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBwcml2YXRlIGNvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlcjtcbiAgcHJpdmF0ZSBhYm9ydFByb21pc2U6IFByb21pc2U8dm9pZD47XG4gIHByaXZhdGUgdW5saXN0ZW5BYm9ydFNpZ25hbDogKCkgPT4gdm9pZDtcbiAgcHJpdmF0ZSBzdWJzY3JpYmVyczogU2V0PChhYm9ydGVkOiBib29sZWFuLCBzZXR0bGVkS2V5Pzogc3RyaW5nKSA9PiB2b2lkPiA9XG4gICAgbmV3IFNldCgpO1xuICBkYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgaW5pdD86IFJlc3BvbnNlSW5pdDtcbiAgZGVmZXJyZWRLZXlzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LCByZXNwb25zZUluaXQ/OiBSZXNwb25zZUluaXQpIHtcbiAgICBpbnZhcmlhbnQoXG4gICAgICBkYXRhICYmIHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KGRhdGEpLFxuICAgICAgXCJkZWZlcigpIG9ubHkgYWNjZXB0cyBwbGFpbiBvYmplY3RzXCJcbiAgICApO1xuXG4gICAgLy8gU2V0IHVwIGFuIEFib3J0Q29udHJvbGxlciArIFByb21pc2Ugd2UgY2FuIHJhY2UgYWdhaW5zdCB0byBleGl0IGVhcmx5XG4gICAgLy8gY2FuY2VsbGF0aW9uXG4gICAgbGV0IHJlamVjdDogKGU6IEFib3J0ZWREZWZlcnJlZEVycm9yKSA9PiB2b2lkO1xuICAgIHRoaXMuYWJvcnRQcm9taXNlID0gbmV3IFByb21pc2UoKF8sIHIpID0+IChyZWplY3QgPSByKSk7XG4gICAgdGhpcy5jb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGxldCBvbkFib3J0ID0gKCkgPT5cbiAgICAgIHJlamVjdChuZXcgQWJvcnRlZERlZmVycmVkRXJyb3IoXCJEZWZlcnJlZCBkYXRhIGFib3J0ZWRcIikpO1xuICAgIHRoaXMudW5saXN0ZW5BYm9ydFNpZ25hbCA9ICgpID0+XG4gICAgICB0aGlzLmNvbnRyb2xsZXIuc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcbiAgICB0aGlzLmNvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcblxuICAgIHRoaXMuZGF0YSA9IE9iamVjdC5lbnRyaWVzKGRhdGEpLnJlZHVjZShcbiAgICAgIChhY2MsIFtrZXksIHZhbHVlXSkgPT5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihhY2MsIHtcbiAgICAgICAgICBba2V5XTogdGhpcy50cmFja1Byb21pc2Uoa2V5LCB2YWx1ZSksXG4gICAgICAgIH0pLFxuICAgICAge31cbiAgICApO1xuXG4gICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgLy8gQWxsIGluY29taW5nIHZhbHVlcyB3ZXJlIHJlc29sdmVkXG4gICAgICB0aGlzLnVubGlzdGVuQWJvcnRTaWduYWwoKTtcbiAgICB9XG5cbiAgICB0aGlzLmluaXQgPSByZXNwb25zZUluaXQ7XG4gIH1cblxuICBwcml2YXRlIHRyYWNrUHJvbWlzZShcbiAgICBrZXk6IHN0cmluZyxcbiAgICB2YWx1ZTogUHJvbWlzZTx1bmtub3duPiB8IHVua25vd25cbiAgKTogVHJhY2tlZFByb21pc2UgfCB1bmtub3duIHtcbiAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgdGhpcy5kZWZlcnJlZEtleXMucHVzaChrZXkpO1xuICAgIHRoaXMucGVuZGluZ0tleXNTZXQuYWRkKGtleSk7XG5cbiAgICAvLyBXZSBzdG9yZSBhIGxpdHRsZSB3cmFwcGVyIHByb21pc2UgdGhhdCB3aWxsIGJlIGV4dGVuZGVkIHdpdGhcbiAgICAvLyBfZGF0YS9fZXJyb3IgcHJvcHMgdXBvbiByZXNvbHZlL3JlamVjdFxuICAgIGxldCBwcm9taXNlOiBUcmFja2VkUHJvbWlzZSA9IFByb21pc2UucmFjZShbdmFsdWUsIHRoaXMuYWJvcnRQcm9taXNlXSkudGhlbihcbiAgICAgIChkYXRhKSA9PiB0aGlzLm9uU2V0dGxlKHByb21pc2UsIGtleSwgbnVsbCwgZGF0YSBhcyB1bmtub3duKSxcbiAgICAgIChlcnJvcikgPT4gdGhpcy5vblNldHRsZShwcm9taXNlLCBrZXksIGVycm9yIGFzIHVua25vd24pXG4gICAgKTtcblxuICAgIC8vIFJlZ2lzdGVyIHJlamVjdGlvbiBsaXN0ZW5lcnMgdG8gYXZvaWQgdW5jYXVnaHQgcHJvbWlzZSByZWplY3Rpb25zIG9uXG4gICAgLy8gZXJyb3JzIG9yIGFib3J0ZWQgZGVmZXJyZWQgdmFsdWVzXG4gICAgcHJvbWlzZS5jYXRjaCgoKSA9PiB7fSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfdHJhY2tlZFwiLCB7IGdldDogKCkgPT4gdHJ1ZSB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIHByaXZhdGUgb25TZXR0bGUoXG4gICAgcHJvbWlzZTogVHJhY2tlZFByb21pc2UsXG4gICAga2V5OiBzdHJpbmcsXG4gICAgZXJyb3I6IHVua25vd24sXG4gICAgZGF0YT86IHVua25vd25cbiAgKTogdW5rbm93biB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5jb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkICYmXG4gICAgICBlcnJvciBpbnN0YW5jZW9mIEFib3J0ZWREZWZlcnJlZEVycm9yXG4gICAgKSB7XG4gICAgICB0aGlzLnVubGlzdGVuQWJvcnRTaWduYWwoKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl9lcnJvclwiLCB7IGdldDogKCkgPT4gZXJyb3IgfSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cblxuICAgIHRoaXMucGVuZGluZ0tleXNTZXQuZGVsZXRlKGtleSk7XG5cbiAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAvLyBOb3RoaW5nIGxlZnQgdG8gYWJvcnQhXG4gICAgICB0aGlzLnVubGlzdGVuQWJvcnRTaWduYWwoKTtcbiAgICB9XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl9lcnJvclwiLCB7IGdldDogKCkgPT4gZXJyb3IgfSk7XG4gICAgICB0aGlzLmVtaXQoZmFsc2UsIGtleSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl9kYXRhXCIsIHsgZ2V0OiAoKSA9PiBkYXRhIH0pO1xuICAgIHRoaXMuZW1pdChmYWxzZSwga2V5KTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHByaXZhdGUgZW1pdChhYm9ydGVkOiBib29sZWFuLCBzZXR0bGVkS2V5Pzogc3RyaW5nKSB7XG4gICAgdGhpcy5zdWJzY3JpYmVycy5mb3JFYWNoKChzdWJzY3JpYmVyKSA9PiBzdWJzY3JpYmVyKGFib3J0ZWQsIHNldHRsZWRLZXkpKTtcbiAgfVxuXG4gIHN1YnNjcmliZShmbjogKGFib3J0ZWQ6IGJvb2xlYW4sIHNldHRsZWRLZXk/OiBzdHJpbmcpID0+IHZvaWQpIHtcbiAgICB0aGlzLnN1YnNjcmliZXJzLmFkZChmbik7XG4gICAgcmV0dXJuICgpID0+IHRoaXMuc3Vic2NyaWJlcnMuZGVsZXRlKGZuKTtcbiAgfVxuXG4gIGNhbmNlbCgpIHtcbiAgICB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICB0aGlzLnBlbmRpbmdLZXlzU2V0LmZvckVhY2goKHYsIGspID0+IHRoaXMucGVuZGluZ0tleXNTZXQuZGVsZXRlKGspKTtcbiAgICB0aGlzLmVtaXQodHJ1ZSk7XG4gIH1cblxuICBhc3luYyByZXNvbHZlRGF0YShzaWduYWw6IEFib3J0U2lnbmFsKSB7XG4gICAgbGV0IGFib3J0ZWQgPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMuZG9uZSkge1xuICAgICAgbGV0IG9uQWJvcnQgPSAoKSA9PiB0aGlzLmNhbmNlbCgpO1xuICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcbiAgICAgIGFib3J0ZWQgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICB0aGlzLnN1YnNjcmliZSgoYWJvcnRlZCkgPT4ge1xuICAgICAgICAgIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25BYm9ydCk7XG4gICAgICAgICAgaWYgKGFib3J0ZWQgfHwgdGhpcy5kb25lKSB7XG4gICAgICAgICAgICByZXNvbHZlKGFib3J0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFib3J0ZWQ7XG4gIH1cblxuICBnZXQgZG9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wZW5kaW5nS2V5c1NldC5zaXplID09PSAwO1xuICB9XG5cbiAgZ2V0IHVud3JhcHBlZERhdGEoKSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgdGhpcy5kYXRhICE9PSBudWxsICYmIHRoaXMuZG9uZSxcbiAgICAgIFwiQ2FuIG9ubHkgdW53cmFwIGRhdGEgb24gaW5pdGlhbGl6ZWQgYW5kIHNldHRsZWQgZGVmZXJyZWRzXCJcbiAgICApO1xuXG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHRoaXMuZGF0YSkucmVkdWNlKFxuICAgICAgKGFjYywgW2tleSwgdmFsdWVdKSA9PlxuICAgICAgICBPYmplY3QuYXNzaWduKGFjYywge1xuICAgICAgICAgIFtrZXldOiB1bndyYXBUcmFja2VkUHJvbWlzZSh2YWx1ZSksXG4gICAgICAgIH0pLFxuICAgICAge31cbiAgICApO1xuICB9XG5cbiAgZ2V0IHBlbmRpbmdLZXlzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMucGVuZGluZ0tleXNTZXQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVHJhY2tlZFByb21pc2UodmFsdWU6IGFueSk6IHZhbHVlIGlzIFRyYWNrZWRQcm9taXNlIHtcbiAgcmV0dXJuIChcbiAgICB2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UgJiYgKHZhbHVlIGFzIFRyYWNrZWRQcm9taXNlKS5fdHJhY2tlZCA9PT0gdHJ1ZVxuICApO1xufVxuXG5mdW5jdGlvbiB1bndyYXBUcmFja2VkUHJvbWlzZSh2YWx1ZTogYW55KSB7XG4gIGlmICghaXNUcmFja2VkUHJvbWlzZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAodmFsdWUuX2Vycm9yKSB7XG4gICAgdGhyb3cgdmFsdWUuX2Vycm9yO1xuICB9XG4gIHJldHVybiB2YWx1ZS5fZGF0YTtcbn1cblxuZXhwb3J0IHR5cGUgRGVmZXJGdW5jdGlvbiA9IChcbiAgZGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gIGluaXQ/OiBudW1iZXIgfCBSZXNwb25zZUluaXRcbikgPT4gRGVmZXJyZWREYXRhO1xuXG5leHBvcnQgY29uc3QgZGVmZXI6IERlZmVyRnVuY3Rpb24gPSAoZGF0YSwgaW5pdCA9IHt9KSA9PiB7XG4gIGxldCByZXNwb25zZUluaXQgPSB0eXBlb2YgaW5pdCA9PT0gXCJudW1iZXJcIiA/IHsgc3RhdHVzOiBpbml0IH0gOiBpbml0O1xuXG4gIHJldHVybiBuZXcgRGVmZXJyZWREYXRhKGRhdGEsIHJlc3BvbnNlSW5pdCk7XG59O1xuXG5leHBvcnQgdHlwZSBSZWRpcmVjdEZ1bmN0aW9uID0gKFxuICB1cmw6IHN0cmluZyxcbiAgaW5pdD86IG51bWJlciB8IFJlc3BvbnNlSW5pdFxuKSA9PiBSZXNwb25zZTtcblxuLyoqXG4gKiBBIHJlZGlyZWN0IHJlc3BvbnNlLiBTZXRzIHRoZSBzdGF0dXMgY29kZSBhbmQgdGhlIGBMb2NhdGlvbmAgaGVhZGVyLlxuICogRGVmYXVsdHMgdG8gXCIzMDIgRm91bmRcIi5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlZGlyZWN0OiBSZWRpcmVjdEZ1bmN0aW9uID0gKHVybCwgaW5pdCA9IDMwMikgPT4ge1xuICBsZXQgcmVzcG9uc2VJbml0ID0gaW5pdDtcbiAgaWYgKHR5cGVvZiByZXNwb25zZUluaXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXNwb25zZUluaXQgPSB7IHN0YXR1czogcmVzcG9uc2VJbml0IH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIHJlc3BvbnNlSW5pdC5zdGF0dXMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXNwb25zZUluaXQuc3RhdHVzID0gMzAyO1xuICB9XG5cbiAgbGV0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhyZXNwb25zZUluaXQuaGVhZGVycyk7XG4gIGhlYWRlcnMuc2V0KFwiTG9jYXRpb25cIiwgdXJsKTtcblxuICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtcbiAgICAuLi5yZXNwb25zZUluaXQsXG4gICAgaGVhZGVycyxcbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBVdGlsaXR5IGNsYXNzIHdlIHVzZSB0byBob2xkIGF1dG8tdW53cmFwcGVkIDR4eC81eHggUmVzcG9uc2UgYm9kaWVzXG4gKi9cbmV4cG9ydCBjbGFzcyBFcnJvclJlc3BvbnNlIHtcbiAgc3RhdHVzOiBudW1iZXI7XG4gIHN0YXR1c1RleHQ6IHN0cmluZztcbiAgZGF0YTogYW55O1xuICBlcnJvcj86IEVycm9yO1xuICBpbnRlcm5hbDogYm9vbGVhbjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBzdGF0dXM6IG51bWJlcixcbiAgICBzdGF0dXNUZXh0OiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgZGF0YTogYW55LFxuICAgIGludGVybmFsID0gZmFsc2VcbiAgKSB7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gc3RhdHVzVGV4dCB8fCBcIlwiO1xuICAgIHRoaXMuaW50ZXJuYWwgPSBpbnRlcm5hbDtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aGlzLmRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICB0aGlzLmVycm9yID0gZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gZXJyb3IgaXMgYW4gRXJyb3JSZXNwb25zZSBnZW5lcmF0ZWQgZnJvbSBhIDR4eC81eHhcbiAqIFJlc3BvbnNlIHRocm93biBmcm9tIGFuIGFjdGlvbi9sb2FkZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUm91dGVFcnJvclJlc3BvbnNlKGVycm9yOiBhbnkpOiBlcnJvciBpcyBFcnJvclJlc3BvbnNlIHtcbiAgcmV0dXJuIChcbiAgICBlcnJvciAhPSBudWxsICYmXG4gICAgdHlwZW9mIGVycm9yLnN0YXR1cyA9PT0gXCJudW1iZXJcIiAmJlxuICAgIHR5cGVvZiBlcnJvci5zdGF0dXNUZXh0ID09PSBcInN0cmluZ1wiICYmXG4gICAgdHlwZW9mIGVycm9yLmludGVybmFsID09PSBcImJvb2xlYW5cIiAmJlxuICAgIFwiZGF0YVwiIGluIGVycm9yXG4gICk7XG59XG4iLCJpbXBvcnQgdHlwZSB7IEhpc3RvcnksIExvY2F0aW9uLCBQYXRoLCBUbyB9IGZyb20gXCIuL2hpc3RvcnlcIjtcbmltcG9ydCB7XG4gIEFjdGlvbiBhcyBIaXN0b3J5QWN0aW9uLFxuICBjcmVhdGVMb2NhdGlvbixcbiAgY3JlYXRlUGF0aCxcbiAgaW52YXJpYW50LFxuICBwYXJzZVBhdGgsXG4gIHdhcm5pbmcsXG59IGZyb20gXCIuL2hpc3RvcnlcIjtcbmltcG9ydCB0eXBlIHtcbiAgRGF0YVJlc3VsdCxcbiAgQWdub3N0aWNEYXRhUm91dGVNYXRjaCxcbiAgQWdub3N0aWNEYXRhUm91dGVPYmplY3QsXG4gIERlZmVycmVkUmVzdWx0LFxuICBFcnJvclJlc3VsdCxcbiAgRm9ybUVuY1R5cGUsXG4gIEZvcm1NZXRob2QsXG4gIERldGVjdEVycm9yQm91bmRhcnlGdW5jdGlvbixcbiAgUmVkaXJlY3RSZXN1bHQsXG4gIFJvdXRlRGF0YSxcbiAgQWdub3N0aWNSb3V0ZU9iamVjdCxcbiAgU3VibWlzc2lvbixcbiAgU3VjY2Vzc1Jlc3VsdCxcbiAgQWdub3N0aWNSb3V0ZU1hdGNoLFxuICBNdXRhdGlvbkZvcm1NZXRob2QsXG4gIFNob3VsZFJldmFsaWRhdGVGdW5jdGlvbixcbiAgUm91dGVNYW5pZmVzdCxcbiAgSW1tdXRhYmxlUm91dGVLZXksXG4gIEFjdGlvbkZ1bmN0aW9uLFxuICBMb2FkZXJGdW5jdGlvbixcbn0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCB7XG4gIERlZmVycmVkRGF0YSxcbiAgRXJyb3JSZXNwb25zZSxcbiAgUmVzdWx0VHlwZSxcbiAgY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyxcbiAgZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXMsXG4gIGltbXV0YWJsZVJvdXRlS2V5cyxcbiAgaXNSb3V0ZUVycm9yUmVzcG9uc2UsXG4gIGpvaW5QYXRocyxcbiAgbWF0Y2hSb3V0ZXMsXG4gIHJlc29sdmVUbyxcbiAgc3RyaXBCYXNlbmFtZSxcbn0gZnJvbSBcIi4vdXRpbHNcIjtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBUeXBlcyBhbmQgQ29uc3RhbnRzXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEEgUm91dGVyIGluc3RhbmNlIG1hbmFnZXMgYWxsIG5hdmlnYXRpb24gYW5kIGRhdGEgbG9hZGluZy9tdXRhdGlvbnNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSb3V0ZXIge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIFJldHVybiB0aGUgYmFzZW5hbWUgZm9yIHRoZSByb3V0ZXJcbiAgICovXG4gIGdldCBiYXNlbmFtZSgpOiBSb3V0ZXJJbml0W1wiYmFzZW5hbWVcIl07XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHJvdXRlclxuICAgKi9cbiAgZ2V0IHN0YXRlKCk6IFJvdXRlclN0YXRlO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogUmV0dXJuIHRoZSByb3V0ZXMgZm9yIHRoaXMgcm91dGVyIGluc3RhbmNlXG4gICAqL1xuICBnZXQgcm91dGVzKCk6IEFnbm9zdGljRGF0YVJvdXRlT2JqZWN0W107XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBJbml0aWFsaXplIHRoZSByb3V0ZXIsIGluY2x1ZGluZyBhZGRpbmcgaGlzdG9yeSBsaXN0ZW5lcnMgYW5kIGtpY2tpbmcgb2ZmXG4gICAqIGluaXRpYWwgZGF0YSBmZXRjaGVzLiAgUmV0dXJucyBhIGZ1bmN0aW9uIHRvIGNsZWFudXAgbGlzdGVuZXJzIGFuZCBhYm9ydFxuICAgKiBhbnkgaW4tcHJvZ3Jlc3MgbG9hZHNcbiAgICovXG4gIGluaXRpYWxpemUoKTogUm91dGVyO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogU3Vic2NyaWJlIHRvIHJvdXRlci5zdGF0ZSB1cGRhdGVzXG4gICAqXG4gICAqIEBwYXJhbSBmbiBmdW5jdGlvbiB0byBjYWxsIHdpdGggdGhlIG5ldyBzdGF0ZVxuICAgKi9cbiAgc3Vic2NyaWJlKGZuOiBSb3V0ZXJTdWJzY3JpYmVyKTogKCkgPT4gdm9pZDtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIEVuYWJsZSBzY3JvbGwgcmVzdG9yYXRpb24gYmVoYXZpb3IgaW4gdGhlIHJvdXRlclxuICAgKlxuICAgKiBAcGFyYW0gc2F2ZWRTY3JvbGxQb3NpdGlvbnMgT2JqZWN0IHRoYXQgd2lsbCBtYW5hZ2UgcG9zaXRpb25zLCBpbiBjYXNlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdCdzIGJlaW5nIHJlc3RvcmVkIGZyb20gc2Vzc2lvblN0b3JhZ2VcbiAgICogQHBhcmFtIGdldFNjcm9sbFBvc2l0aW9uICAgIEZ1bmN0aW9uIHRvIGdldCB0aGUgYWN0aXZlIFkgc2Nyb2xsIHBvc2l0aW9uXG4gICAqIEBwYXJhbSBnZXRLZXkgICAgICAgICAgICAgICBGdW5jdGlvbiB0byBnZXQgdGhlIGtleSB0byB1c2UgZm9yIHJlc3RvcmF0aW9uXG4gICAqL1xuICBlbmFibGVTY3JvbGxSZXN0b3JhdGlvbihcbiAgICBzYXZlZFNjcm9sbFBvc2l0aW9uczogUmVjb3JkPHN0cmluZywgbnVtYmVyPixcbiAgICBnZXRTY3JvbGxQb3NpdGlvbjogR2V0U2Nyb2xsUG9zaXRpb25GdW5jdGlvbixcbiAgICBnZXRLZXk/OiBHZXRTY3JvbGxSZXN0b3JhdGlvbktleUZ1bmN0aW9uXG4gICk6ICgpID0+IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBOYXZpZ2F0ZSBmb3J3YXJkL2JhY2t3YXJkIGluIHRoZSBoaXN0b3J5IHN0YWNrXG4gICAqIEBwYXJhbSB0byBEZWx0YSB0byBtb3ZlIGluIHRoZSBoaXN0b3J5IHN0YWNrXG4gICAqL1xuICBuYXZpZ2F0ZSh0bzogbnVtYmVyKTogUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogTmF2aWdhdGUgdG8gdGhlIGdpdmVuIHBhdGhcbiAgICogQHBhcmFtIHRvIFBhdGggdG8gbmF2aWdhdGUgdG9cbiAgICogQHBhcmFtIG9wdHMgTmF2aWdhdGlvbiBvcHRpb25zIChtZXRob2QsIHN1Ym1pc3Npb24sIGV0Yy4pXG4gICAqL1xuICBuYXZpZ2F0ZSh0bzogVG8sIG9wdHM/OiBSb3V0ZXJOYXZpZ2F0ZU9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogVHJpZ2dlciBhIGZldGNoZXIgbG9hZC9zdWJtaXNzaW9uXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgICAgIEZldGNoZXIga2V5XG4gICAqIEBwYXJhbSByb3V0ZUlkIFJvdXRlIHRoYXQgb3ducyB0aGUgZmV0Y2hlclxuICAgKiBAcGFyYW0gaHJlZiAgICBocmVmIHRvIGZldGNoXG4gICAqIEBwYXJhbSBvcHRzICAgIEZldGNoZXIgb3B0aW9ucywgKG1ldGhvZCwgc3VibWlzc2lvbiwgZXRjLilcbiAgICovXG4gIGZldGNoKFxuICAgIGtleTogc3RyaW5nLFxuICAgIHJvdXRlSWQ6IHN0cmluZyxcbiAgICBocmVmOiBzdHJpbmcsXG4gICAgb3B0cz86IFJvdXRlck5hdmlnYXRlT3B0aW9uc1xuICApOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogVHJpZ2dlciBhIHJldmFsaWRhdGlvbiBvZiBhbGwgY3VycmVudCByb3V0ZSBsb2FkZXJzIGFuZCBmZXRjaGVyIGxvYWRzXG4gICAqL1xuICByZXZhbGlkYXRlKCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBhbiBocmVmIGZvciB0aGUgZ2l2ZW4gbG9jYXRpb25cbiAgICogQHBhcmFtIGxvY2F0aW9uXG4gICAqL1xuICBjcmVhdGVIcmVmKGxvY2F0aW9uOiBMb2NhdGlvbiB8IFVSTCk6IHN0cmluZztcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gVVJMIGVuY29kZSBhIGRlc3RpbmF0aW9uIHBhdGggYWNjb3JkaW5nIHRvIHRoZSBpbnRlcm5hbFxuICAgKiBoaXN0b3J5IGltcGxlbWVudGF0aW9uXG4gICAqIEBwYXJhbSB0b1xuICAgKi9cbiAgZW5jb2RlTG9jYXRpb24odG86IFRvKTogUGF0aDtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIEdldC9jcmVhdGUgYSBmZXRjaGVyIGZvciB0aGUgZ2l2ZW4ga2V5XG4gICAqIEBwYXJhbSBrZXlcbiAgICovXG4gIGdldEZldGNoZXI8VERhdGEgPSBhbnk+KGtleT86IHN0cmluZyk6IEZldGNoZXI8VERhdGE+O1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogRGVsZXRlIHRoZSBmZXRjaGVyIGZvciBhIGdpdmVuIGtleVxuICAgKiBAcGFyYW0ga2V5XG4gICAqL1xuICBkZWxldGVGZXRjaGVyKGtleT86IHN0cmluZyk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBDbGVhbnVwIGxpc3RlbmVycyBhbmQgYWJvcnQgYW55IGluLXByb2dyZXNzIGxvYWRzXG4gICAqL1xuICBkaXNwb3NlKCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBHZXQgYSBuYXZpZ2F0aW9uIGJsb2NrZXJcbiAgICogQHBhcmFtIGtleSBUaGUgaWRlbnRpZmllciBmb3IgdGhlIGJsb2NrZXJcbiAgICogQHBhcmFtIGZuIFRoZSBibG9ja2VyIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9uXG4gICAqL1xuICBnZXRCbG9ja2VyKGtleTogc3RyaW5nLCBmbjogQmxvY2tlckZ1bmN0aW9uKTogQmxvY2tlcjtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIERlbGV0ZSBhIG5hdmlnYXRpb24gYmxvY2tlclxuICAgKiBAcGFyYW0ga2V5IFRoZSBpZGVudGlmaWVyIGZvciB0aGUgYmxvY2tlclxuICAgKi9cbiAgZGVsZXRlQmxvY2tlcihrZXk6IHN0cmluZyk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBITVIgbmVlZHMgdG8gcGFzcyBpbi1mbGlnaHQgcm91dGUgdXBkYXRlcyB0byBSZWFjdCBSb3V0ZXJcbiAgICogVE9ETzogUmVwbGFjZSB0aGlzIHdpdGggZ3JhbnVsYXIgcm91dGUgdXBkYXRlIEFQSXMgKGFkZFJvdXRlLCB1cGRhdGVSb3V0ZSwgZGVsZXRlUm91dGUpXG4gICAqL1xuICBfaW50ZXJuYWxTZXRSb3V0ZXMocm91dGVzOiBBZ25vc3RpY1JvdXRlT2JqZWN0W10pOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogSW50ZXJuYWwgZmV0Y2ggQWJvcnRDb250cm9sbGVycyBhY2Nlc3NlZCBieSB1bml0IHRlc3RzXG4gICAqL1xuICBfaW50ZXJuYWxGZXRjaENvbnRyb2xsZXJzOiBNYXA8c3RyaW5nLCBBYm9ydENvbnRyb2xsZXI+O1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogSW50ZXJuYWwgcGVuZGluZyBEZWZlcnJlZERhdGEgaW5zdGFuY2VzIGFjY2Vzc2VkIGJ5IHVuaXQgdGVzdHNcbiAgICovXG4gIF9pbnRlcm5hbEFjdGl2ZURlZmVycmVkczogTWFwPHN0cmluZywgRGVmZXJyZWREYXRhPjtcbn1cblxuLyoqXG4gKiBTdGF0ZSBtYWludGFpbmVkIGludGVybmFsbHkgYnkgdGhlIHJvdXRlci4gIER1cmluZyBhIG5hdmlnYXRpb24sIGFsbCBzdGF0ZXNcbiAqIHJlZmxlY3QgdGhlIHRoZSBcIm9sZFwiIGxvY2F0aW9uIHVubGVzcyBvdGhlcndpc2Ugbm90ZWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVyU3RhdGUge1xuICAvKipcbiAgICogVGhlIGFjdGlvbiBvZiB0aGUgbW9zdCByZWNlbnQgbmF2aWdhdGlvblxuICAgKi9cbiAgaGlzdG9yeUFjdGlvbjogSGlzdG9yeUFjdGlvbjtcblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgbG9jYXRpb24gcmVmbGVjdGVkIGJ5IHRoZSByb3V0ZXJcbiAgICovXG4gIGxvY2F0aW9uOiBMb2NhdGlvbjtcblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgc2V0IG9mIHJvdXRlIG1hdGNoZXNcbiAgICovXG4gIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXTtcblxuICAvKipcbiAgICogVHJhY2tzIHdoZXRoZXIgd2UndmUgY29tcGxldGVkIG91ciBpbml0aWFsIGRhdGEgbG9hZFxuICAgKi9cbiAgaW5pdGlhbGl6ZWQ6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uIHdlIHNob3VsZCBzdGFydCBhdCBmb3IgYSBuZXcgdmlld1xuICAgKiAgLSBudW1iZXIgLT4gc2Nyb2xsIHBvc2l0aW9uIHRvIHJlc3RvcmUgdG9cbiAgICogIC0gZmFsc2UgLT4gZG8gbm90IHJlc3RvcmUgc2Nyb2xsIGF0IGFsbCAodXNlZCBkdXJpbmcgc3VibWlzc2lvbnMpXG4gICAqICAtIG51bGwgLT4gZG9uJ3QgaGF2ZSBhIHNhdmVkIHBvc2l0aW9uLCBzY3JvbGwgdG8gaGFzaCBvciB0b3Agb2YgcGFnZVxuICAgKi9cbiAgcmVzdG9yZVNjcm9sbFBvc2l0aW9uOiBudW1iZXIgfCBmYWxzZSB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEluZGljYXRlIHdoZXRoZXIgdGhpcyBuYXZpZ2F0aW9uIHNob3VsZCBza2lwIHJlc2V0dGluZyB0aGUgc2Nyb2xsIHBvc2l0aW9uXG4gICAqIGlmIHdlIGFyZSB1bmFibGUgdG8gcmVzdG9yZSB0aGUgc2Nyb2xsIHBvc2l0aW9uXG4gICAqL1xuICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFRyYWNrcyB0aGUgc3RhdGUgb2YgdGhlIGN1cnJlbnQgbmF2aWdhdGlvblxuICAgKi9cbiAgbmF2aWdhdGlvbjogTmF2aWdhdGlvbjtcblxuICAvKipcbiAgICogVHJhY2tzIGFueSBpbi1wcm9ncmVzcyByZXZhbGlkYXRpb25zXG4gICAqL1xuICByZXZhbGlkYXRpb246IFJldmFsaWRhdGlvblN0YXRlO1xuXG4gIC8qKlxuICAgKiBEYXRhIGZyb20gdGhlIGxvYWRlcnMgZm9yIHRoZSBjdXJyZW50IG1hdGNoZXNcbiAgICovXG4gIGxvYWRlckRhdGE6IFJvdXRlRGF0YTtcblxuICAvKipcbiAgICogRGF0YSBmcm9tIHRoZSBhY3Rpb24gZm9yIHRoZSBjdXJyZW50IG1hdGNoZXNcbiAgICovXG4gIGFjdGlvbkRhdGE6IFJvdXRlRGF0YSB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEVycm9ycyBjYXVnaHQgZnJvbSBsb2FkZXJzIGZvciB0aGUgY3VycmVudCBtYXRjaGVzXG4gICAqL1xuICBlcnJvcnM6IFJvdXRlRGF0YSB8IG51bGw7XG5cbiAgLyoqXG4gICAqIE1hcCBvZiBjdXJyZW50IGZldGNoZXJzXG4gICAqL1xuICBmZXRjaGVyczogTWFwPHN0cmluZywgRmV0Y2hlcj47XG5cbiAgLyoqXG4gICAqIE1hcCBvZiBjdXJyZW50IGJsb2NrZXJzXG4gICAqL1xuICBibG9ja2VyczogTWFwPHN0cmluZywgQmxvY2tlcj47XG59XG5cbi8qKlxuICogRGF0YSB0aGF0IGNhbiBiZSBwYXNzZWQgaW50byBoeWRyYXRlIGEgUm91dGVyIGZyb20gU1NSXG4gKi9cbmV4cG9ydCB0eXBlIEh5ZHJhdGlvblN0YXRlID0gUGFydGlhbDxcbiAgUGljazxSb3V0ZXJTdGF0ZSwgXCJsb2FkZXJEYXRhXCIgfCBcImFjdGlvbkRhdGFcIiB8IFwiZXJyb3JzXCI+XG4+O1xuXG4vKipcbiAqIEluaXRpYWxpemF0aW9uIG9wdGlvbnMgZm9yIGNyZWF0ZVJvdXRlclxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlckluaXQge1xuICBiYXNlbmFtZT86IHN0cmluZztcbiAgcm91dGVzOiBBZ25vc3RpY1JvdXRlT2JqZWN0W107XG4gIGhpc3Rvcnk6IEhpc3Rvcnk7XG4gIGh5ZHJhdGlvbkRhdGE/OiBIeWRyYXRpb25TdGF0ZTtcbiAgZGV0ZWN0RXJyb3JCb3VuZGFyeT86IERldGVjdEVycm9yQm91bmRhcnlGdW5jdGlvbjtcbn1cblxuLyoqXG4gKiBTdGF0ZSByZXR1cm5lZCBmcm9tIGEgc2VydmVyLXNpZGUgcXVlcnkoKSBjYWxsXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGljSGFuZGxlckNvbnRleHQge1xuICBiYXNlbmFtZTogUm91dGVyW1wiYmFzZW5hbWVcIl07XG4gIGxvY2F0aW9uOiBSb3V0ZXJTdGF0ZVtcImxvY2F0aW9uXCJdO1xuICBtYXRjaGVzOiBSb3V0ZXJTdGF0ZVtcIm1hdGNoZXNcIl07XG4gIGxvYWRlckRhdGE6IFJvdXRlclN0YXRlW1wibG9hZGVyRGF0YVwiXTtcbiAgYWN0aW9uRGF0YTogUm91dGVyU3RhdGVbXCJhY3Rpb25EYXRhXCJdO1xuICBlcnJvcnM6IFJvdXRlclN0YXRlW1wiZXJyb3JzXCJdO1xuICBzdGF0dXNDb2RlOiBudW1iZXI7XG4gIGxvYWRlckhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIEhlYWRlcnM+O1xuICBhY3Rpb25IZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBIZWFkZXJzPjtcbiAgYWN0aXZlRGVmZXJyZWRzOiBSZWNvcmQ8c3RyaW5nLCBEZWZlcnJlZERhdGE+IHwgbnVsbDtcbiAgX2RlZXBlc3RSZW5kZXJlZEJvdW5kYXJ5SWQ/OiBzdHJpbmcgfCBudWxsO1xufVxuXG4vKipcbiAqIEEgU3RhdGljSGFuZGxlciBpbnN0YW5jZSBtYW5hZ2VzIGEgc2luZ3VsYXIgU1NSIG5hdmlnYXRpb24vZmV0Y2ggZXZlbnRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdGF0aWNIYW5kbGVyIHtcbiAgZGF0YVJvdXRlczogQWdub3N0aWNEYXRhUm91dGVPYmplY3RbXTtcbiAgcXVlcnkoXG4gICAgcmVxdWVzdDogUmVxdWVzdCxcbiAgICBvcHRzPzogeyByZXF1ZXN0Q29udGV4dD86IHVua25vd24gfVxuICApOiBQcm9taXNlPFN0YXRpY0hhbmRsZXJDb250ZXh0IHwgUmVzcG9uc2U+O1xuICBxdWVyeVJvdXRlKFxuICAgIHJlcXVlc3Q6IFJlcXVlc3QsXG4gICAgb3B0cz86IHsgcm91dGVJZD86IHN0cmluZzsgcmVxdWVzdENvbnRleHQ/OiB1bmtub3duIH1cbiAgKTogUHJvbWlzZTxhbnk+O1xufVxuXG4vKipcbiAqIFN1YnNjcmliZXIgZnVuY3Rpb24gc2lnbmF0dXJlIGZvciBjaGFuZ2VzIHRvIHJvdXRlciBzdGF0ZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlclN1YnNjcmliZXIge1xuICAoc3RhdGU6IFJvdXRlclN0YXRlKTogdm9pZDtcbn1cblxuaW50ZXJmYWNlIFVzZU1hdGNoZXNNYXRjaCB7XG4gIGlkOiBzdHJpbmc7XG4gIHBhdGhuYW1lOiBzdHJpbmc7XG4gIHBhcmFtczogQWdub3N0aWNSb3V0ZU1hdGNoW1wicGFyYW1zXCJdO1xuICBkYXRhOiB1bmtub3duO1xuICBoYW5kbGU6IHVua25vd247XG59XG5cbi8qKlxuICogRnVuY3Rpb24gc2lnbmF0dXJlIGZvciBkZXRlcm1pbmluZyB0aGUga2V5IHRvIGJlIHVzZWQgaW4gc2Nyb2xsIHJlc3RvcmF0aW9uXG4gKiBmb3IgYSBnaXZlbiBsb2NhdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIEdldFNjcm9sbFJlc3RvcmF0aW9uS2V5RnVuY3Rpb24ge1xuICAobG9jYXRpb246IExvY2F0aW9uLCBtYXRjaGVzOiBVc2VNYXRjaGVzTWF0Y2hbXSk6IHN0cmluZyB8IG51bGw7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gc2lnbmF0dXJlIGZvciBkZXRlcm1pbmluZyB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBHZXRTY3JvbGxQb3NpdGlvbkZ1bmN0aW9uIHtcbiAgKCk6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBPcHRpb25zIGZvciBhIG5hdmlnYXRlKCkgY2FsbCBmb3IgYSBMaW5rIG5hdmlnYXRpb25cbiAqL1xudHlwZSBMaW5rTmF2aWdhdGVPcHRpb25zID0ge1xuICByZXBsYWNlPzogYm9vbGVhbjtcbiAgc3RhdGU/OiBhbnk7XG4gIHByZXZlbnRTY3JvbGxSZXNldD86IGJvb2xlYW47XG59O1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGEgbmF2aWdhdGUoKSBjYWxsIGZvciBhIEZvcm0gbmF2aWdhdGlvblxuICovXG50eXBlIFN1Ym1pc3Npb25OYXZpZ2F0ZU9wdGlvbnMgPSB7XG4gIHJlcGxhY2U/OiBib29sZWFuO1xuICBzdGF0ZT86IGFueTtcbiAgcHJldmVudFNjcm9sbFJlc2V0PzogYm9vbGVhbjtcbiAgZm9ybU1ldGhvZD86IEZvcm1NZXRob2Q7XG4gIGZvcm1FbmNUeXBlPzogRm9ybUVuY1R5cGU7XG4gIGZvcm1EYXRhOiBGb3JtRGF0YTtcbn07XG5cbi8qKlxuICogT3B0aW9ucyB0byBwYXNzIHRvIG5hdmlnYXRlKCkgZm9yIGVpdGhlciBhIExpbmsgb3IgRm9ybSBuYXZpZ2F0aW9uXG4gKi9cbmV4cG9ydCB0eXBlIFJvdXRlck5hdmlnYXRlT3B0aW9ucyA9XG4gIHwgTGlua05hdmlnYXRlT3B0aW9uc1xuICB8IFN1Ym1pc3Npb25OYXZpZ2F0ZU9wdGlvbnM7XG5cbi8qKlxuICogT3B0aW9ucyB0byBwYXNzIHRvIGZldGNoKClcbiAqL1xuZXhwb3J0IHR5cGUgUm91dGVyRmV0Y2hPcHRpb25zID1cbiAgfCBPbWl0PExpbmtOYXZpZ2F0ZU9wdGlvbnMsIFwicmVwbGFjZVwiPlxuICB8IE9taXQ8U3VibWlzc2lvbk5hdmlnYXRlT3B0aW9ucywgXCJyZXBsYWNlXCI+O1xuXG4vKipcbiAqIFBvdGVudGlhbCBzdGF0ZXMgZm9yIHN0YXRlLm5hdmlnYXRpb25cbiAqL1xuZXhwb3J0IHR5cGUgTmF2aWdhdGlvblN0YXRlcyA9IHtcbiAgSWRsZToge1xuICAgIHN0YXRlOiBcImlkbGVcIjtcbiAgICBsb2NhdGlvbjogdW5kZWZpbmVkO1xuICAgIGZvcm1NZXRob2Q6IHVuZGVmaW5lZDtcbiAgICBmb3JtQWN0aW9uOiB1bmRlZmluZWQ7XG4gICAgZm9ybUVuY1R5cGU6IHVuZGVmaW5lZDtcbiAgICBmb3JtRGF0YTogdW5kZWZpbmVkO1xuICB9O1xuICBMb2FkaW5nOiB7XG4gICAgc3RhdGU6IFwibG9hZGluZ1wiO1xuICAgIGxvY2F0aW9uOiBMb2NhdGlvbjtcbiAgICBmb3JtTWV0aG9kOiBGb3JtTWV0aG9kIHwgdW5kZWZpbmVkO1xuICAgIGZvcm1BY3Rpb246IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICBmb3JtRW5jVHlwZTogRm9ybUVuY1R5cGUgfCB1bmRlZmluZWQ7XG4gICAgZm9ybURhdGE6IEZvcm1EYXRhIHwgdW5kZWZpbmVkO1xuICB9O1xuICBTdWJtaXR0aW5nOiB7XG4gICAgc3RhdGU6IFwic3VibWl0dGluZ1wiO1xuICAgIGxvY2F0aW9uOiBMb2NhdGlvbjtcbiAgICBmb3JtTWV0aG9kOiBGb3JtTWV0aG9kO1xuICAgIGZvcm1BY3Rpb246IHN0cmluZztcbiAgICBmb3JtRW5jVHlwZTogRm9ybUVuY1R5cGU7XG4gICAgZm9ybURhdGE6IEZvcm1EYXRhO1xuICB9O1xufTtcblxuZXhwb3J0IHR5cGUgTmF2aWdhdGlvbiA9IE5hdmlnYXRpb25TdGF0ZXNba2V5b2YgTmF2aWdhdGlvblN0YXRlc107XG5cbmV4cG9ydCB0eXBlIFJldmFsaWRhdGlvblN0YXRlID0gXCJpZGxlXCIgfCBcImxvYWRpbmdcIjtcblxuLyoqXG4gKiBQb3RlbnRpYWwgc3RhdGVzIGZvciBmZXRjaGVyc1xuICovXG50eXBlIEZldGNoZXJTdGF0ZXM8VERhdGEgPSBhbnk+ID0ge1xuICBJZGxlOiB7XG4gICAgc3RhdGU6IFwiaWRsZVwiO1xuICAgIGZvcm1NZXRob2Q6IHVuZGVmaW5lZDtcbiAgICBmb3JtQWN0aW9uOiB1bmRlZmluZWQ7XG4gICAgZm9ybUVuY1R5cGU6IHVuZGVmaW5lZDtcbiAgICBmb3JtRGF0YTogdW5kZWZpbmVkO1xuICAgIGRhdGE6IFREYXRhIHwgdW5kZWZpbmVkO1xuICAgIFwiIF9oYXNGZXRjaGVyRG9uZUFueXRoaW5nIFwiPzogYm9vbGVhbjtcbiAgfTtcbiAgTG9hZGluZzoge1xuICAgIHN0YXRlOiBcImxvYWRpbmdcIjtcbiAgICBmb3JtTWV0aG9kOiBGb3JtTWV0aG9kIHwgdW5kZWZpbmVkO1xuICAgIGZvcm1BY3Rpb246IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICBmb3JtRW5jVHlwZTogRm9ybUVuY1R5cGUgfCB1bmRlZmluZWQ7XG4gICAgZm9ybURhdGE6IEZvcm1EYXRhIHwgdW5kZWZpbmVkO1xuICAgIGRhdGE6IFREYXRhIHwgdW5kZWZpbmVkO1xuICAgIFwiIF9oYXNGZXRjaGVyRG9uZUFueXRoaW5nIFwiPzogYm9vbGVhbjtcbiAgfTtcbiAgU3VibWl0dGluZzoge1xuICAgIHN0YXRlOiBcInN1Ym1pdHRpbmdcIjtcbiAgICBmb3JtTWV0aG9kOiBGb3JtTWV0aG9kO1xuICAgIGZvcm1BY3Rpb246IHN0cmluZztcbiAgICBmb3JtRW5jVHlwZTogRm9ybUVuY1R5cGU7XG4gICAgZm9ybURhdGE6IEZvcm1EYXRhO1xuICAgIGRhdGE6IFREYXRhIHwgdW5kZWZpbmVkO1xuICAgIFwiIF9oYXNGZXRjaGVyRG9uZUFueXRoaW5nIFwiPzogYm9vbGVhbjtcbiAgfTtcbn07XG5cbmV4cG9ydCB0eXBlIEZldGNoZXI8VERhdGEgPSBhbnk+ID1cbiAgRmV0Y2hlclN0YXRlczxURGF0YT5ba2V5b2YgRmV0Y2hlclN0YXRlczxURGF0YT5dO1xuXG5pbnRlcmZhY2UgQmxvY2tlckJsb2NrZWQge1xuICBzdGF0ZTogXCJibG9ja2VkXCI7XG4gIHJlc2V0KCk6IHZvaWQ7XG4gIHByb2NlZWQoKTogdm9pZDtcbiAgbG9jYXRpb246IExvY2F0aW9uO1xufVxuXG5pbnRlcmZhY2UgQmxvY2tlclVuYmxvY2tlZCB7XG4gIHN0YXRlOiBcInVuYmxvY2tlZFwiO1xuICByZXNldDogdW5kZWZpbmVkO1xuICBwcm9jZWVkOiB1bmRlZmluZWQ7XG4gIGxvY2F0aW9uOiB1bmRlZmluZWQ7XG59XG5cbmludGVyZmFjZSBCbG9ja2VyUHJvY2VlZGluZyB7XG4gIHN0YXRlOiBcInByb2NlZWRpbmdcIjtcbiAgcmVzZXQ6IHVuZGVmaW5lZDtcbiAgcHJvY2VlZDogdW5kZWZpbmVkO1xuICBsb2NhdGlvbjogTG9jYXRpb247XG59XG5cbmV4cG9ydCB0eXBlIEJsb2NrZXIgPSBCbG9ja2VyVW5ibG9ja2VkIHwgQmxvY2tlckJsb2NrZWQgfCBCbG9ja2VyUHJvY2VlZGluZztcblxuZXhwb3J0IHR5cGUgQmxvY2tlckZ1bmN0aW9uID0gKGFyZ3M6IHtcbiAgY3VycmVudExvY2F0aW9uOiBMb2NhdGlvbjtcbiAgbmV4dExvY2F0aW9uOiBMb2NhdGlvbjtcbiAgaGlzdG9yeUFjdGlvbjogSGlzdG9yeUFjdGlvbjtcbn0pID0+IGJvb2xlYW47XG5cbmludGVyZmFjZSBTaG9ydENpcmN1aXRhYmxlIHtcbiAgLyoqXG4gICAqIHN0YXJ0TmF2aWdhdGlvbiBkb2VzIG5vdCBuZWVkIHRvIGNvbXBsZXRlIHRoZSBuYXZpZ2F0aW9uIGJlY2F1c2Ugd2VcbiAgICogcmVkaXJlY3RlZCBvciBnb3QgaW50ZXJydXB0ZWRcbiAgICovXG4gIHNob3J0Q2lyY3VpdGVkPzogYm9vbGVhbjtcbn1cblxuaW50ZXJmYWNlIEhhbmRsZUFjdGlvblJlc3VsdCBleHRlbmRzIFNob3J0Q2lyY3VpdGFibGUge1xuICAvKipcbiAgICogRXJyb3IgdGhyb3duIGZyb20gdGhlIGN1cnJlbnQgYWN0aW9uLCBrZXllZCBieSB0aGUgcm91dGUgY29udGFpbmluZyB0aGVcbiAgICogZXJyb3IgYm91bmRhcnkgdG8gcmVuZGVyIHRoZSBlcnJvci4gIFRvIGJlIGNvbW1pdHRlZCB0byB0aGUgc3RhdGUgYWZ0ZXJcbiAgICogbG9hZGVycyBoYXZlIGNvbXBsZXRlZFxuICAgKi9cbiAgcGVuZGluZ0FjdGlvbkVycm9yPzogUm91dGVEYXRhO1xuICAvKipcbiAgICogRGF0YSByZXR1cm5lZCBmcm9tIHRoZSBjdXJyZW50IGFjdGlvbiwga2V5ZWQgYnkgdGhlIHJvdXRlIG93bmluZyB0aGUgYWN0aW9uLlxuICAgKiBUbyBiZSBjb21taXR0ZWQgdG8gdGhlIHN0YXRlIGFmdGVyIGxvYWRlcnMgaGF2ZSBjb21wbGV0ZWRcbiAgICovXG4gIHBlbmRpbmdBY3Rpb25EYXRhPzogUm91dGVEYXRhO1xufVxuXG5pbnRlcmZhY2UgSGFuZGxlTG9hZGVyc1Jlc3VsdCBleHRlbmRzIFNob3J0Q2lyY3VpdGFibGUge1xuICAvKipcbiAgICogbG9hZGVyRGF0YSByZXR1cm5lZCBmcm9tIHRoZSBjdXJyZW50IHNldCBvZiBsb2FkZXJzXG4gICAqL1xuICBsb2FkZXJEYXRhPzogUm91dGVyU3RhdGVbXCJsb2FkZXJEYXRhXCJdO1xuICAvKipcbiAgICogZXJyb3JzIHRocm93biBmcm9tIHRoZSBjdXJyZW50IHNldCBvZiBsb2FkZXJzXG4gICAqL1xuICBlcnJvcnM/OiBSb3V0ZXJTdGF0ZVtcImVycm9yc1wiXTtcbn1cblxuLyoqXG4gKiBDYWNoZWQgaW5mbyBmb3IgYWN0aXZlIGZldGNoZXIubG9hZCgpIGluc3RhbmNlcyBzbyB0aGV5IGNhbiBwYXJ0aWNpcGF0ZVxuICogaW4gcmV2YWxpZGF0aW9uXG4gKi9cbmludGVyZmFjZSBGZXRjaExvYWRNYXRjaCB7XG4gIHJvdXRlSWQ6IHN0cmluZztcbiAgcGF0aDogc3RyaW5nO1xufVxuXG4vKipcbiAqIElkZW50aWZpZWQgZmV0Y2hlci5sb2FkKCkgY2FsbHMgdGhhdCBuZWVkIHRvIGJlIHJldmFsaWRhdGVkXG4gKi9cbmludGVyZmFjZSBSZXZhbGlkYXRpbmdGZXRjaGVyIGV4dGVuZHMgRmV0Y2hMb2FkTWF0Y2gge1xuICBrZXk6IHN0cmluZztcbiAgbWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2ggfCBudWxsO1xuICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10gfCBudWxsO1xufVxuXG4vKipcbiAqIFdyYXBwZXIgb2JqZWN0IHRvIGFsbG93IHVzIHRvIHRocm93IGFueSByZXNwb25zZSBvdXQgZnJvbSBjYWxsTG9hZGVyT3JBY3Rpb25cbiAqIGZvciBxdWVyeVJvdXRlciB3aGlsZSBwcmVzZXJ2aW5nIHdoZXRoZXIgb3Igbm90IGl0IHdhcyB0aHJvd24gb3IgcmV0dXJuZWRcbiAqIGZyb20gdGhlIGxvYWRlci9hY3Rpb25cbiAqL1xuaW50ZXJmYWNlIFF1ZXJ5Um91dGVSZXNwb25zZSB7XG4gIHR5cGU6IFJlc3VsdFR5cGUuZGF0YSB8IFJlc3VsdFR5cGUuZXJyb3I7XG4gIHJlc3BvbnNlOiBSZXNwb25zZTtcbn1cblxuY29uc3QgdmFsaWRNdXRhdGlvbk1ldGhvZHNBcnI6IE11dGF0aW9uRm9ybU1ldGhvZFtdID0gW1xuICBcInBvc3RcIixcbiAgXCJwdXRcIixcbiAgXCJwYXRjaFwiLFxuICBcImRlbGV0ZVwiLFxuXTtcbmNvbnN0IHZhbGlkTXV0YXRpb25NZXRob2RzID0gbmV3IFNldDxNdXRhdGlvbkZvcm1NZXRob2Q+KFxuICB2YWxpZE11dGF0aW9uTWV0aG9kc0FyclxuKTtcblxuY29uc3QgdmFsaWRSZXF1ZXN0TWV0aG9kc0FycjogRm9ybU1ldGhvZFtdID0gW1xuICBcImdldFwiLFxuICAuLi52YWxpZE11dGF0aW9uTWV0aG9kc0Fycixcbl07XG5jb25zdCB2YWxpZFJlcXVlc3RNZXRob2RzID0gbmV3IFNldDxGb3JtTWV0aG9kPih2YWxpZFJlcXVlc3RNZXRob2RzQXJyKTtcblxuY29uc3QgcmVkaXJlY3RTdGF0dXNDb2RlcyA9IG5ldyBTZXQoWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XSk7XG5jb25zdCByZWRpcmVjdFByZXNlcnZlTWV0aG9kU3RhdHVzQ29kZXMgPSBuZXcgU2V0KFszMDcsIDMwOF0pO1xuXG5leHBvcnQgY29uc3QgSURMRV9OQVZJR0FUSU9OOiBOYXZpZ2F0aW9uU3RhdGVzW1wiSWRsZVwiXSA9IHtcbiAgc3RhdGU6IFwiaWRsZVwiLFxuICBsb2NhdGlvbjogdW5kZWZpbmVkLFxuICBmb3JtTWV0aG9kOiB1bmRlZmluZWQsXG4gIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgZm9ybUVuY1R5cGU6IHVuZGVmaW5lZCxcbiAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbn07XG5cbmV4cG9ydCBjb25zdCBJRExFX0ZFVENIRVI6IEZldGNoZXJTdGF0ZXNbXCJJZGxlXCJdID0ge1xuICBzdGF0ZTogXCJpZGxlXCIsXG4gIGRhdGE6IHVuZGVmaW5lZCxcbiAgZm9ybU1ldGhvZDogdW5kZWZpbmVkLFxuICBmb3JtQWN0aW9uOiB1bmRlZmluZWQsXG4gIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQsXG4gIGZvcm1EYXRhOiB1bmRlZmluZWQsXG59O1xuXG5leHBvcnQgY29uc3QgSURMRV9CTE9DS0VSOiBCbG9ja2VyVW5ibG9ja2VkID0ge1xuICBzdGF0ZTogXCJ1bmJsb2NrZWRcIixcbiAgcHJvY2VlZDogdW5kZWZpbmVkLFxuICByZXNldDogdW5kZWZpbmVkLFxuICBsb2NhdGlvbjogdW5kZWZpbmVkLFxufTtcblxuY29uc3QgQUJTT0xVVEVfVVJMX1JFR0VYID0gL14oPzpbYS16XVthLXowLTkrLi1dKjp8XFwvXFwvKS9pO1xuXG5jb25zdCBpc0Jyb3dzZXIgPVxuICB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiO1xuY29uc3QgaXNTZXJ2ZXIgPSAhaXNCcm93c2VyO1xuXG5jb25zdCBkZWZhdWx0RGV0ZWN0RXJyb3JCb3VuZGFyeSA9IChyb3V0ZTogQWdub3N0aWNSb3V0ZU9iamVjdCkgPT5cbiAgQm9vbGVhbihyb3V0ZS5oYXNFcnJvckJvdW5kYXJ5KTtcbi8vI2VuZHJlZ2lvblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIGNyZWF0ZVJvdXRlclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBDcmVhdGUgYSByb3V0ZXIgYW5kIGxpc3RlbiB0byBoaXN0b3J5IFBPUCBuYXZpZ2F0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUm91dGVyKGluaXQ6IFJvdXRlckluaXQpOiBSb3V0ZXIge1xuICBpbnZhcmlhbnQoXG4gICAgaW5pdC5yb3V0ZXMubGVuZ3RoID4gMCxcbiAgICBcIllvdSBtdXN0IHByb3ZpZGUgYSBub24tZW1wdHkgcm91dGVzIGFycmF5IHRvIGNyZWF0ZVJvdXRlclwiXG4gICk7XG5cbiAgbGV0IGRldGVjdEVycm9yQm91bmRhcnkgPVxuICAgIGluaXQuZGV0ZWN0RXJyb3JCb3VuZGFyeSB8fCBkZWZhdWx0RGV0ZWN0RXJyb3JCb3VuZGFyeTtcblxuICAvLyBSb3V0ZXMga2V5ZWQgYnkgSURcbiAgbGV0IG1hbmlmZXN0OiBSb3V0ZU1hbmlmZXN0ID0ge307XG4gIC8vIFJvdXRlcyBpbiB0cmVlIGZvcm1hdCBmb3IgbWF0Y2hpbmdcbiAgbGV0IGRhdGFSb3V0ZXMgPSBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKFxuICAgIGluaXQucm91dGVzLFxuICAgIGRldGVjdEVycm9yQm91bmRhcnksXG4gICAgdW5kZWZpbmVkLFxuICAgIG1hbmlmZXN0XG4gICk7XG4gIGxldCBpbkZsaWdodERhdGFSb3V0ZXM6IEFnbm9zdGljRGF0YVJvdXRlT2JqZWN0W10gfCB1bmRlZmluZWQ7XG4gIC8vIENsZWFudXAgZnVuY3Rpb24gZm9yIGhpc3RvcnlcbiAgbGV0IHVubGlzdGVuSGlzdG9yeTogKCgpID0+IHZvaWQpIHwgbnVsbCA9IG51bGw7XG4gIC8vIEV4dGVybmFsbHktcHJvdmlkZWQgZnVuY3Rpb25zIHRvIGNhbGwgb24gYWxsIHN0YXRlIGNoYW5nZXNcbiAgbGV0IHN1YnNjcmliZXJzID0gbmV3IFNldDxSb3V0ZXJTdWJzY3JpYmVyPigpO1xuICAvLyBFeHRlcm5hbGx5LXByb3ZpZGVkIG9iamVjdCB0byBob2xkIHNjcm9sbCByZXN0b3JhdGlvbiBsb2NhdGlvbnMgZHVyaW5nIHJvdXRpbmdcbiAgbGV0IHNhdmVkU2Nyb2xsUG9zaXRpb25zOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+IHwgbnVsbCA9IG51bGw7XG4gIC8vIEV4dGVybmFsbHktcHJvdmlkZWQgZnVuY3Rpb24gdG8gZ2V0IHNjcm9sbCByZXN0b3JhdGlvbiBrZXlzXG4gIGxldCBnZXRTY3JvbGxSZXN0b3JhdGlvbktleTogR2V0U2Nyb2xsUmVzdG9yYXRpb25LZXlGdW5jdGlvbiB8IG51bGwgPSBudWxsO1xuICAvLyBFeHRlcm5hbGx5LXByb3ZpZGVkIGZ1bmN0aW9uIHRvIGdldCBjdXJyZW50IHNjcm9sbCBwb3NpdGlvblxuICBsZXQgZ2V0U2Nyb2xsUG9zaXRpb246IEdldFNjcm9sbFBvc2l0aW9uRnVuY3Rpb24gfCBudWxsID0gbnVsbDtcbiAgLy8gT25lLXRpbWUgZmxhZyB0byBjb250cm9sIHRoZSBpbml0aWFsIGh5ZHJhdGlvbiBzY3JvbGwgcmVzdG9yYXRpb24uICBCZWNhdXNlXG4gIC8vIHdlIGRvbid0IGdldCB0aGUgc2F2ZWQgcG9zaXRpb25zIGZyb20gPFNjcm9sbFJlc3RvcmF0aW9uIC8+IHVudGlsIF9hZnRlcl9cbiAgLy8gdGhlIGluaXRpYWwgcmVuZGVyLCB3ZSBuZWVkIHRvIG1hbnVhbGx5IHRyaWdnZXIgYSBzZXBhcmF0ZSB1cGRhdGVTdGF0ZSB0b1xuICAvLyBzZW5kIGFsb25nIHRoZSByZXN0b3JlU2Nyb2xsUG9zaXRpb25cbiAgLy8gU2V0IHRvIHRydWUgaWYgd2UgaGF2ZSBgaHlkcmF0aW9uRGF0YWAgc2luY2Ugd2UgYXNzdW1lIHdlIHdlcmUgU1NSJ2QgYW5kIHRoYXRcbiAgLy8gU1NSIGRpZCB0aGUgaW5pdGlhbCBzY3JvbGwgcmVzdG9yYXRpb24uXG4gIGxldCBpbml0aWFsU2Nyb2xsUmVzdG9yZWQgPSBpbml0Lmh5ZHJhdGlvbkRhdGEgIT0gbnVsbDtcblxuICBsZXQgaW5pdGlhbE1hdGNoZXMgPSBtYXRjaFJvdXRlcyhcbiAgICBkYXRhUm91dGVzLFxuICAgIGluaXQuaGlzdG9yeS5sb2NhdGlvbixcbiAgICBpbml0LmJhc2VuYW1lXG4gICk7XG4gIGxldCBpbml0aWFsRXJyb3JzOiBSb3V0ZURhdGEgfCBudWxsID0gbnVsbDtcblxuICBpZiAoaW5pdGlhbE1hdGNoZXMgPT0gbnVsbCkge1xuICAgIC8vIElmIHdlIGRvIG5vdCBtYXRjaCBhIHVzZXItcHJvdmlkZWQtcm91dGUsIGZhbGwgYmFjayB0byB0aGUgcm9vdFxuICAgIC8vIHRvIGFsbG93IHRoZSBlcnJvciBib3VuZGFyeSB0byB0YWtlIG92ZXJcbiAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwge1xuICAgICAgcGF0aG5hbWU6IGluaXQuaGlzdG9yeS5sb2NhdGlvbi5wYXRobmFtZSxcbiAgICB9KTtcbiAgICBsZXQgeyBtYXRjaGVzLCByb3V0ZSB9ID0gZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyhkYXRhUm91dGVzKTtcbiAgICBpbml0aWFsTWF0Y2hlcyA9IG1hdGNoZXM7XG4gICAgaW5pdGlhbEVycm9ycyA9IHsgW3JvdXRlLmlkXTogZXJyb3IgfTtcbiAgfVxuXG4gIGxldCBpbml0aWFsaXplZCA9XG4gICAgLy8gQWxsIGluaXRpYWxNYXRjaGVzIG5lZWQgdG8gYmUgbG9hZGVkIGJlZm9yZSB3ZSdyZSByZWFkeS4gIElmIHdlIGhhdmUgbGF6eVxuICAgIC8vIGZ1bmN0aW9ucyBhcm91bmQgc3RpbGwgdGhlbiB3ZSdsbCBuZWVkIHRvIHJ1biB0aGVtIGluIGluaXRpYWxpemUoKVxuICAgICFpbml0aWFsTWF0Y2hlcy5zb21lKChtKSA9PiBtLnJvdXRlLmxhenkpICYmXG4gICAgLy8gQW5kIHdlIGhhdmUgdG8gZWl0aGVyIGhhdmUgbm8gbG9hZGVycyBvciBoYXZlIGJlZW4gcHJvdmlkZWQgaHlkcmF0aW9uRGF0YVxuICAgICghaW5pdGlhbE1hdGNoZXMuc29tZSgobSkgPT4gbS5yb3V0ZS5sb2FkZXIpIHx8IGluaXQuaHlkcmF0aW9uRGF0YSAhPSBudWxsKTtcblxuICBsZXQgcm91dGVyOiBSb3V0ZXI7XG4gIGxldCBzdGF0ZTogUm91dGVyU3RhdGUgPSB7XG4gICAgaGlzdG9yeUFjdGlvbjogaW5pdC5oaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaW5pdC5oaXN0b3J5LmxvY2F0aW9uLFxuICAgIG1hdGNoZXM6IGluaXRpYWxNYXRjaGVzLFxuICAgIGluaXRpYWxpemVkLFxuICAgIG5hdmlnYXRpb246IElETEVfTkFWSUdBVElPTixcbiAgICAvLyBEb24ndCByZXN0b3JlIG9uIGluaXRpYWwgdXBkYXRlU3RhdGUoKSBpZiB3ZSB3ZXJlIFNTUidkXG4gICAgcmVzdG9yZVNjcm9sbFBvc2l0aW9uOiBpbml0Lmh5ZHJhdGlvbkRhdGEgIT0gbnVsbCA/IGZhbHNlIDogbnVsbCxcbiAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IGZhbHNlLFxuICAgIHJldmFsaWRhdGlvbjogXCJpZGxlXCIsXG4gICAgbG9hZGVyRGF0YTogKGluaXQuaHlkcmF0aW9uRGF0YSAmJiBpbml0Lmh5ZHJhdGlvbkRhdGEubG9hZGVyRGF0YSkgfHwge30sXG4gICAgYWN0aW9uRGF0YTogKGluaXQuaHlkcmF0aW9uRGF0YSAmJiBpbml0Lmh5ZHJhdGlvbkRhdGEuYWN0aW9uRGF0YSkgfHwgbnVsbCxcbiAgICBlcnJvcnM6IChpbml0Lmh5ZHJhdGlvbkRhdGEgJiYgaW5pdC5oeWRyYXRpb25EYXRhLmVycm9ycykgfHwgaW5pdGlhbEVycm9ycyxcbiAgICBmZXRjaGVyczogbmV3IE1hcCgpLFxuICAgIGJsb2NrZXJzOiBuZXcgTWFwKCksXG4gIH07XG5cbiAgLy8gLS0gU3RhdGVmdWwgaW50ZXJuYWwgdmFyaWFibGVzIHRvIG1hbmFnZSBuYXZpZ2F0aW9ucyAtLVxuICAvLyBDdXJyZW50IG5hdmlnYXRpb24gaW4gcHJvZ3Jlc3MgKHRvIGJlIGNvbW1pdHRlZCBpbiBjb21wbGV0ZU5hdmlnYXRpb24pXG4gIGxldCBwZW5kaW5nQWN0aW9uOiBIaXN0b3J5QWN0aW9uID0gSGlzdG9yeUFjdGlvbi5Qb3A7XG5cbiAgLy8gU2hvdWxkIHRoZSBjdXJyZW50IG5hdmlnYXRpb24gcHJldmVudCB0aGUgc2Nyb2xsIHJlc2V0IGlmIHNjcm9sbCBjYW5ub3RcbiAgLy8gYmUgcmVzdG9yZWQ/XG4gIGxldCBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0ID0gZmFsc2U7XG5cbiAgLy8gQWJvcnRDb250cm9sbGVyIGZvciB0aGUgYWN0aXZlIG5hdmlnYXRpb25cbiAgbGV0IHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyIHwgbnVsbDtcblxuICAvLyBXZSB1c2UgdGhpcyB0byBhdm9pZCB0b3VjaGluZyBoaXN0b3J5IGluIGNvbXBsZXRlTmF2aWdhdGlvbiBpZiBhXG4gIC8vIHJldmFsaWRhdGlvbiBpcyBlbnRpcmVseSB1bmludGVycnVwdGVkXG4gIGxldCBpc1VuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24gPSBmYWxzZTtcblxuICAvLyBVc2UgdGhpcyBpbnRlcm5hbCBmbGFnIHRvIGZvcmNlIHJldmFsaWRhdGlvbiBvZiBhbGwgbG9hZGVyczpcbiAgLy8gIC0gc3VibWlzc2lvbnMgKGNvbXBsZXRlZCBvciBpbnRlcnJ1cHRlZClcbiAgLy8gIC0gdXNlUmV2YWxpZGF0ZSgpXG4gIC8vICAtIFgtUmVtaXgtUmV2YWxpZGF0ZSAoZnJvbSByZWRpcmVjdClcbiAgbGV0IGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgPSBmYWxzZTtcblxuICAvLyBVc2UgdGhpcyBpbnRlcm5hbCBhcnJheSB0byBjYXB0dXJlIHJvdXRlcyB0aGF0IHJlcXVpcmUgcmV2YWxpZGF0aW9uIGR1ZVxuICAvLyB0byBhIGNhbmNlbGxlZCBkZWZlcnJlZCBvbiBhY3Rpb24gc3VibWlzc2lvblxuICBsZXQgY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXM6IHN0cmluZ1tdID0gW107XG5cbiAgLy8gVXNlIHRoaXMgaW50ZXJuYWwgYXJyYXkgdG8gY2FwdHVyZSBmZXRjaGVyIGxvYWRzIHRoYXQgd2VyZSBjYW5jZWxsZWQgYnkgYW5cbiAgLy8gYWN0aW9uIG5hdmlnYXRpb24gYW5kIHJlcXVpcmUgcmV2YWxpZGF0aW9uXG4gIGxldCBjYW5jZWxsZWRGZXRjaGVyTG9hZHM6IHN0cmluZ1tdID0gW107XG5cbiAgLy8gQWJvcnRDb250cm9sbGVycyBmb3IgYW55IGluLWZsaWdodCBmZXRjaGVyc1xuICBsZXQgZmV0Y2hDb250cm9sbGVycyA9IG5ldyBNYXA8c3RyaW5nLCBBYm9ydENvbnRyb2xsZXI+KCk7XG5cbiAgLy8gVHJhY2sgbG9hZHMgYmFzZWQgb24gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgc3RhcnRlZFxuICBsZXQgaW5jcmVtZW50aW5nTG9hZElkID0gMDtcblxuICAvLyBUcmFjayB0aGUgb3V0c3RhbmRpbmcgcGVuZGluZyBuYXZpZ2F0aW9uIGRhdGEgbG9hZCB0byBiZSBjb21wYXJlZCBhZ2FpbnN0XG4gIC8vIHRoZSBnbG9iYWxseSBpbmNyZW1lbnRpbmcgbG9hZCB3aGVuIGEgZmV0Y2hlciBsb2FkIGxhbmRzIGFmdGVyIGEgY29tcGxldGVkXG4gIC8vIG5hdmlnYXRpb25cbiAgbGV0IHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkID0gLTE7XG5cbiAgLy8gRmV0Y2hlcnMgdGhhdCB0cmlnZ2VyZWQgZGF0YSByZWxvYWRzIGFzIGEgcmVzdWx0IG9mIHRoZWlyIGFjdGlvbnNcbiAgbGV0IGZldGNoUmVsb2FkSWRzID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcblxuICAvLyBGZXRjaGVycyB0aGF0IHRyaWdnZXJlZCByZWRpcmVjdCBuYXZpZ2F0aW9ucyBmcm9tIHRoZWlyIGFjdGlvbnNcbiAgbGV0IGZldGNoUmVkaXJlY3RJZHMgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICAvLyBNb3N0IHJlY2VudCBocmVmL21hdGNoIGZvciBmZXRjaGVyLmxvYWQgY2FsbHMgZm9yIGZldGNoZXJzXG4gIGxldCBmZXRjaExvYWRNYXRjaGVzID0gbmV3IE1hcDxzdHJpbmcsIEZldGNoTG9hZE1hdGNoPigpO1xuXG4gIC8vIFN0b3JlIERlZmVycmVkRGF0YSBpbnN0YW5jZXMgZm9yIGFjdGl2ZSByb3V0ZSBtYXRjaGVzLiAgV2hlbiBhXG4gIC8vIHJvdXRlIGxvYWRlciByZXR1cm5zIGRlZmVyKCkgd2Ugc3RpY2sgb25lIGluIGhlcmUuICBUaGVuLCB3aGVuIGEgbmVzdGVkXG4gIC8vIHByb21pc2UgcmVzb2x2ZXMgd2UgdXBkYXRlIGxvYWRlckRhdGEuICBJZiBhIG5ldyBuYXZpZ2F0aW9uIHN0YXJ0cyB3ZVxuICAvLyBjYW5jZWwgYWN0aXZlIGRlZmVycmVkcyBmb3IgZWxpbWluYXRlZCByb3V0ZXMuXG4gIGxldCBhY3RpdmVEZWZlcnJlZHMgPSBuZXcgTWFwPHN0cmluZywgRGVmZXJyZWREYXRhPigpO1xuXG4gIC8vIFN0b3JlIGJsb2NrZXIgZnVuY3Rpb25zIGluIGEgc2VwYXJhdGUgTWFwIG91dHNpZGUgb2Ygcm91dGVyIHN0YXRlIHNpbmNlXG4gIC8vIHdlIGRvbid0IG5lZWQgdG8gdXBkYXRlIFVJIHN0YXRlIGlmIHRoZXkgY2hhbmdlXG4gIGxldCBibG9ja2VyRnVuY3Rpb25zID0gbmV3IE1hcDxzdHJpbmcsIEJsb2NrZXJGdW5jdGlvbj4oKTtcblxuICAvLyBGbGFnIHRvIGlnbm9yZSB0aGUgbmV4dCBoaXN0b3J5IHVwZGF0ZSwgc28gd2UgY2FuIHJldmVydCB0aGUgVVJMIGNoYW5nZSBvblxuICAvLyBhIFBPUCBuYXZpZ2F0aW9uIHRoYXQgd2FzIGJsb2NrZWQgYnkgdGhlIHVzZXIgd2l0aG91dCB0b3VjaGluZyByb3V0ZXIgc3RhdGVcbiAgbGV0IGlnbm9yZU5leHRIaXN0b3J5VXBkYXRlID0gZmFsc2U7XG5cbiAgLy8gSW5pdGlhbGl6ZSB0aGUgcm91dGVyLCBhbGwgc2lkZSBlZmZlY3RzIHNob3VsZCBiZSBraWNrZWQgb2ZmIGZyb20gaGVyZS5cbiAgLy8gSW1wbGVtZW50ZWQgYXMgYSBGbHVlbnQgQVBJIGZvciBlYXNlIG9mOlxuICAvLyAgIGxldCByb3V0ZXIgPSBjcmVhdGVSb3V0ZXIoaW5pdCkuaW5pdGlhbGl6ZSgpO1xuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIC8vIElmIGhpc3RvcnkgaW5mb3JtcyB1cyBvZiBhIFBPUCBuYXZpZ2F0aW9uLCBzdGFydCB0aGUgbmF2aWdhdGlvbiBidXQgZG8gbm90IHVwZGF0ZVxuICAgIC8vIHN0YXRlLiAgV2UnbGwgdXBkYXRlIG91ciBvd24gc3RhdGUgb25jZSB0aGUgbmF2aWdhdGlvbiBjb21wbGV0ZXNcbiAgICB1bmxpc3Rlbkhpc3RvcnkgPSBpbml0Lmhpc3RvcnkubGlzdGVuKFxuICAgICAgKHsgYWN0aW9uOiBoaXN0b3J5QWN0aW9uLCBsb2NhdGlvbiwgZGVsdGEgfSkgPT4ge1xuICAgICAgICAvLyBJZ25vcmUgdGhpcyBldmVudCBpZiBpdCB3YXMganVzdCB1cyByZXNldHRpbmcgdGhlIFVSTCBmcm9tIGFcbiAgICAgICAgLy8gYmxvY2tlZCBQT1AgbmF2aWdhdGlvblxuICAgICAgICBpZiAoaWdub3JlTmV4dEhpc3RvcnlVcGRhdGUpIHtcbiAgICAgICAgICBpZ25vcmVOZXh0SGlzdG9yeVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgYmxvY2tlckZ1bmN0aW9ucy5zaXplID09PSAwIHx8IGRlbHRhICE9IG51bGwsXG4gICAgICAgICAgXCJZb3UgYXJlIHRyeWluZyB0byB1c2UgYSBibG9ja2VyIG9uIGEgUE9QIG5hdmlnYXRpb24gdG8gYSBsb2NhdGlvbiBcIiArXG4gICAgICAgICAgICBcInRoYXQgd2FzIG5vdCBjcmVhdGVkIGJ5IEByZW1peC1ydW4vcm91dGVyLiBUaGlzIHdpbGwgZmFpbCBzaWxlbnRseSBpbiBcIiArXG4gICAgICAgICAgICBcInByb2R1Y3Rpb24uIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgYXJlIG5hdmlnYXRpbmcgb3V0c2lkZSB0aGUgcm91dGVyIFwiICtcbiAgICAgICAgICAgIFwidmlhIGB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGVgL2B3aW5kb3cubG9jYXRpb24uaGFzaGAgaW5zdGVhZCBvZiB1c2luZyBcIiArXG4gICAgICAgICAgICBcInJvdXRlciBuYXZpZ2F0aW9uIEFQSXMuICBUaGlzIGNhbiBhbHNvIGhhcHBlbiBpZiB5b3UgYXJlIHVzaW5nIFwiICtcbiAgICAgICAgICAgIFwiY3JlYXRlSGFzaFJvdXRlciBhbmQgdGhlIHVzZXIgbWFudWFsbHkgY2hhbmdlcyB0aGUgVVJMLlwiXG4gICAgICAgICk7XG5cbiAgICAgICAgbGV0IGJsb2NrZXJLZXkgPSBzaG91bGRCbG9ja05hdmlnYXRpb24oe1xuICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICAgICAgbmV4dExvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgICBoaXN0b3J5QWN0aW9uLFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoYmxvY2tlcktleSAmJiBkZWx0YSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gUmVzdG9yZSB0aGUgVVJMIHRvIG1hdGNoIHRoZSBjdXJyZW50IFVJLCBidXQgZG9uJ3QgdXBkYXRlIHJvdXRlciBzdGF0ZVxuICAgICAgICAgIGlnbm9yZU5leHRIaXN0b3J5VXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICBpbml0Lmhpc3RvcnkuZ28oZGVsdGEgKiAtMSk7XG5cbiAgICAgICAgICAvLyBQdXQgdGhlIGJsb2NrZXIgaW50byBhIGJsb2NrZWQgc3RhdGVcbiAgICAgICAgICB1cGRhdGVCbG9ja2VyKGJsb2NrZXJLZXksIHtcbiAgICAgICAgICAgIHN0YXRlOiBcImJsb2NrZWRcIixcbiAgICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgICAgcHJvY2VlZCgpIHtcbiAgICAgICAgICAgICAgdXBkYXRlQmxvY2tlcihibG9ja2VyS2V5ISwge1xuICAgICAgICAgICAgICAgIHN0YXRlOiBcInByb2NlZWRpbmdcIixcbiAgICAgICAgICAgICAgICBwcm9jZWVkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgcmVzZXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIC8vIFJlLWRvIHRoZSBzYW1lIFBPUCBuYXZpZ2F0aW9uIHdlIGp1c3QgYmxvY2tlZFxuICAgICAgICAgICAgICBpbml0Lmhpc3RvcnkuZ28oZGVsdGEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc2V0KCkge1xuICAgICAgICAgICAgICBkZWxldGVCbG9ja2VyKGJsb2NrZXJLZXkhKTtcbiAgICAgICAgICAgICAgdXBkYXRlU3RhdGUoeyBibG9ja2VyczogbmV3IE1hcChyb3V0ZXIuc3RhdGUuYmxvY2tlcnMpIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RhcnROYXZpZ2F0aW9uKGhpc3RvcnlBY3Rpb24sIGxvY2F0aW9uKTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgaWYgKHN0YXRlLmluaXRpYWxpemVkKSB7XG4gICAgICByZXR1cm4gcm91dGVyO1xuICAgIH1cblxuICAgIGxldCBsYXp5TWF0Y2hlcyA9IHN0YXRlLm1hdGNoZXMuZmlsdGVyKChtKSA9PiBtLnJvdXRlLmxhenkpO1xuXG4gICAgaWYgKGxhenlNYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gS2ljayBvZmYgaW5pdGlhbCBkYXRhIGxvYWQgaWYgbmVlZGVkLiAgVXNlIFBvcCB0byBhdm9pZCBtb2RpZnlpbmcgaGlzdG9yeVxuICAgICAgc3RhcnROYXZpZ2F0aW9uKEhpc3RvcnlBY3Rpb24uUG9wLCBzdGF0ZS5sb2NhdGlvbik7XG4gICAgICByZXR1cm4gcm91dGVyO1xuICAgIH1cblxuICAgIC8vIExvYWQgbGF6eSBtb2R1bGVzLCB0aGVuIGtpY2sgb2ZmIGluaXRpYWwgZGF0YSBsb2FkIGlmIG5lZWRlZFxuICAgIGxldCBsYXp5UHJvbWlzZXMgPSBsYXp5TWF0Y2hlcy5tYXAoKG0pID0+XG4gICAgICBsb2FkTGF6eVJvdXRlTW9kdWxlKG0ucm91dGUsIGRldGVjdEVycm9yQm91bmRhcnksIG1hbmlmZXN0KVxuICAgICk7XG4gICAgUHJvbWlzZS5hbGwobGF6eVByb21pc2VzKS50aGVuKCgpID0+IHtcbiAgICAgIGxldCBpbml0aWFsaXplZCA9XG4gICAgICAgICFzdGF0ZS5tYXRjaGVzLnNvbWUoKG0pID0+IG0ucm91dGUubG9hZGVyKSB8fFxuICAgICAgICBpbml0Lmh5ZHJhdGlvbkRhdGEgIT0gbnVsbDtcbiAgICAgIGlmIChpbml0aWFsaXplZCkge1xuICAgICAgICAvLyBXZSBhbHJlYWR5IGhhdmUgcmVxdWlyZWQgbG9hZGVyRGF0YSBzbyB3ZSBjYW4ganVzdCBzZXQgaW5pdGlhbGl6ZWRcbiAgICAgICAgdXBkYXRlU3RhdGUoeyBpbml0aWFsaXplZDogdHJ1ZSB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlIHN0aWxsIG5lZWQgdG8ga2ljayBvZmYgaW5pdGlhbCBkYXRhIGxvYWRzXG4gICAgICAgIHN0YXJ0TmF2aWdhdGlvbihIaXN0b3J5QWN0aW9uLlBvcCwgc3RhdGUubG9jYXRpb24pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJvdXRlcjtcbiAgfVxuXG4gIC8vIENsZWFuIHVwIGEgcm91dGVyIGFuZCBpdCdzIHNpZGUgZWZmZWN0c1xuICBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIGlmICh1bmxpc3Rlbkhpc3RvcnkpIHtcbiAgICAgIHVubGlzdGVuSGlzdG9yeSgpO1xuICAgIH1cbiAgICBzdWJzY3JpYmVycy5jbGVhcigpO1xuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciAmJiBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICBzdGF0ZS5mZXRjaGVycy5mb3JFYWNoKChfLCBrZXkpID0+IGRlbGV0ZUZldGNoZXIoa2V5KSk7XG4gICAgc3RhdGUuYmxvY2tlcnMuZm9yRWFjaCgoXywga2V5KSA9PiBkZWxldGVCbG9ja2VyKGtleSkpO1xuICB9XG5cbiAgLy8gU3Vic2NyaWJlIHRvIHN0YXRlIHVwZGF0ZXMgZm9yIHRoZSByb3V0ZXJcbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGZuOiBSb3V0ZXJTdWJzY3JpYmVyKSB7XG4gICAgc3Vic2NyaWJlcnMuYWRkKGZuKTtcbiAgICByZXR1cm4gKCkgPT4gc3Vic2NyaWJlcnMuZGVsZXRlKGZuKTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSBvdXIgc3RhdGUgYW5kIG5vdGlmeSB0aGUgY2FsbGluZyBjb250ZXh0IG9mIHRoZSBjaGFuZ2VcbiAgZnVuY3Rpb24gdXBkYXRlU3RhdGUobmV3U3RhdGU6IFBhcnRpYWw8Um91dGVyU3RhdGU+KTogdm9pZCB7XG4gICAgc3RhdGUgPSB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIC4uLm5ld1N0YXRlLFxuICAgIH07XG4gICAgc3Vic2NyaWJlcnMuZm9yRWFjaCgoc3Vic2NyaWJlcikgPT4gc3Vic2NyaWJlcihzdGF0ZSkpO1xuICB9XG5cbiAgLy8gQ29tcGxldGUgYSBuYXZpZ2F0aW9uIHJldHVybmluZyB0aGUgc3RhdGUubmF2aWdhdGlvbiBiYWNrIHRvIHRoZSBJRExFX05BVklHQVRJT05cbiAgLy8gYW5kIHNldHRpbmcgc3RhdGUuW2hpc3RvcnlBY3Rpb24vbG9jYXRpb24vbWF0Y2hlc10gdG8gdGhlIG5ldyByb3V0ZS5cbiAgLy8gLSBMb2NhdGlvbiBpcyBhIHJlcXVpcmVkIHBhcmFtXG4gIC8vIC0gTmF2aWdhdGlvbiB3aWxsIGFsd2F5cyBiZSBzZXQgdG8gSURMRV9OQVZJR0FUSU9OXG4gIC8vIC0gQ2FuIHBhc3MgYW55IG90aGVyIHN0YXRlIGluIG5ld1N0YXRlXG4gIGZ1bmN0aW9uIGNvbXBsZXRlTmF2aWdhdGlvbihcbiAgICBsb2NhdGlvbjogTG9jYXRpb24sXG4gICAgbmV3U3RhdGU6IFBhcnRpYWw8T21pdDxSb3V0ZXJTdGF0ZSwgXCJhY3Rpb25cIiB8IFwibG9jYXRpb25cIiB8IFwibmF2aWdhdGlvblwiPj5cbiAgKTogdm9pZCB7XG4gICAgLy8gRGVkdWNlIGlmIHdlJ3JlIGluIGEgbG9hZGluZy9hY3Rpb25SZWxvYWQgc3RhdGU6XG4gICAgLy8gLSBXZSBoYXZlIGNvbW1pdHRlZCBhY3Rpb25EYXRhIGluIHRoZSBzdG9yZVxuICAgIC8vIC0gVGhlIGN1cnJlbnQgbmF2aWdhdGlvbiB3YXMgYSBtdXRhdGlvbiBzdWJtaXNzaW9uXG4gICAgLy8gLSBXZSdyZSBwYXN0IHRoZSBzdWJtaXR0aW5nIHN0YXRlIGFuZCBpbnRvIHRoZSBsb2FkaW5nIHN0YXRlXG4gICAgLy8gLSBUaGUgbG9jYXRpb24gYmVpbmcgbG9hZGVkIGlzIG5vdCB0aGUgcmVzdWx0IG9mIGEgcmVkaXJlY3RcbiAgICBsZXQgaXNBY3Rpb25SZWxvYWQgPVxuICAgICAgc3RhdGUuYWN0aW9uRGF0YSAhPSBudWxsICYmXG4gICAgICBzdGF0ZS5uYXZpZ2F0aW9uLmZvcm1NZXRob2QgIT0gbnVsbCAmJlxuICAgICAgaXNNdXRhdGlvbk1ldGhvZChzdGF0ZS5uYXZpZ2F0aW9uLmZvcm1NZXRob2QpICYmXG4gICAgICBzdGF0ZS5uYXZpZ2F0aW9uLnN0YXRlID09PSBcImxvYWRpbmdcIiAmJlxuICAgICAgbG9jYXRpb24uc3RhdGU/Ll9pc1JlZGlyZWN0ICE9PSB0cnVlO1xuXG4gICAgbGV0IGFjdGlvbkRhdGE6IFJvdXRlRGF0YSB8IG51bGw7XG4gICAgaWYgKG5ld1N0YXRlLmFjdGlvbkRhdGEpIHtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhuZXdTdGF0ZS5hY3Rpb25EYXRhKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGFjdGlvbkRhdGEgPSBuZXdTdGF0ZS5hY3Rpb25EYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRW1wdHkgYWN0aW9uRGF0YSAtPiBjbGVhciBwcmlvciBhY3Rpb25EYXRhIGR1ZSB0byBhbiBhY3Rpb24gZXJyb3JcbiAgICAgICAgYWN0aW9uRGF0YSA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0FjdGlvblJlbG9hZCkge1xuICAgICAgLy8gS2VlcCB0aGUgY3VycmVudCBkYXRhIGlmIHdlJ3JlIHdyYXBwaW5nIHVwIHRoZSBhY3Rpb24gcmVsb2FkXG4gICAgICBhY3Rpb25EYXRhID0gc3RhdGUuYWN0aW9uRGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2xlYXIgYWN0aW9uRGF0YSBvbiBhbnkgb3RoZXIgY29tcGxldGVkIG5hdmlnYXRpb25zXG4gICAgICBhY3Rpb25EYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBBbHdheXMgcHJlc2VydmUgYW55IGV4aXN0aW5nIGxvYWRlckRhdGEgZnJvbSByZS11c2VkIHJvdXRlc1xuICAgIGxldCBsb2FkZXJEYXRhID0gbmV3U3RhdGUubG9hZGVyRGF0YVxuICAgICAgPyBtZXJnZUxvYWRlckRhdGEoXG4gICAgICAgICAgc3RhdGUubG9hZGVyRGF0YSxcbiAgICAgICAgICBuZXdTdGF0ZS5sb2FkZXJEYXRhLFxuICAgICAgICAgIG5ld1N0YXRlLm1hdGNoZXMgfHwgW10sXG4gICAgICAgICAgbmV3U3RhdGUuZXJyb3JzXG4gICAgICAgIClcbiAgICAgIDogc3RhdGUubG9hZGVyRGF0YTtcblxuICAgIC8vIE9uIGEgc3VjY2Vzc2Z1bCBuYXZpZ2F0aW9uIHdlIGNhbiBhc3N1bWUgd2UgZ290IHRocm91Z2ggYWxsIGJsb2NrZXJzXG4gICAgLy8gc28gd2UgY2FuIHN0YXJ0IGZyZXNoXG4gICAgZm9yIChsZXQgW2tleV0gb2YgYmxvY2tlckZ1bmN0aW9ucykge1xuICAgICAgZGVsZXRlQmxvY2tlcihrZXkpO1xuICAgIH1cblxuICAgIC8vIEFsd2F5cyByZXNwZWN0IHRoZSB1c2VyIGZsYWcuICBPdGhlcndpc2UgZG9uJ3QgcmVzZXQgb24gbXV0YXRpb25cbiAgICAvLyBzdWJtaXNzaW9uIG5hdmlnYXRpb25zIHVubGVzcyB0aGV5IHJlZGlyZWN0XG4gICAgbGV0IHByZXZlbnRTY3JvbGxSZXNldCA9XG4gICAgICBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0ID09PSB0cnVlIHx8XG4gICAgICAoc3RhdGUubmF2aWdhdGlvbi5mb3JtTWV0aG9kICE9IG51bGwgJiZcbiAgICAgICAgaXNNdXRhdGlvbk1ldGhvZChzdGF0ZS5uYXZpZ2F0aW9uLmZvcm1NZXRob2QpICYmXG4gICAgICAgIGxvY2F0aW9uLnN0YXRlPy5faXNSZWRpcmVjdCAhPT0gdHJ1ZSk7XG5cbiAgICBpZiAoaW5GbGlnaHREYXRhUm91dGVzKSB7XG4gICAgICBkYXRhUm91dGVzID0gaW5GbGlnaHREYXRhUm91dGVzO1xuICAgICAgaW5GbGlnaHREYXRhUm91dGVzID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgIC4uLm5ld1N0YXRlLCAvLyBtYXRjaGVzLCBlcnJvcnMsIGZldGNoZXJzIGdvIHRocm91Z2ggYXMtaXNcbiAgICAgIGFjdGlvbkRhdGEsXG4gICAgICBsb2FkZXJEYXRhLFxuICAgICAgaGlzdG9yeUFjdGlvbjogcGVuZGluZ0FjdGlvbixcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgaW5pdGlhbGl6ZWQ6IHRydWUsXG4gICAgICBuYXZpZ2F0aW9uOiBJRExFX05BVklHQVRJT04sXG4gICAgICByZXZhbGlkYXRpb246IFwiaWRsZVwiLFxuICAgICAgcmVzdG9yZVNjcm9sbFBvc2l0aW9uOiBnZXRTYXZlZFNjcm9sbFBvc2l0aW9uKFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgbmV3U3RhdGUubWF0Y2hlcyB8fCBzdGF0ZS5tYXRjaGVzXG4gICAgICApLFxuICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgYmxvY2tlcnM6IG5ldyBNYXAoc3RhdGUuYmxvY2tlcnMpLFxuICAgIH0pO1xuXG4gICAgaWYgKGlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbikge1xuICAgICAgLy8gSWYgdGhpcyB3YXMgYW4gdW5pbnRlcnJ1cHRlZCByZXZhbGlkYXRpb24gdGhlbiBkbyBub3QgdG91Y2ggaGlzdG9yeVxuICAgIH0gZWxzZSBpZiAocGVuZGluZ0FjdGlvbiA9PT0gSGlzdG9yeUFjdGlvbi5Qb3ApIHtcbiAgICAgIC8vIERvIG5vdGhpbmcgZm9yIFBPUCAtIFVSTCBoYXMgYWxyZWFkeSBiZWVuIHVwZGF0ZWRcbiAgICB9IGVsc2UgaWYgKHBlbmRpbmdBY3Rpb24gPT09IEhpc3RvcnlBY3Rpb24uUHVzaCkge1xuICAgICAgaW5pdC5oaXN0b3J5LnB1c2gobG9jYXRpb24sIGxvY2F0aW9uLnN0YXRlKTtcbiAgICB9IGVsc2UgaWYgKHBlbmRpbmdBY3Rpb24gPT09IEhpc3RvcnlBY3Rpb24uUmVwbGFjZSkge1xuICAgICAgaW5pdC5oaXN0b3J5LnJlcGxhY2UobG9jYXRpb24sIGxvY2F0aW9uLnN0YXRlKTtcbiAgICB9XG5cbiAgICAvLyBSZXNldCBzdGF0ZWZ1bCBuYXZpZ2F0aW9uIHZhcnNcbiAgICBwZW5kaW5nQWN0aW9uID0gSGlzdG9yeUFjdGlvbi5Qb3A7XG4gICAgcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCA9IGZhbHNlO1xuICAgIGlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiA9IGZhbHNlO1xuICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgPSBmYWxzZTtcbiAgICBjYW5jZWxsZWREZWZlcnJlZFJvdXRlcyA9IFtdO1xuICAgIGNhbmNlbGxlZEZldGNoZXJMb2FkcyA9IFtdO1xuICB9XG5cbiAgLy8gVHJpZ2dlciBhIG5hdmlnYXRpb24gZXZlbnQsIHdoaWNoIGNhbiBlaXRoZXIgYmUgYSBudW1lcmljYWwgUE9QIG9yIGEgUFVTSFxuICAvLyByZXBsYWNlIHdpdGggYW4gb3B0aW9uYWwgc3VibWlzc2lvblxuICBhc3luYyBmdW5jdGlvbiBuYXZpZ2F0ZShcbiAgICB0bzogbnVtYmVyIHwgVG8sXG4gICAgb3B0cz86IFJvdXRlck5hdmlnYXRlT3B0aW9uc1xuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodHlwZW9mIHRvID09PSBcIm51bWJlclwiKSB7XG4gICAgICBpbml0Lmhpc3RvcnkuZ28odG8pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCB7IHBhdGgsIHN1Ym1pc3Npb24sIGVycm9yIH0gPSBub3JtYWxpemVOYXZpZ2F0ZU9wdGlvbnModG8sIG9wdHMpO1xuXG4gICAgbGV0IGN1cnJlbnRMb2NhdGlvbiA9IHN0YXRlLmxvY2F0aW9uO1xuICAgIGxldCBuZXh0TG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihzdGF0ZS5sb2NhdGlvbiwgcGF0aCwgb3B0cyAmJiBvcHRzLnN0YXRlKTtcblxuICAgIC8vIFdoZW4gdXNpbmcgbmF2aWdhdGUgYXMgYSBQVVNIL1JFUExBQ0Ugd2UgYXJlbid0IHJlYWRpbmcgYW4gYWxyZWFkeS1lbmNvZGVkXG4gICAgLy8gVVJMIGZyb20gd2luZG93LmxvY2F0aW9uLCBzbyB3ZSBuZWVkIHRvIGVuY29kZSBpdCBoZXJlIHNvIHRoZSBiZWhhdmlvclxuICAgIC8vIHJlbWFpbnMgdGhlIHNhbWUgYXMgUE9QIGFuZCBub24tZGF0YS1yb3V0ZXIgdXNhZ2VzLiAgbmV3IFVSTCgpIGRvZXMgYWxsXG4gICAgLy8gdGhlIHNhbWUgZW5jb2Rpbmcgd2UnZCBnZXQgZnJvbSBhIGhpc3RvcnkucHVzaFN0YXRlL3dpbmRvdy5sb2NhdGlvbiByZWFkXG4gICAgLy8gd2l0aG91dCBoYXZpbmcgdG8gdG91Y2ggaGlzdG9yeVxuICAgIG5leHRMb2NhdGlvbiA9IHtcbiAgICAgIC4uLm5leHRMb2NhdGlvbixcbiAgICAgIC4uLmluaXQuaGlzdG9yeS5lbmNvZGVMb2NhdGlvbihuZXh0TG9jYXRpb24pLFxuICAgIH07XG5cbiAgICBsZXQgdXNlclJlcGxhY2UgPSBvcHRzICYmIG9wdHMucmVwbGFjZSAhPSBudWxsID8gb3B0cy5yZXBsYWNlIDogdW5kZWZpbmVkO1xuXG4gICAgbGV0IGhpc3RvcnlBY3Rpb24gPSBIaXN0b3J5QWN0aW9uLlB1c2g7XG5cbiAgICBpZiAodXNlclJlcGxhY2UgPT09IHRydWUpIHtcbiAgICAgIGhpc3RvcnlBY3Rpb24gPSBIaXN0b3J5QWN0aW9uLlJlcGxhY2U7XG4gICAgfSBlbHNlIGlmICh1c2VyUmVwbGFjZSA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIG5vLW9wXG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHN1Ym1pc3Npb24gIT0gbnVsbCAmJlxuICAgICAgaXNNdXRhdGlvbk1ldGhvZChzdWJtaXNzaW9uLmZvcm1NZXRob2QpICYmXG4gICAgICBzdWJtaXNzaW9uLmZvcm1BY3Rpb24gPT09IHN0YXRlLmxvY2F0aW9uLnBhdGhuYW1lICsgc3RhdGUubG9jYXRpb24uc2VhcmNoXG4gICAgKSB7XG4gICAgICAvLyBCeSBkZWZhdWx0IG9uIHN1Ym1pc3Npb25zIHRvIHRoZSBjdXJyZW50IGxvY2F0aW9uIHdlIFJFUExBQ0Ugc28gdGhhdFxuICAgICAgLy8gdXNlcnMgZG9uJ3QgaGF2ZSB0byBkb3VibGUtY2xpY2sgdGhlIGJhY2sgYnV0dG9uIHRvIGdldCB0byB0aGUgcHJpb3JcbiAgICAgIC8vIGxvY2F0aW9uLiAgSWYgdGhlIHVzZXIgcmVkaXJlY3RzIHRvIGEgZGlmZmVyZW50IGxvY2F0aW9uIGZyb20gdGhlXG4gICAgICAvLyBhY3Rpb24vbG9hZGVyIHRoaXMgd2lsbCBiZSBpZ25vcmVkIGFuZCB0aGUgcmVkaXJlY3Qgd2lsbCBiZSBhIFBVU0hcbiAgICAgIGhpc3RvcnlBY3Rpb24gPSBIaXN0b3J5QWN0aW9uLlJlcGxhY2U7XG4gICAgfVxuXG4gICAgbGV0IHByZXZlbnRTY3JvbGxSZXNldCA9XG4gICAgICBvcHRzICYmIFwicHJldmVudFNjcm9sbFJlc2V0XCIgaW4gb3B0c1xuICAgICAgICA/IG9wdHMucHJldmVudFNjcm9sbFJlc2V0ID09PSB0cnVlXG4gICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgbGV0IGJsb2NrZXJLZXkgPSBzaG91bGRCbG9ja05hdmlnYXRpb24oe1xuICAgICAgY3VycmVudExvY2F0aW9uLFxuICAgICAgbmV4dExvY2F0aW9uLFxuICAgICAgaGlzdG9yeUFjdGlvbixcbiAgICB9KTtcbiAgICBpZiAoYmxvY2tlcktleSkge1xuICAgICAgLy8gUHV0IHRoZSBibG9ja2VyIGludG8gYSBibG9ja2VkIHN0YXRlXG4gICAgICB1cGRhdGVCbG9ja2VyKGJsb2NrZXJLZXksIHtcbiAgICAgICAgc3RhdGU6IFwiYmxvY2tlZFwiLFxuICAgICAgICBsb2NhdGlvbjogbmV4dExvY2F0aW9uLFxuICAgICAgICBwcm9jZWVkKCkge1xuICAgICAgICAgIHVwZGF0ZUJsb2NrZXIoYmxvY2tlcktleSEsIHtcbiAgICAgICAgICAgIHN0YXRlOiBcInByb2NlZWRpbmdcIixcbiAgICAgICAgICAgIHByb2NlZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHJlc2V0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBsb2NhdGlvbjogbmV4dExvY2F0aW9uLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8vIFNlbmQgdGhlIHNhbWUgbmF2aWdhdGlvbiB0aHJvdWdoXG4gICAgICAgICAgbmF2aWdhdGUodG8sIG9wdHMpO1xuICAgICAgICB9LFxuICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICBkZWxldGVCbG9ja2VyKGJsb2NrZXJLZXkhKTtcbiAgICAgICAgICB1cGRhdGVTdGF0ZSh7IGJsb2NrZXJzOiBuZXcgTWFwKHN0YXRlLmJsb2NrZXJzKSB9KTtcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCBzdGFydE5hdmlnYXRpb24oaGlzdG9yeUFjdGlvbiwgbmV4dExvY2F0aW9uLCB7XG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgLy8gU2VuZCB0aHJvdWdoIHRoZSBmb3JtRGF0YSBzZXJpYWxpemF0aW9uIGVycm9yIGlmIHdlIGhhdmUgb25lIHNvIHdlIGNhblxuICAgICAgLy8gcmVuZGVyIGF0IHRoZSByaWdodCBlcnJvciBib3VuZGFyeSBhZnRlciB3ZSBtYXRjaCByb3V0ZXNcbiAgICAgIHBlbmRpbmdFcnJvcjogZXJyb3IsXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICByZXBsYWNlOiBvcHRzICYmIG9wdHMucmVwbGFjZSxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFJldmFsaWRhdGUgYWxsIGN1cnJlbnQgbG9hZGVycy4gIElmIGEgbmF2aWdhdGlvbiBpcyBpbiBwcm9ncmVzcyBvciBpZiB0aGlzXG4gIC8vIGlzIGludGVycnVwdGVkIGJ5IGEgbmF2aWdhdGlvbiwgYWxsb3cgdGhpcyB0byBcInN1Y2NlZWRcIiBieSBjYWxsaW5nIGFsbFxuICAvLyBsb2FkZXJzIGR1cmluZyB0aGUgbmV4dCBsb2FkZXIgcm91bmRcbiAgZnVuY3Rpb24gcmV2YWxpZGF0ZSgpIHtcbiAgICBpbnRlcnJ1cHRBY3RpdmVMb2FkcygpO1xuICAgIHVwZGF0ZVN0YXRlKHsgcmV2YWxpZGF0aW9uOiBcImxvYWRpbmdcIiB9KTtcblxuICAgIC8vIElmIHdlJ3JlIGN1cnJlbnRseSBzdWJtaXR0aW5nIGFuIGFjdGlvbiwgd2UgZG9uJ3QgbmVlZCB0byBzdGFydCBhIG5ld1xuICAgIC8vIG5hdmlnYXRpb24sIHdlJ2xsIGp1c3QgbGV0IHRoZSBmb2xsb3cgdXAgbG9hZGVyIGV4ZWN1dGlvbiBjYWxsIGFsbCBsb2FkZXJzXG4gICAgaWYgKHN0YXRlLm5hdmlnYXRpb24uc3RhdGUgPT09IFwic3VibWl0dGluZ1wiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgd2UncmUgY3VycmVudGx5IGluIGFuIGlkbGUgc3RhdGUsIHN0YXJ0IGEgbmV3IG5hdmlnYXRpb24gZm9yIHRoZSBjdXJyZW50XG4gICAgLy8gYWN0aW9uL2xvY2F0aW9uIGFuZCBtYXJrIGl0IGFzIHVuaW50ZXJydXB0ZWQsIHdoaWNoIHdpbGwgc2tpcCB0aGUgaGlzdG9yeVxuICAgIC8vIHVwZGF0ZSBpbiBjb21wbGV0ZU5hdmlnYXRpb25cbiAgICBpZiAoc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJpZGxlXCIpIHtcbiAgICAgIHN0YXJ0TmF2aWdhdGlvbihzdGF0ZS5oaXN0b3J5QWN0aW9uLCBzdGF0ZS5sb2NhdGlvbiwge1xuICAgICAgICBzdGFydFVuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb246IHRydWUsXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIGlmIHdlJ3JlIGN1cnJlbnRseSBpbiBhIGxvYWRpbmcgc3RhdGUsIGp1c3Qgc3RhcnQgYSBuZXdcbiAgICAvLyBuYXZpZ2F0aW9uIHRvIHRoZSBuYXZpZ2F0aW9uLmxvY2F0aW9uIGJ1dCBkbyBub3QgdHJpZ2dlciBhbiB1bmludGVycnVwdGVkXG4gICAgLy8gcmV2YWxpZGF0aW9uIHNvIHRoYXQgaGlzdG9yeSBjb3JyZWN0bHkgdXBkYXRlcyBvbmNlIHRoZSBuYXZpZ2F0aW9uIGNvbXBsZXRlc1xuICAgIHN0YXJ0TmF2aWdhdGlvbihcbiAgICAgIHBlbmRpbmdBY3Rpb24gfHwgc3RhdGUuaGlzdG9yeUFjdGlvbixcbiAgICAgIHN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24sXG4gICAgICB7IG92ZXJyaWRlTmF2aWdhdGlvbjogc3RhdGUubmF2aWdhdGlvbiB9XG4gICAgKTtcbiAgfVxuXG4gIC8vIFN0YXJ0IGEgbmF2aWdhdGlvbiB0byB0aGUgZ2l2ZW4gYWN0aW9uL2xvY2F0aW9uLiAgQ2FuIG9wdGlvbmFsbHkgcHJvdmlkZSBhXG4gIC8vIG92ZXJyaWRlTmF2aWdhdGlvbiB3aGljaCB3aWxsIG92ZXJyaWRlIHRoZSBub3JtYWxMb2FkIGluIHRoZSBjYXNlIG9mIGEgcmVkaXJlY3RcbiAgLy8gbmF2aWdhdGlvblxuICBhc3luYyBmdW5jdGlvbiBzdGFydE5hdmlnYXRpb24oXG4gICAgaGlzdG9yeUFjdGlvbjogSGlzdG9yeUFjdGlvbixcbiAgICBsb2NhdGlvbjogTG9jYXRpb24sXG4gICAgb3B0cz86IHtcbiAgICAgIHN1Ym1pc3Npb24/OiBTdWJtaXNzaW9uO1xuICAgICAgb3ZlcnJpZGVOYXZpZ2F0aW9uPzogTmF2aWdhdGlvbjtcbiAgICAgIHBlbmRpbmdFcnJvcj86IEVycm9yUmVzcG9uc2U7XG4gICAgICBzdGFydFVuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24/OiBib29sZWFuO1xuICAgICAgcHJldmVudFNjcm9sbFJlc2V0PzogYm9vbGVhbjtcbiAgICAgIHJlcGxhY2U/OiBib29sZWFuO1xuICAgIH1cbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gQWJvcnQgYW55IGluLXByb2dyZXNzIG5hdmlnYXRpb25zIGFuZCBzdGFydCBhIG5ldyBvbmUuIFVuc2V0IGFueSBvbmdvaW5nXG4gICAgLy8gdW5pbnRlcnJ1cHRlZCByZXZhbGlkYXRpb25zIHVubGVzcyB0b2xkIG90aGVyd2lzZSwgc2luY2Ugd2Ugd2FudCB0aGlzXG4gICAgLy8gbmV3IG5hdmlnYXRpb24gdG8gdXBkYXRlIGhpc3Rvcnkgbm9ybWFsbHlcbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgJiYgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyLmFib3J0KCk7XG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyID0gbnVsbDtcbiAgICBwZW5kaW5nQWN0aW9uID0gaGlzdG9yeUFjdGlvbjtcbiAgICBpc1VuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24gPVxuICAgICAgKG9wdHMgJiYgb3B0cy5zdGFydFVuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24pID09PSB0cnVlO1xuXG4gICAgLy8gU2F2ZSB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb24gZXZlcnkgdGltZSB3ZSBzdGFydCBhIG5ldyBuYXZpZ2F0aW9uLFxuICAgIC8vIGFuZCB0cmFjayB3aGV0aGVyIHdlIHNob3VsZCByZXNldCBzY3JvbGwgb24gY29tcGxldGlvblxuICAgIHNhdmVTY3JvbGxQb3NpdGlvbihzdGF0ZS5sb2NhdGlvbiwgc3RhdGUubWF0Y2hlcyk7XG4gICAgcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCA9IChvcHRzICYmIG9wdHMucHJldmVudFNjcm9sbFJlc2V0KSA9PT0gdHJ1ZTtcblxuICAgIGxldCByb3V0ZXNUb1VzZSA9IGluRmxpZ2h0RGF0YVJvdXRlcyB8fCBkYXRhUm91dGVzO1xuICAgIGxldCBsb2FkaW5nTmF2aWdhdGlvbiA9IG9wdHMgJiYgb3B0cy5vdmVycmlkZU5hdmlnYXRpb247XG4gICAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhyb3V0ZXNUb1VzZSwgbG9jYXRpb24sIGluaXQuYmFzZW5hbWUpO1xuXG4gICAgLy8gU2hvcnQgY2lyY3VpdCB3aXRoIGEgNDA0IG9uIHRoZSByb290IGVycm9yIGJvdW5kYXJ5IGlmIHdlIG1hdGNoIG5vdGhpbmdcbiAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7IHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSB9KTtcbiAgICAgIGxldCB7IG1hdGNoZXM6IG5vdEZvdW5kTWF0Y2hlcywgcm91dGUgfSA9XG4gICAgICAgIGdldFNob3J0Q2lyY3VpdE1hdGNoZXMocm91dGVzVG9Vc2UpO1xuICAgICAgLy8gQ2FuY2VsIGFsbCBwZW5kaW5nIGRlZmVycmVkIG9uIDQwNHMgc2luY2Ugd2UgZG9uJ3Qga2VlcCBhbnkgcm91dGVzXG4gICAgICBjYW5jZWxBY3RpdmVEZWZlcnJlZHMoKTtcbiAgICAgIGNvbXBsZXRlTmF2aWdhdGlvbihsb2NhdGlvbiwge1xuICAgICAgICBtYXRjaGVzOiBub3RGb3VuZE1hdGNoZXMsXG4gICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICBbcm91dGUuaWRdOiBlcnJvcixcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNob3J0IGNpcmN1aXQgaWYgaXQncyBvbmx5IGEgaGFzaCBjaGFuZ2UgYW5kIG5vdCBhIG11dGF0aW9uIHN1Ym1pc3Npb25cbiAgICAvLyBGb3IgZXhhbXBsZSwgb24gL3BhZ2UjaGFzaCBhbmQgc3VibWl0IGEgPEZvcm0gbWV0aG9kPVwicG9zdFwiPiB3aGljaCB3aWxsXG4gICAgLy8gZGVmYXVsdCB0byBhIG5hdmlnYXRpb24gdG8gL3BhZ2VcbiAgICBpZiAoXG4gICAgICBpc0hhc2hDaGFuZ2VPbmx5KHN0YXRlLmxvY2F0aW9uLCBsb2NhdGlvbikgJiZcbiAgICAgICEob3B0cyAmJiBvcHRzLnN1Ym1pc3Npb24gJiYgaXNNdXRhdGlvbk1ldGhvZChvcHRzLnN1Ym1pc3Npb24uZm9ybU1ldGhvZCkpXG4gICAgKSB7XG4gICAgICBjb21wbGV0ZU5hdmlnYXRpb24obG9jYXRpb24sIHsgbWF0Y2hlcyB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYSBjb250cm9sbGVyL1JlcXVlc3QgZm9yIHRoaXMgbmF2aWdhdGlvblxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBsZXQgcmVxdWVzdCA9IGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KFxuICAgICAgaW5pdC5oaXN0b3J5LFxuICAgICAgbG9jYXRpb24sXG4gICAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgb3B0cyAmJiBvcHRzLnN1Ym1pc3Npb25cbiAgICApO1xuICAgIGxldCBwZW5kaW5nQWN0aW9uRGF0YTogUm91dGVEYXRhIHwgdW5kZWZpbmVkO1xuICAgIGxldCBwZW5kaW5nRXJyb3I6IFJvdXRlRGF0YSB8IHVuZGVmaW5lZDtcblxuICAgIGlmIChvcHRzICYmIG9wdHMucGVuZGluZ0Vycm9yKSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIGEgcGVuZGluZ0Vycm9yLCBpdCBtZWFucyB0aGUgdXNlciBhdHRlbXB0ZWQgYSBHRVQgc3VibWlzc2lvblxuICAgICAgLy8gd2l0aCBiaW5hcnkgRm9ybURhdGEgc28gYXNzaWduIGhlcmUgYW5kIHNraXAgdG8gaGFuZGxlTG9hZGVycy4gIFRoYXRcbiAgICAgIC8vIHdheSB3ZSBoYW5kbGUgY2FsbGluZyBsb2FkZXJzIGFib3ZlIHRoZSBib3VuZGFyeSBldGMuICBJdCdzIG5vdCByZWFsbHlcbiAgICAgIC8vIGRpZmZlcmVudCBmcm9tIGFuIGFjdGlvbkVycm9yIGluIHRoYXQgc2Vuc2UuXG4gICAgICBwZW5kaW5nRXJyb3IgPSB7XG4gICAgICAgIFtmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoZXMpLnJvdXRlLmlkXTogb3B0cy5wZW5kaW5nRXJyb3IsXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBvcHRzICYmXG4gICAgICBvcHRzLnN1Ym1pc3Npb24gJiZcbiAgICAgIGlzTXV0YXRpb25NZXRob2Qob3B0cy5zdWJtaXNzaW9uLmZvcm1NZXRob2QpXG4gICAgKSB7XG4gICAgICAvLyBDYWxsIGFjdGlvbiBpZiB3ZSByZWNlaXZlZCBhbiBhY3Rpb24gc3VibWlzc2lvblxuICAgICAgbGV0IGFjdGlvbk91dHB1dCA9IGF3YWl0IGhhbmRsZUFjdGlvbihcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIG9wdHMuc3VibWlzc2lvbixcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgeyByZXBsYWNlOiBvcHRzLnJlcGxhY2UgfVxuICAgICAgKTtcblxuICAgICAgaWYgKGFjdGlvbk91dHB1dC5zaG9ydENpcmN1aXRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHBlbmRpbmdBY3Rpb25EYXRhID0gYWN0aW9uT3V0cHV0LnBlbmRpbmdBY3Rpb25EYXRhO1xuICAgICAgcGVuZGluZ0Vycm9yID0gYWN0aW9uT3V0cHV0LnBlbmRpbmdBY3Rpb25FcnJvcjtcblxuICAgICAgbGV0IG5hdmlnYXRpb246IE5hdmlnYXRpb25TdGF0ZXNbXCJMb2FkaW5nXCJdID0ge1xuICAgICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAuLi5vcHRzLnN1Ym1pc3Npb24sXG4gICAgICB9O1xuICAgICAgbG9hZGluZ05hdmlnYXRpb24gPSBuYXZpZ2F0aW9uO1xuXG4gICAgICAvLyBDcmVhdGUgYSBHRVQgcmVxdWVzdCBmb3IgdGhlIGxvYWRlcnNcbiAgICAgIHJlcXVlc3QgPSBuZXcgUmVxdWVzdChyZXF1ZXN0LnVybCwgeyBzaWduYWw6IHJlcXVlc3Quc2lnbmFsIH0pO1xuICAgIH1cblxuICAgIC8vIENhbGwgbG9hZGVyc1xuICAgIGxldCB7IHNob3J0Q2lyY3VpdGVkLCBsb2FkZXJEYXRhLCBlcnJvcnMgfSA9IGF3YWl0IGhhbmRsZUxvYWRlcnMoXG4gICAgICByZXF1ZXN0LFxuICAgICAgbG9jYXRpb24sXG4gICAgICBtYXRjaGVzLFxuICAgICAgbG9hZGluZ05hdmlnYXRpb24sXG4gICAgICBvcHRzICYmIG9wdHMuc3VibWlzc2lvbixcbiAgICAgIG9wdHMgJiYgb3B0cy5yZXBsYWNlLFxuICAgICAgcGVuZGluZ0FjdGlvbkRhdGEsXG4gICAgICBwZW5kaW5nRXJyb3JcbiAgICApO1xuXG4gICAgaWYgKHNob3J0Q2lyY3VpdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2xlYW4gdXAgbm93IHRoYXQgdGhlIGFjdGlvbi9sb2FkZXJzIGhhdmUgY29tcGxldGVkLiAgRG9uJ3QgY2xlYW4gdXAgaWZcbiAgICAvLyB3ZSBzaG9ydCBjaXJjdWl0ZWQgYmVjYXVzZSBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgd2lsbCBoYXZlIGFscmVhZHlcbiAgICAvLyBiZWVuIGFzc2lnbmVkIHRvIGEgbmV3IGNvbnRyb2xsZXIgZm9yIHRoZSBuZXh0IG5hdmlnYXRpb25cbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBudWxsO1xuXG4gICAgY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCB7XG4gICAgICBtYXRjaGVzLFxuICAgICAgLi4uKHBlbmRpbmdBY3Rpb25EYXRhID8geyBhY3Rpb25EYXRhOiBwZW5kaW5nQWN0aW9uRGF0YSB9IDoge30pLFxuICAgICAgbG9hZGVyRGF0YSxcbiAgICAgIGVycm9ycyxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIENhbGwgdGhlIGFjdGlvbiBtYXRjaGVkIGJ5IHRoZSBsZWFmIHJvdXRlIGZvciB0aGlzIG5hdmlnYXRpb24gYW5kIGhhbmRsZVxuICAvLyByZWRpcmVjdHMvZXJyb3JzXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUFjdGlvbihcbiAgICByZXF1ZXN0OiBSZXF1ZXN0LFxuICAgIGxvY2F0aW9uOiBMb2NhdGlvbixcbiAgICBzdWJtaXNzaW9uOiBTdWJtaXNzaW9uLFxuICAgIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgICBvcHRzPzogeyByZXBsYWNlPzogYm9vbGVhbiB9XG4gICk6IFByb21pc2U8SGFuZGxlQWN0aW9uUmVzdWx0PiB7XG4gICAgaW50ZXJydXB0QWN0aXZlTG9hZHMoKTtcblxuICAgIC8vIFB1dCB1cyBpbiBhIHN1Ym1pdHRpbmcgc3RhdGVcbiAgICBsZXQgbmF2aWdhdGlvbjogTmF2aWdhdGlvblN0YXRlc1tcIlN1Ym1pdHRpbmdcIl0gPSB7XG4gICAgICBzdGF0ZTogXCJzdWJtaXR0aW5nXCIsXG4gICAgICBsb2NhdGlvbixcbiAgICAgIC4uLnN1Ym1pc3Npb24sXG4gICAgfTtcbiAgICB1cGRhdGVTdGF0ZSh7IG5hdmlnYXRpb24gfSk7XG5cbiAgICAvLyBDYWxsIG91ciBhY3Rpb24gYW5kIGdldCB0aGUgcmVzdWx0XG4gICAgbGV0IHJlc3VsdDogRGF0YVJlc3VsdDtcbiAgICBsZXQgYWN0aW9uTWF0Y2ggPSBnZXRUYXJnZXRNYXRjaChtYXRjaGVzLCBsb2NhdGlvbik7XG5cbiAgICBpZiAoIWFjdGlvbk1hdGNoLnJvdXRlLmFjdGlvbiAmJiAhYWN0aW9uTWF0Y2gucm91dGUubGF6eSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLmVycm9yLFxuICAgICAgICBlcnJvcjogZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHtcbiAgICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICAgIHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgICAgICByb3V0ZUlkOiBhY3Rpb25NYXRjaC5yb3V0ZS5pZCxcbiAgICAgICAgfSksXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBhd2FpdCBjYWxsTG9hZGVyT3JBY3Rpb24oXG4gICAgICAgIFwiYWN0aW9uXCIsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGFjdGlvbk1hdGNoLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBtYW5pZmVzdCxcbiAgICAgICAgZGV0ZWN0RXJyb3JCb3VuZGFyeSxcbiAgICAgICAgcm91dGVyLmJhc2VuYW1lXG4gICAgICApO1xuXG4gICAgICBpZiAocmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCByZXBsYWNlOiBib29sZWFuO1xuICAgICAgaWYgKG9wdHMgJiYgb3B0cy5yZXBsYWNlICE9IG51bGwpIHtcbiAgICAgICAgcmVwbGFjZSA9IG9wdHMucmVwbGFjZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZSB1c2VyIGRpZG4ndCBleHBsaWNpdHkgaW5kaWNhdGUgcmVwbGFjZSBiZWhhdmlvciwgcmVwbGFjZSBpZlxuICAgICAgICAvLyB3ZSByZWRpcmVjdGVkIHRvIHRoZSBleGFjdCBzYW1lIGxvY2F0aW9uIHdlJ3JlIGN1cnJlbnRseSBhdCB0byBhdm9pZFxuICAgICAgICAvLyBkb3VibGUgYmFjay1idXR0b25zXG4gICAgICAgIHJlcGxhY2UgPVxuICAgICAgICAgIHJlc3VsdC5sb2NhdGlvbiA9PT0gc3RhdGUubG9jYXRpb24ucGF0aG5hbWUgKyBzdGF0ZS5sb2NhdGlvbi5zZWFyY2g7XG4gICAgICB9XG4gICAgICBhd2FpdCBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihzdGF0ZSwgcmVzdWx0LCB7IHN1Ym1pc3Npb24sIHJlcGxhY2UgfSk7XG4gICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgIH1cblxuICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIC8vIFN0b3JlIG9mZiB0aGUgcGVuZGluZyBlcnJvciAtIHdlIHVzZSBpdCB0byBkZXRlcm1pbmUgd2hpY2ggbG9hZGVyc1xuICAgICAgLy8gdG8gY2FsbCBhbmQgd2lsbCBjb21taXQgaXQgd2hlbiB3ZSBjb21wbGV0ZSB0aGUgbmF2aWdhdGlvblxuICAgICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoZXMsIGFjdGlvbk1hdGNoLnJvdXRlLmlkKTtcblxuICAgICAgLy8gQnkgZGVmYXVsdCwgYWxsIHN1Ym1pc3Npb25zIGFyZSBSRVBMQUNFIG5hdmlnYXRpb25zLCBidXQgaWYgdGhlXG4gICAgICAvLyBhY3Rpb24gdGhyZXcgYW4gZXJyb3IgdGhhdCdsbCBiZSByZW5kZXJlZCBpbiBhbiBlcnJvckVsZW1lbnQsIHdlIGZhbGxcbiAgICAgIC8vIGJhY2sgdG8gUFVTSCBzbyB0aGF0IHRoZSB1c2VyIGNhbiB1c2UgdGhlIGJhY2sgYnV0dG9uIHRvIGdldCBiYWNrIHRvXG4gICAgICAvLyB0aGUgcHJlLXN1Ym1pc3Npb24gZm9ybSBsb2NhdGlvbiB0byB0cnkgYWdhaW5cbiAgICAgIGlmICgob3B0cyAmJiBvcHRzLnJlcGxhY2UpICE9PSB0cnVlKSB7XG4gICAgICAgIHBlbmRpbmdBY3Rpb24gPSBIaXN0b3J5QWN0aW9uLlB1c2g7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC8vIFNlbmQgYmFjayBhbiBlbXB0eSBvYmplY3Qgd2UgY2FuIHVzZSB0byBjbGVhciBvdXQgYW55IHByaW9yIGFjdGlvbkRhdGFcbiAgICAgICAgcGVuZGluZ0FjdGlvbkRhdGE6IHt9LFxuICAgICAgICBwZW5kaW5nQWN0aW9uRXJyb3I6IHsgW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZXJyb3IgfSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGlzRGVmZXJyZWRSZXN1bHQocmVzdWx0KSkge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDAsIHsgdHlwZTogXCJkZWZlci1hY3Rpb25cIiB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGVuZGluZ0FjdGlvbkRhdGE6IHsgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmRhdGEgfSxcbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBhbGwgYXBwbGljYWJsZSBsb2FkZXJzIGZvciB0aGUgZ2l2ZW4gbWF0Y2hlcywgaGFuZGxpbmcgcmVkaXJlY3RzLFxuICAvLyBlcnJvcnMsIGV0Yy5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlTG9hZGVycyhcbiAgICByZXF1ZXN0OiBSZXF1ZXN0LFxuICAgIGxvY2F0aW9uOiBMb2NhdGlvbixcbiAgICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gICAgb3ZlcnJpZGVOYXZpZ2F0aW9uPzogTmF2aWdhdGlvbixcbiAgICBzdWJtaXNzaW9uPzogU3VibWlzc2lvbixcbiAgICByZXBsYWNlPzogYm9vbGVhbixcbiAgICBwZW5kaW5nQWN0aW9uRGF0YT86IFJvdXRlRGF0YSxcbiAgICBwZW5kaW5nRXJyb3I/OiBSb3V0ZURhdGFcbiAgKTogUHJvbWlzZTxIYW5kbGVMb2FkZXJzUmVzdWx0PiB7XG4gICAgLy8gRmlndXJlIG91dCB0aGUgcmlnaHQgbmF2aWdhdGlvbiB3ZSB3YW50IHRvIHVzZSBmb3IgZGF0YSBsb2FkaW5nXG4gICAgbGV0IGxvYWRpbmdOYXZpZ2F0aW9uID0gb3ZlcnJpZGVOYXZpZ2F0aW9uO1xuICAgIGlmICghbG9hZGluZ05hdmlnYXRpb24pIHtcbiAgICAgIGxldCBuYXZpZ2F0aW9uOiBOYXZpZ2F0aW9uU3RhdGVzW1wiTG9hZGluZ1wiXSA9IHtcbiAgICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgZm9ybU1ldGhvZDogdW5kZWZpbmVkLFxuICAgICAgICBmb3JtQWN0aW9uOiB1bmRlZmluZWQsXG4gICAgICAgIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQsXG4gICAgICAgIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gICAgICAgIC4uLnN1Ym1pc3Npb24sXG4gICAgICB9O1xuICAgICAgbG9hZGluZ05hdmlnYXRpb24gPSBuYXZpZ2F0aW9uO1xuICAgIH1cblxuICAgIC8vIElmIHRoaXMgd2FzIGEgcmVkaXJlY3QgZnJvbSBhbiBhY3Rpb24gd2UgZG9uJ3QgaGF2ZSBhIFwic3VibWlzc2lvblwiIGJ1dFxuICAgIC8vIHdlIGhhdmUgaXQgb24gdGhlIGxvYWRpbmcgbmF2aWdhdGlvbiBzbyB1c2UgdGhhdCBpZiBhdmFpbGFibGVcbiAgICBsZXQgYWN0aXZlU3VibWlzc2lvbiA9IHN1Ym1pc3Npb25cbiAgICAgID8gc3VibWlzc2lvblxuICAgICAgOiBsb2FkaW5nTmF2aWdhdGlvbi5mb3JtTWV0aG9kICYmXG4gICAgICAgIGxvYWRpbmdOYXZpZ2F0aW9uLmZvcm1BY3Rpb24gJiZcbiAgICAgICAgbG9hZGluZ05hdmlnYXRpb24uZm9ybURhdGEgJiZcbiAgICAgICAgbG9hZGluZ05hdmlnYXRpb24uZm9ybUVuY1R5cGVcbiAgICAgID8ge1xuICAgICAgICAgIGZvcm1NZXRob2Q6IGxvYWRpbmdOYXZpZ2F0aW9uLmZvcm1NZXRob2QsXG4gICAgICAgICAgZm9ybUFjdGlvbjogbG9hZGluZ05hdmlnYXRpb24uZm9ybUFjdGlvbixcbiAgICAgICAgICBmb3JtRGF0YTogbG9hZGluZ05hdmlnYXRpb24uZm9ybURhdGEsXG4gICAgICAgICAgZm9ybUVuY1R5cGU6IGxvYWRpbmdOYXZpZ2F0aW9uLmZvcm1FbmNUeXBlLFxuICAgICAgICB9XG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGxldCByb3V0ZXNUb1VzZSA9IGluRmxpZ2h0RGF0YVJvdXRlcyB8fCBkYXRhUm91dGVzO1xuICAgIGxldCBbbWF0Y2hlc1RvTG9hZCwgcmV2YWxpZGF0aW5nRmV0Y2hlcnNdID0gZ2V0TWF0Y2hlc1RvTG9hZChcbiAgICAgIGluaXQuaGlzdG9yeSxcbiAgICAgIHN0YXRlLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIGFjdGl2ZVN1Ym1pc3Npb24sXG4gICAgICBsb2NhdGlvbixcbiAgICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQsXG4gICAgICBjYW5jZWxsZWREZWZlcnJlZFJvdXRlcyxcbiAgICAgIGNhbmNlbGxlZEZldGNoZXJMb2FkcyxcbiAgICAgIGZldGNoTG9hZE1hdGNoZXMsXG4gICAgICByb3V0ZXNUb1VzZSxcbiAgICAgIGluaXQuYmFzZW5hbWUsXG4gICAgICBwZW5kaW5nQWN0aW9uRGF0YSxcbiAgICAgIHBlbmRpbmdFcnJvclxuICAgICk7XG5cbiAgICAvLyBDYW5jZWwgcGVuZGluZyBkZWZlcnJlZHMgZm9yIG5vLWxvbmdlci1tYXRjaGVkIHJvdXRlcyBvciByb3V0ZXMgd2UncmVcbiAgICAvLyBhYm91dCB0byByZWxvYWQuICBOb3RlIHRoYXQgaWYgdGhpcyBpcyBhbiBhY3Rpb24gcmVsb2FkIHdlIHdvdWxkIGhhdmVcbiAgICAvLyBhbHJlYWR5IGNhbmNlbGxlZCBhbGwgcGVuZGluZyBkZWZlcnJlZHMgc28gdGhpcyB3b3VsZCBiZSBhIG5vLW9wXG4gICAgY2FuY2VsQWN0aXZlRGVmZXJyZWRzKFxuICAgICAgKHJvdXRlSWQpID0+XG4gICAgICAgICEobWF0Y2hlcyAmJiBtYXRjaGVzLnNvbWUoKG0pID0+IG0ucm91dGUuaWQgPT09IHJvdXRlSWQpKSB8fFxuICAgICAgICAobWF0Y2hlc1RvTG9hZCAmJiBtYXRjaGVzVG9Mb2FkLnNvbWUoKG0pID0+IG0ucm91dGUuaWQgPT09IHJvdXRlSWQpKVxuICAgICk7XG5cbiAgICAvLyBTaG9ydCBjaXJjdWl0IGlmIHdlIGhhdmUgbm8gbG9hZGVycyB0byBydW5cbiAgICBpZiAobWF0Y2hlc1RvTG9hZC5sZW5ndGggPT09IDAgJiYgcmV2YWxpZGF0aW5nRmV0Y2hlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb21wbGV0ZU5hdmlnYXRpb24obG9jYXRpb24sIHtcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgIC8vIENvbW1pdCBwZW5kaW5nIGVycm9yIGlmIHdlJ3JlIHNob3J0IGNpcmN1aXRpbmdcbiAgICAgICAgZXJyb3JzOiBwZW5kaW5nRXJyb3IgfHwgbnVsbCxcbiAgICAgICAgLi4uKHBlbmRpbmdBY3Rpb25EYXRhID8geyBhY3Rpb25EYXRhOiBwZW5kaW5nQWN0aW9uRGF0YSB9IDoge30pLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgIH1cblxuICAgIC8vIElmIHRoaXMgaXMgYW4gdW5pbnRlcnJ1cHRlZCByZXZhbGlkYXRpb24sIHdlIHJlbWFpbiBpbiBvdXIgY3VycmVudCBpZGxlXG4gICAgLy8gc3RhdGUuICBJZiBub3QsIHdlIG5lZWQgdG8gc3dpdGNoIHRvIG91ciBsb2FkaW5nIHN0YXRlIGFuZCBsb2FkIGRhdGEsXG4gICAgLy8gcHJlc2VydmluZyBhbnkgbmV3IGFjdGlvbiBkYXRhIG9yIGV4aXN0aW5nIGFjdGlvbiBkYXRhIChpbiB0aGUgY2FzZSBvZlxuICAgIC8vIGEgcmV2YWxpZGF0aW9uIGludGVycnVwdGluZyBhbiBhY3Rpb25SZWxvYWQpXG4gICAgaWYgKCFpc1VuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24pIHtcbiAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2goKHJmKSA9PiB7XG4gICAgICAgIGxldCBmZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KHJmLmtleSk7XG4gICAgICAgIGxldCByZXZhbGlkYXRpbmdGZXRjaGVyOiBGZXRjaGVyU3RhdGVzW1wiTG9hZGluZ1wiXSA9IHtcbiAgICAgICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICAgICAgZGF0YTogZmV0Y2hlciAmJiBmZXRjaGVyLmRhdGEsXG4gICAgICAgICAgZm9ybU1ldGhvZDogdW5kZWZpbmVkLFxuICAgICAgICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgICAgICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkLFxuICAgICAgICAgIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gICAgICAgICAgXCIgX2hhc0ZldGNoZXJEb25lQW55dGhpbmcgXCI6IHRydWUsXG4gICAgICAgIH07XG4gICAgICAgIHN0YXRlLmZldGNoZXJzLnNldChyZi5rZXksIHJldmFsaWRhdGluZ0ZldGNoZXIpO1xuICAgICAgfSk7XG4gICAgICBsZXQgYWN0aW9uRGF0YSA9IHBlbmRpbmdBY3Rpb25EYXRhIHx8IHN0YXRlLmFjdGlvbkRhdGE7XG4gICAgICB1cGRhdGVTdGF0ZSh7XG4gICAgICAgIG5hdmlnYXRpb246IGxvYWRpbmdOYXZpZ2F0aW9uLFxuICAgICAgICAuLi4oYWN0aW9uRGF0YVxuICAgICAgICAgID8gT2JqZWN0LmtleXMoYWN0aW9uRGF0YSkubGVuZ3RoID09PSAwXG4gICAgICAgICAgICA/IHsgYWN0aW9uRGF0YTogbnVsbCB9XG4gICAgICAgICAgICA6IHsgYWN0aW9uRGF0YSB9XG4gICAgICAgICAgOiB7fSksXG4gICAgICAgIC4uLihyZXZhbGlkYXRpbmdGZXRjaGVycy5sZW5ndGggPiAwXG4gICAgICAgICAgPyB7IGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSB9XG4gICAgICAgICAgOiB7fSksXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCA9ICsraW5jcmVtZW50aW5nTG9hZElkO1xuICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2goKHJmKSA9PlxuICAgICAgZmV0Y2hDb250cm9sbGVycy5zZXQocmYua2V5LCBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIhKVxuICAgICk7XG5cbiAgICBsZXQgeyByZXN1bHRzLCBsb2FkZXJSZXN1bHRzLCBmZXRjaGVyUmVzdWx0cyB9ID1cbiAgICAgIGF3YWl0IGNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YShcbiAgICAgICAgc3RhdGUubWF0Y2hlcyxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgbWF0Y2hlc1RvTG9hZCxcbiAgICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMsXG4gICAgICAgIHJlcXVlc3RcbiAgICAgICk7XG5cbiAgICBpZiAocmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuIHsgc2hvcnRDaXJjdWl0ZWQ6IHRydWUgfTtcbiAgICB9XG5cbiAgICAvLyBDbGVhbiB1cCBfYWZ0ZXJfIGxvYWRlcnMgaGF2ZSBjb21wbGV0ZWQuICBEb24ndCBjbGVhbiB1cCBpZiB3ZSBzaG9ydFxuICAgIC8vIGNpcmN1aXRlZCBiZWNhdXNlIGZldGNoQ29udHJvbGxlcnMgd291bGQgaGF2ZSBiZWVuIGFib3J0ZWQgYW5kXG4gICAgLy8gcmVhc3NpZ25lZCB0byBuZXcgY29udHJvbGxlcnMgZm9yIHRoZSBuZXh0IG5hdmlnYXRpb25cbiAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKChyZikgPT4gZmV0Y2hDb250cm9sbGVycy5kZWxldGUocmYua2V5KSk7XG5cbiAgICAvLyBJZiBhbnkgbG9hZGVycyByZXR1cm5lZCBhIHJlZGlyZWN0IFJlc3BvbnNlLCBzdGFydCBhIG5ldyBSRVBMQUNFIG5hdmlnYXRpb25cbiAgICBsZXQgcmVkaXJlY3QgPSBmaW5kUmVkaXJlY3QocmVzdWx0cyk7XG4gICAgaWYgKHJlZGlyZWN0KSB7XG4gICAgICBhd2FpdCBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihzdGF0ZSwgcmVkaXJlY3QsIHsgcmVwbGFjZSB9KTtcbiAgICAgIHJldHVybiB7IHNob3J0Q2lyY3VpdGVkOiB0cnVlIH07XG4gICAgfVxuXG4gICAgLy8gUHJvY2VzcyBhbmQgY29tbWl0IG91dHB1dCBmcm9tIGxvYWRlcnNcbiAgICBsZXQgeyBsb2FkZXJEYXRhLCBlcnJvcnMgfSA9IHByb2Nlc3NMb2FkZXJEYXRhKFxuICAgICAgc3RhdGUsXG4gICAgICBtYXRjaGVzLFxuICAgICAgbWF0Y2hlc1RvTG9hZCxcbiAgICAgIGxvYWRlclJlc3VsdHMsXG4gICAgICBwZW5kaW5nRXJyb3IsXG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycyxcbiAgICAgIGZldGNoZXJSZXN1bHRzLFxuICAgICAgYWN0aXZlRGVmZXJyZWRzXG4gICAgKTtcblxuICAgIC8vIFdpcmUgdXAgc3Vic2NyaWJlcnMgdG8gdXBkYXRlIGxvYWRlckRhdGEgYXMgcHJvbWlzZXMgc2V0dGxlXG4gICAgYWN0aXZlRGVmZXJyZWRzLmZvckVhY2goKGRlZmVycmVkRGF0YSwgcm91dGVJZCkgPT4ge1xuICAgICAgZGVmZXJyZWREYXRhLnN1YnNjcmliZSgoYWJvcnRlZCkgPT4ge1xuICAgICAgICAvLyBOb3RlOiBObyBuZWVkIHRvIHVwZGF0ZVN0YXRlIGhlcmUgc2luY2UgdGhlIFRyYWNrZWRQcm9taXNlIG9uXG4gICAgICAgIC8vIGxvYWRlckRhdGEgaXMgc3RhYmxlIGFjcm9zcyByZXNvbHZlL3JlamVjdFxuICAgICAgICAvLyBSZW1vdmUgdGhpcyBpbnN0YW5jZSBpZiB3ZSB3ZXJlIGFib3J0ZWQgb3IgaWYgcHJvbWlzZXMgaGF2ZSBzZXR0bGVkXG4gICAgICAgIGlmIChhYm9ydGVkIHx8IGRlZmVycmVkRGF0YS5kb25lKSB7XG4gICAgICAgICAgYWN0aXZlRGVmZXJyZWRzLmRlbGV0ZShyb3V0ZUlkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBtYXJrRmV0Y2hSZWRpcmVjdHNEb25lKCk7XG4gICAgbGV0IGRpZEFib3J0RmV0Y2hMb2FkcyA9IGFib3J0U3RhbGVGZXRjaExvYWRzKHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkKTtcblxuICAgIHJldHVybiB7XG4gICAgICBsb2FkZXJEYXRhLFxuICAgICAgZXJyb3JzLFxuICAgICAgLi4uKGRpZEFib3J0RmV0Y2hMb2FkcyB8fCByZXZhbGlkYXRpbmdGZXRjaGVycy5sZW5ndGggPiAwXG4gICAgICAgID8geyBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycykgfVxuICAgICAgICA6IHt9KSxcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RmV0Y2hlcjxURGF0YSA9IGFueT4oa2V5OiBzdHJpbmcpOiBGZXRjaGVyPFREYXRhPiB7XG4gICAgcmV0dXJuIHN0YXRlLmZldGNoZXJzLmdldChrZXkpIHx8IElETEVfRkVUQ0hFUjtcbiAgfVxuXG4gIC8vIFRyaWdnZXIgYSBmZXRjaGVyIGxvYWQvc3VibWl0IGZvciB0aGUgZ2l2ZW4gZmV0Y2hlciBrZXlcbiAgZnVuY3Rpb24gZmV0Y2goXG4gICAga2V5OiBzdHJpbmcsXG4gICAgcm91dGVJZDogc3RyaW5nLFxuICAgIGhyZWY6IHN0cmluZyxcbiAgICBvcHRzPzogUm91dGVyRmV0Y2hPcHRpb25zXG4gICkge1xuICAgIGlmIChpc1NlcnZlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcInJvdXRlci5mZXRjaCgpIHdhcyBjYWxsZWQgZHVyaW5nIHRoZSBzZXJ2ZXIgcmVuZGVyLCBidXQgaXQgc2hvdWxkbid0IGJlLiBcIiArXG4gICAgICAgICAgXCJZb3UgYXJlIGxpa2VseSBjYWxsaW5nIGEgdXNlRmV0Y2hlcigpIG1ldGhvZCBpbiB0aGUgYm9keSBvZiB5b3VyIGNvbXBvbmVudC4gXCIgK1xuICAgICAgICAgIFwiVHJ5IG1vdmluZyBpdCB0byBhIHVzZUVmZmVjdCBvciBhIGNhbGxiYWNrLlwiXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmhhcyhrZXkpKSBhYm9ydEZldGNoZXIoa2V5KTtcblxuICAgIGxldCByb3V0ZXNUb1VzZSA9IGluRmxpZ2h0RGF0YVJvdXRlcyB8fCBkYXRhUm91dGVzO1xuICAgIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzVG9Vc2UsIGhyZWYsIGluaXQuYmFzZW5hbWUpO1xuICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgc2V0RmV0Y2hlckVycm9yKFxuICAgICAgICBrZXksXG4gICAgICAgIHJvdXRlSWQsXG4gICAgICAgIGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7IHBhdGhuYW1lOiBocmVmIH0pXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCB7IHBhdGgsIHN1Ym1pc3Npb24gfSA9IG5vcm1hbGl6ZU5hdmlnYXRlT3B0aW9ucyhocmVmLCBvcHRzLCB0cnVlKTtcbiAgICBsZXQgbWF0Y2ggPSBnZXRUYXJnZXRNYXRjaChtYXRjaGVzLCBwYXRoKTtcblxuICAgIHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQgPSAob3B0cyAmJiBvcHRzLnByZXZlbnRTY3JvbGxSZXNldCkgPT09IHRydWU7XG5cbiAgICBpZiAoc3VibWlzc2lvbiAmJiBpc011dGF0aW9uTWV0aG9kKHN1Ym1pc3Npb24uZm9ybU1ldGhvZCkpIHtcbiAgICAgIGhhbmRsZUZldGNoZXJBY3Rpb24oa2V5LCByb3V0ZUlkLCBwYXRoLCBtYXRjaCwgbWF0Y2hlcywgc3VibWlzc2lvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU3RvcmUgb2ZmIHRoZSBtYXRjaCBzbyB3ZSBjYW4gY2FsbCBpdCdzIHNob3VsZFJldmFsaWRhdGUgb24gc3Vic2VxdWVudFxuICAgIC8vIHJldmFsaWRhdGlvbnNcbiAgICBmZXRjaExvYWRNYXRjaGVzLnNldChrZXksIHsgcm91dGVJZCwgcGF0aCB9KTtcbiAgICBoYW5kbGVGZXRjaGVyTG9hZGVyKGtleSwgcm91dGVJZCwgcGF0aCwgbWF0Y2gsIG1hdGNoZXMsIHN1Ym1pc3Npb24pO1xuICB9XG5cbiAgLy8gQ2FsbCB0aGUgYWN0aW9uIGZvciB0aGUgbWF0Y2hlZCBmZXRjaGVyLnN1Ym1pdCgpLCBhbmQgdGhlbiBoYW5kbGUgcmVkaXJlY3RzLFxuICAvLyBlcnJvcnMsIGFuZCByZXZhbGlkYXRpb25cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlRmV0Y2hlckFjdGlvbihcbiAgICBrZXk6IHN0cmluZyxcbiAgICByb3V0ZUlkOiBzdHJpbmcsXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIG1hdGNoOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoLFxuICAgIHJlcXVlc3RNYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gICAgc3VibWlzc2lvbjogU3VibWlzc2lvblxuICApIHtcbiAgICBpbnRlcnJ1cHRBY3RpdmVMb2FkcygpO1xuICAgIGZldGNoTG9hZE1hdGNoZXMuZGVsZXRlKGtleSk7XG5cbiAgICBpZiAoIW1hdGNoLnJvdXRlLmFjdGlvbiAmJiAhbWF0Y2gucm91dGUubGF6eSkge1xuICAgICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHtcbiAgICAgICAgbWV0aG9kOiBzdWJtaXNzaW9uLmZvcm1NZXRob2QsXG4gICAgICAgIHBhdGhuYW1lOiBwYXRoLFxuICAgICAgICByb3V0ZUlkOiByb3V0ZUlkLFxuICAgICAgfSk7XG4gICAgICBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUHV0IHRoaXMgZmV0Y2hlciBpbnRvIGl0J3Mgc3VibWl0dGluZyBzdGF0ZVxuICAgIGxldCBleGlzdGluZ0ZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICBsZXQgZmV0Y2hlcjogRmV0Y2hlclN0YXRlc1tcIlN1Ym1pdHRpbmdcIl0gPSB7XG4gICAgICBzdGF0ZTogXCJzdWJtaXR0aW5nXCIsXG4gICAgICAuLi5zdWJtaXNzaW9uLFxuICAgICAgZGF0YTogZXhpc3RpbmdGZXRjaGVyICYmIGV4aXN0aW5nRmV0Y2hlci5kYXRhLFxuICAgICAgXCIgX2hhc0ZldGNoZXJEb25lQW55dGhpbmcgXCI6IHRydWUsXG4gICAgfTtcbiAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBmZXRjaGVyKTtcbiAgICB1cGRhdGVTdGF0ZSh7IGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSB9KTtcblxuICAgIC8vIENhbGwgdGhlIGFjdGlvbiBmb3IgdGhlIGZldGNoZXJcbiAgICBsZXQgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGxldCBmZXRjaFJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChcbiAgICAgIGluaXQuaGlzdG9yeSxcbiAgICAgIHBhdGgsXG4gICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgc3VibWlzc2lvblxuICAgICk7XG4gICAgZmV0Y2hDb250cm9sbGVycy5zZXQoa2V5LCBhYm9ydENvbnRyb2xsZXIpO1xuXG4gICAgbGV0IGFjdGlvblJlc3VsdCA9IGF3YWl0IGNhbGxMb2FkZXJPckFjdGlvbihcbiAgICAgIFwiYWN0aW9uXCIsXG4gICAgICBmZXRjaFJlcXVlc3QsXG4gICAgICBtYXRjaCxcbiAgICAgIHJlcXVlc3RNYXRjaGVzLFxuICAgICAgbWFuaWZlc3QsXG4gICAgICBkZXRlY3RFcnJvckJvdW5kYXJ5LFxuICAgICAgcm91dGVyLmJhc2VuYW1lXG4gICAgKTtcblxuICAgIGlmIChmZXRjaFJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIC8vIFdlIGNhbiBkZWxldGUgdGhpcyBzbyBsb25nIGFzIHdlIHdlcmVuJ3QgYWJvcnRlZCBieSBvdSBvdXIgb3duIGZldGNoZXJcbiAgICAgIC8vIHJlLXN1Ym1pdCB3aGljaCB3b3VsZCBoYXZlIHB1dCBfbmV3XyBjb250cm9sbGVyIGlzIGluIGZldGNoQ29udHJvbGxlcnNcbiAgICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmdldChrZXkpID09PSBhYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChhY3Rpb25SZXN1bHQpKSB7XG4gICAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgICAgZmV0Y2hSZWRpcmVjdElkcy5hZGQoa2V5KTtcbiAgICAgIGxldCBsb2FkaW5nRmV0Y2hlcjogRmV0Y2hlclN0YXRlc1tcIkxvYWRpbmdcIl0gPSB7XG4gICAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgICAgLi4uc3VibWlzc2lvbixcbiAgICAgICAgZGF0YTogdW5kZWZpbmVkLFxuICAgICAgICBcIiBfaGFzRmV0Y2hlckRvbmVBbnl0aGluZyBcIjogdHJ1ZSxcbiAgICAgIH07XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBsb2FkaW5nRmV0Y2hlcik7XG4gICAgICB1cGRhdGVTdGF0ZSh7IGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSB9KTtcblxuICAgICAgcmV0dXJuIHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHN0YXRlLCBhY3Rpb25SZXN1bHQsIHtcbiAgICAgICAgaXNGZXRjaEFjdGlvblJlZGlyZWN0OiB0cnVlLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gUHJvY2VzcyBhbnkgbm9uLXJlZGlyZWN0IGVycm9ycyB0aHJvd25cbiAgICBpZiAoaXNFcnJvclJlc3VsdChhY3Rpb25SZXN1bHQpKSB7XG4gICAgICBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBhY3Rpb25SZXN1bHQuZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc0RlZmVycmVkUmVzdWx0KGFjdGlvblJlc3VsdCkpIHtcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDAwLCB7IHR5cGU6IFwiZGVmZXItYWN0aW9uXCIgfSk7XG4gICAgfVxuXG4gICAgLy8gU3RhcnQgdGhlIGRhdGEgbG9hZCBmb3IgY3VycmVudCBtYXRjaGVzLCBvciB0aGUgbmV4dCBsb2NhdGlvbiBpZiB3ZSdyZVxuICAgIC8vIGluIHRoZSBtaWRkbGUgb2YgYSBuYXZpZ2F0aW9uXG4gICAgbGV0IG5leHRMb2NhdGlvbiA9IHN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24gfHwgc3RhdGUubG9jYXRpb247XG4gICAgbGV0IHJldmFsaWRhdGlvblJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChcbiAgICAgIGluaXQuaGlzdG9yeSxcblxuICAgICAgbmV4dExvY2F0aW9uLFxuICAgICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbFxuICAgICk7XG4gICAgbGV0IHJvdXRlc1RvVXNlID0gaW5GbGlnaHREYXRhUm91dGVzIHx8IGRhdGFSb3V0ZXM7XG4gICAgbGV0IG1hdGNoZXMgPVxuICAgICAgc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSAhPT0gXCJpZGxlXCJcbiAgICAgICAgPyBtYXRjaFJvdXRlcyhyb3V0ZXNUb1VzZSwgc3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbiwgaW5pdC5iYXNlbmFtZSlcbiAgICAgICAgOiBzdGF0ZS5tYXRjaGVzO1xuXG4gICAgaW52YXJpYW50KG1hdGNoZXMsIFwiRGlkbid0IGZpbmQgYW55IG1hdGNoZXMgYWZ0ZXIgZmV0Y2hlciBhY3Rpb25cIik7XG5cbiAgICBsZXQgbG9hZElkID0gKytpbmNyZW1lbnRpbmdMb2FkSWQ7XG4gICAgZmV0Y2hSZWxvYWRJZHMuc2V0KGtleSwgbG9hZElkKTtcblxuICAgIGxldCBsb2FkRmV0Y2hlcjogRmV0Y2hlclN0YXRlc1tcIkxvYWRpbmdcIl0gPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICBkYXRhOiBhY3Rpb25SZXN1bHQuZGF0YSxcbiAgICAgIC4uLnN1Ym1pc3Npb24sXG4gICAgICBcIiBfaGFzRmV0Y2hlckRvbmVBbnl0aGluZyBcIjogdHJ1ZSxcbiAgICB9O1xuICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGxvYWRGZXRjaGVyKTtcblxuICAgIGxldCBbbWF0Y2hlc1RvTG9hZCwgcmV2YWxpZGF0aW5nRmV0Y2hlcnNdID0gZ2V0TWF0Y2hlc1RvTG9hZChcbiAgICAgIGluaXQuaGlzdG9yeSxcbiAgICAgIHN0YXRlLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIHN1Ym1pc3Npb24sXG4gICAgICBuZXh0TG9jYXRpb24sXG4gICAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkLFxuICAgICAgY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXMsXG4gICAgICBjYW5jZWxsZWRGZXRjaGVyTG9hZHMsXG4gICAgICBmZXRjaExvYWRNYXRjaGVzLFxuICAgICAgcm91dGVzVG9Vc2UsXG4gICAgICBpbml0LmJhc2VuYW1lLFxuICAgICAgeyBbbWF0Y2gucm91dGUuaWRdOiBhY3Rpb25SZXN1bHQuZGF0YSB9LFxuICAgICAgdW5kZWZpbmVkIC8vIE5vIG5lZWQgdG8gc2VuZCB0aHJvdWdoIGVycm9ycyBzaW5jZSB3ZSBzaG9ydCBjaXJjdWl0IGFib3ZlXG4gICAgKTtcblxuICAgIC8vIFB1dCBhbGwgcmV2YWxpZGF0aW5nIGZldGNoZXJzIGludG8gdGhlIGxvYWRpbmcgc3RhdGUsIGV4Y2VwdCBmb3IgdGhlXG4gICAgLy8gY3VycmVudCBmZXRjaGVyIHdoaWNoIHdlIHdhbnQgdG8ga2VlcCBpbiBpdCdzIGN1cnJlbnQgbG9hZGluZyBzdGF0ZSB3aGljaFxuICAgIC8vIGNvbnRhaW5zIGl0J3MgYWN0aW9uIHN1Ym1pc3Npb24gaW5mbyArIGFjdGlvbiBkYXRhXG4gICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnNcbiAgICAgIC5maWx0ZXIoKHJmKSA9PiByZi5rZXkgIT09IGtleSlcbiAgICAgIC5mb3JFYWNoKChyZikgPT4ge1xuICAgICAgICBsZXQgc3RhbGVLZXkgPSByZi5rZXk7XG4gICAgICAgIGxldCBleGlzdGluZ0ZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoc3RhbGVLZXkpO1xuICAgICAgICBsZXQgcmV2YWxpZGF0aW5nRmV0Y2hlcjogRmV0Y2hlclN0YXRlc1tcIkxvYWRpbmdcIl0gPSB7XG4gICAgICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgICAgIGRhdGE6IGV4aXN0aW5nRmV0Y2hlciAmJiBleGlzdGluZ0ZldGNoZXIuZGF0YSxcbiAgICAgICAgICBmb3JtTWV0aG9kOiB1bmRlZmluZWQsXG4gICAgICAgICAgZm9ybUFjdGlvbjogdW5kZWZpbmVkLFxuICAgICAgICAgIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQsXG4gICAgICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAgICAgICAgICBcIiBfaGFzRmV0Y2hlckRvbmVBbnl0aGluZyBcIjogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgc3RhdGUuZmV0Y2hlcnMuc2V0KHN0YWxlS2V5LCByZXZhbGlkYXRpbmdGZXRjaGVyKTtcbiAgICAgICAgZmV0Y2hDb250cm9sbGVycy5zZXQoc3RhbGVLZXksIGFib3J0Q29udHJvbGxlcik7XG4gICAgICB9KTtcblxuICAgIHVwZGF0ZVN0YXRlKHsgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpIH0pO1xuXG4gICAgbGV0IHsgcmVzdWx0cywgbG9hZGVyUmVzdWx0cywgZmV0Y2hlclJlc3VsdHMgfSA9XG4gICAgICBhd2FpdCBjYWxsTG9hZGVyc0FuZE1heWJlUmVzb2x2ZURhdGEoXG4gICAgICAgIHN0YXRlLm1hdGNoZXMsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIG1hdGNoZXNUb0xvYWQsXG4gICAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLFxuICAgICAgICByZXZhbGlkYXRpb25SZXF1ZXN0XG4gICAgICApO1xuXG4gICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZldGNoUmVsb2FkSWRzLmRlbGV0ZShrZXkpO1xuICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKGtleSk7XG4gICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaCgocikgPT4gZmV0Y2hDb250cm9sbGVycy5kZWxldGUoci5rZXkpKTtcblxuICAgIGxldCByZWRpcmVjdCA9IGZpbmRSZWRpcmVjdChyZXN1bHRzKTtcbiAgICBpZiAocmVkaXJlY3QpIHtcbiAgICAgIHJldHVybiBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihzdGF0ZSwgcmVkaXJlY3QpO1xuICAgIH1cblxuICAgIC8vIFByb2Nlc3MgYW5kIGNvbW1pdCBvdXRwdXQgZnJvbSBsb2FkZXJzXG4gICAgbGV0IHsgbG9hZGVyRGF0YSwgZXJyb3JzIH0gPSBwcm9jZXNzTG9hZGVyRGF0YShcbiAgICAgIHN0YXRlLFxuICAgICAgc3RhdGUubWF0Y2hlcyxcbiAgICAgIG1hdGNoZXNUb0xvYWQsXG4gICAgICBsb2FkZXJSZXN1bHRzLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMsXG4gICAgICBmZXRjaGVyUmVzdWx0cyxcbiAgICAgIGFjdGl2ZURlZmVycmVkc1xuICAgICk7XG5cbiAgICBsZXQgZG9uZUZldGNoZXI6IEZldGNoZXJTdGF0ZXNbXCJJZGxlXCJdID0ge1xuICAgICAgc3RhdGU6IFwiaWRsZVwiLFxuICAgICAgZGF0YTogYWN0aW9uUmVzdWx0LmRhdGEsXG4gICAgICBmb3JtTWV0aG9kOiB1bmRlZmluZWQsXG4gICAgICBmb3JtQWN0aW9uOiB1bmRlZmluZWQsXG4gICAgICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkLFxuICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAgICAgIFwiIF9oYXNGZXRjaGVyRG9uZUFueXRoaW5nIFwiOiB0cnVlLFxuICAgIH07XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZG9uZUZldGNoZXIpO1xuXG4gICAgbGV0IGRpZEFib3J0RmV0Y2hMb2FkcyA9IGFib3J0U3RhbGVGZXRjaExvYWRzKGxvYWRJZCk7XG5cbiAgICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGluIGEgbmF2aWdhdGlvbiBsb2FkaW5nIHN0YXRlIGFuZCB0aGlzIGZldGNoZXIgaXNcbiAgICAvLyBtb3JlIHJlY2VudCB0aGFuIHRoZSBuYXZpZ2F0aW9uLCB3ZSB3YW50IHRoZSBuZXdlciBkYXRhIHNvIGFib3J0IHRoZVxuICAgIC8vIG5hdmlnYXRpb24gYW5kIGNvbXBsZXRlIGl0IHdpdGggdGhlIGZldGNoZXIgZGF0YVxuICAgIGlmIChcbiAgICAgIHN0YXRlLm5hdmlnYXRpb24uc3RhdGUgPT09IFwibG9hZGluZ1wiICYmXG4gICAgICBsb2FkSWQgPiBwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZFxuICAgICkge1xuICAgICAgaW52YXJpYW50KHBlbmRpbmdBY3Rpb24sIFwiRXhwZWN0ZWQgcGVuZGluZyBhY3Rpb25cIik7XG4gICAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgJiYgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyLmFib3J0KCk7XG5cbiAgICAgIGNvbXBsZXRlTmF2aWdhdGlvbihzdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uLCB7XG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGxvYWRlckRhdGEsXG4gICAgICAgIGVycm9ycyxcbiAgICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG90aGVyd2lzZSBqdXN0IHVwZGF0ZSB3aXRoIHRoZSBmZXRjaGVyIGRhdGEsIHByZXNlcnZpbmcgYW55IGV4aXN0aW5nXG4gICAgICAvLyBsb2FkZXJEYXRhIGZvciBsb2FkZXJzIHRoYXQgZGlkIG5vdCBuZWVkIHRvIHJlbG9hZC4gIFdlIGhhdmUgdG9cbiAgICAgIC8vIG1hbnVhbGx5IG1lcmdlIGhlcmUgc2luY2Ugd2UgYXJlbid0IGdvaW5nIHRocm91Z2ggY29tcGxldGVOYXZpZ2F0aW9uXG4gICAgICB1cGRhdGVTdGF0ZSh7XG4gICAgICAgIGVycm9ycyxcbiAgICAgICAgbG9hZGVyRGF0YTogbWVyZ2VMb2FkZXJEYXRhKFxuICAgICAgICAgIHN0YXRlLmxvYWRlckRhdGEsXG4gICAgICAgICAgbG9hZGVyRGF0YSxcbiAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgIGVycm9yc1xuICAgICAgICApLFxuICAgICAgICAuLi4oZGlkQWJvcnRGZXRjaExvYWRzID8geyBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycykgfSA6IHt9KSxcbiAgICAgIH0pO1xuICAgICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIENhbGwgdGhlIG1hdGNoZWQgbG9hZGVyIGZvciBmZXRjaGVyLmxvYWQoKSwgaGFuZGxpbmcgcmVkaXJlY3RzLCBlcnJvcnMsIGV0Yy5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlRmV0Y2hlckxvYWRlcihcbiAgICBrZXk6IHN0cmluZyxcbiAgICByb3V0ZUlkOiBzdHJpbmcsXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIG1hdGNoOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoLFxuICAgIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgICBzdWJtaXNzaW9uPzogU3VibWlzc2lvblxuICApIHtcbiAgICBsZXQgZXhpc3RpbmdGZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XG4gICAgLy8gUHV0IHRoaXMgZmV0Y2hlciBpbnRvIGl0J3MgbG9hZGluZyBzdGF0ZVxuICAgIGxldCBsb2FkaW5nRmV0Y2hlcjogRmV0Y2hlclN0YXRlc1tcIkxvYWRpbmdcIl0gPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICBmb3JtTWV0aG9kOiB1bmRlZmluZWQsXG4gICAgICBmb3JtQWN0aW9uOiB1bmRlZmluZWQsXG4gICAgICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkLFxuICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAgICAgIC4uLnN1Ym1pc3Npb24sXG4gICAgICBkYXRhOiBleGlzdGluZ0ZldGNoZXIgJiYgZXhpc3RpbmdGZXRjaGVyLmRhdGEsXG4gICAgICBcIiBfaGFzRmV0Y2hlckRvbmVBbnl0aGluZyBcIjogdHJ1ZSxcbiAgICB9O1xuICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGxvYWRpbmdGZXRjaGVyKTtcbiAgICB1cGRhdGVTdGF0ZSh7IGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSB9KTtcblxuICAgIC8vIENhbGwgdGhlIGxvYWRlciBmb3IgdGhpcyBmZXRjaGVyIHJvdXRlIG1hdGNoXG4gICAgbGV0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBsZXQgZmV0Y2hSZXF1ZXN0ID0gY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoXG4gICAgICBpbml0Lmhpc3RvcnksXG4gICAgICBwYXRoLFxuICAgICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbFxuICAgICk7XG4gICAgZmV0Y2hDb250cm9sbGVycy5zZXQoa2V5LCBhYm9ydENvbnRyb2xsZXIpO1xuXG4gICAgbGV0IHJlc3VsdDogRGF0YVJlc3VsdCA9IGF3YWl0IGNhbGxMb2FkZXJPckFjdGlvbihcbiAgICAgIFwibG9hZGVyXCIsXG4gICAgICBmZXRjaFJlcXVlc3QsXG4gICAgICBtYXRjaCxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBtYW5pZmVzdCxcbiAgICAgIGRldGVjdEVycm9yQm91bmRhcnksXG4gICAgICByb3V0ZXIuYmFzZW5hbWVcbiAgICApO1xuXG4gICAgLy8gRGVmZXJyZWQgaXNuJ3Qgc3VwcG9ydGVkIGZvciBmZXRjaGVyIGxvYWRzLCBhd2FpdCBldmVyeXRoaW5nIGFuZCB0cmVhdCBpdFxuICAgIC8vIGFzIGEgbm9ybWFsIGxvYWQuICByZXNvbHZlRGVmZXJyZWREYXRhIHdpbGwgcmV0dXJuIHVuZGVmaW5lZCBpZiB0aGlzXG4gICAgLy8gZmV0Y2hlciBnZXRzIGFib3J0ZWQsIHNvIHdlIGp1c3QgbGVhdmUgcmVzdWx0IHVudG91Y2hlZCBhbmQgc2hvcnQgY2lyY3VpdFxuICAgIC8vIGJlbG93IGlmIHRoYXQgaGFwcGVuc1xuICAgIGlmIChpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIHJlc3VsdCA9XG4gICAgICAgIChhd2FpdCByZXNvbHZlRGVmZXJyZWREYXRhKHJlc3VsdCwgZmV0Y2hSZXF1ZXN0LnNpZ25hbCwgdHJ1ZSkpIHx8XG4gICAgICAgIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBXZSBjYW4gZGVsZXRlIHRoaXMgc28gbG9uZyBhcyB3ZSB3ZXJlbid0IGFib3J0ZWQgYnkgb3Ugb3VyIG93biBmZXRjaGVyXG4gICAgLy8gcmUtbG9hZCB3aGljaCB3b3VsZCBoYXZlIHB1dCBfbmV3XyBjb250cm9sbGVyIGlzIGluIGZldGNoQ29udHJvbGxlcnNcbiAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5nZXQoa2V5KSA9PT0gYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgIH1cblxuICAgIGlmIChmZXRjaFJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgbG9hZGVyIHRocmV3IGEgcmVkaXJlY3QgUmVzcG9uc2UsIHN0YXJ0IGEgbmV3IFJFUExBQ0UgbmF2aWdhdGlvblxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGF3YWl0IHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHN0YXRlLCByZXN1bHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFByb2Nlc3MgYW55IG5vbi1yZWRpcmVjdCBlcnJvcnMgdGhyb3duXG4gICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KHN0YXRlLm1hdGNoZXMsIHJvdXRlSWQpO1xuICAgICAgc3RhdGUuZmV0Y2hlcnMuZGVsZXRlKGtleSk7XG4gICAgICAvLyBUT0RPOiBJbiByZW1peCwgdGhpcyB3b3VsZCByZXNldCB0byBJRExFX05BVklHQVRJT04gaWYgaXQgd2FzIGEgY2F0Y2ggLVxuICAgICAgLy8gZG8gd2UgbmVlZCB0byBiZWhhdmUgYW55IGRpZmZlcmVudGx5IHdpdGggb3VyIG5vbi1yZWRpcmVjdCBlcnJvcnM/XG4gICAgICAvLyBXaGF0IGlmIGl0IHdhcyBhIG5vbi1yZWRpcmVjdCBSZXNwb25zZT9cbiAgICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpLFxuICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICBbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5lcnJvcixcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludmFyaWFudCghaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpLCBcIlVuaGFuZGxlZCBmZXRjaGVyIGRlZmVycmVkIGRhdGFcIik7XG5cbiAgICAvLyBQdXQgdGhlIGZldGNoZXIgYmFjayBpbnRvIGFuIGlkbGUgc3RhdGVcbiAgICBsZXQgZG9uZUZldGNoZXI6IEZldGNoZXJTdGF0ZXNbXCJJZGxlXCJdID0ge1xuICAgICAgc3RhdGU6IFwiaWRsZVwiLFxuICAgICAgZGF0YTogcmVzdWx0LmRhdGEsXG4gICAgICBmb3JtTWV0aG9kOiB1bmRlZmluZWQsXG4gICAgICBmb3JtQWN0aW9uOiB1bmRlZmluZWQsXG4gICAgICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkLFxuICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAgICAgIFwiIF9oYXNGZXRjaGVyRG9uZUFueXRoaW5nIFwiOiB0cnVlLFxuICAgIH07XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZG9uZUZldGNoZXIpO1xuICAgIHVwZGF0ZVN0YXRlKHsgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gaGFuZGxlIHJlZGlyZWN0cyByZXR1cm5lZCBmcm9tIGFuIGFjdGlvbiBvciBsb2FkZXIuXG4gICAqIE5vcm1hbGx5LCBhIHJlZGlyZWN0IFwicmVwbGFjZXNcIiB0aGUgbmF2aWdhdGlvbiB0aGF0IHRyaWdnZXJlZCBpdC4gIFNvLCBmb3JcbiAgICogZXhhbXBsZTpcbiAgICpcbiAgICogIC0gdXNlciBpcyBvbiAvYVxuICAgKiAgLSB1c2VyIGNsaWNrcyBhIGxpbmsgdG8gL2JcbiAgICogIC0gbG9hZGVyIGZvciAvYiByZWRpcmVjdHMgdG8gL2NcbiAgICpcbiAgICogSW4gYSBub24tSlMgYXBwIHRoZSBicm93c2VyIHdvdWxkIHRyYWNrIHRoZSBpbi1mbGlnaHQgbmF2aWdhdGlvbiB0byAvYiBhbmRcbiAgICogdGhlbiByZXBsYWNlIGl0IHdpdGggL2Mgd2hlbiBpdCBlbmNvdW50ZXJlZCB0aGUgcmVkaXJlY3QgcmVzcG9uc2UuICBJblxuICAgKiB0aGUgZW5kIGl0IHdvdWxkIG9ubHkgZXZlciB1cGRhdGUgdGhlIFVSTCBiYXIgd2l0aCAvYy5cbiAgICpcbiAgICogSW4gY2xpZW50LXNpZGUgcm91dGluZyB1c2luZyBwdXNoU3RhdGUvcmVwbGFjZVN0YXRlLCB3ZSBhaW0gdG8gZW11bGF0ZVxuICAgKiB0aGlzIGJlaGF2aW9yIGFuZCB3ZSBhbHNvIGRvIG5vdCB1cGRhdGUgaGlzdG9yeSB1bnRpbCB0aGUgZW5kIG9mIHRoZVxuICAgKiBuYXZpZ2F0aW9uIChpbmNsdWRpbmcgcHJvY2Vzc2VkIHJlZGlyZWN0cykuICBUaGlzIG1lYW5zIHRoYXQgd2UgbmV2ZXJcbiAgICogYWN0dWFsbHkgdG91Y2ggaGlzdG9yeSB1bnRpbCB3ZSd2ZSBwcm9jZXNzZWQgcmVkaXJlY3RzLCBzbyB3ZSBqdXN0IHVzZVxuICAgKiB0aGUgaGlzdG9yeSBhY3Rpb24gZnJvbSB0aGUgb3JpZ2luYWwgbmF2aWdhdGlvbiAoUFVTSCBvciBSRVBMQUNFKS5cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKFxuICAgIHN0YXRlOiBSb3V0ZXJTdGF0ZSxcbiAgICByZWRpcmVjdDogUmVkaXJlY3RSZXN1bHQsXG4gICAge1xuICAgICAgc3VibWlzc2lvbixcbiAgICAgIHJlcGxhY2UsXG4gICAgICBpc0ZldGNoQWN0aW9uUmVkaXJlY3QsXG4gICAgfToge1xuICAgICAgc3VibWlzc2lvbj86IFN1Ym1pc3Npb247XG4gICAgICByZXBsYWNlPzogYm9vbGVhbjtcbiAgICAgIGlzRmV0Y2hBY3Rpb25SZWRpcmVjdD86IGJvb2xlYW47XG4gICAgfSA9IHt9XG4gICkge1xuICAgIGlmIChyZWRpcmVjdC5yZXZhbGlkYXRlKSB7XG4gICAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBsZXQgcmVkaXJlY3RMb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKFxuICAgICAgc3RhdGUubG9jYXRpb24sXG4gICAgICByZWRpcmVjdC5sb2NhdGlvbixcbiAgICAgIC8vIFRPRE86IFRoaXMgY2FuIGJlIHJlbW92ZWQgb25jZSB3ZSBnZXQgcmlkIG9mIHVzZVRyYW5zaXRpb24gaW4gUmVtaXggdjJcbiAgICAgIHtcbiAgICAgICAgX2lzUmVkaXJlY3Q6IHRydWUsXG4gICAgICAgIC4uLihpc0ZldGNoQWN0aW9uUmVkaXJlY3QgPyB7IF9pc0ZldGNoQWN0aW9uUmVkaXJlY3Q6IHRydWUgfSA6IHt9KSxcbiAgICAgIH1cbiAgICApO1xuICAgIGludmFyaWFudChcbiAgICAgIHJlZGlyZWN0TG9jYXRpb24sXG4gICAgICBcIkV4cGVjdGVkIGEgbG9jYXRpb24gb24gdGhlIHJlZGlyZWN0IG5hdmlnYXRpb25cIlxuICAgICk7XG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBhbiBhYnNvbHV0ZSBleHRlcm5hbCByZWRpcmVjdCB0aGF0IGdvZXMgdG8gYSBuZXcgb3JpZ2luXG4gICAgaWYgKFxuICAgICAgQUJTT0xVVEVfVVJMX1JFR0VYLnRlc3QocmVkaXJlY3QubG9jYXRpb24pICYmXG4gICAgICBpc0Jyb3dzZXIgJiZcbiAgICAgIHR5cGVvZiB3aW5kb3c/LmxvY2F0aW9uICE9PSBcInVuZGVmaW5lZFwiXG4gICAgKSB7XG4gICAgICBsZXQgdXJsID0gaW5pdC5oaXN0b3J5LmNyZWF0ZVVSTChyZWRpcmVjdC5sb2NhdGlvbik7XG4gICAgICBsZXQgaXNEaWZmZXJlbnRCYXNlbmFtZSA9XG4gICAgICAgIHN0cmlwQmFzZW5hbWUodXJsLnBhdGhuYW1lLCBpbml0LmJhc2VuYW1lIHx8IFwiL1wiKSA9PSBudWxsO1xuXG4gICAgICBpZiAod2luZG93LmxvY2F0aW9uLm9yaWdpbiAhPT0gdXJsLm9yaWdpbiB8fCBpc0RpZmZlcmVudEJhc2VuYW1lKSB7XG4gICAgICAgIGlmIChyZXBsYWNlKSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UocmVkaXJlY3QubG9jYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24ocmVkaXJlY3QubG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gYWJvcnQgb24gcmVkaXJlY3RzLCBzaW5jZSB3ZSBkb24ndCBkZXRlY3QgdGhlXG4gICAgLy8gcmVkaXJlY3QgdW50aWwgdGhlIGFjdGlvbi9sb2FkZXJzIGhhdmUgc2V0dGxlZFxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG51bGw7XG5cbiAgICBsZXQgcmVkaXJlY3RIaXN0b3J5QWN0aW9uID1cbiAgICAgIHJlcGxhY2UgPT09IHRydWUgPyBIaXN0b3J5QWN0aW9uLlJlcGxhY2UgOiBIaXN0b3J5QWN0aW9uLlB1c2g7XG5cbiAgICAvLyBVc2UgdGhlIGluY29taW5nIHN1Ym1pc3Npb24gaWYgcHJvdmlkZWQsIGZhbGxiYWNrIG9uIHRoZSBhY3RpdmUgb25lIGluXG4gICAgLy8gc3RhdGUubmF2aWdhdGlvblxuICAgIGxldCB7IGZvcm1NZXRob2QsIGZvcm1BY3Rpb24sIGZvcm1FbmNUeXBlLCBmb3JtRGF0YSB9ID0gc3RhdGUubmF2aWdhdGlvbjtcbiAgICBpZiAoIXN1Ym1pc3Npb24gJiYgZm9ybU1ldGhvZCAmJiBmb3JtQWN0aW9uICYmIGZvcm1EYXRhICYmIGZvcm1FbmNUeXBlKSB7XG4gICAgICBzdWJtaXNzaW9uID0ge1xuICAgICAgICBmb3JtTWV0aG9kLFxuICAgICAgICBmb3JtQWN0aW9uLFxuICAgICAgICBmb3JtRW5jVHlwZSxcbiAgICAgICAgZm9ybURhdGEsXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHRoaXMgd2FzIGEgMzA3LzMwOCBzdWJtaXNzaW9uIHdlIHdhbnQgdG8gcHJlc2VydmUgdGhlIEhUVFAgbWV0aG9kIGFuZFxuICAgIC8vIHJlLXN1Ym1pdCB0aGUgR0VUL1BPU1QvUFVUL1BBVENIL0RFTEVURSBhcyBhIHN1Ym1pc3Npb24gbmF2aWdhdGlvbiB0byB0aGVcbiAgICAvLyByZWRpcmVjdGVkIGxvY2F0aW9uXG4gICAgaWYgKFxuICAgICAgcmVkaXJlY3RQcmVzZXJ2ZU1ldGhvZFN0YXR1c0NvZGVzLmhhcyhyZWRpcmVjdC5zdGF0dXMpICYmXG4gICAgICBzdWJtaXNzaW9uICYmXG4gICAgICBpc011dGF0aW9uTWV0aG9kKHN1Ym1pc3Npb24uZm9ybU1ldGhvZClcbiAgICApIHtcbiAgICAgIGF3YWl0IHN0YXJ0TmF2aWdhdGlvbihyZWRpcmVjdEhpc3RvcnlBY3Rpb24sIHJlZGlyZWN0TG9jYXRpb24sIHtcbiAgICAgICAgc3VibWlzc2lvbjoge1xuICAgICAgICAgIC4uLnN1Ym1pc3Npb24sXG4gICAgICAgICAgZm9ybUFjdGlvbjogcmVkaXJlY3QubG9jYXRpb24sXG4gICAgICAgIH0sXG4gICAgICAgIC8vIFByZXNlcnZlIHRoaXMgZmxhZyBhY3Jvc3MgcmVkaXJlY3RzXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2UsIHdlIGtpY2sgb2ZmIGEgbmV3IGxvYWRpbmcgbmF2aWdhdGlvbiwgcHJlc2VydmluZyB0aGVcbiAgICAgIC8vIHN1Ym1pc3Npb24gaW5mbyBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoaXMgbmF2aWdhdGlvblxuICAgICAgYXdhaXQgc3RhcnROYXZpZ2F0aW9uKHJlZGlyZWN0SGlzdG9yeUFjdGlvbiwgcmVkaXJlY3RMb2NhdGlvbiwge1xuICAgICAgICBvdmVycmlkZU5hdmlnYXRpb246IHtcbiAgICAgICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICAgICAgbG9jYXRpb246IHJlZGlyZWN0TG9jYXRpb24sXG4gICAgICAgICAgZm9ybU1ldGhvZDogc3VibWlzc2lvbiA/IHN1Ym1pc3Npb24uZm9ybU1ldGhvZCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBmb3JtQWN0aW9uOiBzdWJtaXNzaW9uID8gc3VibWlzc2lvbi5mb3JtQWN0aW9uIDogdW5kZWZpbmVkLFxuICAgICAgICAgIGZvcm1FbmNUeXBlOiBzdWJtaXNzaW9uID8gc3VibWlzc2lvbi5mb3JtRW5jVHlwZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBmb3JtRGF0YTogc3VibWlzc2lvbiA/IHN1Ym1pc3Npb24uZm9ybURhdGEgOiB1bmRlZmluZWQsXG4gICAgICAgIH0sXG4gICAgICAgIC8vIFByZXNlcnZlIHRoaXMgZmxhZyBhY3Jvc3MgcmVkaXJlY3RzXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YShcbiAgICBjdXJyZW50TWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICAgIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgICBtYXRjaGVzVG9Mb2FkOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gICAgZmV0Y2hlcnNUb0xvYWQ6IFJldmFsaWRhdGluZ0ZldGNoZXJbXSxcbiAgICByZXF1ZXN0OiBSZXF1ZXN0XG4gICkge1xuICAgIC8vIENhbGwgYWxsIG5hdmlnYXRpb24gbG9hZGVycyBhbmQgcmV2YWxpZGF0aW5nIGZldGNoZXIgbG9hZGVycyBpbiBwYXJhbGxlbCxcbiAgICAvLyB0aGVuIHNsaWNlIG9mZiB0aGUgcmVzdWx0cyBpbnRvIHNlcGFyYXRlIGFycmF5cyBzbyB3ZSBjYW4gaGFuZGxlIHRoZW1cbiAgICAvLyBhY2NvcmRpbmdseVxuICAgIGxldCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgLi4ubWF0Y2hlc1RvTG9hZC5tYXAoKG1hdGNoKSA9PlxuICAgICAgICBjYWxsTG9hZGVyT3JBY3Rpb24oXG4gICAgICAgICAgXCJsb2FkZXJcIixcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgbWFuaWZlc3QsXG4gICAgICAgICAgZGV0ZWN0RXJyb3JCb3VuZGFyeSxcbiAgICAgICAgICByb3V0ZXIuYmFzZW5hbWVcbiAgICAgICAgKVxuICAgICAgKSxcbiAgICAgIC4uLmZldGNoZXJzVG9Mb2FkLm1hcCgoZikgPT4ge1xuICAgICAgICBpZiAoZi5tYXRjaGVzICYmIGYubWF0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbExvYWRlck9yQWN0aW9uKFxuICAgICAgICAgICAgXCJsb2FkZXJcIixcbiAgICAgICAgICAgIGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KGluaXQuaGlzdG9yeSwgZi5wYXRoLCByZXF1ZXN0LnNpZ25hbCksXG4gICAgICAgICAgICBmLm1hdGNoLFxuICAgICAgICAgICAgZi5tYXRjaGVzLFxuICAgICAgICAgICAgbWFuaWZlc3QsXG4gICAgICAgICAgICBkZXRlY3RFcnJvckJvdW5kYXJ5LFxuICAgICAgICAgICAgcm91dGVyLmJhc2VuYW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgZXJyb3I6IEVycm9yUmVzdWx0ID0ge1xuICAgICAgICAgICAgdHlwZTogUmVzdWx0VHlwZS5lcnJvcixcbiAgICAgICAgICAgIGVycm9yOiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwgeyBwYXRobmFtZTogZi5wYXRoIH0pLFxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICBdKTtcbiAgICBsZXQgbG9hZGVyUmVzdWx0cyA9IHJlc3VsdHMuc2xpY2UoMCwgbWF0Y2hlc1RvTG9hZC5sZW5ndGgpO1xuICAgIGxldCBmZXRjaGVyUmVzdWx0cyA9IHJlc3VsdHMuc2xpY2UobWF0Y2hlc1RvTG9hZC5sZW5ndGgpO1xuXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgcmVzb2x2ZURlZmVycmVkUmVzdWx0cyhcbiAgICAgICAgY3VycmVudE1hdGNoZXMsXG4gICAgICAgIG1hdGNoZXNUb0xvYWQsXG4gICAgICAgIGxvYWRlclJlc3VsdHMsXG4gICAgICAgIHJlcXVlc3Quc2lnbmFsLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgc3RhdGUubG9hZGVyRGF0YVxuICAgICAgKSxcbiAgICAgIHJlc29sdmVEZWZlcnJlZFJlc3VsdHMoXG4gICAgICAgIGN1cnJlbnRNYXRjaGVzLFxuICAgICAgICBmZXRjaGVyc1RvTG9hZC5tYXAoKGYpID0+IGYubWF0Y2gpLFxuICAgICAgICBmZXRjaGVyUmVzdWx0cyxcbiAgICAgICAgcmVxdWVzdC5zaWduYWwsXG4gICAgICAgIHRydWVcbiAgICAgICksXG4gICAgXSk7XG5cbiAgICByZXR1cm4geyByZXN1bHRzLCBsb2FkZXJSZXN1bHRzLCBmZXRjaGVyUmVzdWx0cyB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaW50ZXJydXB0QWN0aXZlTG9hZHMoKSB7XG4gICAgLy8gRXZlcnkgaW50ZXJydXB0aW9uIHRyaWdnZXJzIGEgcmV2YWxpZGF0aW9uXG4gICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IHRydWU7XG5cbiAgICAvLyBDYW5jZWwgcGVuZGluZyByb3V0ZS1sZXZlbCBkZWZlcnJlZHMgYW5kIG1hcmsgY2FuY2VsbGVkIHJvdXRlcyBmb3JcbiAgICAvLyByZXZhbGlkYXRpb25cbiAgICBjYW5jZWxsZWREZWZlcnJlZFJvdXRlcy5wdXNoKC4uLmNhbmNlbEFjdGl2ZURlZmVycmVkcygpKTtcblxuICAgIC8vIEFib3J0IGluLWZsaWdodCBmZXRjaGVyIGxvYWRzXG4gICAgZmV0Y2hMb2FkTWF0Y2hlcy5mb3JFYWNoKChfLCBrZXkpID0+IHtcbiAgICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmhhcyhrZXkpKSB7XG4gICAgICAgIGNhbmNlbGxlZEZldGNoZXJMb2Fkcy5wdXNoKGtleSk7XG4gICAgICAgIGFib3J0RmV0Y2hlcihrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0RmV0Y2hlckVycm9yKGtleTogc3RyaW5nLCByb3V0ZUlkOiBzdHJpbmcsIGVycm9yOiBhbnkpIHtcbiAgICBsZXQgYm91bmRhcnlNYXRjaCA9IGZpbmROZWFyZXN0Qm91bmRhcnkoc3RhdGUubWF0Y2hlcywgcm91dGVJZCk7XG4gICAgZGVsZXRlRmV0Y2hlcihrZXkpO1xuICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgIGVycm9yczoge1xuICAgICAgICBbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF06IGVycm9yLFxuICAgICAgfSxcbiAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSxcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZUZldGNoZXIoa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5oYXMoa2V5KSkgYWJvcnRGZXRjaGVyKGtleSk7XG4gICAgZmV0Y2hMb2FkTWF0Y2hlcy5kZWxldGUoa2V5KTtcbiAgICBmZXRjaFJlbG9hZElkcy5kZWxldGUoa2V5KTtcbiAgICBmZXRjaFJlZGlyZWN0SWRzLmRlbGV0ZShrZXkpO1xuICAgIHN0YXRlLmZldGNoZXJzLmRlbGV0ZShrZXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWJvcnRGZXRjaGVyKGtleTogc3RyaW5nKSB7XG4gICAgbGV0IGNvbnRyb2xsZXIgPSBmZXRjaENvbnRyb2xsZXJzLmdldChrZXkpO1xuICAgIGludmFyaWFudChjb250cm9sbGVyLCBgRXhwZWN0ZWQgZmV0Y2ggY29udHJvbGxlcjogJHtrZXl9YCk7XG4gICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKGtleSk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrRmV0Y2hlcnNEb25lKGtleXM6IHN0cmluZ1tdKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIGtleXMpIHtcbiAgICAgIGxldCBmZXRjaGVyID0gZ2V0RmV0Y2hlcihrZXkpO1xuICAgICAgbGV0IGRvbmVGZXRjaGVyOiBGZXRjaGVyU3RhdGVzW1wiSWRsZVwiXSA9IHtcbiAgICAgICAgc3RhdGU6IFwiaWRsZVwiLFxuICAgICAgICBkYXRhOiBmZXRjaGVyLmRhdGEsXG4gICAgICAgIGZvcm1NZXRob2Q6IHVuZGVmaW5lZCxcbiAgICAgICAgZm9ybUFjdGlvbjogdW5kZWZpbmVkLFxuICAgICAgICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkLFxuICAgICAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICAgICAgICBcIiBfaGFzRmV0Y2hlckRvbmVBbnl0aGluZyBcIjogdHJ1ZSxcbiAgICAgIH07XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFya0ZldGNoUmVkaXJlY3RzRG9uZSgpOiB2b2lkIHtcbiAgICBsZXQgZG9uZUtleXMgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgb2YgZmV0Y2hSZWRpcmVjdElkcykge1xuICAgICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICAgIGludmFyaWFudChmZXRjaGVyLCBgRXhwZWN0ZWQgZmV0Y2hlcjogJHtrZXl9YCk7XG4gICAgICBpZiAoZmV0Y2hlci5zdGF0ZSA9PT0gXCJsb2FkaW5nXCIpIHtcbiAgICAgICAgZmV0Y2hSZWRpcmVjdElkcy5kZWxldGUoa2V5KTtcbiAgICAgICAgZG9uZUtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBtYXJrRmV0Y2hlcnNEb25lKGRvbmVLZXlzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFib3J0U3RhbGVGZXRjaExvYWRzKGxhbmRlZElkOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBsZXQgeWVldGVkS2V5cyA9IFtdO1xuICAgIGZvciAobGV0IFtrZXksIGlkXSBvZiBmZXRjaFJlbG9hZElkcykge1xuICAgICAgaWYgKGlkIDwgbGFuZGVkSWQpIHtcbiAgICAgICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICAgICAgaW52YXJpYW50KGZldGNoZXIsIGBFeHBlY3RlZCBmZXRjaGVyOiAke2tleX1gKTtcbiAgICAgICAgaWYgKGZldGNoZXIuc3RhdGUgPT09IFwibG9hZGluZ1wiKSB7XG4gICAgICAgICAgYWJvcnRGZXRjaGVyKGtleSk7XG4gICAgICAgICAgZmV0Y2hSZWxvYWRJZHMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgeWVldGVkS2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbWFya0ZldGNoZXJzRG9uZSh5ZWV0ZWRLZXlzKTtcbiAgICByZXR1cm4geWVldGVkS2V5cy5sZW5ndGggPiAwO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QmxvY2tlcihrZXk6IHN0cmluZywgZm46IEJsb2NrZXJGdW5jdGlvbikge1xuICAgIGxldCBibG9ja2VyOiBCbG9ja2VyID0gc3RhdGUuYmxvY2tlcnMuZ2V0KGtleSkgfHwgSURMRV9CTE9DS0VSO1xuXG4gICAgaWYgKGJsb2NrZXJGdW5jdGlvbnMuZ2V0KGtleSkgIT09IGZuKSB7XG4gICAgICBibG9ja2VyRnVuY3Rpb25zLnNldChrZXksIGZuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmxvY2tlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZUJsb2NrZXIoa2V5OiBzdHJpbmcpIHtcbiAgICBzdGF0ZS5ibG9ja2Vycy5kZWxldGUoa2V5KTtcbiAgICBibG9ja2VyRnVuY3Rpb25zLmRlbGV0ZShrZXkpO1xuICB9XG5cbiAgLy8gVXRpbGl0eSBmdW5jdGlvbiB0byB1cGRhdGUgYmxvY2tlcnMsIGVuc3VyaW5nIHZhbGlkIHN0YXRlIHRyYW5zaXRpb25zXG4gIGZ1bmN0aW9uIHVwZGF0ZUJsb2NrZXIoa2V5OiBzdHJpbmcsIG5ld0Jsb2NrZXI6IEJsb2NrZXIpIHtcbiAgICBsZXQgYmxvY2tlciA9IHN0YXRlLmJsb2NrZXJzLmdldChrZXkpIHx8IElETEVfQkxPQ0tFUjtcblxuICAgIC8vIFBvb3IgbWFucyBzdGF0ZSBtYWNoaW5lIDopXG4gICAgLy8gaHR0cHM6Ly9tZXJtYWlkLmxpdmUvZWRpdCNwYWtvOmVOcVZrYzlPd3pBTXhsOGw4bm5qQVlyRXRESU9IRUJJZ3d2S0pUUmVHeTNfbERwSXFPMjdrNmF3TUcwWGNyTGxuejg3bndkb25FU29nS1hYQnVFNzlycTc1WFpPMy15SGRzMFJKVnV2NzBZclBsVXJDRWUySGZyT1JTM3J1YnFaZnVodHBnNUM5d2s1dFo0VktjUlVxODhxOVo4UlMwLTQ4Y0UxaUhKa0wwdWdiSHVGTHVzOUw2c3BaeThuWDlNUDJDTmRvbVZhcG9zcXUzZkdheVQ4VDgtakpRd2hlcG9fVXRwZ0JRYURFVW9tMDRkWmhBTjFhSkJEbFVLSkJ4RTFjZUIyU21qME1sbi1JQlc1QUZVMmR3VWlrdHRfMlFhcTJkQmZhS2RFdXA4NVVWN1lkLWRLamxua2FibDJQdnIwRFRrVHJlTVxuICAgIGludmFyaWFudChcbiAgICAgIChibG9ja2VyLnN0YXRlID09PSBcInVuYmxvY2tlZFwiICYmIG5ld0Jsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiKSB8fFxuICAgICAgICAoYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIpIHx8XG4gICAgICAgIChibG9ja2VyLnN0YXRlID09PSBcImJsb2NrZWRcIiAmJiBuZXdCbG9ja2VyLnN0YXRlID09PSBcInByb2NlZWRpbmdcIikgfHxcbiAgICAgICAgKGJsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiICYmIG5ld0Jsb2NrZXIuc3RhdGUgPT09IFwidW5ibG9ja2VkXCIpIHx8XG4gICAgICAgIChibG9ja2VyLnN0YXRlID09PSBcInByb2NlZWRpbmdcIiAmJiBuZXdCbG9ja2VyLnN0YXRlID09PSBcInVuYmxvY2tlZFwiKSxcbiAgICAgIGBJbnZhbGlkIGJsb2NrZXIgc3RhdGUgdHJhbnNpdGlvbjogJHtibG9ja2VyLnN0YXRlfSAtPiAke25ld0Jsb2NrZXIuc3RhdGV9YFxuICAgICk7XG5cbiAgICBzdGF0ZS5ibG9ja2Vycy5zZXQoa2V5LCBuZXdCbG9ja2VyKTtcbiAgICB1cGRhdGVTdGF0ZSh7IGJsb2NrZXJzOiBuZXcgTWFwKHN0YXRlLmJsb2NrZXJzKSB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEJsb2NrTmF2aWdhdGlvbih7XG4gICAgY3VycmVudExvY2F0aW9uLFxuICAgIG5leHRMb2NhdGlvbixcbiAgICBoaXN0b3J5QWN0aW9uLFxuICB9OiB7XG4gICAgY3VycmVudExvY2F0aW9uOiBMb2NhdGlvbjtcbiAgICBuZXh0TG9jYXRpb246IExvY2F0aW9uO1xuICAgIGhpc3RvcnlBY3Rpb246IEhpc3RvcnlBY3Rpb247XG4gIH0pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIGlmIChibG9ja2VyRnVuY3Rpb25zLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBXZSBvbnkgc3VwcG9ydCBhIHNpbmdsZSBhY3RpdmUgYmxvY2tlciBhdCB0aGUgbW9tZW50IHNpbmNlIHdlIGRvbid0IGhhdmVcbiAgICAvLyBhbnkgY29tcGVsbGluZyB1c2UgY2FzZXMgZm9yIG11bHRpLWJsb2NrZXIgeWV0XG4gICAgaWYgKGJsb2NrZXJGdW5jdGlvbnMuc2l6ZSA+IDEpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsIFwiQSByb3V0ZXIgb25seSBzdXBwb3J0cyBvbmUgYmxvY2tlciBhdCBhIHRpbWVcIik7XG4gICAgfVxuXG4gICAgbGV0IGVudHJpZXMgPSBBcnJheS5mcm9tKGJsb2NrZXJGdW5jdGlvbnMuZW50cmllcygpKTtcbiAgICBsZXQgW2Jsb2NrZXJLZXksIGJsb2NrZXJGdW5jdGlvbl0gPSBlbnRyaWVzW2VudHJpZXMubGVuZ3RoIC0gMV07XG4gICAgbGV0IGJsb2NrZXIgPSBzdGF0ZS5ibG9ja2Vycy5nZXQoYmxvY2tlcktleSk7XG5cbiAgICBpZiAoYmxvY2tlciAmJiBibG9ja2VyLnN0YXRlID09PSBcInByb2NlZWRpbmdcIikge1xuICAgICAgLy8gSWYgdGhlIGJsb2NrZXIgaXMgY3VycmVudGx5IHByb2NlZWRpbmcsIHdlIGRvbid0IG5lZWQgdG8gcmUtY2hlY2tcbiAgICAgIC8vIGl0IGFuZCBjYW4gbGV0IHRoaXMgbmF2aWdhdGlvbiBjb250aW51ZVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIGtub3cgd2UncmUgdW5ibG9ja2VkL2Jsb2NrZWQgc28gd2UgbmVlZCB0byBjaGVjayB0aGVcbiAgICAvLyB1c2VyLXByb3ZpZGVkIGJsb2NrZXIgZnVuY3Rpb25cbiAgICBpZiAoYmxvY2tlckZ1bmN0aW9uKHsgY3VycmVudExvY2F0aW9uLCBuZXh0TG9jYXRpb24sIGhpc3RvcnlBY3Rpb24gfSkpIHtcbiAgICAgIHJldHVybiBibG9ja2VyS2V5O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbEFjdGl2ZURlZmVycmVkcyhcbiAgICBwcmVkaWNhdGU/OiAocm91dGVJZDogc3RyaW5nKSA9PiBib29sZWFuXG4gICk6IHN0cmluZ1tdIHtcbiAgICBsZXQgY2FuY2VsbGVkUm91dGVJZHM6IHN0cmluZ1tdID0gW107XG4gICAgYWN0aXZlRGVmZXJyZWRzLmZvckVhY2goKGRmZCwgcm91dGVJZCkgPT4ge1xuICAgICAgaWYgKCFwcmVkaWNhdGUgfHwgcHJlZGljYXRlKHJvdXRlSWQpKSB7XG4gICAgICAgIC8vIENhbmNlbCB0aGUgZGVmZXJyZWQgLSBidXQgZG8gbm90IHJlbW92ZSBmcm9tIGFjdGl2ZURlZmVycmVkcyBoZXJlIC1cbiAgICAgICAgLy8gd2UgcmVseSBvbiB0aGUgc3Vic2NyaWJlcnMgdG8gZG8gdGhhdCBzbyBvdXIgdGVzdHMgY2FuIGFzc2VydCBwcm9wZXJcbiAgICAgICAgLy8gY2xlYW51cCB2aWEgX2ludGVybmFsQWN0aXZlRGVmZXJyZWRzXG4gICAgICAgIGRmZC5jYW5jZWwoKTtcbiAgICAgICAgY2FuY2VsbGVkUm91dGVJZHMucHVzaChyb3V0ZUlkKTtcbiAgICAgICAgYWN0aXZlRGVmZXJyZWRzLmRlbGV0ZShyb3V0ZUlkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY2FuY2VsbGVkUm91dGVJZHM7XG4gIH1cblxuICAvLyBPcHQgaW4gdG8gY2FwdHVyaW5nIGFuZCByZXBvcnRpbmcgc2Nyb2xsIHBvc2l0aW9ucyBkdXJpbmcgbmF2aWdhdGlvbnMsXG4gIC8vIHVzZWQgYnkgdGhlIDxTY3JvbGxSZXN0b3JhdGlvbj4gY29tcG9uZW50XG4gIGZ1bmN0aW9uIGVuYWJsZVNjcm9sbFJlc3RvcmF0aW9uKFxuICAgIHBvc2l0aW9uczogUmVjb3JkPHN0cmluZywgbnVtYmVyPixcbiAgICBnZXRQb3NpdGlvbjogR2V0U2Nyb2xsUG9zaXRpb25GdW5jdGlvbixcbiAgICBnZXRLZXk/OiBHZXRTY3JvbGxSZXN0b3JhdGlvbktleUZ1bmN0aW9uXG4gICkge1xuICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zID0gcG9zaXRpb25zO1xuICAgIGdldFNjcm9sbFBvc2l0aW9uID0gZ2V0UG9zaXRpb247XG4gICAgZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkgPSBnZXRLZXkgfHwgKChsb2NhdGlvbikgPT4gbG9jYXRpb24ua2V5KTtcblxuICAgIC8vIFBlcmZvcm0gaW5pdGlhbCBoeWRyYXRpb24gc2Nyb2xsIHJlc3RvcmF0aW9uLCBzaW5jZSB3ZSBtaXNzIHRoZSBib2F0IG9uXG4gICAgLy8gdGhlIGluaXRpYWwgdXBkYXRlU3RhdGUoKSBiZWNhdXNlIHdlJ3ZlIG5vdCB5ZXQgcmVuZGVyZWQgPFNjcm9sbFJlc3RvcmF0aW9uLz5cbiAgICAvLyBhbmQgdGhlcmVmb3JlIGhhdmUgbm8gc2F2ZWRTY3JvbGxQb3NpdGlvbnMgYXZhaWxhYmxlXG4gICAgaWYgKCFpbml0aWFsU2Nyb2xsUmVzdG9yZWQgJiYgc3RhdGUubmF2aWdhdGlvbiA9PT0gSURMRV9OQVZJR0FUSU9OKSB7XG4gICAgICBpbml0aWFsU2Nyb2xsUmVzdG9yZWQgPSB0cnVlO1xuICAgICAgbGV0IHkgPSBnZXRTYXZlZFNjcm9sbFBvc2l0aW9uKHN0YXRlLmxvY2F0aW9uLCBzdGF0ZS5tYXRjaGVzKTtcbiAgICAgIGlmICh5ICE9IG51bGwpIHtcbiAgICAgICAgdXBkYXRlU3RhdGUoeyByZXN0b3JlU2Nyb2xsUG9zaXRpb246IHkgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zID0gbnVsbDtcbiAgICAgIGdldFNjcm9sbFBvc2l0aW9uID0gbnVsbDtcbiAgICAgIGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5ID0gbnVsbDtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2F2ZVNjcm9sbFBvc2l0aW9uKFxuICAgIGxvY2F0aW9uOiBMb2NhdGlvbixcbiAgICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW11cbiAgKTogdm9pZCB7XG4gICAgaWYgKHNhdmVkU2Nyb2xsUG9zaXRpb25zICYmIGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5ICYmIGdldFNjcm9sbFBvc2l0aW9uKSB7XG4gICAgICBsZXQgdXNlck1hdGNoZXMgPSBtYXRjaGVzLm1hcCgobSkgPT5cbiAgICAgICAgY3JlYXRlVXNlTWF0Y2hlc01hdGNoKG0sIHN0YXRlLmxvYWRlckRhdGEpXG4gICAgICApO1xuICAgICAgbGV0IGtleSA9IGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5KGxvY2F0aW9uLCB1c2VyTWF0Y2hlcykgfHwgbG9jYXRpb24ua2V5O1xuICAgICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnNba2V5XSA9IGdldFNjcm9sbFBvc2l0aW9uKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U2F2ZWRTY3JvbGxQb3NpdGlvbihcbiAgICBsb2NhdGlvbjogTG9jYXRpb24sXG4gICAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdXG4gICk6IG51bWJlciB8IG51bGwge1xuICAgIGlmIChzYXZlZFNjcm9sbFBvc2l0aW9ucyAmJiBnZXRTY3JvbGxSZXN0b3JhdGlvbktleSAmJiBnZXRTY3JvbGxQb3NpdGlvbikge1xuICAgICAgbGV0IHVzZXJNYXRjaGVzID0gbWF0Y2hlcy5tYXAoKG0pID0+XG4gICAgICAgIGNyZWF0ZVVzZU1hdGNoZXNNYXRjaChtLCBzdGF0ZS5sb2FkZXJEYXRhKVxuICAgICAgKTtcbiAgICAgIGxldCBrZXkgPSBnZXRTY3JvbGxSZXN0b3JhdGlvbktleShsb2NhdGlvbiwgdXNlck1hdGNoZXMpIHx8IGxvY2F0aW9uLmtleTtcbiAgICAgIGxldCB5ID0gc2F2ZWRTY3JvbGxQb3NpdGlvbnNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgeSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4geTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBfaW50ZXJuYWxTZXRSb3V0ZXMobmV3Um91dGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdFtdKSB7XG4gICAgaW5GbGlnaHREYXRhUm91dGVzID0gbmV3Um91dGVzO1xuICB9XG5cbiAgcm91dGVyID0ge1xuICAgIGdldCBiYXNlbmFtZSgpIHtcbiAgICAgIHJldHVybiBpbml0LmJhc2VuYW1lO1xuICAgIH0sXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG4gICAgZ2V0IHJvdXRlcygpIHtcbiAgICAgIHJldHVybiBkYXRhUm91dGVzO1xuICAgIH0sXG4gICAgaW5pdGlhbGl6ZSxcbiAgICBzdWJzY3JpYmUsXG4gICAgZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb24sXG4gICAgbmF2aWdhdGUsXG4gICAgZmV0Y2gsXG4gICAgcmV2YWxpZGF0ZSxcbiAgICAvLyBQYXNzdGhyb3VnaCB0byBoaXN0b3J5LWF3YXJlIGNyZWF0ZUhyZWYgdXNlZCBieSB1c2VIcmVmIHNvIHdlIGdldCBwcm9wZXJcbiAgICAvLyBoYXNoLWF3YXJlIFVSTHMgaW4gRE9NIHBhdGhzXG4gICAgY3JlYXRlSHJlZjogKHRvOiBUbykgPT4gaW5pdC5oaXN0b3J5LmNyZWF0ZUhyZWYodG8pLFxuICAgIGVuY29kZUxvY2F0aW9uOiAodG86IFRvKSA9PiBpbml0Lmhpc3RvcnkuZW5jb2RlTG9jYXRpb24odG8pLFxuICAgIGdldEZldGNoZXIsXG4gICAgZGVsZXRlRmV0Y2hlcixcbiAgICBkaXNwb3NlLFxuICAgIGdldEJsb2NrZXIsXG4gICAgZGVsZXRlQmxvY2tlcixcbiAgICBfaW50ZXJuYWxGZXRjaENvbnRyb2xsZXJzOiBmZXRjaENvbnRyb2xsZXJzLFxuICAgIF9pbnRlcm5hbEFjdGl2ZURlZmVycmVkczogYWN0aXZlRGVmZXJyZWRzLFxuICAgIC8vIFRPRE86IFJlbW92ZSBzZXRSb3V0ZXMsIGl0J3MgdGVtcG9yYXJ5IHRvIGF2b2lkIGRlYWxpbmcgd2l0aFxuICAgIC8vIHVwZGF0aW5nIHRoZSB0cmVlIHdoaWxlIHZhbGlkYXRpbmcgdGhlIHVwZGF0ZSBhbGdvcml0aG0uXG4gICAgX2ludGVybmFsU2V0Um91dGVzLFxuICB9O1xuXG4gIHJldHVybiByb3V0ZXI7XG59XG4vLyNlbmRyZWdpb25cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBjcmVhdGVTdGF0aWNIYW5kbGVyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5leHBvcnQgY29uc3QgVU5TQUZFX0RFRkVSUkVEX1NZTUJPTCA9IFN5bWJvbChcImRlZmVycmVkXCIpO1xuXG5leHBvcnQgaW50ZXJmYWNlIENyZWF0ZVN0YXRpY0hhbmRsZXJPcHRpb25zIHtcbiAgYmFzZW5hbWU/OiBzdHJpbmc7XG4gIGRldGVjdEVycm9yQm91bmRhcnk/OiBEZXRlY3RFcnJvckJvdW5kYXJ5RnVuY3Rpb247XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdGF0aWNIYW5kbGVyKFxuICByb3V0ZXM6IEFnbm9zdGljUm91dGVPYmplY3RbXSxcbiAgb3B0cz86IENyZWF0ZVN0YXRpY0hhbmRsZXJPcHRpb25zXG4pOiBTdGF0aWNIYW5kbGVyIHtcbiAgaW52YXJpYW50KFxuICAgIHJvdXRlcy5sZW5ndGggPiAwLFxuICAgIFwiWW91IG11c3QgcHJvdmlkZSBhIG5vbi1lbXB0eSByb3V0ZXMgYXJyYXkgdG8gY3JlYXRlU3RhdGljSGFuZGxlclwiXG4gICk7XG5cbiAgbGV0IG1hbmlmZXN0OiBSb3V0ZU1hbmlmZXN0ID0ge307XG4gIGxldCBkZXRlY3RFcnJvckJvdW5kYXJ5ID1cbiAgICBvcHRzPy5kZXRlY3RFcnJvckJvdW5kYXJ5IHx8IGRlZmF1bHREZXRlY3RFcnJvckJvdW5kYXJ5O1xuICBsZXQgZGF0YVJvdXRlcyA9IGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMoXG4gICAgcm91dGVzLFxuICAgIGRldGVjdEVycm9yQm91bmRhcnksXG4gICAgdW5kZWZpbmVkLFxuICAgIG1hbmlmZXN0XG4gICk7XG4gIGxldCBiYXNlbmFtZSA9IChvcHRzID8gb3B0cy5iYXNlbmFtZSA6IG51bGwpIHx8IFwiL1wiO1xuXG4gIC8qKlxuICAgKiBUaGUgcXVlcnkoKSBtZXRob2QgaXMgaW50ZW5kZWQgZm9yIGRvY3VtZW50IHJlcXVlc3RzLCBpbiB3aGljaCB3ZSB3YW50IHRvXG4gICAqIGNhbGwgYW4gb3B0aW9uYWwgYWN0aW9uIGFuZCBwb3RlbnRpYWxseSBtdWx0aXBsZSBsb2FkZXJzIGZvciBhbGwgbmVzdGVkXG4gICAqIHJvdXRlcy4gIEl0IHJldHVybnMgYSBTdGF0aWNIYW5kbGVyQ29udGV4dCBvYmplY3QsIHdoaWNoIGlzIHZlcnkgc2ltaWxhclxuICAgKiB0byB0aGUgcm91dGVyIHN0YXRlIChsb2NhdGlvbiwgbG9hZGVyRGF0YSwgYWN0aW9uRGF0YSwgZXJyb3JzLCBldGMuKSBhbmRcbiAgICogYWxzbyBhZGRzIFNTUi1zcGVjaWZpYyBpbmZvcm1hdGlvbiBzdWNoIGFzIHRoZSBzdGF0dXNDb2RlIGFuZCBoZWFkZXJzXG4gICAqIGZyb20gYWN0aW9uL2xvYWRlcnMgUmVzcG9uc2VzLlxuICAgKlxuICAgKiBJdCBfc2hvdWxkXyBuZXZlciB0aHJvdyBhbmQgc2hvdWxkIHJlcG9ydCBhbGwgZXJyb3JzIHRocm91Z2ggdGhlXG4gICAqIHJldHVybmVkIGNvbnRleHQuZXJyb3JzIG9iamVjdCwgcHJvcGVybHkgYXNzb2NpYXRpbmcgZXJyb3JzIHRvIHRoZWlyIGVycm9yXG4gICAqIGJvdW5kYXJ5LiAgQWRkaXRpb25hbGx5LCBpdCB0cmFja3MgX2RlZXBlc3RSZW5kZXJlZEJvdW5kYXJ5SWQgd2hpY2ggY2FuIGJlXG4gICAqIHVzZWQgdG8gZW11bGF0ZSBSZWFjdCBlcnJvciBib3VuZGFyaWVzIGR1cmluZyBTU3IgYnkgcGVyZm9ybWluZyBhIHNlY29uZFxuICAgKiBwYXNzIG9ubHkgZG93biB0byB0aGUgYm91bmRhcnlJZC5cbiAgICpcbiAgICogVGhlIG9uZSBleGNlcHRpb24gd2hlcmUgd2UgZG8gbm90IHJldHVybiBhIFN0YXRpY0hhbmRsZXJDb250ZXh0IGlzIHdoZW4gYVxuICAgKiByZWRpcmVjdCByZXNwb25zZSBpcyByZXR1cm5lZCBvciB0aHJvd24gZnJvbSBhbnkgYWN0aW9uL2xvYWRlci4gIFdlXG4gICAqIHByb3BhZ2F0ZSB0aGF0IG91dCBhbmQgcmV0dXJuIHRoZSByYXcgUmVzcG9uc2Ugc28gdGhlIEhUVFAgc2VydmVyIGNhblxuICAgKiByZXR1cm4gaXQgZGlyZWN0bHkuXG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiBxdWVyeShcbiAgICByZXF1ZXN0OiBSZXF1ZXN0LFxuICAgIHsgcmVxdWVzdENvbnRleHQgfTogeyByZXF1ZXN0Q29udGV4dD86IHVua25vd24gfSA9IHt9XG4gICk6IFByb21pc2U8U3RhdGljSGFuZGxlckNvbnRleHQgfCBSZXNwb25zZT4ge1xuICAgIGxldCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgICBsZXQgbWV0aG9kID0gcmVxdWVzdC5tZXRob2QudG9Mb3dlckNhc2UoKTtcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihcIlwiLCBjcmVhdGVQYXRoKHVybCksIG51bGwsIFwiZGVmYXVsdFwiKTtcbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKGRhdGFSb3V0ZXMsIGxvY2F0aW9uLCBiYXNlbmFtZSk7XG5cbiAgICAvLyBTU1Igc3VwcG9ydHMgSEVBRCByZXF1ZXN0cyB3aGlsZSBTUEEgZG9lc24ndFxuICAgIGlmICghaXNWYWxpZE1ldGhvZChtZXRob2QpICYmIG1ldGhvZCAhPT0gXCJoZWFkXCIpIHtcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7IG1ldGhvZCB9KTtcbiAgICAgIGxldCB7IG1hdGNoZXM6IG1ldGhvZE5vdEFsbG93ZWRNYXRjaGVzLCByb3V0ZSB9ID1cbiAgICAgICAgZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyhkYXRhUm91dGVzKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJhc2VuYW1lLFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgbWF0Y2hlczogbWV0aG9kTm90QWxsb3dlZE1hdGNoZXMsXG4gICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICBhY3Rpb25EYXRhOiBudWxsLFxuICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICBbcm91dGUuaWRdOiBlcnJvcixcbiAgICAgICAgfSxcbiAgICAgICAgc3RhdHVzQ29kZTogZXJyb3Iuc3RhdHVzLFxuICAgICAgICBsb2FkZXJIZWFkZXJzOiB7fSxcbiAgICAgICAgYWN0aW9uSGVhZGVyczoge30sXG4gICAgICAgIGFjdGl2ZURlZmVycmVkczogbnVsbCxcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICghbWF0Y2hlcykge1xuICAgICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHsgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lIH0pO1xuICAgICAgbGV0IHsgbWF0Y2hlczogbm90Rm91bmRNYXRjaGVzLCByb3V0ZSB9ID1cbiAgICAgICAgZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyhkYXRhUm91dGVzKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJhc2VuYW1lLFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgbWF0Y2hlczogbm90Rm91bmRNYXRjaGVzLFxuICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgYWN0aW9uRGF0YTogbnVsbCxcbiAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgW3JvdXRlLmlkXTogZXJyb3IsXG4gICAgICAgIH0sXG4gICAgICAgIHN0YXR1c0NvZGU6IGVycm9yLnN0YXR1cyxcbiAgICAgICAgbG9hZGVySGVhZGVyczoge30sXG4gICAgICAgIGFjdGlvbkhlYWRlcnM6IHt9LFxuICAgICAgICBhY3RpdmVEZWZlcnJlZHM6IG51bGwsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGxldCByZXN1bHQgPSBhd2FpdCBxdWVyeUltcGwocmVxdWVzdCwgbG9jYXRpb24sIG1hdGNoZXMsIHJlcXVlc3RDb250ZXh0KTtcbiAgICBpZiAoaXNSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIFdoZW4gcmV0dXJuaW5nIFN0YXRpY0hhbmRsZXJDb250ZXh0LCB3ZSBwYXRjaCBiYWNrIGluIHRoZSBsb2NhdGlvbiBoZXJlXG4gICAgLy8gc2luY2Ugd2UgbmVlZCBpdCBmb3IgUmVhY3QgQ29udGV4dC4gIEJ1dCB0aGlzIGhlbHBzIGtlZXAgb3VyIHN1Ym1pdCBhbmRcbiAgICAvLyBsb2FkUm91dGVEYXRhIG9wZXJhdGluZyBvbiBhIFJlcXVlc3QgaW5zdGVhZCBvZiBhIExvY2F0aW9uXG4gICAgcmV0dXJuIHsgbG9jYXRpb24sIGJhc2VuYW1lLCAuLi5yZXN1bHQgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcXVlcnlSb3V0ZSgpIG1ldGhvZCBpcyBpbnRlbmRlZCBmb3IgdGFyZ2V0ZWQgcm91dGUgcmVxdWVzdHMsIGVpdGhlclxuICAgKiBmb3IgZmV0Y2ggP19kYXRhIHJlcXVlc3RzIG9yIHJlc291cmNlIHJvdXRlIHJlcXVlc3RzLiAgSW4gdGhpcyBjYXNlLCB3ZVxuICAgKiBhcmUgb25seSBldmVyIGNhbGxpbmcgYSBzaW5nbGUgYWN0aW9uIG9yIGxvYWRlciwgYW5kIHdlIGFyZSByZXR1cm5pbmcgdGhlXG4gICAqIHJldHVybmVkIHZhbHVlIGRpcmVjdGx5LiAgSW4gbW9zdCBjYXNlcywgdGhpcyB3aWxsIGJlIGEgUmVzcG9uc2UgcmV0dXJuZWRcbiAgICogZnJvbSB0aGUgYWN0aW9uL2xvYWRlciwgYnV0IGl0IG1heSBiZSBhIHByaW1pdGl2ZSBvciBvdGhlciB2YWx1ZSBhcyB3ZWxsIC1cbiAgICogYW5kIGluIHN1Y2ggY2FzZXMgdGhlIGNhbGxpbmcgY29udGV4dCBzaG91bGQgaGFuZGxlIHRoYXQgYWNjb3JkaW5nbHkuXG4gICAqXG4gICAqIFdlIGRvIHJlc3BlY3QgdGhlIHRocm93L3JldHVybiBkaWZmZXJlbnRpYXRpb24sIHNvIGlmIGFuIGFjdGlvbi9sb2FkZXJcbiAgICogdGhyb3dzLCB0aGVuIHRoaXMgbWV0aG9kIHdpbGwgdGhyb3cgdGhlIHZhbHVlLiAgVGhpcyBpcyBpbXBvcnRhbnQgc28gd2VcbiAgICogY2FuIGRvIHByb3BlciBib3VuZGFyeSBpZGVudGlmaWNhdGlvbiBpbiBSZW1peCB3aGVyZSBhIHRocm93biBSZXNwb25zZVxuICAgKiBtdXN0IGdvIHRvIHRoZSBDYXRjaCBCb3VuZGFyeSBidXQgYSByZXR1cm5lZCBSZXNwb25zZSBpcyBoYXBweS1wYXRoLlxuICAgKlxuICAgKiBPbmUgdGhpbmcgdG8gbm90ZSBpcyB0aGF0IGFueSBSb3V0ZXItaW5pdGlhdGVkIEVycm9ycyB0aGF0IG1ha2Ugc2Vuc2VcbiAgICogdG8gYXNzb2NpYXRlIHdpdGggYSBzdGF0dXMgY29kZSB3aWxsIGJlIHRocm93biBhcyBhbiBFcnJvclJlc3BvbnNlXG4gICAqIGluc3RhbmNlIHdoaWNoIGluY2x1ZGUgdGhlIHJhdyBFcnJvciwgc3VjaCB0aGF0IHRoZSBjYWxsaW5nIGNvbnRleHQgY2FuXG4gICAqIHNlcmlhbGl6ZSB0aGUgZXJyb3IgYXMgdGhleSBzZWUgZml0IHdoaWxlIGluY2x1ZGluZyB0aGUgcHJvcGVyIHJlc3BvbnNlXG4gICAqIGNvZGUuICBFeGFtcGxlcyBoZXJlIGFyZSA0MDQgYW5kIDQwNSBlcnJvcnMgdGhhdCBvY2N1ciBwcmlvciB0byByZWFjaGluZ1xuICAgKiBhbnkgdXNlci1kZWZpbmVkIGxvYWRlcnMuXG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiBxdWVyeVJvdXRlKFxuICAgIHJlcXVlc3Q6IFJlcXVlc3QsXG4gICAge1xuICAgICAgcm91dGVJZCxcbiAgICAgIHJlcXVlc3RDb250ZXh0LFxuICAgIH06IHsgcmVxdWVzdENvbnRleHQ/OiB1bmtub3duOyByb3V0ZUlkPzogc3RyaW5nIH0gPSB7fVxuICApOiBQcm9taXNlPGFueT4ge1xuICAgIGxldCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgICBsZXQgbWV0aG9kID0gcmVxdWVzdC5tZXRob2QudG9Mb3dlckNhc2UoKTtcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihcIlwiLCBjcmVhdGVQYXRoKHVybCksIG51bGwsIFwiZGVmYXVsdFwiKTtcbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKGRhdGFSb3V0ZXMsIGxvY2F0aW9uLCBiYXNlbmFtZSk7XG5cbiAgICAvLyBTU1Igc3VwcG9ydHMgSEVBRCByZXF1ZXN0cyB3aGlsZSBTUEEgZG9lc24ndFxuICAgIGlmICghaXNWYWxpZE1ldGhvZChtZXRob2QpICYmIG1ldGhvZCAhPT0gXCJoZWFkXCIgJiYgbWV0aG9kICE9PSBcIm9wdGlvbnNcIikge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHsgbWV0aG9kIH0pO1xuICAgIH0gZWxzZSBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7IHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSB9KTtcbiAgICB9XG5cbiAgICBsZXQgbWF0Y2ggPSByb3V0ZUlkXG4gICAgICA/IG1hdGNoZXMuZmluZCgobSkgPT4gbS5yb3V0ZS5pZCA9PT0gcm91dGVJZClcbiAgICAgIDogZ2V0VGFyZ2V0TWF0Y2gobWF0Y2hlcywgbG9jYXRpb24pO1xuXG4gICAgaWYgKHJvdXRlSWQgJiYgIW1hdGNoKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMywge1xuICAgICAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgIHJvdXRlSWQsXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCFtYXRjaCkge1xuICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGl0IEkgZG9uJ3QgdGhpbms/XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwgeyBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUgfSk7XG4gICAgfVxuXG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IHF1ZXJ5SW1wbChcbiAgICAgIHJlcXVlc3QsXG4gICAgICBsb2NhdGlvbixcbiAgICAgIG1hdGNoZXMsXG4gICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgIG1hdGNoXG4gICAgKTtcbiAgICBpZiAoaXNSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGxldCBlcnJvciA9IHJlc3VsdC5lcnJvcnMgPyBPYmplY3QudmFsdWVzKHJlc3VsdC5lcnJvcnMpWzBdIDogdW5kZWZpbmVkO1xuICAgIGlmIChlcnJvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBJZiB3ZSBnb3QgYmFjayByZXN1bHQuZXJyb3JzLCB0aGF0IG1lYW5zIHRoZSBsb2FkZXIvYWN0aW9uIHRocmV3XG4gICAgICAvLyBfc29tZXRoaW5nXyB0aGF0IHdhc24ndCBhIFJlc3BvbnNlLCBidXQgaXQncyBub3QgZ3VhcmFudGVlZC9yZXF1aXJlZFxuICAgICAgLy8gdG8gYmUgYW4gYGluc3RhbmNlb2YgRXJyb3JgIGVpdGhlciwgc28gd2UgaGF2ZSB0byB1c2UgdGhyb3cgaGVyZSB0b1xuICAgICAgLy8gcHJlc2VydmUgdGhlIFwiZXJyb3JcIiBzdGF0ZSBvdXRzaWRlIG9mIHF1ZXJ5SW1wbC5cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIC8vIFBpY2sgb2ZmIHRoZSByaWdodCBzdGF0ZSB2YWx1ZSB0byByZXR1cm5cbiAgICBpZiAocmVzdWx0LmFjdGlvbkRhdGEpIHtcbiAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHJlc3VsdC5hY3Rpb25EYXRhKVswXTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0LmxvYWRlckRhdGEpIHtcbiAgICAgIGxldCBkYXRhID0gT2JqZWN0LnZhbHVlcyhyZXN1bHQubG9hZGVyRGF0YSlbMF07XG4gICAgICBpZiAocmVzdWx0LmFjdGl2ZURlZmVycmVkcz8uW21hdGNoLnJvdXRlLmlkXSkge1xuICAgICAgICBkYXRhW1VOU0FGRV9ERUZFUlJFRF9TWU1CT0xdID0gcmVzdWx0LmFjdGl2ZURlZmVycmVkc1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gcXVlcnlJbXBsKFxuICAgIHJlcXVlc3Q6IFJlcXVlc3QsXG4gICAgbG9jYXRpb246IExvY2F0aW9uLFxuICAgIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgICByZXF1ZXN0Q29udGV4dDogdW5rbm93bixcbiAgICByb3V0ZU1hdGNoPzogQWdub3N0aWNEYXRhUm91dGVNYXRjaFxuICApOiBQcm9taXNlPE9taXQ8U3RhdGljSGFuZGxlckNvbnRleHQsIFwibG9jYXRpb25cIiB8IFwiYmFzZW5hbWVcIj4gfCBSZXNwb25zZT4ge1xuICAgIGludmFyaWFudChcbiAgICAgIHJlcXVlc3Quc2lnbmFsLFxuICAgICAgXCJxdWVyeSgpL3F1ZXJ5Um91dGUoKSByZXF1ZXN0cyBtdXN0IGNvbnRhaW4gYW4gQWJvcnRDb250cm9sbGVyIHNpZ25hbFwiXG4gICAgKTtcblxuICAgIHRyeSB7XG4gICAgICBpZiAoaXNNdXRhdGlvbk1ldGhvZChyZXF1ZXN0Lm1ldGhvZC50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgc3VibWl0KFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICByb3V0ZU1hdGNoIHx8IGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIGxvY2F0aW9uKSxcbiAgICAgICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgICAgICByb3V0ZU1hdGNoICE9IG51bGxcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IGxvYWRSb3V0ZURhdGEoXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIHJlcXVlc3RDb250ZXh0LFxuICAgICAgICByb3V0ZU1hdGNoXG4gICAgICApO1xuICAgICAgcmV0dXJuIGlzUmVzcG9uc2UocmVzdWx0KVxuICAgICAgICA/IHJlc3VsdFxuICAgICAgICA6IHtcbiAgICAgICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgICAgIGFjdGlvbkRhdGE6IG51bGwsXG4gICAgICAgICAgICBhY3Rpb25IZWFkZXJzOiB7fSxcbiAgICAgICAgICB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHRocmV3L3JldHVybmVkIGEgUmVzcG9uc2UgaW4gY2FsbExvYWRlck9yQWN0aW9uLCB3ZSB0aHJvd1xuICAgICAgLy8gaXQgdG8gYmFpbCBvdXQgYW5kIHRoZW4gcmV0dXJuIG9yIHRocm93IGhlcmUgYmFzZWQgb24gd2hldGhlciB0aGUgdXNlclxuICAgICAgLy8gcmV0dXJuZWQgb3IgdGhyZXdcbiAgICAgIGlmIChpc1F1ZXJ5Um91dGVSZXNwb25zZShlKSkge1xuICAgICAgICBpZiAoZS50eXBlID09PSBSZXN1bHRUeXBlLmVycm9yICYmICFpc1JlZGlyZWN0UmVzcG9uc2UoZS5yZXNwb25zZSkpIHtcbiAgICAgICAgICB0aHJvdyBlLnJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlLnJlc3BvbnNlO1xuICAgICAgfVxuICAgICAgLy8gUmVkaXJlY3RzIGFyZSBhbHdheXMgcmV0dXJuZWQgc2luY2UgdGhleSBkb24ndCBwcm9wYWdhdGUgdG8gY2F0Y2hcbiAgICAgIC8vIGJvdW5kYXJpZXNcbiAgICAgIGlmIChpc1JlZGlyZWN0UmVzcG9uc2UoZSkpIHtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIHN1Ym1pdChcbiAgICByZXF1ZXN0OiBSZXF1ZXN0LFxuICAgIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgICBhY3Rpb25NYXRjaDogQWdub3N0aWNEYXRhUm91dGVNYXRjaCxcbiAgICByZXF1ZXN0Q29udGV4dDogdW5rbm93bixcbiAgICBpc1JvdXRlUmVxdWVzdDogYm9vbGVhblxuICApOiBQcm9taXNlPE9taXQ8U3RhdGljSGFuZGxlckNvbnRleHQsIFwibG9jYXRpb25cIiB8IFwiYmFzZW5hbWVcIj4gfCBSZXNwb25zZT4ge1xuICAgIGxldCByZXN1bHQ6IERhdGFSZXN1bHQ7XG5cbiAgICBpZiAoIWFjdGlvbk1hdGNoLnJvdXRlLmFjdGlvbiAmJiAhYWN0aW9uTWF0Y2gucm91dGUubGF6eSkge1xuICAgICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHtcbiAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgcGF0aG5hbWU6IG5ldyBVUkwocmVxdWVzdC51cmwpLnBhdGhuYW1lLFxuICAgICAgICByb3V0ZUlkOiBhY3Rpb25NYXRjaC5yb3V0ZS5pZCxcbiAgICAgIH0pO1xuICAgICAgaWYgKGlzUm91dGVSZXF1ZXN0KSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLmVycm9yLFxuICAgICAgICBlcnJvcixcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGF3YWl0IGNhbGxMb2FkZXJPckFjdGlvbihcbiAgICAgICAgXCJhY3Rpb25cIixcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgYWN0aW9uTWF0Y2gsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIG1hbmlmZXN0LFxuICAgICAgICBkZXRlY3RFcnJvckJvdW5kYXJ5LFxuICAgICAgICBiYXNlbmFtZSxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgaXNSb3V0ZVJlcXVlc3QsXG4gICAgICAgIHJlcXVlc3RDb250ZXh0XG4gICAgICApO1xuXG4gICAgICBpZiAocmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICBsZXQgbWV0aG9kID0gaXNSb3V0ZVJlcXVlc3QgPyBcInF1ZXJ5Um91dGVcIiA6IFwicXVlcnlcIjtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke21ldGhvZH0oKSBjYWxsIGFib3J0ZWRgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAvLyBVaGhoaCAtIHRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiwgd2Ugc2hvdWxkIGFsd2F5cyB0aHJvdyB0aGVzZSBmcm9tXG4gICAgICAvLyBjYWxsTG9hZGVyT3JBY3Rpb24sIGJ1dCB0aGUgdHlwZSBuYXJyb3dpbmcgaGVyZSBrZWVwcyBUUyBoYXBweSBhbmQgd2VcbiAgICAgIC8vIGNhbiBnZXQgYmFjayBvbiB0aGUgXCJ0aHJvdyBhbGwgcmVkaXJlY3QgcmVzcG9uc2VzXCIgdHJhaW4gaGVyZSBzaG91bGRcbiAgICAgIC8vIHRoaXMgZXZlciBoYXBwZW4gOi9cbiAgICAgIHRocm93IG5ldyBSZXNwb25zZShudWxsLCB7XG4gICAgICAgIHN0YXR1czogcmVzdWx0LnN0YXR1cyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiByZXN1bHQubG9jYXRpb24sXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMCwgeyB0eXBlOiBcImRlZmVyLWFjdGlvblwiIH0pO1xuICAgICAgaWYgKGlzUm91dGVSZXF1ZXN0KSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLmVycm9yLFxuICAgICAgICBlcnJvcixcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGlzUm91dGVSZXF1ZXN0KSB7XG4gICAgICAvLyBOb3RlOiBUaGlzIHNob3VsZCBvbmx5IGJlIG5vbi1SZXNwb25zZSB2YWx1ZXMgaWYgd2UgZ2V0IGhlcmUsIHNpbmNlXG4gICAgICAvLyBpc1JvdXRlUmVxdWVzdCBzaG91bGQgdGhyb3cgYW55IFJlc3BvbnNlIHJlY2VpdmVkIGluIGNhbGxMb2FkZXJPckFjdGlvblxuICAgICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hdGNoZXM6IFthY3Rpb25NYXRjaF0sXG4gICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICBhY3Rpb25EYXRhOiB7IFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5kYXRhIH0sXG4gICAgICAgIGVycm9yczogbnVsbCxcbiAgICAgICAgLy8gTm90ZTogc3RhdHVzQ29kZSArIGhlYWRlcnMgYXJlIHVudXNlZCBoZXJlIHNpbmNlIHF1ZXJ5Um91dGUgd2lsbFxuICAgICAgICAvLyByZXR1cm4gdGhlIHJhdyBSZXNwb25zZSBvciB2YWx1ZVxuICAgICAgICBzdGF0dXNDb2RlOiAyMDAsXG4gICAgICAgIGxvYWRlckhlYWRlcnM6IHt9LFxuICAgICAgICBhY3Rpb25IZWFkZXJzOiB7fSxcbiAgICAgICAgYWN0aXZlRGVmZXJyZWRzOiBudWxsLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAvLyBTdG9yZSBvZmYgdGhlIHBlbmRpbmcgZXJyb3IgLSB3ZSB1c2UgaXQgdG8gZGV0ZXJtaW5lIHdoaWNoIGxvYWRlcnNcbiAgICAgIC8vIHRvIGNhbGwgYW5kIHdpbGwgY29tbWl0IGl0IHdoZW4gd2UgY29tcGxldGUgdGhlIG5hdmlnYXRpb25cbiAgICAgIGxldCBib3VuZGFyeU1hdGNoID0gZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzLCBhY3Rpb25NYXRjaC5yb3V0ZS5pZCk7XG4gICAgICBsZXQgY29udGV4dCA9IGF3YWl0IGxvYWRSb3V0ZURhdGEoXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIHJlcXVlc3RDb250ZXh0LFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHtcbiAgICAgICAgICBbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5lcnJvcixcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgLy8gYWN0aW9uIHN0YXR1cyBjb2RlcyB0YWtlIHByZWNlZGVuY2Ugb3ZlciBsb2FkZXIgc3RhdHVzIGNvZGVzXG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5jb250ZXh0LFxuICAgICAgICBzdGF0dXNDb2RlOiBpc1JvdXRlRXJyb3JSZXNwb25zZShyZXN1bHQuZXJyb3IpXG4gICAgICAgICAgPyByZXN1bHQuZXJyb3Iuc3RhdHVzXG4gICAgICAgICAgOiA1MDAsXG4gICAgICAgIGFjdGlvbkRhdGE6IG51bGwsXG4gICAgICAgIGFjdGlvbkhlYWRlcnM6IHtcbiAgICAgICAgICAuLi4ocmVzdWx0LmhlYWRlcnMgPyB7IFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5oZWFkZXJzIH0gOiB7fSksXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIEdFVCByZXF1ZXN0IGZvciB0aGUgbG9hZGVyc1xuICAgIGxldCBsb2FkZXJSZXF1ZXN0ID0gbmV3IFJlcXVlc3QocmVxdWVzdC51cmwsIHtcbiAgICAgIGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVycyxcbiAgICAgIHJlZGlyZWN0OiByZXF1ZXN0LnJlZGlyZWN0LFxuICAgICAgc2lnbmFsOiByZXF1ZXN0LnNpZ25hbCxcbiAgICB9KTtcbiAgICBsZXQgY29udGV4dCA9IGF3YWl0IGxvYWRSb3V0ZURhdGEobG9hZGVyUmVxdWVzdCwgbWF0Y2hlcywgcmVxdWVzdENvbnRleHQpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmNvbnRleHQsXG4gICAgICAvLyBhY3Rpb24gc3RhdHVzIGNvZGVzIHRha2UgcHJlY2VkZW5jZSBvdmVyIGxvYWRlciBzdGF0dXMgY29kZXNcbiAgICAgIC4uLihyZXN1bHQuc3RhdHVzQ29kZSA/IHsgc3RhdHVzQ29kZTogcmVzdWx0LnN0YXR1c0NvZGUgfSA6IHt9KSxcbiAgICAgIGFjdGlvbkRhdGE6IHtcbiAgICAgICAgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmRhdGEsXG4gICAgICB9LFxuICAgICAgYWN0aW9uSGVhZGVyczoge1xuICAgICAgICAuLi4ocmVzdWx0LmhlYWRlcnMgPyB7IFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5oZWFkZXJzIH0gOiB7fSksXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBsb2FkUm91dGVEYXRhKFxuICAgIHJlcXVlc3Q6IFJlcXVlc3QsXG4gICAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICAgIHJlcXVlc3RDb250ZXh0OiB1bmtub3duLFxuICAgIHJvdXRlTWF0Y2g/OiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoLFxuICAgIHBlbmRpbmdBY3Rpb25FcnJvcj86IFJvdXRlRGF0YVxuICApOiBQcm9taXNlPFxuICAgIHwgT21pdDxcbiAgICAgICAgU3RhdGljSGFuZGxlckNvbnRleHQsXG4gICAgICAgIFwibG9jYXRpb25cIiB8IFwiYmFzZW5hbWVcIiB8IFwiYWN0aW9uRGF0YVwiIHwgXCJhY3Rpb25IZWFkZXJzXCJcbiAgICAgID5cbiAgICB8IFJlc3BvbnNlXG4gID4ge1xuICAgIGxldCBpc1JvdXRlUmVxdWVzdCA9IHJvdXRlTWF0Y2ggIT0gbnVsbDtcblxuICAgIC8vIFNob3J0IGNpcmN1aXQgaWYgd2UgaGF2ZSBubyBsb2FkZXJzIHRvIHJ1biAocXVlcnlSb3V0ZSgpKVxuICAgIGlmIChcbiAgICAgIGlzUm91dGVSZXF1ZXN0ICYmXG4gICAgICAhcm91dGVNYXRjaD8ucm91dGUubG9hZGVyICYmXG4gICAgICAhcm91dGVNYXRjaD8ucm91dGUubGF6eVxuICAgICkge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDAsIHtcbiAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgcGF0aG5hbWU6IG5ldyBVUkwocmVxdWVzdC51cmwpLnBhdGhuYW1lLFxuICAgICAgICByb3V0ZUlkOiByb3V0ZU1hdGNoPy5yb3V0ZS5pZCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGxldCByZXF1ZXN0TWF0Y2hlcyA9IHJvdXRlTWF0Y2hcbiAgICAgID8gW3JvdXRlTWF0Y2hdXG4gICAgICA6IGdldExvYWRlck1hdGNoZXNVbnRpbEJvdW5kYXJ5KFxuICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgT2JqZWN0LmtleXMocGVuZGluZ0FjdGlvbkVycm9yIHx8IHt9KVswXVxuICAgICAgICApO1xuICAgIGxldCBtYXRjaGVzVG9Mb2FkID0gcmVxdWVzdE1hdGNoZXMuZmlsdGVyKFxuICAgICAgKG0pID0+IG0ucm91dGUubG9hZGVyIHx8IG0ucm91dGUubGF6eVxuICAgICk7XG5cbiAgICAvLyBTaG9ydCBjaXJjdWl0IGlmIHdlIGhhdmUgbm8gbG9hZGVycyB0byBydW4gKHF1ZXJ5KCkpXG4gICAgaWYgKG1hdGNoZXNUb0xvYWQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXRjaGVzLFxuICAgICAgICAvLyBBZGQgYSBudWxsIGZvciBhbGwgbWF0Y2hlZCByb3V0ZXMgZm9yIHByb3BlciByZXZhbGlkYXRpb24gb24gdGhlIGNsaWVudFxuICAgICAgICBsb2FkZXJEYXRhOiBtYXRjaGVzLnJlZHVjZShcbiAgICAgICAgICAoYWNjLCBtKSA9PiBPYmplY3QuYXNzaWduKGFjYywgeyBbbS5yb3V0ZS5pZF06IG51bGwgfSksXG4gICAgICAgICAge31cbiAgICAgICAgKSxcbiAgICAgICAgZXJyb3JzOiBwZW5kaW5nQWN0aW9uRXJyb3IgfHwgbnVsbCxcbiAgICAgICAgc3RhdHVzQ29kZTogMjAwLFxuICAgICAgICBsb2FkZXJIZWFkZXJzOiB7fSxcbiAgICAgICAgYWN0aXZlRGVmZXJyZWRzOiBudWxsLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIC4uLm1hdGNoZXNUb0xvYWQubWFwKChtYXRjaCkgPT5cbiAgICAgICAgY2FsbExvYWRlck9yQWN0aW9uKFxuICAgICAgICAgIFwibG9hZGVyXCIsXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgIG1hbmlmZXN0LFxuICAgICAgICAgIGRldGVjdEVycm9yQm91bmRhcnksXG4gICAgICAgICAgYmFzZW5hbWUsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICBpc1JvdXRlUmVxdWVzdCxcbiAgICAgICAgICByZXF1ZXN0Q29udGV4dFxuICAgICAgICApXG4gICAgICApLFxuICAgIF0pO1xuXG4gICAgaWYgKHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIGxldCBtZXRob2QgPSBpc1JvdXRlUmVxdWVzdCA/IFwicXVlcnlSb3V0ZVwiIDogXCJxdWVyeVwiO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke21ldGhvZH0oKSBjYWxsIGFib3J0ZWRgKTtcbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIGFuZCBjb21taXQgb3V0cHV0IGZyb20gbG9hZGVyc1xuICAgIGxldCBhY3RpdmVEZWZlcnJlZHMgPSBuZXcgTWFwPHN0cmluZywgRGVmZXJyZWREYXRhPigpO1xuICAgIGxldCBjb250ZXh0ID0gcHJvY2Vzc1JvdXRlTG9hZGVyRGF0YShcbiAgICAgIG1hdGNoZXMsXG4gICAgICBtYXRjaGVzVG9Mb2FkLFxuICAgICAgcmVzdWx0cyxcbiAgICAgIHBlbmRpbmdBY3Rpb25FcnJvcixcbiAgICAgIGFjdGl2ZURlZmVycmVkc1xuICAgICk7XG5cbiAgICAvLyBBZGQgYSBudWxsIGZvciBhbnkgbm9uLWxvYWRlciBtYXRjaGVzIGZvciBwcm9wZXIgcmV2YWxpZGF0aW9uIG9uIHRoZSBjbGllbnRcbiAgICBsZXQgZXhlY3V0ZWRMb2FkZXJzID0gbmV3IFNldDxzdHJpbmc+KFxuICAgICAgbWF0Y2hlc1RvTG9hZC5tYXAoKG1hdGNoKSA9PiBtYXRjaC5yb3V0ZS5pZClcbiAgICApO1xuICAgIG1hdGNoZXMuZm9yRWFjaCgobWF0Y2gpID0+IHtcbiAgICAgIGlmICghZXhlY3V0ZWRMb2FkZXJzLmhhcyhtYXRjaC5yb3V0ZS5pZCkpIHtcbiAgICAgICAgY29udGV4dC5sb2FkZXJEYXRhW21hdGNoLnJvdXRlLmlkXSA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uY29udGV4dCxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBhY3RpdmVEZWZlcnJlZHM6XG4gICAgICAgIGFjdGl2ZURlZmVycmVkcy5zaXplID4gMFxuICAgICAgICAgID8gT2JqZWN0LmZyb21FbnRyaWVzKGFjdGl2ZURlZmVycmVkcy5lbnRyaWVzKCkpXG4gICAgICAgICAgOiBudWxsLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGRhdGFSb3V0ZXMsXG4gICAgcXVlcnksXG4gICAgcXVlcnlSb3V0ZSxcbiAgfTtcbn1cblxuLy8jZW5kcmVnaW9uXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gSGVscGVyc1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBHaXZlbiBhbiBleGlzdGluZyBTdGF0aWNIYW5kbGVyQ29udGV4dCBhbmQgYW4gZXJyb3IgdGhyb3duIGF0IHJlbmRlciB0aW1lLFxuICogcHJvdmlkZSBhbiB1cGRhdGVkIFN0YXRpY0hhbmRsZXJDb250ZXh0IHN1aXRhYmxlIGZvciBhIHNlY29uZCBTU1IgcmVuZGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdGF0aWNDb250ZXh0RnJvbUVycm9yKFxuICByb3V0ZXM6IEFnbm9zdGljRGF0YVJvdXRlT2JqZWN0W10sXG4gIGNvbnRleHQ6IFN0YXRpY0hhbmRsZXJDb250ZXh0LFxuICBlcnJvcjogYW55XG4pIHtcbiAgbGV0IG5ld0NvbnRleHQ6IFN0YXRpY0hhbmRsZXJDb250ZXh0ID0ge1xuICAgIC4uLmNvbnRleHQsXG4gICAgc3RhdHVzQ29kZTogNTAwLFxuICAgIGVycm9yczoge1xuICAgICAgW2NvbnRleHQuX2RlZXBlc3RSZW5kZXJlZEJvdW5kYXJ5SWQgfHwgcm91dGVzWzBdLmlkXTogZXJyb3IsXG4gICAgfSxcbiAgfTtcbiAgcmV0dXJuIG5ld0NvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGlzU3VibWlzc2lvbk5hdmlnYXRpb24oXG4gIG9wdHM6IFJvdXRlck5hdmlnYXRlT3B0aW9uc1xuKTogb3B0cyBpcyBTdWJtaXNzaW9uTmF2aWdhdGVPcHRpb25zIHtcbiAgcmV0dXJuIG9wdHMgIT0gbnVsbCAmJiBcImZvcm1EYXRhXCIgaW4gb3B0cztcbn1cblxuLy8gTm9ybWFsaXplIG5hdmlnYXRpb24gb3B0aW9ucyBieSBjb252ZXJ0aW5nIGZvcm1NZXRob2Q9R0VUIGZvcm1EYXRhIG9iamVjdHMgdG9cbi8vIFVSTFNlYXJjaFBhcmFtcyBzbyB0aGV5IGJlaGF2ZSBpZGVudGljYWxseSB0byBsaW5rcyB3aXRoIHF1ZXJ5IHBhcmFtc1xuZnVuY3Rpb24gbm9ybWFsaXplTmF2aWdhdGVPcHRpb25zKFxuICB0bzogVG8sXG4gIG9wdHM/OiBSb3V0ZXJOYXZpZ2F0ZU9wdGlvbnMsXG4gIGlzRmV0Y2hlciA9IGZhbHNlXG4pOiB7XG4gIHBhdGg6IHN0cmluZztcbiAgc3VibWlzc2lvbj86IFN1Ym1pc3Npb247XG4gIGVycm9yPzogRXJyb3JSZXNwb25zZTtcbn0ge1xuICBsZXQgcGF0aCA9IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG5cbiAgLy8gUmV0dXJuIGxvY2F0aW9uIHZlcmJhdGltIG9uIG5vbi1zdWJtaXNzaW9uIG5hdmlnYXRpb25zXG4gIGlmICghb3B0cyB8fCAhaXNTdWJtaXNzaW9uTmF2aWdhdGlvbihvcHRzKSkge1xuICAgIHJldHVybiB7IHBhdGggfTtcbiAgfVxuXG4gIGlmIChvcHRzLmZvcm1NZXRob2QgJiYgIWlzVmFsaWRNZXRob2Qob3B0cy5mb3JtTWV0aG9kKSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoLFxuICAgICAgZXJyb3I6IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7IG1ldGhvZDogb3B0cy5mb3JtTWV0aG9kIH0pLFxuICAgIH07XG4gIH1cblxuICAvLyBDcmVhdGUgYSBTdWJtaXNzaW9uIG9uIG5vbi1HRVQgbmF2aWdhdGlvbnNcbiAgbGV0IHN1Ym1pc3Npb246IFN1Ym1pc3Npb24gfCB1bmRlZmluZWQ7XG4gIGlmIChvcHRzLmZvcm1EYXRhKSB7XG4gICAgc3VibWlzc2lvbiA9IHtcbiAgICAgIGZvcm1NZXRob2Q6IG9wdHMuZm9ybU1ldGhvZCB8fCBcImdldFwiLFxuICAgICAgZm9ybUFjdGlvbjogc3RyaXBIYXNoRnJvbVBhdGgocGF0aCksXG4gICAgICBmb3JtRW5jVHlwZTpcbiAgICAgICAgKG9wdHMgJiYgb3B0cy5mb3JtRW5jVHlwZSkgfHwgXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIixcbiAgICAgIGZvcm1EYXRhOiBvcHRzLmZvcm1EYXRhLFxuICAgIH07XG5cbiAgICBpZiAoaXNNdXRhdGlvbk1ldGhvZChzdWJtaXNzaW9uLmZvcm1NZXRob2QpKSB7XG4gICAgICByZXR1cm4geyBwYXRoLCBzdWJtaXNzaW9uIH07XG4gICAgfVxuICB9XG5cbiAgLy8gRmxhdHRlbiBzdWJtaXNzaW9uIG9udG8gVVJMU2VhcmNoUGFyYW1zIGZvciBHRVQgc3VibWlzc2lvbnNcbiAgbGV0IHBhcnNlZFBhdGggPSBwYXJzZVBhdGgocGF0aCk7XG4gIGxldCBzZWFyY2hQYXJhbXMgPSBjb252ZXJ0Rm9ybURhdGFUb1NlYXJjaFBhcmFtcyhvcHRzLmZvcm1EYXRhKTtcbiAgLy8gU2luY2UgZmV0Y2hlciBHRVQgc3VibWlzc2lvbnMgb25seSBydW4gYSBzaW5nbGUgbG9hZGVyIChhcyBvcHBvc2VkIHRvXG4gIC8vIG5hdmlnYXRpb24gR0VUIHN1Ym1pc3Npb25zIHdoaWNoIHJ1biBhbGwgbG9hZGVycyksIHdlIG5lZWQgdG8gcHJlc2VydmVcbiAgLy8gYW55IGluY29taW5nID9pbmRleCBwYXJhbXNcbiAgaWYgKGlzRmV0Y2hlciAmJiBwYXJzZWRQYXRoLnNlYXJjaCAmJiBoYXNOYWtlZEluZGV4UXVlcnkocGFyc2VkUGF0aC5zZWFyY2gpKSB7XG4gICAgc2VhcmNoUGFyYW1zLmFwcGVuZChcImluZGV4XCIsIFwiXCIpO1xuICB9XG4gIHBhcnNlZFBhdGguc2VhcmNoID0gYD8ke3NlYXJjaFBhcmFtc31gO1xuXG4gIHJldHVybiB7IHBhdGg6IGNyZWF0ZVBhdGgocGFyc2VkUGF0aCksIHN1Ym1pc3Npb24gfTtcbn1cblxuLy8gRmlsdGVyIG91dCBhbGwgcm91dGVzIGJlbG93IGFueSBjYXVnaHQgZXJyb3IgYXMgdGhleSBhcmVuJ3QgZ29pbmcgdG9cbi8vIHJlbmRlciBzbyB3ZSBkb24ndCBuZWVkIHRvIGxvYWQgdGhlbVxuZnVuY3Rpb24gZ2V0TG9hZGVyTWF0Y2hlc1VudGlsQm91bmRhcnkoXG4gIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgYm91bmRhcnlJZD86IHN0cmluZ1xuKSB7XG4gIGxldCBib3VuZGFyeU1hdGNoZXMgPSBtYXRjaGVzO1xuICBpZiAoYm91bmRhcnlJZCkge1xuICAgIGxldCBpbmRleCA9IG1hdGNoZXMuZmluZEluZGV4KChtKSA9PiBtLnJvdXRlLmlkID09PSBib3VuZGFyeUlkKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgYm91bmRhcnlNYXRjaGVzID0gbWF0Y2hlcy5zbGljZSgwLCBpbmRleCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBib3VuZGFyeU1hdGNoZXM7XG59XG5cbmZ1bmN0aW9uIGdldE1hdGNoZXNUb0xvYWQoXG4gIGhpc3Rvcnk6IEhpc3RvcnksXG4gIHN0YXRlOiBSb3V0ZXJTdGF0ZSxcbiAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICBzdWJtaXNzaW9uOiBTdWJtaXNzaW9uIHwgdW5kZWZpbmVkLFxuICBsb2NhdGlvbjogTG9jYXRpb24sXG4gIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQ6IGJvb2xlYW4sXG4gIGNhbmNlbGxlZERlZmVycmVkUm91dGVzOiBzdHJpbmdbXSxcbiAgY2FuY2VsbGVkRmV0Y2hlckxvYWRzOiBzdHJpbmdbXSxcbiAgZmV0Y2hMb2FkTWF0Y2hlczogTWFwPHN0cmluZywgRmV0Y2hMb2FkTWF0Y2g+LFxuICByb3V0ZXNUb1VzZTogQWdub3N0aWNEYXRhUm91dGVPYmplY3RbXSxcbiAgYmFzZW5hbWU6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgcGVuZGluZ0FjdGlvbkRhdGE/OiBSb3V0ZURhdGEsXG4gIHBlbmRpbmdFcnJvcj86IFJvdXRlRGF0YVxuKTogW0Fnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSwgUmV2YWxpZGF0aW5nRmV0Y2hlcltdXSB7XG4gIGxldCBhY3Rpb25SZXN1bHQgPSBwZW5kaW5nRXJyb3JcbiAgICA/IE9iamVjdC52YWx1ZXMocGVuZGluZ0Vycm9yKVswXVxuICAgIDogcGVuZGluZ0FjdGlvbkRhdGFcbiAgICA/IE9iamVjdC52YWx1ZXMocGVuZGluZ0FjdGlvbkRhdGEpWzBdXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgbGV0IGN1cnJlbnRVcmwgPSBoaXN0b3J5LmNyZWF0ZVVSTChzdGF0ZS5sb2NhdGlvbik7XG4gIGxldCBuZXh0VXJsID0gaGlzdG9yeS5jcmVhdGVVUkwobG9jYXRpb24pO1xuXG4gIGxldCBkZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZSA9XG4gICAgLy8gRm9yY2VkIHJldmFsaWRhdGlvbiBkdWUgdG8gc3VibWlzc2lvbiwgdXNlUmV2YWxpZGF0ZSwgb3IgWC1SZW1peC1SZXZhbGlkYXRlXG4gICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCB8fFxuICAgIC8vIENsaWNrZWQgdGhlIHNhbWUgbGluaywgcmVzdWJtaXR0ZWQgYSBHRVQgZm9ybVxuICAgIGN1cnJlbnRVcmwudG9TdHJpbmcoKSA9PT0gbmV4dFVybC50b1N0cmluZygpIHx8XG4gICAgLy8gU2VhcmNoIHBhcmFtcyBhZmZlY3QgYWxsIGxvYWRlcnNcbiAgICBjdXJyZW50VXJsLnNlYXJjaCAhPT0gbmV4dFVybC5zZWFyY2g7XG5cbiAgLy8gUGljayBuYXZpZ2F0aW9uIG1hdGNoZXMgdGhhdCBhcmUgbmV0LW5ldyBvciBxdWFsaWZ5IGZvciByZXZhbGlkYXRpb25cbiAgbGV0IGJvdW5kYXJ5SWQgPSBwZW5kaW5nRXJyb3IgPyBPYmplY3Qua2V5cyhwZW5kaW5nRXJyb3IpWzBdIDogdW5kZWZpbmVkO1xuICBsZXQgYm91bmRhcnlNYXRjaGVzID0gZ2V0TG9hZGVyTWF0Y2hlc1VudGlsQm91bmRhcnkobWF0Y2hlcywgYm91bmRhcnlJZCk7XG5cbiAgbGV0IG5hdmlnYXRpb25NYXRjaGVzID0gYm91bmRhcnlNYXRjaGVzLmZpbHRlcigobWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgaWYgKG1hdGNoLnJvdXRlLmxhenkpIHtcbiAgICAgIC8vIFdlIGhhdmVuJ3QgbG9hZGVkIHRoaXMgcm91dGUgeWV0IHNvIHdlIGRvbid0IGtub3cgaWYgaXQncyBnb3QgYSBsb2FkZXIhXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG1hdGNoLnJvdXRlLmxvYWRlciA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQWx3YXlzIGNhbGwgdGhlIGxvYWRlciBvbiBuZXcgcm91dGUgaW5zdGFuY2VzIGFuZCBwZW5kaW5nIGRlZmVyIGNhbmNlbGxhdGlvbnNcbiAgICBpZiAoXG4gICAgICBpc05ld0xvYWRlcihzdGF0ZS5sb2FkZXJEYXRhLCBzdGF0ZS5tYXRjaGVzW2luZGV4XSwgbWF0Y2gpIHx8XG4gICAgICBjYW5jZWxsZWREZWZlcnJlZFJvdXRlcy5zb21lKChpZCkgPT4gaWQgPT09IG1hdGNoLnJvdXRlLmlkKVxuICAgICkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBpcyB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBmb3Igd2hlbiB3ZSByZXZhbGlkYXRlLiAgSWYgdGhlIHJvdXRlXG4gICAgLy8gcHJvdmlkZXMgaXQncyBvd24gaW1wbGVtZW50YXRpb24sIHRoZW4gd2UgZ2l2ZSB0aGVtIGZ1bGwgY29udHJvbCBidXRcbiAgICAvLyBwcm92aWRlIHRoaXMgdmFsdWUgc28gdGhleSBjYW4gbGV2ZXJhZ2UgaXQgaWYgbmVlZGVkIGFmdGVyIHRoZXkgY2hlY2tcbiAgICAvLyB0aGVpciBvd24gc3BlY2lmaWMgdXNlIGNhc2VzXG4gICAgbGV0IGN1cnJlbnRSb3V0ZU1hdGNoID0gc3RhdGUubWF0Y2hlc1tpbmRleF07XG4gICAgbGV0IG5leHRSb3V0ZU1hdGNoID0gbWF0Y2g7XG5cbiAgICByZXR1cm4gc2hvdWxkUmV2YWxpZGF0ZUxvYWRlcihtYXRjaCwge1xuICAgICAgY3VycmVudFVybCxcbiAgICAgIGN1cnJlbnRQYXJhbXM6IGN1cnJlbnRSb3V0ZU1hdGNoLnBhcmFtcyxcbiAgICAgIG5leHRVcmwsXG4gICAgICBuZXh0UGFyYW1zOiBuZXh0Um91dGVNYXRjaC5wYXJhbXMsXG4gICAgICAuLi5zdWJtaXNzaW9uLFxuICAgICAgYWN0aW9uUmVzdWx0LFxuICAgICAgZGVmYXVsdFNob3VsZFJldmFsaWRhdGU6XG4gICAgICAgIGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlIHx8XG4gICAgICAgIGlzTmV3Um91dGVJbnN0YW5jZShjdXJyZW50Um91dGVNYXRjaCwgbmV4dFJvdXRlTWF0Y2gpLFxuICAgIH0pO1xuICB9KTtcblxuICAvLyBQaWNrIGZldGNoZXIubG9hZHMgdGhhdCBuZWVkIHRvIGJlIHJldmFsaWRhdGVkXG4gIGxldCByZXZhbGlkYXRpbmdGZXRjaGVyczogUmV2YWxpZGF0aW5nRmV0Y2hlcltdID0gW107XG4gIGZldGNoTG9hZE1hdGNoZXMuZm9yRWFjaCgoZiwga2V5KSA9PiB7XG4gICAgLy8gRG9uJ3QgcmV2YWxpZGF0ZSBpZiBmZXRjaGVyIHdvbid0IGJlIHByZXNlbnQgaW4gdGhlIHN1YnNlcXVlbnQgcmVuZGVyXG4gICAgaWYgKCFtYXRjaGVzLnNvbWUoKG0pID0+IG0ucm91dGUuaWQgPT09IGYucm91dGVJZCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgZmV0Y2hlck1hdGNoZXMgPSBtYXRjaFJvdXRlcyhyb3V0ZXNUb1VzZSwgZi5wYXRoLCBiYXNlbmFtZSk7XG5cbiAgICAvLyBJZiB0aGUgZmV0Y2hlciBwYXRoIG5vIGxvbmdlciBtYXRjaGVzLCBwdXNoIGl0IGluIHdpdGggbnVsbCBtYXRjaGVzIHNvXG4gICAgLy8gd2UgY2FuIHRyaWdnZXIgYSA0MDQgaW4gY2FsbExvYWRlcnNBbmRNYXliZVJlc29sdmVEYXRhXG4gICAgaWYgKCFmZXRjaGVyTWF0Y2hlcykge1xuICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMucHVzaCh7IGtleSwgLi4uZiwgbWF0Y2hlczogbnVsbCwgbWF0Y2g6IG51bGwgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGZldGNoZXJNYXRjaCA9IGdldFRhcmdldE1hdGNoKGZldGNoZXJNYXRjaGVzLCBmLnBhdGgpO1xuXG4gICAgaWYgKGNhbmNlbGxlZEZldGNoZXJMb2Fkcy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5wdXNoKHtcbiAgICAgICAga2V5LFxuICAgICAgICBtYXRjaGVzOiBmZXRjaGVyTWF0Y2hlcyxcbiAgICAgICAgbWF0Y2g6IGZldGNoZXJNYXRjaCxcbiAgICAgICAgLi4uZixcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFJldmFsaWRhdGluZyBmZXRjaGVycyBhcmUgZGVjb3VwbGVkIGZyb20gdGhlIHJvdXRlIG1hdGNoZXMgc2luY2UgdGhleVxuICAgIC8vIGhpdCBhIHN0YXRpYyBocmVmLCBzbyB0aGV5IF9hbHdheXNfIGNoZWNrIHNob3VsZFJldmFsaWRhdGUgYW5kIHRoZVxuICAgIC8vIGRlZmF1bHQgaXMgc3RyaWN0bHkgaWYgYSByZXZhbGlkYXRpb24gaXMgZXhwbGljaXRseSByZXF1aXJlZCAoYWN0aW9uXG4gICAgLy8gc3VibWlzc2lvbnMsIHVzZVJldmFsaWRhdG9yLCBYLVJlbWl4LVJldmFsaWRhdGUpLlxuICAgIGxldCBzaG91bGRSZXZhbGlkYXRlID0gc2hvdWxkUmV2YWxpZGF0ZUxvYWRlcihmZXRjaGVyTWF0Y2gsIHtcbiAgICAgIGN1cnJlbnRVcmwsXG4gICAgICBjdXJyZW50UGFyYW1zOiBzdGF0ZS5tYXRjaGVzW3N0YXRlLm1hdGNoZXMubGVuZ3RoIC0gMV0ucGFyYW1zLFxuICAgICAgbmV4dFVybCxcbiAgICAgIG5leHRQYXJhbXM6IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5wYXJhbXMsXG4gICAgICAuLi5zdWJtaXNzaW9uLFxuICAgICAgYWN0aW9uUmVzdWx0LFxuICAgICAgZGVmYXVsdFNob3VsZFJldmFsaWRhdGUsXG4gICAgfSk7XG4gICAgaWYgKHNob3VsZFJldmFsaWRhdGUpIHtcbiAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLnB1c2goe1xuICAgICAgICBrZXksXG4gICAgICAgIG1hdGNoZXM6IGZldGNoZXJNYXRjaGVzLFxuICAgICAgICBtYXRjaDogZmV0Y2hlck1hdGNoLFxuICAgICAgICAuLi5mLFxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gW25hdmlnYXRpb25NYXRjaGVzLCByZXZhbGlkYXRpbmdGZXRjaGVyc107XG59XG5cbmZ1bmN0aW9uIGlzTmV3TG9hZGVyKFxuICBjdXJyZW50TG9hZGVyRGF0YTogUm91dGVEYXRhLFxuICBjdXJyZW50TWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2gsXG4gIG1hdGNoOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoXG4pIHtcbiAgbGV0IGlzTmV3ID1cbiAgICAvLyBbYV0gLT4gW2EsIGJdXG4gICAgIWN1cnJlbnRNYXRjaCB8fFxuICAgIC8vIFthLCBiXSAtPiBbYSwgY11cbiAgICBtYXRjaC5yb3V0ZS5pZCAhPT0gY3VycmVudE1hdGNoLnJvdXRlLmlkO1xuXG4gIC8vIEhhbmRsZSB0aGUgY2FzZSB0aGF0IHdlIGRvbid0IGhhdmUgZGF0YSBmb3IgYSByZS11c2VkIHJvdXRlLCBwb3RlbnRpYWxseVxuICAvLyBmcm9tIGEgcHJpb3IgZXJyb3Igb3IgZnJvbSBhIGNhbmNlbGxlZCBwZW5kaW5nIGRlZmVycmVkXG4gIGxldCBpc01pc3NpbmdEYXRhID0gY3VycmVudExvYWRlckRhdGFbbWF0Y2gucm91dGUuaWRdID09PSB1bmRlZmluZWQ7XG5cbiAgLy8gQWx3YXlzIGxvYWQgaWYgdGhpcyBpcyBhIG5ldC1uZXcgcm91dGUgb3Igd2UgZG9uJ3QgeWV0IGhhdmUgZGF0YVxuICByZXR1cm4gaXNOZXcgfHwgaXNNaXNzaW5nRGF0YTtcbn1cblxuZnVuY3Rpb24gaXNOZXdSb3V0ZUluc3RhbmNlKFxuICBjdXJyZW50TWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2gsXG4gIG1hdGNoOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoXG4pIHtcbiAgbGV0IGN1cnJlbnRQYXRoID0gY3VycmVudE1hdGNoLnJvdXRlLnBhdGg7XG4gIHJldHVybiAoXG4gICAgLy8gcGFyYW0gY2hhbmdlIGZvciB0aGlzIG1hdGNoLCAvdXNlcnMvMTIzIC0+IC91c2Vycy80NTZcbiAgICBjdXJyZW50TWF0Y2gucGF0aG5hbWUgIT09IG1hdGNoLnBhdGhuYW1lIHx8XG4gICAgLy8gc3BsYXQgcGFyYW0gY2hhbmdlZCwgd2hpY2ggaXMgbm90IHByZXNlbnQgaW4gbWF0Y2gucGF0aFxuICAgIC8vIGUuZy4gL2ZpbGVzL2ltYWdlcy9hdmF0YXIuanBnIC0+IGZpbGVzL2ZpbmFuY2VzLnhsc1xuICAgIChjdXJyZW50UGF0aCAhPSBudWxsICYmXG4gICAgICBjdXJyZW50UGF0aC5lbmRzV2l0aChcIipcIikgJiZcbiAgICAgIGN1cnJlbnRNYXRjaC5wYXJhbXNbXCIqXCJdICE9PSBtYXRjaC5wYXJhbXNbXCIqXCJdKVxuICApO1xufVxuXG5mdW5jdGlvbiBzaG91bGRSZXZhbGlkYXRlTG9hZGVyKFxuICBsb2FkZXJNYXRjaDogQWdub3N0aWNEYXRhUm91dGVNYXRjaCxcbiAgYXJnOiBQYXJhbWV0ZXJzPFNob3VsZFJldmFsaWRhdGVGdW5jdGlvbj5bMF1cbikge1xuICBpZiAobG9hZGVyTWF0Y2gucm91dGUuc2hvdWxkUmV2YWxpZGF0ZSkge1xuICAgIGxldCByb3V0ZUNob2ljZSA9IGxvYWRlck1hdGNoLnJvdXRlLnNob3VsZFJldmFsaWRhdGUoYXJnKTtcbiAgICBpZiAodHlwZW9mIHJvdXRlQ2hvaWNlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgcmV0dXJuIHJvdXRlQ2hvaWNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhcmcuZGVmYXVsdFNob3VsZFJldmFsaWRhdGU7XG59XG5cbi8qKlxuICogRXhlY3V0ZSByb3V0ZS5sYXp5KCkgbWV0aG9kcyB0byBsYXppbHkgbG9hZCByb3V0ZSBtb2R1bGVzIChsb2FkZXIsIGFjdGlvbixcbiAqIHNob3VsZFJldmFsaWRhdGUpIGFuZCB1cGRhdGUgdGhlIHJvdXRlTWFuaWZlc3QgaW4gcGxhY2Ugd2hpY2ggc2hhcmVzIG9iamVjdHNcbiAqIHdpdGggZGF0YVJvdXRlcyBzbyB0aG9zZSBnZXQgdXBkYXRlZCBhcyB3ZWxsLlxuICovXG5hc3luYyBmdW5jdGlvbiBsb2FkTGF6eVJvdXRlTW9kdWxlKFxuICByb3V0ZTogQWdub3N0aWNEYXRhUm91dGVPYmplY3QsXG4gIGRldGVjdEVycm9yQm91bmRhcnk6IERldGVjdEVycm9yQm91bmRhcnlGdW5jdGlvbixcbiAgbWFuaWZlc3Q6IFJvdXRlTWFuaWZlc3Rcbikge1xuICBpZiAoIXJvdXRlLmxhenkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgbGF6eVJvdXRlID0gYXdhaXQgcm91dGUubGF6eSgpO1xuXG4gIC8vIElmIHRoZSBsYXp5IHJvdXRlIGZ1bmN0aW9uIHdhcyBleGVjdXRlZCBhbmQgcmVtb3ZlZCBieSBhbm90aGVyIHBhcmFsbGVsXG4gIC8vIGNhbGwgdGhlbiB3ZSBjYW4gcmV0dXJuIC0gZmlyc3QgbGF6eSgpIHRvIGZpbmlzaCB3aW5zIGJlY2F1c2UgdGhlIHJldHVyblxuICAvLyB2YWx1ZSBvZiBsYXp5IGlzIGV4cGVjdGVkIHRvIGJlIHN0YXRpY1xuICBpZiAoIXJvdXRlLmxhenkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgcm91dGVUb1VwZGF0ZSA9IG1hbmlmZXN0W3JvdXRlLmlkXTtcbiAgaW52YXJpYW50KHJvdXRlVG9VcGRhdGUsIFwiTm8gcm91dGUgZm91bmQgaW4gbWFuaWZlc3RcIik7XG5cbiAgLy8gVXBkYXRlIHRoZSByb3V0ZSBpbiBwbGFjZS4gIFRoaXMgc2hvdWxkIGJlIHNhZmUgYmVjYXVzZSB0aGVyZSdzIG5vIHdheVxuICAvLyB3ZSBjb3VsZCB5ZXQgYmUgc2l0dGluZyBvbiB0aGlzIHJvdXRlIGFzIHdlIGNhbid0IGdldCB0aGVyZSB3aXRob3V0XG4gIC8vIHJlc29sdmluZyBsYXp5KCkgZmlyc3QuXG4gIC8vXG4gIC8vIFRoaXMgaXMgZGlmZmVyZW50IHRoYW4gdGhlIEhNUiBcInVwZGF0ZVwiIHVzZS1jYXNlIHdoZXJlIHdlIG1heSBhY3RpdmVseSBiZVxuICAvLyBvbiB0aGUgcm91dGUgYmVpbmcgdXBkYXRlZC4gIFRoZSBtYWluIGNvbmNlcm4gYm9pbHMgZG93biB0byBcImRvZXMgdGhpc1xuICAvLyBtdXRhdGlvbiBhZmZlY3QgYW55IG9uZ29pbmcgbmF2aWdhdGlvbnMgb3IgYW55IGN1cnJlbnQgc3RhdGUubWF0Y2hlc1xuICAvLyB2YWx1ZXM/XCIuICBJZiBub3QsIGl0IHNob3VsZCBiZSBzYWZlIHRvIHVwZGF0ZSBpbiBwbGFjZS5cbiAgbGV0IHJvdXRlVXBkYXRlczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9O1xuICBmb3IgKGxldCBsYXp5Um91dGVQcm9wZXJ0eSBpbiBsYXp5Um91dGUpIHtcbiAgICBsZXQgc3RhdGljUm91dGVWYWx1ZSA9XG4gICAgICByb3V0ZVRvVXBkYXRlW2xhenlSb3V0ZVByb3BlcnR5IGFzIGtleW9mIHR5cGVvZiByb3V0ZVRvVXBkYXRlXTtcblxuICAgIGxldCBpc1Byb3BlcnR5U3RhdGljYWxseURlZmluZWQgPVxuICAgICAgc3RhdGljUm91dGVWYWx1ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAvLyBUaGlzIHByb3BlcnR5IGlzbid0IHN0YXRpYyBzaW5jZSBpdCBzaG91bGQgYWx3YXlzIGJlIHVwZGF0ZWQgYmFzZWRcbiAgICAgIC8vIG9uIHRoZSByb3V0ZSB1cGRhdGVzXG4gICAgICBsYXp5Um91dGVQcm9wZXJ0eSAhPT0gXCJoYXNFcnJvckJvdW5kYXJ5XCI7XG5cbiAgICB3YXJuaW5nKFxuICAgICAgIWlzUHJvcGVydHlTdGF0aWNhbGx5RGVmaW5lZCxcbiAgICAgIGBSb3V0ZSBcIiR7cm91dGVUb1VwZGF0ZS5pZH1cIiBoYXMgYSBzdGF0aWMgcHJvcGVydHkgXCIke2xhenlSb3V0ZVByb3BlcnR5fVwiIGAgK1xuICAgICAgICBgZGVmaW5lZCBidXQgaXRzIGxhenkgZnVuY3Rpb24gaXMgYWxzbyByZXR1cm5pbmcgYSB2YWx1ZSBmb3IgdGhpcyBwcm9wZXJ0eS4gYCArXG4gICAgICAgIGBUaGUgbGF6eSByb3V0ZSBwcm9wZXJ0eSBcIiR7bGF6eVJvdXRlUHJvcGVydHl9XCIgd2lsbCBiZSBpZ25vcmVkLmBcbiAgICApO1xuXG4gICAgaWYgKFxuICAgICAgIWlzUHJvcGVydHlTdGF0aWNhbGx5RGVmaW5lZCAmJlxuICAgICAgIWltbXV0YWJsZVJvdXRlS2V5cy5oYXMobGF6eVJvdXRlUHJvcGVydHkgYXMgSW1tdXRhYmxlUm91dGVLZXkpXG4gICAgKSB7XG4gICAgICByb3V0ZVVwZGF0ZXNbbGF6eVJvdXRlUHJvcGVydHldID1cbiAgICAgICAgbGF6eVJvdXRlW2xhenlSb3V0ZVByb3BlcnR5IGFzIGtleW9mIHR5cGVvZiBsYXp5Um91dGVdO1xuICAgIH1cbiAgfVxuXG4gIC8vIE11dGF0ZSB0aGUgcm91dGUgd2l0aCB0aGUgcHJvdmlkZWQgdXBkYXRlcy4gIERvIHRoaXMgZmlyc3Qgc28gd2UgcGFzc1xuICAvLyB0aGUgdXBkYXRlZCB2ZXJzaW9uIHRvIGRldGVjdEVycm9yQm91bmRhcnlcbiAgT2JqZWN0LmFzc2lnbihyb3V0ZVRvVXBkYXRlLCByb3V0ZVVwZGF0ZXMpO1xuXG4gIC8vIE11dGF0ZSB0aGUgYGhhc0Vycm9yQm91bmRhcnlgIHByb3BlcnR5IG9uIHRoZSByb3V0ZSBiYXNlZCBvbiB0aGUgcm91dGVcbiAgLy8gdXBkYXRlcyBhbmQgcmVtb3ZlIHRoZSBgbGF6eWAgZnVuY3Rpb24gc28gd2UgZG9uJ3QgcmVzb2x2ZSB0aGUgbGF6eVxuICAvLyByb3V0ZSBhZ2Fpbi5cbiAgT2JqZWN0LmFzc2lnbihyb3V0ZVRvVXBkYXRlLCB7XG4gICAgLy8gVG8ga2VlcCB0aGluZ3MgZnJhbWV3b3JrIGFnbm9zdGljLCB3ZSB1c2UgdGhlIHByb3ZpZGVkXG4gICAgLy8gYGRldGVjdEVycm9yQm91bmRhcnlgIGZ1bmN0aW9uIHRvIHNldCB0aGUgYGhhc0Vycm9yQm91bmRhcnlgIHJvdXRlXG4gICAgLy8gcHJvcGVydHkgc2luY2UgdGhlIGxvZ2ljIHdpbGwgZGlmZmVyIGJldHdlZW4gZnJhbWV3b3Jrcy5cbiAgICBoYXNFcnJvckJvdW5kYXJ5OiBkZXRlY3RFcnJvckJvdW5kYXJ5KHsgLi4ucm91dGVUb1VwZGF0ZSB9KSxcbiAgICBsYXp5OiB1bmRlZmluZWQsXG4gIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBjYWxsTG9hZGVyT3JBY3Rpb24oXG4gIHR5cGU6IFwibG9hZGVyXCIgfCBcImFjdGlvblwiLFxuICByZXF1ZXN0OiBSZXF1ZXN0LFxuICBtYXRjaDogQWdub3N0aWNEYXRhUm91dGVNYXRjaCxcbiAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICBtYW5pZmVzdDogUm91dGVNYW5pZmVzdCxcbiAgZGV0ZWN0RXJyb3JCb3VuZGFyeTogRGV0ZWN0RXJyb3JCb3VuZGFyeUZ1bmN0aW9uLFxuICBiYXNlbmFtZSA9IFwiL1wiLFxuICBpc1N0YXRpY1JlcXVlc3Q6IGJvb2xlYW4gPSBmYWxzZSxcbiAgaXNSb3V0ZVJlcXVlc3Q6IGJvb2xlYW4gPSBmYWxzZSxcbiAgcmVxdWVzdENvbnRleHQ/OiB1bmtub3duXG4pOiBQcm9taXNlPERhdGFSZXN1bHQ+IHtcbiAgbGV0IHJlc3VsdFR5cGU7XG4gIGxldCByZXN1bHQ7XG4gIGxldCBvblJlamVjdDogKCgpID0+IHZvaWQpIHwgdW5kZWZpbmVkO1xuXG4gIGxldCBydW5IYW5kbGVyID0gKGhhbmRsZXI6IEFjdGlvbkZ1bmN0aW9uIHwgTG9hZGVyRnVuY3Rpb24pID0+IHtcbiAgICAvLyBTZXR1cCBhIHByb21pc2Ugd2UgY2FuIHJhY2UgYWdhaW5zdCBzbyB0aGF0IGFib3J0IHNpZ25hbHMgc2hvcnQgY2lyY3VpdFxuICAgIGxldCByZWplY3Q6ICgpID0+IHZvaWQ7XG4gICAgbGV0IGFib3J0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByKSA9PiAocmVqZWN0ID0gcikpO1xuICAgIG9uUmVqZWN0ID0gKCkgPT4gcmVqZWN0KCk7XG4gICAgcmVxdWVzdC5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uUmVqZWN0KTtcbiAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICAgIGhhbmRsZXIoeyByZXF1ZXN0LCBwYXJhbXM6IG1hdGNoLnBhcmFtcywgY29udGV4dDogcmVxdWVzdENvbnRleHQgfSksXG4gICAgICBhYm9ydFByb21pc2UsXG4gICAgXSk7XG4gIH07XG5cbiAgdHJ5IHtcbiAgICBsZXQgaGFuZGxlciA9IG1hdGNoLnJvdXRlW3R5cGVdO1xuXG4gICAgaWYgKG1hdGNoLnJvdXRlLmxhenkpIHtcbiAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgIC8vIFJ1biBzdGF0aWNhbGx5IGRlZmluZWQgaGFuZGxlciBpbiBwYXJhbGxlbCB3aXRoIGxhenkoKVxuICAgICAgICBsZXQgdmFsdWVzID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgIHJ1bkhhbmRsZXIoaGFuZGxlciksXG4gICAgICAgICAgbG9hZExhenlSb3V0ZU1vZHVsZShtYXRjaC5yb3V0ZSwgZGV0ZWN0RXJyb3JCb3VuZGFyeSwgbWFuaWZlc3QpLFxuICAgICAgICBdKTtcbiAgICAgICAgcmVzdWx0ID0gdmFsdWVzWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTG9hZCBsYXp5IHJvdXRlIG1vZHVsZSwgdGhlbiBydW4gYW55IHJldHVybmVkIGhhbmRsZXJcbiAgICAgICAgYXdhaXQgbG9hZExhenlSb3V0ZU1vZHVsZShtYXRjaC5yb3V0ZSwgZGV0ZWN0RXJyb3JCb3VuZGFyeSwgbWFuaWZlc3QpO1xuXG4gICAgICAgIGhhbmRsZXIgPSBtYXRjaC5yb3V0ZVt0eXBlXTtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAvLyBIYW5kbGVyIHN0aWxsIHJ1biBldmVuIGlmIHdlIGdvdCBpbnRlcnJ1cHRlZCB0byBtYWludGFpbiBjb25zaXN0ZW5jeVxuICAgICAgICAgIC8vIHdpdGggdW4tYWJvcnRhYmxlIGJlaGF2aW9yIG9mIGhhbmRsZXIgZXhlY3V0aW9uIG9uIG5vbi1sYXp5IG9yXG4gICAgICAgICAgLy8gcHJldmlvdXNseS1sYXp5LWxvYWRlZCByb3V0ZXNcbiAgICAgICAgICByZXN1bHQgPSBhd2FpdCBydW5IYW5kbGVyKGhhbmRsZXIpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiYWN0aW9uXCIpIHtcbiAgICAgICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgICAgIHBhdGhuYW1lOiBuZXcgVVJMKHJlcXVlc3QudXJsKS5wYXRobmFtZSxcbiAgICAgICAgICAgIHJvdXRlSWQ6IG1hdGNoLnJvdXRlLmlkLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGxhenkoKSByb3V0ZSBoYXMgbm8gbG9hZGVyIHRvIHJ1bi4gIFNob3J0IGNpcmN1aXQgaGVyZSBzbyB3ZSBkb24ndFxuICAgICAgICAgIC8vIGhpdCB0aGUgaW52YXJpYW50IGJlbG93IHRoYXQgZXJyb3JzIG9uIHJldHVybmluZyB1bmRlZmluZWQuXG4gICAgICAgICAgcmV0dXJuIHsgdHlwZTogUmVzdWx0VHlwZS5kYXRhLCBkYXRhOiB1bmRlZmluZWQgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbnZhcmlhbnQ8RnVuY3Rpb24+KFxuICAgICAgICBoYW5kbGVyLFxuICAgICAgICBgQ291bGQgbm90IGZpbmQgdGhlICR7dHlwZX0gdG8gcnVuIG9uIHRoZSBcIiR7bWF0Y2gucm91dGUuaWR9XCIgcm91dGVgXG4gICAgICApO1xuXG4gICAgICByZXN1bHQgPSBhd2FpdCBydW5IYW5kbGVyKGhhbmRsZXIpO1xuICAgIH1cblxuICAgIGludmFyaWFudChcbiAgICAgIHJlc3VsdCAhPT0gdW5kZWZpbmVkLFxuICAgICAgYFlvdSBkZWZpbmVkICR7dHlwZSA9PT0gXCJhY3Rpb25cIiA/IFwiYW4gYWN0aW9uXCIgOiBcImEgbG9hZGVyXCJ9IGZvciByb3V0ZSBgICtcbiAgICAgICAgYFwiJHttYXRjaC5yb3V0ZS5pZH1cIiBidXQgZGlkbid0IHJldHVybiBhbnl0aGluZyBmcm9tIHlvdXIgXFxgJHt0eXBlfVxcYCBgICtcbiAgICAgICAgYGZ1bmN0aW9uLiBQbGVhc2UgcmV0dXJuIGEgdmFsdWUgb3IgXFxgbnVsbFxcYC5gXG4gICAgKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJlc3VsdFR5cGUgPSBSZXN1bHRUeXBlLmVycm9yO1xuICAgIHJlc3VsdCA9IGU7XG4gIH0gZmluYWxseSB7XG4gICAgaWYgKG9uUmVqZWN0KSB7XG4gICAgICByZXF1ZXN0LnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25SZWplY3QpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc1Jlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICBsZXQgc3RhdHVzID0gcmVzdWx0LnN0YXR1cztcblxuICAgIC8vIFByb2Nlc3MgcmVkaXJlY3RzXG4gICAgaWYgKHJlZGlyZWN0U3RhdHVzQ29kZXMuaGFzKHN0YXR1cykpIHtcbiAgICAgIGxldCBsb2NhdGlvbiA9IHJlc3VsdC5oZWFkZXJzLmdldChcIkxvY2F0aW9uXCIpO1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgXCJSZWRpcmVjdHMgcmV0dXJuZWQvdGhyb3duIGZyb20gbG9hZGVycy9hY3Rpb25zIG11c3QgaGF2ZSBhIExvY2F0aW9uIGhlYWRlclwiXG4gICAgICApO1xuXG4gICAgICAvLyBTdXBwb3J0IHJlbGF0aXZlIHJvdXRpbmcgaW4gaW50ZXJuYWwgcmVkaXJlY3RzXG4gICAgICBpZiAoIUFCU09MVVRFX1VSTF9SRUdFWC50ZXN0KGxvY2F0aW9uKSkge1xuICAgICAgICBsZXQgYWN0aXZlTWF0Y2hlcyA9IG1hdGNoZXMuc2xpY2UoMCwgbWF0Y2hlcy5pbmRleE9mKG1hdGNoKSArIDEpO1xuICAgICAgICBsZXQgcm91dGVQYXRobmFtZXMgPSBnZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyhhY3RpdmVNYXRjaGVzKS5tYXAoXG4gICAgICAgICAgKG1hdGNoKSA9PiBtYXRjaC5wYXRobmFtZUJhc2VcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IHJlc29sdmVkTG9jYXRpb24gPSByZXNvbHZlVG8oXG4gICAgICAgICAgbG9jYXRpb24sXG4gICAgICAgICAgcm91dGVQYXRobmFtZXMsXG4gICAgICAgICAgbmV3IFVSTChyZXF1ZXN0LnVybCkucGF0aG5hbWVcbiAgICAgICAgKTtcbiAgICAgICAgaW52YXJpYW50KFxuICAgICAgICAgIGNyZWF0ZVBhdGgocmVzb2x2ZWRMb2NhdGlvbiksXG4gICAgICAgICAgYFVuYWJsZSB0byByZXNvbHZlIHJlZGlyZWN0IGxvY2F0aW9uOiAke2xvY2F0aW9ufWBcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBQcmVwZW5kIHRoZSBiYXNlbmFtZSB0byB0aGUgcmVkaXJlY3QgbG9jYXRpb24gaWYgd2UgaGF2ZSBvbmVcbiAgICAgICAgaWYgKGJhc2VuYW1lKSB7XG4gICAgICAgICAgbGV0IHBhdGggPSByZXNvbHZlZExvY2F0aW9uLnBhdGhuYW1lO1xuICAgICAgICAgIHJlc29sdmVkTG9jYXRpb24ucGF0aG5hbWUgPVxuICAgICAgICAgICAgcGF0aCA9PT0gXCIvXCIgPyBiYXNlbmFtZSA6IGpvaW5QYXRocyhbYmFzZW5hbWUsIHBhdGhdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvY2F0aW9uID0gY3JlYXRlUGF0aChyZXNvbHZlZExvY2F0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzU3RhdGljUmVxdWVzdCkge1xuICAgICAgICAvLyBTdHJpcCBvZmYgdGhlIHByb3RvY29sK29yaWdpbiBmb3Igc2FtZS1vcmlnaW4gKyBzYW1lLWJhc2VuYW1lIGFic29sdXRlXG4gICAgICAgIC8vIHJlZGlyZWN0cy4gSWYgdGhpcyBpcyBhIHN0YXRpYyByZXF1ZXN0LCB3ZSBjYW4gbGV0IGl0IGdvIGJhY2sgdG8gdGhlXG4gICAgICAgIC8vIGJyb3dzZXIgYXMtaXNcbiAgICAgICAgbGV0IGN1cnJlbnRVcmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgICAgICAgbGV0IHVybCA9IGxvY2F0aW9uLnN0YXJ0c1dpdGgoXCIvL1wiKVxuICAgICAgICAgID8gbmV3IFVSTChjdXJyZW50VXJsLnByb3RvY29sICsgbG9jYXRpb24pXG4gICAgICAgICAgOiBuZXcgVVJMKGxvY2F0aW9uKTtcbiAgICAgICAgbGV0IGlzU2FtZUJhc2VuYW1lID0gc3RyaXBCYXNlbmFtZSh1cmwucGF0aG5hbWUsIGJhc2VuYW1lKSAhPSBudWxsO1xuICAgICAgICBpZiAodXJsLm9yaWdpbiA9PT0gY3VycmVudFVybC5vcmlnaW4gJiYgaXNTYW1lQmFzZW5hbWUpIHtcbiAgICAgICAgICBsb2NhdGlvbiA9IHVybC5wYXRobmFtZSArIHVybC5zZWFyY2ggKyB1cmwuaGFzaDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBEb24ndCBwcm9jZXNzIHJlZGlyZWN0cyBpbiB0aGUgcm91dGVyIGR1cmluZyBzdGF0aWMgcmVxdWVzdHMgcmVxdWVzdHMuXG4gICAgICAvLyBJbnN0ZWFkLCB0aHJvdyB0aGUgUmVzcG9uc2UgYW5kIGxldCB0aGUgc2VydmVyIGhhbmRsZSBpdCB3aXRoIGFuIEhUVFBcbiAgICAgIC8vIHJlZGlyZWN0LiAgV2UgYWxzbyB1cGRhdGUgdGhlIExvY2F0aW9uIGhlYWRlciBpbiBwbGFjZSBpbiB0aGlzIGZsb3cgc29cbiAgICAgIC8vIGJhc2VuYW1lIGFuZCByZWxhdGl2ZSByb3V0aW5nIGlzIHRha2VuIGludG8gYWNjb3VudFxuICAgICAgaWYgKGlzU3RhdGljUmVxdWVzdCkge1xuICAgICAgICByZXN1bHQuaGVhZGVycy5zZXQoXCJMb2NhdGlvblwiLCBsb2NhdGlvbik7XG4gICAgICAgIHRocm93IHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogUmVzdWx0VHlwZS5yZWRpcmVjdCxcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgcmV2YWxpZGF0ZTogcmVzdWx0LmhlYWRlcnMuZ2V0KFwiWC1SZW1peC1SZXZhbGlkYXRlXCIpICE9PSBudWxsLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBGb3IgU1NSIHNpbmdsZS1yb3V0ZSByZXF1ZXN0cywgd2Ugd2FudCB0byBoYW5kIFJlc3BvbnNlcyBiYWNrIGRpcmVjdGx5XG4gICAgLy8gd2l0aG91dCB1bndyYXBwaW5nLiAgV2UgZG8gdGhpcyB3aXRoIHRoZSBRdWVyeVJvdXRlUmVzcG9uc2Ugd3JhcHBlclxuICAgIC8vIGludGVyZmFjZSBzbyB3ZSBjYW4ga25vdyB3aGV0aGVyIGl0IHdhcyByZXR1cm5lZCBvciB0aHJvd25cbiAgICBpZiAoaXNSb3V0ZVJlcXVlc3QpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG4gICAgICB0aHJvdyB7XG4gICAgICAgIHR5cGU6IHJlc3VsdFR5cGUgfHwgUmVzdWx0VHlwZS5kYXRhLFxuICAgICAgICByZXNwb25zZTogcmVzdWx0LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBsZXQgZGF0YTogYW55O1xuICAgIGxldCBjb250ZW50VHlwZSA9IHJlc3VsdC5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKTtcbiAgICAvLyBDaGVjayBiZXR3ZWVuIHdvcmQgYm91bmRhcmllcyBpbnN0ZWFkIG9mIHN0YXJ0c1dpdGgoKSBkdWUgdG8gdGhlIGxhc3RcbiAgICAvLyBwYXJhZ3JhcGggb2YgaHR0cHM6Ly9odHRwd2cub3JnL3NwZWNzL3JmYzkxMTAuaHRtbCNmaWVsZC5jb250ZW50LXR5cGVcbiAgICBpZiAoY29udGVudFR5cGUgJiYgL1xcYmFwcGxpY2F0aW9uXFwvanNvblxcYi8udGVzdChjb250ZW50VHlwZSkpIHtcbiAgICAgIGRhdGEgPSBhd2FpdCByZXN1bHQuanNvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gYXdhaXQgcmVzdWx0LnRleHQoKTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0VHlwZSA9PT0gUmVzdWx0VHlwZS5lcnJvcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogcmVzdWx0VHlwZSxcbiAgICAgICAgZXJyb3I6IG5ldyBFcnJvclJlc3BvbnNlKHN0YXR1cywgcmVzdWx0LnN0YXR1c1RleHQsIGRhdGEpLFxuICAgICAgICBoZWFkZXJzOiByZXN1bHQuaGVhZGVycyxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZGF0YSxcbiAgICAgIGRhdGEsXG4gICAgICBzdGF0dXNDb2RlOiByZXN1bHQuc3RhdHVzLFxuICAgICAgaGVhZGVyczogcmVzdWx0LmhlYWRlcnMsXG4gICAgfTtcbiAgfVxuXG4gIGlmIChyZXN1bHRUeXBlID09PSBSZXN1bHRUeXBlLmVycm9yKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogcmVzdWx0VHlwZSwgZXJyb3I6IHJlc3VsdCB9O1xuICB9XG5cbiAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIERlZmVycmVkRGF0YSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBSZXN1bHRUeXBlLmRlZmVycmVkLFxuICAgICAgZGVmZXJyZWREYXRhOiByZXN1bHQsXG4gICAgICBzdGF0dXNDb2RlOiByZXN1bHQuaW5pdD8uc3RhdHVzLFxuICAgICAgaGVhZGVyczogcmVzdWx0LmluaXQ/LmhlYWRlcnMgJiYgbmV3IEhlYWRlcnMocmVzdWx0LmluaXQuaGVhZGVycyksXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7IHR5cGU6IFJlc3VsdFR5cGUuZGF0YSwgZGF0YTogcmVzdWx0IH07XG59XG5cbi8vIFV0aWxpdHkgbWV0aG9kIGZvciBjcmVhdGluZyB0aGUgUmVxdWVzdCBpbnN0YW5jZXMgZm9yIGxvYWRlcnMvYWN0aW9ucyBkdXJpbmdcbi8vIGNsaWVudC1zaWRlIG5hdmlnYXRpb25zIGFuZCBmZXRjaGVzLiAgRHVyaW5nIFNTUiB3ZSB3aWxsIGFsd2F5cyBoYXZlIGFcbi8vIFJlcXVlc3QgaW5zdGFuY2UgZnJvbSB0aGUgc3RhdGljIGhhbmRsZXIgKHF1ZXJ5L3F1ZXJ5Um91dGUpXG5mdW5jdGlvbiBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChcbiAgaGlzdG9yeTogSGlzdG9yeSxcbiAgbG9jYXRpb246IHN0cmluZyB8IExvY2F0aW9uLFxuICBzaWduYWw6IEFib3J0U2lnbmFsLFxuICBzdWJtaXNzaW9uPzogU3VibWlzc2lvblxuKTogUmVxdWVzdCB7XG4gIGxldCB1cmwgPSBoaXN0b3J5LmNyZWF0ZVVSTChzdHJpcEhhc2hGcm9tUGF0aChsb2NhdGlvbikpLnRvU3RyaW5nKCk7XG4gIGxldCBpbml0OiBSZXF1ZXN0SW5pdCA9IHsgc2lnbmFsIH07XG5cbiAgaWYgKHN1Ym1pc3Npb24gJiYgaXNNdXRhdGlvbk1ldGhvZChzdWJtaXNzaW9uLmZvcm1NZXRob2QpKSB7XG4gICAgbGV0IHsgZm9ybU1ldGhvZCwgZm9ybUVuY1R5cGUsIGZvcm1EYXRhIH0gPSBzdWJtaXNzaW9uO1xuICAgIGluaXQubWV0aG9kID0gZm9ybU1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgIGluaXQuYm9keSA9XG4gICAgICBmb3JtRW5jVHlwZSA9PT0gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIlxuICAgICAgICA/IGNvbnZlcnRGb3JtRGF0YVRvU2VhcmNoUGFyYW1zKGZvcm1EYXRhKVxuICAgICAgICA6IGZvcm1EYXRhO1xuICB9XG5cbiAgLy8gQ29udGVudC1UeXBlIGlzIGluZmVycmVkIChodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLXJlcXVlc3QpXG4gIHJldHVybiBuZXcgUmVxdWVzdCh1cmwsIGluaXQpO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0Rm9ybURhdGFUb1NlYXJjaFBhcmFtcyhmb3JtRGF0YTogRm9ybURhdGEpOiBVUkxTZWFyY2hQYXJhbXMge1xuICBsZXQgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuXG4gIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBmb3JtRGF0YS5lbnRyaWVzKCkpIHtcbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3JtLWNvbnRyb2wtaW5mcmFzdHJ1Y3R1cmUuaHRtbCNjb252ZXJ0aW5nLWFuLWVudHJ5LWxpc3QtdG8tYS1saXN0LW9mLW5hbWUtdmFsdWUtcGFpcnNcbiAgICBzZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUgaW5zdGFuY2VvZiBGaWxlID8gdmFsdWUubmFtZSA6IHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiBzZWFyY2hQYXJhbXM7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSb3V0ZUxvYWRlckRhdGEoXG4gIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgbWF0Y2hlc1RvTG9hZDogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICByZXN1bHRzOiBEYXRhUmVzdWx0W10sXG4gIHBlbmRpbmdFcnJvcjogUm91dGVEYXRhIHwgdW5kZWZpbmVkLFxuICBhY3RpdmVEZWZlcnJlZHM6IE1hcDxzdHJpbmcsIERlZmVycmVkRGF0YT5cbik6IHtcbiAgbG9hZGVyRGF0YTogUm91dGVyU3RhdGVbXCJsb2FkZXJEYXRhXCJdO1xuICBlcnJvcnM6IFJvdXRlclN0YXRlW1wiZXJyb3JzXCJdIHwgbnVsbDtcbiAgc3RhdHVzQ29kZTogbnVtYmVyO1xuICBsb2FkZXJIZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBIZWFkZXJzPjtcbn0ge1xuICAvLyBGaWxsIGluIGxvYWRlckRhdGEvZXJyb3JzIGZyb20gb3VyIGxvYWRlcnNcbiAgbGV0IGxvYWRlckRhdGE6IFJvdXRlclN0YXRlW1wibG9hZGVyRGF0YVwiXSA9IHt9O1xuICBsZXQgZXJyb3JzOiBSb3V0ZXJTdGF0ZVtcImVycm9yc1wiXSB8IG51bGwgPSBudWxsO1xuICBsZXQgc3RhdHVzQ29kZTogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICBsZXQgZm91bmRFcnJvciA9IGZhbHNlO1xuICBsZXQgbG9hZGVySGVhZGVyczogUmVjb3JkPHN0cmluZywgSGVhZGVycz4gPSB7fTtcblxuICAvLyBQcm9jZXNzIGxvYWRlciByZXN1bHRzIGludG8gc3RhdGUubG9hZGVyRGF0YS9zdGF0ZS5lcnJvcnNcbiAgcmVzdWx0cy5mb3JFYWNoKChyZXN1bHQsIGluZGV4KSA9PiB7XG4gICAgbGV0IGlkID0gbWF0Y2hlc1RvTG9hZFtpbmRleF0ucm91dGUuaWQ7XG4gICAgaW52YXJpYW50KFxuICAgICAgIWlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSxcbiAgICAgIFwiQ2Fubm90IGhhbmRsZSByZWRpcmVjdCByZXN1bHRzIGluIHByb2Nlc3NMb2FkZXJEYXRhXCJcbiAgICApO1xuICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIC8vIExvb2sgdXB3YXJkcyBmcm9tIHRoZSBtYXRjaGVkIHJvdXRlIGZvciB0aGUgY2xvc2VzdCBhbmNlc3RvclxuICAgICAgLy8gZXJyb3IgYm91bmRhcnksIGRlZmF1bHRpbmcgdG8gdGhlIHJvb3QgbWF0Y2hcbiAgICAgIGxldCBib3VuZGFyeU1hdGNoID0gZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzLCBpZCk7XG4gICAgICBsZXQgZXJyb3IgPSByZXN1bHQuZXJyb3I7XG4gICAgICAvLyBJZiB3ZSBoYXZlIGEgcGVuZGluZyBhY3Rpb24gZXJyb3IsIHdlIHJlcG9ydCBpdCBhdCB0aGUgaGlnaGVzdC1yb3V0ZVxuICAgICAgLy8gdGhhdCB0aHJvd3MgYSBsb2FkZXIgZXJyb3IsIGFuZCB0aGVuIGNsZWFyIGl0IG91dCB0byBpbmRpY2F0ZSB0aGF0XG4gICAgICAvLyBpdCB3YXMgY29uc3VtZWRcbiAgICAgIGlmIChwZW5kaW5nRXJyb3IpIHtcbiAgICAgICAgZXJyb3IgPSBPYmplY3QudmFsdWVzKHBlbmRpbmdFcnJvcilbMF07XG4gICAgICAgIHBlbmRpbmdFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgZXJyb3JzID0gZXJyb3JzIHx8IHt9O1xuXG4gICAgICAvLyBQcmVmZXIgaGlnaGVyIGVycm9yIHZhbHVlcyBpZiBsb3dlciBlcnJvcnMgYnViYmxlIHRvIHRoZSBzYW1lIGJvdW5kYXJ5XG4gICAgICBpZiAoZXJyb3JzW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdID09IG51bGwpIHtcbiAgICAgICAgZXJyb3JzW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdID0gZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIC8vIENsZWFyIG91ciBhbnkgcHJpb3IgbG9hZGVyRGF0YSBmb3IgdGhlIHRocm93aW5nIHJvdXRlXG4gICAgICBsb2FkZXJEYXRhW2lkXSA9IHVuZGVmaW5lZDtcblxuICAgICAgLy8gT25jZSB3ZSBmaW5kIG91ciBmaXJzdCAoaGlnaGVzdCkgZXJyb3IsIHdlIHNldCB0aGUgc3RhdHVzIGNvZGUgYW5kXG4gICAgICAvLyBwcmV2ZW50IGRlZXBlciBzdGF0dXMgY29kZXMgZnJvbSBvdmVycmlkaW5nXG4gICAgICBpZiAoIWZvdW5kRXJyb3IpIHtcbiAgICAgICAgZm91bmRFcnJvciA9IHRydWU7XG4gICAgICAgIHN0YXR1c0NvZGUgPSBpc1JvdXRlRXJyb3JSZXNwb25zZShyZXN1bHQuZXJyb3IpXG4gICAgICAgICAgPyByZXN1bHQuZXJyb3Iuc3RhdHVzXG4gICAgICAgICAgOiA1MDA7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0LmhlYWRlcnMpIHtcbiAgICAgICAgbG9hZGVySGVhZGVyc1tpZF0gPSByZXN1bHQuaGVhZGVycztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzRGVmZXJyZWRSZXN1bHQocmVzdWx0KSkge1xuICAgICAgICBhY3RpdmVEZWZlcnJlZHMuc2V0KGlkLCByZXN1bHQuZGVmZXJyZWREYXRhKTtcbiAgICAgICAgbG9hZGVyRGF0YVtpZF0gPSByZXN1bHQuZGVmZXJyZWREYXRhLmRhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2FkZXJEYXRhW2lkXSA9IHJlc3VsdC5kYXRhO1xuICAgICAgfVxuXG4gICAgICAvLyBFcnJvciBzdGF0dXMgY29kZXMgYWx3YXlzIG92ZXJyaWRlIHN1Y2Nlc3Mgc3RhdHVzIGNvZGVzLCBidXQgaWYgYWxsXG4gICAgICAvLyBsb2FkZXJzIGFyZSBzdWNjZXNzZnVsIHdlIHRha2UgdGhlIGRlZXBlc3Qgc3RhdHVzIGNvZGUuXG4gICAgICBpZiAoXG4gICAgICAgIHJlc3VsdC5zdGF0dXNDb2RlICE9IG51bGwgJiZcbiAgICAgICAgcmVzdWx0LnN0YXR1c0NvZGUgIT09IDIwMCAmJlxuICAgICAgICAhZm91bmRFcnJvclxuICAgICAgKSB7XG4gICAgICAgIHN0YXR1c0NvZGUgPSByZXN1bHQuc3RhdHVzQ29kZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQuaGVhZGVycykge1xuICAgICAgICBsb2FkZXJIZWFkZXJzW2lkXSA9IHJlc3VsdC5oZWFkZXJzO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gSWYgd2UgZGlkbid0IGNvbnN1bWUgdGhlIHBlbmRpbmcgYWN0aW9uIGVycm9yIChpLmUuLCBhbGwgbG9hZGVyc1xuICAvLyByZXNvbHZlZCksIHRoZW4gY29uc3VtZSBpdCBoZXJlLiAgQWxzbyBjbGVhciBvdXQgYW55IGxvYWRlckRhdGEgZm9yIHRoZVxuICAvLyB0aHJvd2luZyByb3V0ZVxuICBpZiAocGVuZGluZ0Vycm9yKSB7XG4gICAgZXJyb3JzID0gcGVuZGluZ0Vycm9yO1xuICAgIGxvYWRlckRhdGFbT2JqZWN0LmtleXMocGVuZGluZ0Vycm9yKVswXV0gPSB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxvYWRlckRhdGEsXG4gICAgZXJyb3JzLFxuICAgIHN0YXR1c0NvZGU6IHN0YXR1c0NvZGUgfHwgMjAwLFxuICAgIGxvYWRlckhlYWRlcnMsXG4gIH07XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NMb2FkZXJEYXRhKFxuICBzdGF0ZTogUm91dGVyU3RhdGUsXG4gIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgbWF0Y2hlc1RvTG9hZDogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICByZXN1bHRzOiBEYXRhUmVzdWx0W10sXG4gIHBlbmRpbmdFcnJvcjogUm91dGVEYXRhIHwgdW5kZWZpbmVkLFxuICByZXZhbGlkYXRpbmdGZXRjaGVyczogUmV2YWxpZGF0aW5nRmV0Y2hlcltdLFxuICBmZXRjaGVyUmVzdWx0czogRGF0YVJlc3VsdFtdLFxuICBhY3RpdmVEZWZlcnJlZHM6IE1hcDxzdHJpbmcsIERlZmVycmVkRGF0YT5cbik6IHtcbiAgbG9hZGVyRGF0YTogUm91dGVyU3RhdGVbXCJsb2FkZXJEYXRhXCJdO1xuICBlcnJvcnM/OiBSb3V0ZXJTdGF0ZVtcImVycm9yc1wiXTtcbn0ge1xuICBsZXQgeyBsb2FkZXJEYXRhLCBlcnJvcnMgfSA9IHByb2Nlc3NSb3V0ZUxvYWRlckRhdGEoXG4gICAgbWF0Y2hlcyxcbiAgICBtYXRjaGVzVG9Mb2FkLFxuICAgIHJlc3VsdHMsXG4gICAgcGVuZGluZ0Vycm9yLFxuICAgIGFjdGl2ZURlZmVycmVkc1xuICApO1xuXG4gIC8vIFByb2Nlc3MgcmVzdWx0cyBmcm9tIG91ciByZXZhbGlkYXRpbmcgZmV0Y2hlcnNcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHJldmFsaWRhdGluZ0ZldGNoZXJzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGxldCB7IGtleSwgbWF0Y2ggfSA9IHJldmFsaWRhdGluZ0ZldGNoZXJzW2luZGV4XTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICBmZXRjaGVyUmVzdWx0cyAhPT0gdW5kZWZpbmVkICYmIGZldGNoZXJSZXN1bHRzW2luZGV4XSAhPT0gdW5kZWZpbmVkLFxuICAgICAgXCJEaWQgbm90IGZpbmQgY29ycmVzcG9uZGluZyBmZXRjaGVyIHJlc3VsdFwiXG4gICAgKTtcbiAgICBsZXQgcmVzdWx0ID0gZmV0Y2hlclJlc3VsdHNbaW5kZXhdO1xuXG4gICAgLy8gUHJvY2VzcyBmZXRjaGVyIG5vbi1yZWRpcmVjdCBlcnJvcnNcbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgYm91bmRhcnlNYXRjaCA9IGZpbmROZWFyZXN0Qm91bmRhcnkoc3RhdGUubWF0Y2hlcywgbWF0Y2g/LnJvdXRlLmlkKTtcbiAgICAgIGlmICghKGVycm9ycyAmJiBlcnJvcnNbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF0pKSB7XG4gICAgICAgIGVycm9ycyA9IHtcbiAgICAgICAgICAuLi5lcnJvcnMsXG4gICAgICAgICAgW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZXJyb3IsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBzdGF0ZS5mZXRjaGVycy5kZWxldGUoa2V5KTtcbiAgICB9IGVsc2UgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgLy8gU2hvdWxkIG5ldmVyIGdldCBoZXJlLCByZWRpcmVjdHMgc2hvdWxkIGdldCBwcm9jZXNzZWQgYWJvdmUsIGJ1dCB3ZVxuICAgICAgLy8ga2VlcCB0aGlzIHRvIHR5cGUgbmFycm93IHRvIGEgc3VjY2VzcyByZXN1bHQgaW4gdGhlIGVsc2VcbiAgICAgIGludmFyaWFudChmYWxzZSwgXCJVbmhhbmRsZWQgZmV0Y2hlciByZXZhbGlkYXRpb24gcmVkaXJlY3RcIik7XG4gICAgfSBlbHNlIGlmIChpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIC8vIFNob3VsZCBuZXZlciBnZXQgaGVyZSwgZGVmZXJyZWQgZGF0YSBzaG91bGQgYmUgYXdhaXRlZCBmb3IgZmV0Y2hlcnNcbiAgICAgIC8vIGluIHJlc29sdmVEZWZlcnJlZFJlc3VsdHNcbiAgICAgIGludmFyaWFudChmYWxzZSwgXCJVbmhhbmRsZWQgZmV0Y2hlciBkZWZlcnJlZCBkYXRhXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZG9uZUZldGNoZXI6IEZldGNoZXJTdGF0ZXNbXCJJZGxlXCJdID0ge1xuICAgICAgICBzdGF0ZTogXCJpZGxlXCIsXG4gICAgICAgIGRhdGE6IHJlc3VsdC5kYXRhLFxuICAgICAgICBmb3JtTWV0aG9kOiB1bmRlZmluZWQsXG4gICAgICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgICAgZm9ybUVuY1R5cGU6IHVuZGVmaW5lZCxcbiAgICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAgICAgICAgXCIgX2hhc0ZldGNoZXJEb25lQW55dGhpbmcgXCI6IHRydWUsXG4gICAgICB9O1xuICAgICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZG9uZUZldGNoZXIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IGxvYWRlckRhdGEsIGVycm9ycyB9O1xufVxuXG5mdW5jdGlvbiBtZXJnZUxvYWRlckRhdGEoXG4gIGxvYWRlckRhdGE6IFJvdXRlRGF0YSxcbiAgbmV3TG9hZGVyRGF0YTogUm91dGVEYXRhLFxuICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gIGVycm9yczogUm91dGVEYXRhIHwgbnVsbCB8IHVuZGVmaW5lZFxuKTogUm91dGVEYXRhIHtcbiAgbGV0IG1lcmdlZExvYWRlckRhdGEgPSB7IC4uLm5ld0xvYWRlckRhdGEgfTtcbiAgZm9yIChsZXQgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgIGxldCBpZCA9IG1hdGNoLnJvdXRlLmlkO1xuICAgIGlmIChuZXdMb2FkZXJEYXRhLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgaWYgKG5ld0xvYWRlckRhdGFbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbWVyZ2VkTG9hZGVyRGF0YVtpZF0gPSBuZXdMb2FkZXJEYXRhW2lkXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vLW9wIC0gdGhpcyBpcyBzbyB3ZSBpZ25vcmUgZXhpc3RpbmcgZGF0YSBpZiB3ZSBoYXZlIGEga2V5IGluIHRoZVxuICAgICAgICAvLyBpbmNvbWluZyBvYmplY3Qgd2l0aCBhbiB1bmRlZmluZWQgdmFsdWUsIHdoaWNoIGlzIGhvdyB3ZSB1bnNldCBhIHByaW9yXG4gICAgICAgIC8vIGxvYWRlckRhdGEgaWYgd2UgZW5jb3VudGVyIGEgbG9hZGVyIGVycm9yXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb2FkZXJEYXRhW2lkXSAhPT0gdW5kZWZpbmVkICYmIG1hdGNoLnJvdXRlLmxvYWRlcikge1xuICAgICAgLy8gUHJlc2VydmUgZXhpc3Rpbmcga2V5cyBub3QgaW5jbHVkZWQgaW4gbmV3TG9hZGVyRGF0YSBhbmQgd2hlcmUgYSBsb2FkZXJcbiAgICAgIC8vIHdhc24ndCByZW1vdmVkIGJ5IEhNUlxuICAgICAgbWVyZ2VkTG9hZGVyRGF0YVtpZF0gPSBsb2FkZXJEYXRhW2lkXTtcbiAgICB9XG5cbiAgICBpZiAoZXJyb3JzICYmIGVycm9ycy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgIC8vIERvbid0IGtlZXAgYW55IGxvYWRlciBkYXRhIGJlbG93IHRoZSBib3VuZGFyeVxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBtZXJnZWRMb2FkZXJEYXRhO1xufVxuXG4vLyBGaW5kIHRoZSBuZWFyZXN0IGVycm9yIGJvdW5kYXJ5LCBsb29raW5nIHVwd2FyZHMgZnJvbSB0aGUgbGVhZiByb3V0ZSAob3IgdGhlXG4vLyByb3V0ZSBzcGVjaWZpZWQgYnkgcm91dGVJZCkgZm9yIHRoZSBjbG9zZXN0IGFuY2VzdG9yIGVycm9yIGJvdW5kYXJ5LFxuLy8gZGVmYXVsdGluZyB0byB0aGUgcm9vdCBtYXRjaFxuZnVuY3Rpb24gZmluZE5lYXJlc3RCb3VuZGFyeShcbiAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICByb3V0ZUlkPzogc3RyaW5nXG4pOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoIHtcbiAgbGV0IGVsaWdpYmxlTWF0Y2hlcyA9IHJvdXRlSWRcbiAgICA/IG1hdGNoZXMuc2xpY2UoMCwgbWF0Y2hlcy5maW5kSW5kZXgoKG0pID0+IG0ucm91dGUuaWQgPT09IHJvdXRlSWQpICsgMSlcbiAgICA6IFsuLi5tYXRjaGVzXTtcbiAgcmV0dXJuIChcbiAgICBlbGlnaWJsZU1hdGNoZXMucmV2ZXJzZSgpLmZpbmQoKG0pID0+IG0ucm91dGUuaGFzRXJyb3JCb3VuZGFyeSA9PT0gdHJ1ZSkgfHxcbiAgICBtYXRjaGVzWzBdXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdldFNob3J0Q2lyY3VpdE1hdGNoZXMocm91dGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdFtdKToge1xuICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW107XG4gIHJvdXRlOiBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdDtcbn0ge1xuICAvLyBQcmVmZXIgYSByb290IGxheW91dCByb3V0ZSBpZiBwcmVzZW50LCBvdGhlcndpc2Ugc2hpbSBpbiBhIHJvdXRlIG9iamVjdFxuICBsZXQgcm91dGUgPSByb3V0ZXMuZmluZCgocikgPT4gci5pbmRleCB8fCAhci5wYXRoIHx8IHIucGF0aCA9PT0gXCIvXCIpIHx8IHtcbiAgICBpZDogYF9fc2hpbS1lcnJvci1yb3V0ZV9fYCxcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG1hdGNoZXM6IFtcbiAgICAgIHtcbiAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgcGF0aG5hbWU6IFwiXCIsXG4gICAgICAgIHBhdGhuYW1lQmFzZTogXCJcIixcbiAgICAgICAgcm91dGUsXG4gICAgICB9LFxuICAgIF0sXG4gICAgcm91dGUsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEludGVybmFsUm91dGVyRXJyb3IoXG4gIHN0YXR1czogbnVtYmVyLFxuICB7XG4gICAgcGF0aG5hbWUsXG4gICAgcm91dGVJZCxcbiAgICBtZXRob2QsXG4gICAgdHlwZSxcbiAgfToge1xuICAgIHBhdGhuYW1lPzogc3RyaW5nO1xuICAgIHJvdXRlSWQ/OiBzdHJpbmc7XG4gICAgbWV0aG9kPzogc3RyaW5nO1xuICAgIHR5cGU/OiBcImRlZmVyLWFjdGlvblwiO1xuICB9ID0ge31cbikge1xuICBsZXQgc3RhdHVzVGV4dCA9IFwiVW5rbm93biBTZXJ2ZXIgRXJyb3JcIjtcbiAgbGV0IGVycm9yTWVzc2FnZSA9IFwiVW5rbm93biBAcmVtaXgtcnVuL3JvdXRlciBlcnJvclwiO1xuXG4gIGlmIChzdGF0dXMgPT09IDQwMCkge1xuICAgIHN0YXR1c1RleHQgPSBcIkJhZCBSZXF1ZXN0XCI7XG4gICAgaWYgKG1ldGhvZCAmJiBwYXRobmFtZSAmJiByb3V0ZUlkKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPVxuICAgICAgICBgWW91IG1hZGUgYSAke21ldGhvZH0gcmVxdWVzdCB0byBcIiR7cGF0aG5hbWV9XCIgYnV0IGAgK1xuICAgICAgICBgZGlkIG5vdCBwcm92aWRlIGEgXFxgbG9hZGVyXFxgIGZvciByb3V0ZSBcIiR7cm91dGVJZH1cIiwgYCArXG4gICAgICAgIGBzbyB0aGVyZSBpcyBubyB3YXkgdG8gaGFuZGxlIHRoZSByZXF1ZXN0LmA7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcImRlZmVyLWFjdGlvblwiKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBcImRlZmVyKCkgaXMgbm90IHN1cHBvcnRlZCBpbiBhY3Rpb25zXCI7XG4gICAgfVxuICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gNDAzKSB7XG4gICAgc3RhdHVzVGV4dCA9IFwiRm9yYmlkZGVuXCI7XG4gICAgZXJyb3JNZXNzYWdlID0gYFJvdXRlIFwiJHtyb3V0ZUlkfVwiIGRvZXMgbm90IG1hdGNoIFVSTCBcIiR7cGF0aG5hbWV9XCJgO1xuICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gNDA0KSB7XG4gICAgc3RhdHVzVGV4dCA9IFwiTm90IEZvdW5kXCI7XG4gICAgZXJyb3JNZXNzYWdlID0gYE5vIHJvdXRlIG1hdGNoZXMgVVJMIFwiJHtwYXRobmFtZX1cImA7XG4gIH0gZWxzZSBpZiAoc3RhdHVzID09PSA0MDUpIHtcbiAgICBzdGF0dXNUZXh0ID0gXCJNZXRob2QgTm90IEFsbG93ZWRcIjtcbiAgICBpZiAobWV0aG9kICYmIHBhdGhuYW1lICYmIHJvdXRlSWQpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9XG4gICAgICAgIGBZb3UgbWFkZSBhICR7bWV0aG9kLnRvVXBwZXJDYXNlKCl9IHJlcXVlc3QgdG8gXCIke3BhdGhuYW1lfVwiIGJ1dCBgICtcbiAgICAgICAgYGRpZCBub3QgcHJvdmlkZSBhbiBcXGBhY3Rpb25cXGAgZm9yIHJvdXRlIFwiJHtyb3V0ZUlkfVwiLCBgICtcbiAgICAgICAgYHNvIHRoZXJlIGlzIG5vIHdheSB0byBoYW5kbGUgdGhlIHJlcXVlc3QuYDtcbiAgICB9IGVsc2UgaWYgKG1ldGhvZCkge1xuICAgICAgZXJyb3JNZXNzYWdlID0gYEludmFsaWQgcmVxdWVzdCBtZXRob2QgXCIke21ldGhvZC50b1VwcGVyQ2FzZSgpfVwiYDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IEVycm9yUmVzcG9uc2UoXG4gICAgc3RhdHVzIHx8IDUwMCxcbiAgICBzdGF0dXNUZXh0LFxuICAgIG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpLFxuICAgIHRydWVcbiAgKTtcbn1cblxuLy8gRmluZCBhbnkgcmV0dXJuZWQgcmVkaXJlY3QgZXJyb3JzLCBzdGFydGluZyBmcm9tIHRoZSBsb3dlc3QgbWF0Y2hcbmZ1bmN0aW9uIGZpbmRSZWRpcmVjdChyZXN1bHRzOiBEYXRhUmVzdWx0W10pOiBSZWRpcmVjdFJlc3VsdCB8IHVuZGVmaW5lZCB7XG4gIGZvciAobGV0IGkgPSByZXN1bHRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGV0IHJlc3VsdCA9IHJlc3VsdHNbaV07XG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RyaXBIYXNoRnJvbVBhdGgocGF0aDogVG8pIHtcbiAgbGV0IHBhcnNlZFBhdGggPSB0eXBlb2YgcGF0aCA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aChwYXRoKSA6IHBhdGg7XG4gIHJldHVybiBjcmVhdGVQYXRoKHsgLi4ucGFyc2VkUGF0aCwgaGFzaDogXCJcIiB9KTtcbn1cblxuZnVuY3Rpb24gaXNIYXNoQ2hhbmdlT25seShhOiBMb2NhdGlvbiwgYjogTG9jYXRpb24pOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICBhLnBhdGhuYW1lID09PSBiLnBhdGhuYW1lICYmIGEuc2VhcmNoID09PSBiLnNlYXJjaCAmJiBhLmhhc2ggIT09IGIuaGFzaFxuICApO1xufVxuXG5mdW5jdGlvbiBpc0RlZmVycmVkUmVzdWx0KHJlc3VsdDogRGF0YVJlc3VsdCk6IHJlc3VsdCBpcyBEZWZlcnJlZFJlc3VsdCB7XG4gIHJldHVybiByZXN1bHQudHlwZSA9PT0gUmVzdWx0VHlwZS5kZWZlcnJlZDtcbn1cblxuZnVuY3Rpb24gaXNFcnJvclJlc3VsdChyZXN1bHQ6IERhdGFSZXN1bHQpOiByZXN1bHQgaXMgRXJyb3JSZXN1bHQge1xuICByZXR1cm4gcmVzdWx0LnR5cGUgPT09IFJlc3VsdFR5cGUuZXJyb3I7XG59XG5cbmZ1bmN0aW9uIGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0PzogRGF0YVJlc3VsdCk6IHJlc3VsdCBpcyBSZWRpcmVjdFJlc3VsdCB7XG4gIHJldHVybiAocmVzdWx0ICYmIHJlc3VsdC50eXBlKSA9PT0gUmVzdWx0VHlwZS5yZWRpcmVjdDtcbn1cblxuZnVuY3Rpb24gaXNSZXNwb25zZSh2YWx1ZTogYW55KTogdmFsdWUgaXMgUmVzcG9uc2Uge1xuICByZXR1cm4gKFxuICAgIHZhbHVlICE9IG51bGwgJiZcbiAgICB0eXBlb2YgdmFsdWUuc3RhdHVzID09PSBcIm51bWJlclwiICYmXG4gICAgdHlwZW9mIHZhbHVlLnN0YXR1c1RleHQgPT09IFwic3RyaW5nXCIgJiZcbiAgICB0eXBlb2YgdmFsdWUuaGVhZGVycyA9PT0gXCJvYmplY3RcIiAmJlxuICAgIHR5cGVvZiB2YWx1ZS5ib2R5ICE9PSBcInVuZGVmaW5lZFwiXG4gICk7XG59XG5cbmZ1bmN0aW9uIGlzUmVkaXJlY3RSZXNwb25zZShyZXN1bHQ6IGFueSk6IHJlc3VsdCBpcyBSZXNwb25zZSB7XG4gIGlmICghaXNSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbGV0IHN0YXR1cyA9IHJlc3VsdC5zdGF0dXM7XG4gIGxldCBsb2NhdGlvbiA9IHJlc3VsdC5oZWFkZXJzLmdldChcIkxvY2F0aW9uXCIpO1xuICByZXR1cm4gc3RhdHVzID49IDMwMCAmJiBzdGF0dXMgPD0gMzk5ICYmIGxvY2F0aW9uICE9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzUXVlcnlSb3V0ZVJlc3BvbnNlKG9iajogYW55KTogb2JqIGlzIFF1ZXJ5Um91dGVSZXNwb25zZSB7XG4gIHJldHVybiAoXG4gICAgb2JqICYmXG4gICAgaXNSZXNwb25zZShvYmoucmVzcG9uc2UpICYmXG4gICAgKG9iai50eXBlID09PSBSZXN1bHRUeXBlLmRhdGEgfHwgUmVzdWx0VHlwZS5lcnJvcilcbiAgKTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZE1ldGhvZChtZXRob2Q6IHN0cmluZyk6IG1ldGhvZCBpcyBGb3JtTWV0aG9kIHtcbiAgcmV0dXJuIHZhbGlkUmVxdWVzdE1ldGhvZHMuaGFzKG1ldGhvZCBhcyBGb3JtTWV0aG9kKTtcbn1cblxuZnVuY3Rpb24gaXNNdXRhdGlvbk1ldGhvZChtZXRob2Q/OiBzdHJpbmcpOiBtZXRob2QgaXMgTXV0YXRpb25Gb3JtTWV0aG9kIHtcbiAgcmV0dXJuIHZhbGlkTXV0YXRpb25NZXRob2RzLmhhcyhtZXRob2QgYXMgTXV0YXRpb25Gb3JtTWV0aG9kKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZURlZmVycmVkUmVzdWx0cyhcbiAgY3VycmVudE1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgbWF0Y2hlc1RvTG9hZDogKEFnbm9zdGljRGF0YVJvdXRlTWF0Y2ggfCBudWxsKVtdLFxuICByZXN1bHRzOiBEYXRhUmVzdWx0W10sXG4gIHNpZ25hbDogQWJvcnRTaWduYWwsXG4gIGlzRmV0Y2hlcjogYm9vbGVhbixcbiAgY3VycmVudExvYWRlckRhdGE/OiBSb3V0ZURhdGFcbikge1xuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcmVzdWx0cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBsZXQgcmVzdWx0ID0gcmVzdWx0c1tpbmRleF07XG4gICAgbGV0IG1hdGNoID0gbWF0Y2hlc1RvTG9hZFtpbmRleF07XG4gICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIG1hdGNoLCB0aGVuIHdlIGNhbiBoYXZlIGEgZGVmZXJyZWQgcmVzdWx0IHRvIGRvXG4gICAgLy8gYW55dGhpbmcgd2l0aC4gIFRoaXMgaXMgZm9yIHJldmFsaWRhdGluZyBmZXRjaGVycyB3aGVyZSB0aGUgcm91dGUgd2FzXG4gICAgLy8gcmVtb3ZlZCBkdXJpbmcgSE1SXG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgbGV0IGN1cnJlbnRNYXRjaCA9IGN1cnJlbnRNYXRjaGVzLmZpbmQoXG4gICAgICAobSkgPT4gbS5yb3V0ZS5pZCA9PT0gbWF0Y2ghLnJvdXRlLmlkXG4gICAgKTtcbiAgICBsZXQgaXNSZXZhbGlkYXRpbmdMb2FkZXIgPVxuICAgICAgY3VycmVudE1hdGNoICE9IG51bGwgJiZcbiAgICAgICFpc05ld1JvdXRlSW5zdGFuY2UoY3VycmVudE1hdGNoLCBtYXRjaCkgJiZcbiAgICAgIChjdXJyZW50TG9hZGVyRGF0YSAmJiBjdXJyZW50TG9hZGVyRGF0YVttYXRjaC5yb3V0ZS5pZF0pICE9PSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpICYmIChpc0ZldGNoZXIgfHwgaXNSZXZhbGlkYXRpbmdMb2FkZXIpKSB7XG4gICAgICAvLyBOb3RlOiB3ZSBkbyBub3QgaGF2ZSB0byB0b3VjaCBhY3RpdmVEZWZlcnJlZHMgaGVyZSBzaW5jZSB3ZSByYWNlIHRoZW1cbiAgICAgIC8vIGFnYWluc3QgdGhlIHNpZ25hbCBpbiByZXNvbHZlRGVmZXJyZWREYXRhIGFuZCB0aGV5J2xsIGdldCBhYm9ydGVkXG4gICAgICAvLyB0aGVyZSBpZiBuZWVkZWRcbiAgICAgIGF3YWl0IHJlc29sdmVEZWZlcnJlZERhdGEocmVzdWx0LCBzaWduYWwsIGlzRmV0Y2hlcikudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHRzW2luZGV4XSA9IHJlc3VsdCB8fCByZXN1bHRzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVEZWZlcnJlZERhdGEoXG4gIHJlc3VsdDogRGVmZXJyZWRSZXN1bHQsXG4gIHNpZ25hbDogQWJvcnRTaWduYWwsXG4gIHVud3JhcCA9IGZhbHNlXG4pOiBQcm9taXNlPFN1Y2Nlc3NSZXN1bHQgfCBFcnJvclJlc3VsdCB8IHVuZGVmaW5lZD4ge1xuICBsZXQgYWJvcnRlZCA9IGF3YWl0IHJlc3VsdC5kZWZlcnJlZERhdGEucmVzb2x2ZURhdGEoc2lnbmFsKTtcbiAgaWYgKGFib3J0ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodW53cmFwKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZGF0YSxcbiAgICAgICAgZGF0YTogcmVzdWx0LmRlZmVycmVkRGF0YS51bndyYXBwZWREYXRhLFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBIYW5kbGUgYW55IFRyYWNrZWRQcm9taXNlLl9lcnJvciB2YWx1ZXMgZW5jb3VudGVyZWQgd2hpbGUgdW53cmFwcGluZ1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogUmVzdWx0VHlwZS5lcnJvcixcbiAgICAgICAgZXJyb3I6IGUsXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogUmVzdWx0VHlwZS5kYXRhLFxuICAgIGRhdGE6IHJlc3VsdC5kZWZlcnJlZERhdGEuZGF0YSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gaGFzTmFrZWRJbmRleFF1ZXJ5KHNlYXJjaDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zKHNlYXJjaCkuZ2V0QWxsKFwiaW5kZXhcIikuc29tZSgodikgPT4gdiA9PT0gXCJcIik7XG59XG5cbi8vIE5vdGU6IFRoaXMgc2hvdWxkIG1hdGNoIHRoZSBmb3JtYXQgZXhwb3J0ZWQgYnkgdXNlTWF0Y2hlcywgc28gaWYgeW91IGNoYW5nZVxuLy8gdGhpcyBwbGVhc2UgYWxzbyBjaGFuZ2UgdGhhdCA6KSAgRXZlbnR1YWxseSB3ZSdsbCBEUlkgdGhpcyB1cFxuZnVuY3Rpb24gY3JlYXRlVXNlTWF0Y2hlc01hdGNoKFxuICBtYXRjaDogQWdub3N0aWNEYXRhUm91dGVNYXRjaCxcbiAgbG9hZGVyRGF0YTogUm91dGVEYXRhXG4pOiBVc2VNYXRjaGVzTWF0Y2gge1xuICBsZXQgeyByb3V0ZSwgcGF0aG5hbWUsIHBhcmFtcyB9ID0gbWF0Y2g7XG4gIHJldHVybiB7XG4gICAgaWQ6IHJvdXRlLmlkLFxuICAgIHBhdGhuYW1lLFxuICAgIHBhcmFtcyxcbiAgICBkYXRhOiBsb2FkZXJEYXRhW3JvdXRlLmlkXSBhcyB1bmtub3duLFxuICAgIGhhbmRsZTogcm91dGUuaGFuZGxlIGFzIHVua25vd24sXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldE1hdGNoKFxuICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gIGxvY2F0aW9uOiBMb2NhdGlvbiB8IHN0cmluZ1xuKSB7XG4gIGxldCBzZWFyY2ggPVxuICAgIHR5cGVvZiBsb2NhdGlvbiA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aChsb2NhdGlvbikuc2VhcmNoIDogbG9jYXRpb24uc2VhcmNoO1xuICBpZiAoXG4gICAgbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLmluZGV4ICYmXG4gICAgaGFzTmFrZWRJbmRleFF1ZXJ5KHNlYXJjaCB8fCBcIlwiKVxuICApIHtcbiAgICAvLyBSZXR1cm4gdGhlIGxlYWYgaW5kZXggcm91dGUgd2hlbiBpbmRleCBpcyBwcmVzZW50XG4gICAgcmV0dXJuIG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgfVxuICAvLyBPdGhlcndpc2UgZ3JhYiB0aGUgZGVlcGVzdCBcInBhdGggY29udHJpYnV0aW5nXCIgbWF0Y2ggKGlnbm9yaW5nIGluZGV4IGFuZFxuICAvLyBwYXRobGVzcyBsYXlvdXQgcm91dGVzKVxuICBsZXQgcGF0aE1hdGNoZXMgPSBnZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyhtYXRjaGVzKTtcbiAgcmV0dXJuIHBhdGhNYXRjaGVzW3BhdGhNYXRjaGVzLmxlbmd0aCAtIDFdO1xufVxuLy8jZW5kcmVnaW9uXG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDWUEsT0FBQSxDQUFBQyxNQUFBO0FBd0JaO0FBQ0E7QUFDQTs7V0ExQllBLE1BQUE7RUFBQUEsTUFBQTtFQUFBQSxNQUFBO0VBQUFBLE1BQUE7QUFBQSxHQUFBRCxPQUFBLENBQUFDLE1BQUEsS0FBQUQsT0FBQSxDQUFBQyxNQUFBO0FBd0xaLE1BQU1DLGlCQUFpQixHQUFHLFVBQTFCO0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLFNBQVNDLG1CQUFUQSxDQUNMQyxPQURLLEVBRVU7RUFBQSxJQURmQSxPQUNlO0lBRGZBLE9BQ2UsR0FEaUIsRUFD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