7b523bbdfc14a20272ed6c4e6e3c1698
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var _ref;

// Should be no imports here!
// Some things that should be evaluated before all else...
// We only want to know if non-polyfilled symbols are available
var hasSymbol = typeof Symbol !== "undefined" && typeof /*#__PURE__*/
Symbol("x") === "symbol";
var hasMap = typeof Map !== "undefined";
var hasSet = typeof Set !== "undefined";
var hasProxies = typeof Proxy !== "undefined" && typeof Proxy.revocable !== "undefined" && typeof Reflect !== "undefined";
/**
 * The sentinel value returned by producers to replace the draft with undefined.
 */

var NOTHING = hasSymbol ? /*#__PURE__*/
Symbol.for("immer-nothing") : (_ref = {}, _ref["immer-nothing"] = true, _ref);
/**
 * To let Immer treat your class instances as plain immutable objects
 * (albeit with a custom prototype), you must define either an instance property
 * or a static property on each of your custom classes.
 *
 * Otherwise, your class instance will never be drafted, which means it won't be
 * safe to mutate in a produce callback.
 */

var DRAFTABLE = hasSymbol ? /*#__PURE__*/
Symbol.for("immer-draftable") : "__$immer_draftable";
var DRAFT_STATE = hasSymbol ? /*#__PURE__*/
Symbol.for("immer-state") : "__$immer_state"; // Even a polyfilled Symbol might provide Symbol.iterator

var iteratorSymbol = typeof Symbol != "undefined" && Symbol.iterator || "@@iterator";
var errors = {
  0: "Illegal state",
  1: "Immer drafts cannot have computed properties",
  2: "This object has been frozen and should not be mutated",
  3: function _(data) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + data;
  },
  4: "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  5: "Immer forbids circular references",
  6: "The first or second argument to `produce` must be a function",
  7: "The third argument to `produce` must be a function or undefined",
  8: "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  9: "First argument to `finishDraft` must be a draft returned by `createDraft`",
  10: "The given draft is already finalized",
  11: "Object.defineProperty() cannot be used on an Immer draft",
  12: "Object.setPrototypeOf() cannot be used on an Immer draft",
  13: "Immer only supports deleting array indices",
  14: "Immer only supports setting array indices and the 'length' property",
  15: function _(path) {
    return "Cannot apply patch, path doesn't resolve: " + path;
  },
  16: 'Sets cannot have "replace" patches.',
  17: function _(op) {
    return "Unsupported patch operation: " + op;
  },
  18: function _(plugin) {
    return "The plugin for '" + plugin + "' has not been loaded into Immer. To enable the plugin, import and call `enable" + plugin + "()` when initializing your application.";
  },
  20: "Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available",
  21: function _(thing) {
    return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '" + thing + "'";
  },
  22: function _(thing) {
    return "'current' expects a draft, got: " + thing;
  },
  23: function _(thing) {
    return "'original' expects a draft, got: " + thing;
  },
  24: "Patching reserved attributes like __proto__, prototype and constructor is not allowed"
};
function die(error) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  {
    var e = errors[error];
    var msg = !e ? "unknown error nr: " + error : typeof e === "function" ? e.apply(null, args) : e;
    throw new Error("[Immer] " + msg);
  }
}

/** Returns true if the given value is an Immer draft */

/*#__PURE__*/

function isDraft(value) {
  return !!value && !!value[DRAFT_STATE];
}
/** Returns true if the given value can be drafted by Immer */

/*#__PURE__*/

function isDraftable(value) {
  var _value$constructor;
  if (!value) return false;
  return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!((_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor[DRAFTABLE]) || isMap(value) || isSet(value);
}
var objectCtorString = /*#__PURE__*/
Object.prototype.constructor.toString();
/*#__PURE__*/

function isPlainObject(value) {
  if (!value || typeof value !== "object") return false;
  var proto = Object.getPrototypeOf(value);
  if (proto === null) {
    return true;
  }
  var Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  if (Ctor === Object) return true;
  return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
}
function original(value) {
  if (!isDraft(value)) die(23, value);
  return value[DRAFT_STATE].base_;
}
/*#__PURE__*/

var ownKeys = typeof Reflect !== "undefined" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== "undefined" ? function (obj) {
  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
} : /* istanbul ignore next */
Object.getOwnPropertyNames;
var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(target) {
  // Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274
  var res = {};
  ownKeys(target).forEach(function (key) {
    res[key] = Object.getOwnPropertyDescriptor(target, key);
  });
  return res;
};
function each(obj, iter, enumerableOnly) {
  if (enumerableOnly === void 0) {
    enumerableOnly = false;
  }
  if (getArchtype(obj) === 0
  /* Object */) {
    (enumerableOnly ? Object.keys : ownKeys)(obj).forEach(function (key) {
      if (!enumerableOnly || typeof key !== "symbol") iter(key, obj[key], obj);
    });
  } else {
    obj.forEach(function (entry, index) {
      return iter(index, entry, obj);
    });
  }
}
/*#__PURE__*/

function getArchtype(thing) {
  /* istanbul ignore next */
  var state = thing[DRAFT_STATE];
  return state ? state.type_ > 3 ? state.type_ - 4 // cause Object and Array map back from 4 and 5
  : state.type_ // others are the same
  : Array.isArray(thing) ? 1
  /* Array */ : isMap(thing) ? 2
  /* Map */ : isSet(thing) ? 3
  /* Set */ : 0
  /* Object */;
}
/*#__PURE__*/

function has(thing, prop) {
  return getArchtype(thing) === 2
  /* Map */ ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
}
/*#__PURE__*/

function get(thing, prop) {
  // @ts-ignore
  return getArchtype(thing) === 2
  /* Map */ ? thing.get(prop) : thing[prop];
}
/*#__PURE__*/

function set(thing, propOrOldValue, value) {
  var t = getArchtype(thing);
  if (t === 2
  /* Map */) thing.set(propOrOldValue, value);else if (t === 3
  /* Set */) {
    thing.add(value);
  } else thing[propOrOldValue] = value;
}
/*#__PURE__*/

function is(x, y) {
  // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}
/*#__PURE__*/

function isMap(target) {
  return hasMap && target instanceof Map;
}
/*#__PURE__*/

function isSet(target) {
  return hasSet && target instanceof Set;
}
/*#__PURE__*/

function latest(state) {
  return state.copy_ || state.base_;
}
/*#__PURE__*/

function shallowCopy(base) {
  if (Array.isArray(base)) return Array.prototype.slice.call(base);
  var descriptors = getOwnPropertyDescriptors(base);
  delete descriptors[DRAFT_STATE];
  var keys = ownKeys(descriptors);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var desc = descriptors[key];
    if (desc.writable === false) {
      desc.writable = true;
      desc.configurable = true;
    } // like object.assign, we will read any _own_, get/set accessors. This helps in dealing
    // with libraries that trap values, like mobx or vue
    // unlike object.assign, non-enumerables will be copied as well

    if (desc.get || desc.set) descriptors[key] = {
      configurable: true,
      writable: true,
      enumerable: desc.enumerable,
      value: base[key]
    };
  }
  return Object.create(Object.getPrototypeOf(base), descriptors);
}
function freeze(obj, deep) {
  if (deep === void 0) {
    deep = false;
  }
  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj;
  if (getArchtype(obj) > 1
  /* Map or Set */) {
    obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
  }
  Object.freeze(obj);
  if (deep) each(obj, function (key, value) {
    return freeze(value, true);
  }, true);
  return obj;
}
function dontMutateFrozenCollections() {
  die(2);
}
function isFrozen(obj) {
  if (obj == null || typeof obj !== "object") return true; // See #600, IE dies on non-objects in Object.isFrozen

  return Object.isFrozen(obj);
}

/** Plugin utilities */

var plugins = {};
function getPlugin(pluginKey) {
  var plugin = plugins[pluginKey];
  if (!plugin) {
    die(18, pluginKey);
  } // @ts-ignore

  return plugin;
}
function loadPlugin(pluginKey, implementation) {
  if (!plugins[pluginKey]) plugins[pluginKey] = implementation;
}
var currentScope;
function getCurrentScope() {
  if (!currentScope) die(0);
  return currentScope;
}
function createScope(parent_, immer_) {
  return {
    drafts_: [],
    parent_: parent_,
    immer_: immer_,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: true,
    unfinalizedDrafts_: 0
  };
}
function usePatchesInScope(scope, patchListener) {
  if (patchListener) {
    getPlugin("Patches"); // assert we have the plugin

    scope.patches_ = [];
    scope.inversePatches_ = [];
    scope.patchListener_ = patchListener;
  }
}
function revokeScope(scope) {
  leaveScope(scope);
  scope.drafts_.forEach(revokeDraft); // @ts-ignore

  scope.drafts_ = null;
}
function leaveScope(scope) {
  if (scope === currentScope) {
    currentScope = scope.parent_;
  }
}
function enterScope(immer) {
  return currentScope = createScope(currentScope, immer);
}
function revokeDraft(draft) {
  var state = draft[DRAFT_STATE];
  if (state.type_ === 0
  /* ProxyObject */ || state.type_ === 1
  /* ProxyArray */) state.revoke_();else state.revoked_ = true;
}
function processResult(result, scope) {
  scope.unfinalizedDrafts_ = scope.drafts_.length;
  var baseDraft = scope.drafts_[0];
  var isReplaced = result !== undefined && result !== baseDraft;
  if (!scope.immer_.useProxies_) getPlugin("ES5").willFinalizeES5_(scope, result, isReplaced);
  if (isReplaced) {
    if (baseDraft[DRAFT_STATE].modified_) {
      revokeScope(scope);
      die(4);
    }
    if (isDraftable(result)) {
      // Finalize the result in case it contains (or is) a subset of the draft.
      result = finalize(scope, result);
      if (!scope.parent_) maybeFreeze(scope, result);
    }
    if (scope.patches_) {
      getPlugin("Patches").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope.patches_, scope.inversePatches_);
    }
  } else {
    // Finalize the base draft.
    result = finalize(scope, baseDraft, []);
  }
  revokeScope(scope);
  if (scope.patches_) {
    scope.patchListener_(scope.patches_, scope.inversePatches_);
  }
  return result !== NOTHING ? result : undefined;
}
function finalize(rootScope, value, path) {
  // Don't recurse in tho recursive data structures
  if (isFrozen(value)) return value;
  var state = value[DRAFT_STATE]; // A plain object, might need freezing, might contain drafts

  if (!state) {
    each(value, function (key, childValue) {
      return finalizeProperty(rootScope, state, value, key, childValue, path);
    }, true // See #590, don't recurse into non-enumerable of non drafted objects
    );

    return value;
  } // Never finalize drafts owned by another scope.

  if (state.scope_ !== rootScope) return value; // Unmodified draft, return the (frozen) original

  if (!state.modified_) {
    maybeFreeze(rootScope, state.base_, true);
    return state.base_;
  } // Not finalized yet, let's do that now

  if (!state.finalized_) {
    state.finalized_ = true;
    state.scope_.unfinalizedDrafts_--;
    var result =
    // For ES5, create a good copy from the draft first, with added keys and without deleted keys.
    state.type_ === 4
    /* ES5Object */ || state.type_ === 5
    /* ES5Array */ ? state.copy_ = shallowCopy(state.draft_) : state.copy_; // Finalize all children of the copy
    // For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628
    // To preserve insertion order in all cases we then clear the set
    // And we let finalizeProperty know it needs to re-add non-draft children back to the target

    var resultEach = result;
    var isSet = false;
    if (state.type_ === 3
    /* Set */) {
      resultEach = new Set(result);
      result.clear();
      isSet = true;
    }
    each(resultEach, function (key, childValue) {
      return finalizeProperty(rootScope, state, result, key, childValue, path, isSet);
    }); // everything inside is frozen, we can freeze here

    maybeFreeze(rootScope, result, false); // first time finalizing, let's create those patches

    if (path && rootScope.patches_) {
      getPlugin("Patches").generatePatches_(state, path, rootScope.patches_, rootScope.inversePatches_);
    }
  }
  return state.copy_;
}
function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
  if (childValue === targetObject) die(5);
  if (isDraft(childValue)) {
    var path = rootPath && parentState && parentState.type_ !== 3
    /* Set */ &&
    // Set objects are atomic since they have no keys.
    !has(parentState.assigned_, prop) // Skip deep patches for assigned keys.
    ? rootPath.concat(prop) : undefined; // Drafts owned by `scope` are finalized here.

    var res = finalize(rootScope, childValue, path);
    set(targetObject, prop, res); // Drafts from another scope must prevented to be frozen
    // if we got a draft back from finalize, we're in a nested produce and shouldn't freeze

    if (isDraft(res)) {
      rootScope.canAutoFreeze_ = false;
    } else return;
  } else if (targetIsSet) {
    targetObject.add(childValue);
  } // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.

  if (isDraftable(childValue) && !isFrozen(childValue)) {
    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
      // optimization: if an object is not a draft, and we don't have to
      // deepfreeze everything, and we are sure that no drafts are left in the remaining object
      // cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.
      // This benefits especially adding large data tree's without further processing.
      // See add-data.js perf test
      return;
    }
    finalize(rootScope, childValue); // immer deep freezes plain objects, so if there is no parent state, we freeze as well

    if (!parentState || !parentState.scope_.parent_) maybeFreeze(rootScope, childValue);
  }
}
function maybeFreeze(scope, value, deep) {
  if (deep === void 0) {
    deep = false;
  }

  // we never freeze for a non-root scope; as it would prevent pruning for drafts inside wrapping objects
  if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
    freeze(value, deep);
  }
}

/**
 * Returns a new draft of the `base` object.
 *
 * The second argument is the parent draft-state (used internally).
 */

function createProxyProxy(base, parent) {
  var isArray = Array.isArray(base);
  var state = {
    type_: isArray ? 1
    /* ProxyArray */ : 0
    /* ProxyObject */,

    // Track which produce call this is associated with.
    scope_: parent ? parent.scope_ : getCurrentScope(),
    // True for both shallow and deep changes.
    modified_: false,
    // Used during finalization.
    finalized_: false,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: parent,
    // The base state.
    base_: base,
    // The base proxy.
    draft_: null,
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: false
  }; // the traps must target something, a bit like the 'real' base.
  // but also, we need to be able to determine from the target what the relevant state is
  // (to avoid creating traps per instance to capture the state in closure,
  // and to avoid creating weird hidden properties as well)
  // So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)
  // Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb

  var target = state;
  var traps = objectTraps;
  if (isArray) {
    target = [state];
    traps = arrayTraps;
  }
  var _Proxy$revocable = Proxy.revocable(target, traps),
    revoke = _Proxy$revocable.revoke,
    proxy = _Proxy$revocable.proxy;
  state.draft_ = proxy;
  state.revoke_ = revoke;
  return proxy;
}
/**
 * Object drafts
 */

var objectTraps = {
  get: function get(state, prop) {
    if (prop === DRAFT_STATE) return state;
    var source = latest(state);
    if (!has(source, prop)) {
      // non-existing or non-own property...
      return readPropFromProto(state, source, prop);
    }
    var value = source[prop];
    if (state.finalized_ || !isDraftable(value)) {
      return value;
    } // Check for existing draft in modified state.
    // Assigned values are never drafted. This catches any drafts we created, too.

    if (value === peek(state.base_, prop)) {
      prepareCopy(state);
      return state.copy_[prop] = createProxy(state.scope_.immer_, value, state);
    }
    return value;
  },
  has: function has(state, prop) {
    return prop in latest(state);
  },
  ownKeys: function ownKeys(state) {
    return Reflect.ownKeys(latest(state));
  },
  set: function set(state, prop
  /* strictly not, but helps TS */, value) {
    var desc = getDescriptorFromProto(latest(state), prop);
    if (desc === null || desc === void 0 ? void 0 : desc.set) {
      // special case: if this write is captured by a setter, we have
      // to trigger it with the correct context
      desc.set.call(state.draft_, value);
      return true;
    }
    if (!state.modified_) {
      // the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)
      // from setting an existing property with value undefined to undefined (which is not a change)
      var current = peek(latest(state), prop); // special case, if we assigning the original value to a draft, we can ignore the assignment

      var currentState = current === null || current === void 0 ? void 0 : current[DRAFT_STATE];
      if (currentState && currentState.base_ === value) {
        state.copy_[prop] = value;
        state.assigned_[prop] = false;
        return true;
      }
      if (is(value, current) && (value !== undefined || has(state.base_, prop))) return true;
      prepareCopy(state);
      markChanged(state);
    }
    if (state.copy_[prop] === value && (
    // special case: handle new props with value 'undefined'
    value !== undefined || prop in state.copy_) ||
    // special case: NaN
    Number.isNaN(value) && Number.isNaN(state.copy_[prop])) return true; // @ts-ignore

    state.copy_[prop] = value;
    state.assigned_[prop] = true;
    return true;
  },
  deleteProperty: function deleteProperty(state, prop) {
    // The `undefined` check is a fast path for pre-existing keys.
    if (peek(state.base_, prop) !== undefined || prop in state.base_) {
      state.assigned_[prop] = false;
      prepareCopy(state);
      markChanged(state);
    } else {
      // if an originally not assigned property was deleted
      delete state.assigned_[prop];
    } // @ts-ignore

    if (state.copy_) delete state.copy_[prop];
    return true;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(state, prop) {
    var owner = latest(state);
    var desc = Reflect.getOwnPropertyDescriptor(owner, prop);
    if (!desc) return desc;
    return {
      writable: true,
      configurable: state.type_ !== 1
      /* ProxyArray */ || prop !== "length",
      enumerable: desc.enumerable,
      value: owner[prop]
    };
  },
  defineProperty: function defineProperty() {
    die(11);
  },
  getPrototypeOf: function getPrototypeOf(state) {
    return Object.getPrototypeOf(state.base_);
  },
  setPrototypeOf: function setPrototypeOf() {
    die(12);
  }
};
/**
 * Array drafts
 */

var arrayTraps = {};
each(objectTraps, function (key, fn) {
  // @ts-ignore
  arrayTraps[key] = function () {
    arguments[0] = arguments[0][0];
    return fn.apply(this, arguments);
  };
});
arrayTraps.deleteProperty = function (state, prop) {
  if (isNaN(parseInt(prop))) die(13); // @ts-ignore

  return arrayTraps.set.call(this, state, prop, undefined);
};
arrayTraps.set = function (state, prop, value) {
  if (prop !== "length" && isNaN(parseInt(prop))) die(14);
  return objectTraps.set.call(this, state[0], prop, value, state[0]);
}; // Access a property without creating an Immer draft.

function peek(draft, prop) {
  var state = draft[DRAFT_STATE];
  var source = state ? latest(state) : draft;
  return source[prop];
}
function readPropFromProto(state, source, prop) {
  var _desc$get;
  var desc = getDescriptorFromProto(source, prop);
  return desc ? "value" in desc ? desc.value :
  // This is a very special case, if the prop is a getter defined by the
  // prototype, we should invoke it with the draft as context!
  (_desc$get = desc.get) === null || _desc$get === void 0 ? void 0 : _desc$get.call(state.draft_) : undefined;
}
function getDescriptorFromProto(source, prop) {
  // 'in' checks proto!
  if (!(prop in source)) return undefined;
  var proto = Object.getPrototypeOf(source);
  while (proto) {
    var desc = Object.getOwnPropertyDescriptor(proto, prop);
    if (desc) return desc;
    proto = Object.getPrototypeOf(proto);
  }
  return undefined;
}
function markChanged(state) {
  if (!state.modified_) {
    state.modified_ = true;
    if (state.parent_) {
      markChanged(state.parent_);
    }
  }
}
function prepareCopy(state) {
  if (!state.copy_) {
    state.copy_ = shallowCopy(state.base_);
  }
}
var Immer = /*#__PURE__*/
function () {
  function Immer(config) {
    var _this = this;
    this.useProxies_ = hasProxies;
    this.autoFreeze_ = true;
    /**
     * The `produce` function takes a value and a "recipe function" (whose
     * return value often depends on the base state). The recipe function is
     * free to mutate its first argument however it wants. All mutations are
     * only ever applied to a __copy__ of the base state.
     *
     * Pass only a function to create a "curried producer" which relieves you
     * from passing the recipe function every time.
     *
     * Only plain objects and arrays are made mutable. All other objects are
     * considered uncopyable.
     *
     * Note: This function is __bound__ to its `Immer` instance.
     *
     * @param {any} base - the initial state
     * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified
     * @param {Function} patchListener - optional function that will be called with all the patches produced here
     * @returns {any} a new state, or the initial state if nothing was modified
     */

    this.produce = function (base, recipe, patchListener) {
      // curried invocation
      if (typeof base === "function" && typeof recipe !== "function") {
        var defaultBase = recipe;
        recipe = base;
        var self = _this;
        return function curriedProduce(base) {
          var _this2 = this;
          if (base === void 0) {
            base = defaultBase;
          }
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          return self.produce(base, function (draft) {
            var _recipe;
            return (_recipe = recipe).call.apply(_recipe, [_this2, draft].concat(args));
          }); // prettier-ignore
        };
      }

      if (typeof recipe !== "function") die(6);
      if (patchListener !== undefined && typeof patchListener !== "function") die(7);
      var result; // Only plain objects, arrays, and "immerable classes" are drafted.

      if (isDraftable(base)) {
        var scope = enterScope(_this);
        var proxy = createProxy(_this, base, undefined);
        var hasError = true;
        try {
          result = recipe(proxy);
          hasError = false;
        } finally {
          // finally instead of catch + rethrow better preserves original stack
          if (hasError) revokeScope(scope);else leaveScope(scope);
        }
        if (typeof Promise !== "undefined" && result instanceof Promise) {
          return result.then(function (result) {
            usePatchesInScope(scope, patchListener);
            return processResult(result, scope);
          }, function (error) {
            revokeScope(scope);
            throw error;
          });
        }
        usePatchesInScope(scope, patchListener);
        return processResult(result, scope);
      } else if (!base || typeof base !== "object") {
        result = recipe(base);
        if (result === undefined) result = base;
        if (result === NOTHING) result = undefined;
        if (_this.autoFreeze_) freeze(result, true);
        if (patchListener) {
          var p = [];
          var ip = [];
          getPlugin("Patches").generateReplacementPatches_(base, result, p, ip);
          patchListener(p, ip);
        }
        return result;
      } else die(21, base);
    };
    this.produceWithPatches = function (base, recipe) {
      // curried invocation
      if (typeof base === "function") {
        return function (state) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          return _this.produceWithPatches(state, function (draft) {
            return base.apply(void 0, [draft].concat(args));
          });
        };
      }
      var patches, inversePatches;
      var result = _this.produce(base, recipe, function (p, ip) {
        patches = p;
        inversePatches = ip;
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then(function (nextState) {
          return [nextState, patches, inversePatches];
        });
      }
      return [result, patches, inversePatches];
    };
    if (typeof (config === null || config === void 0 ? void 0 : config.useProxies) === "boolean") this.setUseProxies(config.useProxies);
    if (typeof (config === null || config === void 0 ? void 0 : config.autoFreeze) === "boolean") this.setAutoFreeze(config.autoFreeze);
  }
  var _proto = Immer.prototype;
  _proto.createDraft = function createDraft(base) {
    if (!isDraftable(base)) die(8);
    if (isDraft(base)) base = current(base);
    var scope = enterScope(this);
    var proxy = createProxy(this, base, undefined);
    proxy[DRAFT_STATE].isManual_ = true;
    leaveScope(scope);
    return proxy;
  };
  _proto.finishDraft = function finishDraft(draft, patchListener) {
    var state = draft && draft[DRAFT_STATE];
    {
      if (!state || !state.isManual_) die(9);
      if (state.finalized_) die(10);
    }
    var scope = state.scope_;
    usePatchesInScope(scope, patchListener);
    return processResult(undefined, scope);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */;

  _proto.setAutoFreeze = function setAutoFreeze(value) {
    this.autoFreeze_ = value;
  }
  /**
   * Pass true to use the ES2015 `Proxy` class when creating drafts, which is
   * always faster than using ES5 proxies.
   *
   * By default, feature detection is used, so calling this is rarely necessary.
   */;

  _proto.setUseProxies = function setUseProxies(value) {
    if (value && !hasProxies) {
      die(20);
    }
    this.useProxies_ = value;
  };
  _proto.applyPatches = function applyPatches(base, patches) {
    // If a patch replaces the entire state, take that replacement as base
    // before applying patches
    var i;
    for (i = patches.length - 1; i >= 0; i--) {
      var patch = patches[i];
      if (patch.path.length === 0 && patch.op === "replace") {
        base = patch.value;
        break;
      }
    } // If there was a patch that replaced the entire state, start from the
    // patch after that.

    if (i > -1) {
      patches = patches.slice(i + 1);
    }
    var applyPatchesImpl = getPlugin("Patches").applyPatches_;
    if (isDraft(base)) {
      // N.B: never hits if some patch a replacement, patches are never drafts
      return applyPatchesImpl(base, patches);
    } // Otherwise, produce a copy of the base state.

    return this.produce(base, function (draft) {
      return applyPatchesImpl(draft, patches);
    });
  };
  return Immer;
}();
function createProxy(immer, value, parent) {
  // precondition: createProxy should be guarded by isDraftable, so we know we can safely draft
  var draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : immer.useProxies_ ? createProxyProxy(value, parent) : getPlugin("ES5").createES5Proxy_(value, parent);
  var scope = parent ? parent.scope_ : getCurrentScope();
  scope.drafts_.push(draft);
  return draft;
}
function current(value) {
  if (!isDraft(value)) die(22, value);
  return currentImpl(value);
}
function currentImpl(value) {
  if (!isDraftable(value)) return value;
  var state = value[DRAFT_STATE];
  var copy;
  var archType = getArchtype(value);
  if (state) {
    if (!state.modified_ && (state.type_ < 4 || !getPlugin("ES5").hasChanges_(state))) return state.base_; // Optimization: avoid generating new drafts during copying

    state.finalized_ = true;
    copy = copyHelper(value, archType);
    state.finalized_ = false;
  } else {
    copy = copyHelper(value, archType);
  }
  each(copy, function (key, childValue) {
    if (state && get(state.base_, key) === childValue) return; // no need to copy or search in something that didn't change

    set(copy, key, currentImpl(childValue));
  }); // In the future, we might consider freezing here, based on the current settings

  return archType === 3
  /* Set */ ? new Set(copy) : copy;
}
function copyHelper(value, archType) {
  // creates a shallow copy, even if it is a map or set
  switch (archType) {
    case 2
    /* Map */:
      return new Map(value);
    case 3
    /* Set */:
      // Set will be cloned as array temporarily, so that we can replace individual items
      return Array.from(value);
  }
  return shallowCopy(value);
}
function enableES5() {
  function willFinalizeES5_(scope, result, isReplaced) {
    if (!isReplaced) {
      if (scope.patches_) {
        markChangesRecursively(scope.drafts_[0]);
      } // This is faster when we don't care about which attributes changed.

      markChangesSweep(scope.drafts_);
    } // When a child draft is returned, look for changes.
    else if (isDraft(result) && result[DRAFT_STATE].scope_ === scope) {
      markChangesSweep(scope.drafts_);
    }
  }
  function createES5Draft(isArray, base) {
    if (isArray) {
      var draft = new Array(base.length);
      for (var i = 0; i < base.length; i++) {
        Object.defineProperty(draft, "" + i, proxyProperty(i, true));
      }
      return draft;
    } else {
      var _descriptors = getOwnPropertyDescriptors(base);
      delete _descriptors[DRAFT_STATE];
      var keys = ownKeys(_descriptors);
      for (var _i = 0; _i < keys.length; _i++) {
        var key = keys[_i];
        _descriptors[key] = proxyProperty(key, isArray || !!_descriptors[key].enumerable);
      }
      return Object.create(Object.getPrototypeOf(base), _descriptors);
    }
  }
  function createES5Proxy_(base, parent) {
    var isArray = Array.isArray(base);
    var draft = createES5Draft(isArray, base);
    var state = {
      type_: isArray ? 5
      /* ES5Array */ : 4
      /* ES5Object */,

      scope_: parent ? parent.scope_ : getCurrentScope(),
      modified_: false,
      finalized_: false,
      assigned_: {},
      parent_: parent,
      // base is the object we are drafting
      base_: base,
      // draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)
      draft_: draft,
      copy_: null,
      revoked_: false,
      isManual_: false
    };
    Object.defineProperty(draft, DRAFT_STATE, {
      value: state,
      // enumerable: false <- the default
      writable: true
    });
    return draft;
  } // property descriptors are recycled to make sure we don't create a get and set closure per property,
  // but share them all instead

  var descriptors = {};
  function proxyProperty(prop, enumerable) {
    var desc = descriptors[prop];
    if (desc) {
      desc.enumerable = enumerable;
    } else {
      descriptors[prop] = desc = {
        configurable: true,
        enumerable: enumerable,
        get: function get() {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state); // @ts-ignore

          return objectTraps.get(state, prop);
        },
        set: function set(value) {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state); // @ts-ignore

          objectTraps.set(state, prop, value);
        }
      };
    }
    return desc;
  } // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.

  function markChangesSweep(drafts) {
    // The natural order of drafts in the `scope` array is based on when they
    // were accessed. By processing drafts in reverse natural order, we have a
    // better chance of processing leaf nodes first. When a leaf node is known to
    // have changed, we can avoid any traversal of its ancestor nodes.
    for (var i = drafts.length - 1; i >= 0; i--) {
      var state = drafts[i][DRAFT_STATE];
      if (!state.modified_) {
        switch (state.type_) {
          case 5
          /* ES5Array */:
            if (hasArrayChanges(state)) markChanged(state);
            break;
          case 4
          /* ES5Object */:
            if (hasObjectChanges(state)) markChanged(state);
            break;
        }
      }
    }
  }
  function markChangesRecursively(object) {
    if (!object || typeof object !== "object") return;
    var state = object[DRAFT_STATE];
    if (!state) return;
    var base_ = state.base_,
      draft_ = state.draft_,
      assigned_ = state.assigned_,
      type_ = state.type_;
    if (type_ === 4
    /* ES5Object */) {
      // Look for added keys.
      // probably there is a faster way to detect changes, as sweep + recurse seems to do some
      // unnecessary work.
      // also: probably we can store the information we detect here, to speed up tree finalization!
      each(draft_, function (key) {
        if (key === DRAFT_STATE) return; // The `undefined` check is a fast path for pre-existing keys.

        if (base_[key] === undefined && !has(base_, key)) {
          assigned_[key] = true;
          markChanged(state);
        } else if (!assigned_[key]) {
          // Only untouched properties trigger recursion.
          markChangesRecursively(draft_[key]);
        }
      }); // Look for removed keys.

      each(base_, function (key) {
        // The `undefined` check is a fast path for pre-existing keys.
        if (draft_[key] === undefined && !has(draft_, key)) {
          assigned_[key] = false;
          markChanged(state);
        }
      });
    } else if (type_ === 5
    /* ES5Array */) {
      if (hasArrayChanges(state)) {
        markChanged(state);
        assigned_.length = true;
      }
      if (draft_.length < base_.length) {
        for (var i = draft_.length; i < base_.length; i++) {
          assigned_[i] = false;
        }
      } else {
        for (var _i2 = base_.length; _i2 < draft_.length; _i2++) {
          assigned_[_i2] = true;
        }
      } // Minimum count is enough, the other parts has been processed.

      var min = Math.min(draft_.length, base_.length);
      for (var _i3 = 0; _i3 < min; _i3++) {
        // Only untouched indices trigger recursion.
        if (!draft_.hasOwnProperty(_i3)) {
          assigned_[_i3] = true;
        }
        if (assigned_[_i3] === undefined) markChangesRecursively(draft_[_i3]);
      }
    }
  }
  function hasObjectChanges(state) {
    var base_ = state.base_,
      draft_ = state.draft_; // Search for added keys and changed keys. Start at the back, because
    // non-numeric keys are ordered by time of definition on the object.

    var keys = ownKeys(draft_);
    for (var i = keys.length - 1; i >= 0; i--) {
      var key = keys[i];
      if (key === DRAFT_STATE) continue;
      var baseValue = base_[key]; // The `undefined` check is a fast path for pre-existing keys.

      if (baseValue === undefined && !has(base_, key)) {
        return true;
      } // Once a base key is deleted, future changes go undetected, because its
      // descriptor is erased. This branch detects any missed changes.
      else {
        var value = draft_[key];
        var _state = value && value[DRAFT_STATE];
        if (_state ? _state.base_ !== baseValue : !is(value, baseValue)) {
          return true;
        }
      }
    } // At this point, no keys were added or changed.
    // Compare key count to determine if keys were deleted.

    var baseIsDraft = !!base_[DRAFT_STATE];
    return keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1); // + 1 to correct for DRAFT_STATE
  }

  function hasArrayChanges(state) {
    var draft_ = state.draft_;
    if (draft_.length !== state.base_.length) return true; // See #116
    // If we first shorten the length, our array interceptors will be removed.
    // If after that new items are added, result in the same original length,
    // those last items will have no intercepting property.
    // So if there is no own descriptor on the last position, we know that items were removed and added
    // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check
    // the last one
    // last descriptor can be not a trap, if the array was extended

    var descriptor = Object.getOwnPropertyDescriptor(draft_, draft_.length - 1); // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)

    if (descriptor && !descriptor.get) return true; // if we miss a property, it has been deleted, so array probobaly changed

    for (var i = 0; i < draft_.length; i++) {
      if (!draft_.hasOwnProperty(i)) return true;
    } // For all other cases, we don't have to compare, as they would have been picked up by the index setters

    return false;
  }
  function hasChanges_(state) {
    return state.type_ === 4
    /* ES5Object */ ? hasObjectChanges(state) : hasArrayChanges(state);
  }
  function assertUnrevoked(state
  /*ES5State | MapState | SetState*/) {
    if (state.revoked_) die(3, JSON.stringify(latest(state)));
  }
  loadPlugin("ES5", {
    createES5Proxy_: createES5Proxy_,
    willFinalizeES5_: willFinalizeES5_,
    hasChanges_: hasChanges_
  });
}
function enablePatches() {
  var REPLACE = "replace";
  var ADD = "add";
  var REMOVE = "remove";
  function generatePatches_(state, basePath, patches, inversePatches) {
    switch (state.type_) {
      case 0
      /* ProxyObject */:

      case 4
      /* ES5Object */:

      case 2
      /* Map */:
        return generatePatchesFromAssigned(state, basePath, patches, inversePatches);
      case 5
      /* ES5Array */:

      case 1
      /* ProxyArray */:
        return generateArrayPatches(state, basePath, patches, inversePatches);
      case 3
      /* Set */:
        return generateSetPatches(state, basePath, patches, inversePatches);
    }
  }
  function generateArrayPatches(state, basePath, patches, inversePatches) {
    var base_ = state.base_,
      assigned_ = state.assigned_;
    var copy_ = state.copy_; // Reduce complexity by ensuring `base` is never longer.

    if (copy_.length < base_.length) {
      var _ref = [copy_, base_];
      base_ = _ref[0];
      copy_ = _ref[1];
      var _ref2 = [inversePatches, patches];
      patches = _ref2[0];
      inversePatches = _ref2[1];
    } // Process replaced indices.

    for (var i = 0; i < base_.length; i++) {
      if (assigned_[i] && copy_[i] !== base_[i]) {
        var path = basePath.concat([i]);
        patches.push({
          op: REPLACE,
          path: path,
          // Need to maybe clone it, as it can in fact be the original value
          // due to the base/copy inversion at the start of this function
          value: clonePatchValueIfNeeded(copy_[i])
        });
        inversePatches.push({
          op: REPLACE,
          path: path,
          value: clonePatchValueIfNeeded(base_[i])
        });
      }
    } // Process added indices.

    for (var _i = base_.length; _i < copy_.length; _i++) {
      var _path = basePath.concat([_i]);
      patches.push({
        op: ADD,
        path: _path,
        // Need to maybe clone it, as it can in fact be the original value
        // due to the base/copy inversion at the start of this function
        value: clonePatchValueIfNeeded(copy_[_i])
      });
    }
    if (base_.length < copy_.length) {
      inversePatches.push({
        op: REPLACE,
        path: basePath.concat(["length"]),
        value: base_.length
      });
    }
  } // This is used for both Map objects and normal objects.

  function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {
    var base_ = state.base_,
      copy_ = state.copy_;
    each(state.assigned_, function (key, assignedValue) {
      var origValue = get(base_, key);
      var value = get(copy_, key);
      var op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;
      if (origValue === value && op === REPLACE) return;
      var path = basePath.concat(key);
      patches.push(op === REMOVE ? {
        op: op,
        path: path
      } : {
        op: op,
        path: path,
        value: value
      });
      inversePatches.push(op === ADD ? {
        op: REMOVE,
        path: path
      } : op === REMOVE ? {
        op: ADD,
        path: path,
        value: clonePatchValueIfNeeded(origValue)
      } : {
        op: REPLACE,
        path: path,
        value: clonePatchValueIfNeeded(origValue)
      });
    });
  }
  function generateSetPatches(state, basePath, patches, inversePatches) {
    var base_ = state.base_,
      copy_ = state.copy_;
    var i = 0;
    base_.forEach(function (value) {
      if (!copy_.has(value)) {
        var path = basePath.concat([i]);
        patches.push({
          op: REMOVE,
          path: path,
          value: value
        });
        inversePatches.unshift({
          op: ADD,
          path: path,
          value: value
        });
      }
      i++;
    });
    i = 0;
    copy_.forEach(function (value) {
      if (!base_.has(value)) {
        var path = basePath.concat([i]);
        patches.push({
          op: ADD,
          path: path,
          value: value
        });
        inversePatches.unshift({
          op: REMOVE,
          path: path,
          value: value
        });
      }
      i++;
    });
  }
  function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {
    patches.push({
      op: REPLACE,
      path: [],
      value: replacement === NOTHING ? undefined : replacement
    });
    inversePatches.push({
      op: REPLACE,
      path: [],
      value: baseValue
    });
  }
  function applyPatches_(draft, patches) {
    patches.forEach(function (patch) {
      var path = patch.path,
        op = patch.op;
      var base = draft;
      for (var i = 0; i < path.length - 1; i++) {
        var parentType = getArchtype(base);
        var p = "" + path[i]; // See #738, avoid prototype pollution

        if ((parentType === 0
        /* Object */ || parentType === 1
        /* Array */) && (p === "__proto__" || p === "constructor")) die(24);
        if (typeof base === "function" && p === "prototype") die(24);
        base = get(base, p);
        if (typeof base !== "object") die(15, path.join("/"));
      }
      var type = getArchtype(base);
      var value = deepClonePatchValue(patch.value); // used to clone patch to ensure original patch is not modified, see #411

      var key = path[path.length - 1];
      switch (op) {
        case REPLACE:
          switch (type) {
            case 2
            /* Map */:
              return base.set(key, value);

            /* istanbul ignore next */

            case 3
            /* Set */:
              die(16);
            default:
              // if value is an object, then it's assigned by reference
              // in the following add or remove ops, the value field inside the patch will also be modifyed
              // so we use value from the cloned patch
              // @ts-ignore
              return base[key] = value;
          }
        case ADD:
          switch (type) {
            case 1
            /* Array */:
              return key === "-" ? base.push(value) : base.splice(key, 0, value);
            case 2
            /* Map */:
              return base.set(key, value);
            case 3
            /* Set */:
              return base.add(value);
            default:
              return base[key] = value;
          }
        case REMOVE:
          switch (type) {
            case 1
            /* Array */:
              return base.splice(key, 1);
            case 2
            /* Map */:
              return base.delete(key);
            case 3
            /* Set */:
              return base.delete(patch.value);
            default:
              return delete base[key];
          }
        default:
          die(17, op);
      }
    });
    return draft;
  }
  function deepClonePatchValue(obj) {
    if (!isDraftable(obj)) return obj;
    if (Array.isArray(obj)) return obj.map(deepClonePatchValue);
    if (isMap(obj)) return new Map(Array.from(obj.entries()).map(function (_ref3) {
      var k = _ref3[0],
        v = _ref3[1];
      return [k, deepClonePatchValue(v)];
    }));
    if (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue));
    var cloned = Object.create(Object.getPrototypeOf(obj));
    for (var key in obj) {
      cloned[key] = deepClonePatchValue(obj[key]);
    }
    if (has(obj, DRAFTABLE)) cloned[DRAFTABLE] = obj[DRAFTABLE];
    return cloned;
  }
  function clonePatchValueIfNeeded(obj) {
    if (isDraft(obj)) {
      return deepClonePatchValue(obj);
    } else return obj;
  }
  loadPlugin("Patches", {
    applyPatches_: applyPatches_,
    generatePatches_: generatePatches_,
    generateReplacementPatches_: generateReplacementPatches_
  });
}

// types only!
function enableMapSet() {
  /* istanbul ignore next */
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };
    return _extendStatics(d, b);
  }; // Ugly hack to resolve #502 and inherit built in Map / Set

  function __extends(d, b) {
    _extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = (
    // @ts-ignore
    __.prototype = b.prototype, new __());
  }
  var DraftMap = function (_super) {
    __extends(DraftMap, _super); // Create class manually, cause #502

    function DraftMap(target, parent) {
      this[DRAFT_STATE] = {
        type_: 2
        /* Map */,

        parent_: parent,
        scope_: parent ? parent.scope_ : getCurrentScope(),
        modified_: false,
        finalized_: false,
        copy_: undefined,
        assigned_: undefined,
        base_: target,
        draft_: this,
        isManual_: false,
        revoked_: false
      };
      return this;
    }
    var p = DraftMap.prototype;
    Object.defineProperty(p, "size", {
      get: function get() {
        return latest(this[DRAFT_STATE]).size;
      } // enumerable: false,
      // configurable: true
    });

    p.has = function (key) {
      return latest(this[DRAFT_STATE]).has(key);
    };
    p.set = function (key, value) {
      var state = this[DRAFT_STATE];
      assertUnrevoked(state);
      if (!latest(state).has(key) || latest(state).get(key) !== value) {
        prepareMapCopy(state);
        markChanged(state);
        state.assigned_.set(key, true);
        state.copy_.set(key, value);
        state.assigned_.set(key, true);
      }
      return this;
    };
    p.delete = function (key) {
      if (!this.has(key)) {
        return false;
      }
      var state = this[DRAFT_STATE];
      assertUnrevoked(state);
      prepareMapCopy(state);
      markChanged(state);
      if (state.base_.has(key)) {
        state.assigned_.set(key, false);
      } else {
        state.assigned_.delete(key);
      }
      state.copy_.delete(key);
      return true;
    };
    p.clear = function () {
      var state = this[DRAFT_STATE];
      assertUnrevoked(state);
      if (latest(state).size) {
        prepareMapCopy(state);
        markChanged(state);
        state.assigned_ = new Map();
        each(state.base_, function (key) {
          state.assigned_.set(key, false);
        });
        state.copy_.clear();
      }
    };
    p.forEach = function (cb, thisArg) {
      var _this = this;
      var state = this[DRAFT_STATE];
      latest(state).forEach(function (_value, key, _map) {
        cb.call(thisArg, _this.get(key), key, _this);
      });
    };
    p.get = function (key) {
      var state = this[DRAFT_STATE];
      assertUnrevoked(state);
      var value = latest(state).get(key);
      if (state.finalized_ || !isDraftable(value)) {
        return value;
      }
      if (value !== state.base_.get(key)) {
        return value; // either already drafted or reassigned
      } // despite what it looks, this creates a draft only once, see above condition

      var draft = createProxy(state.scope_.immer_, value, state);
      prepareMapCopy(state);
      state.copy_.set(key, draft);
      return draft;
    };
    p.keys = function () {
      return latest(this[DRAFT_STATE]).keys();
    };
    p.values = function () {
      var _this2 = this,
        _ref;
      var iterator = this.keys();
      return _ref = {}, _ref[iteratorSymbol] = function () {
        return _this2.values();
      }, _ref.next = function next() {
        var r = iterator.next();
        /* istanbul ignore next */

        if (r.done) return r;
        var value = _this2.get(r.value);
        return {
          done: false,
          value: value
        };
      }, _ref;
    };
    p.entries = function () {
      var _this3 = this,
        _ref2;
      var iterator = this.keys();
      return _ref2 = {}, _ref2[iteratorSymbol] = function () {
        return _this3.entries();
      }, _ref2.next = function next() {
        var r = iterator.next();
        /* istanbul ignore next */

        if (r.done) return r;
        var value = _this3.get(r.value);
        return {
          done: false,
          value: [r.value, value]
        };
      }, _ref2;
    };
    p[iteratorSymbol] = function () {
      return this.entries();
    };
    return DraftMap;
  }(Map);
  function proxyMap_(target, parent) {
    // @ts-ignore
    return new DraftMap(target, parent);
  }
  function prepareMapCopy(state) {
    if (!state.copy_) {
      state.assigned_ = new Map();
      state.copy_ = new Map(state.base_);
    }
  }
  var DraftSet = function (_super) {
    __extends(DraftSet, _super); // Create class manually, cause #502

    function DraftSet(target, parent) {
      this[DRAFT_STATE] = {
        type_: 3
        /* Set */,

        parent_: parent,
        scope_: parent ? parent.scope_ : getCurrentScope(),
        modified_: false,
        finalized_: false,
        copy_: undefined,
        base_: target,
        draft_: this,
        drafts_: new Map(),
        revoked_: false,
        isManual_: false
      };
      return this;
    }
    var p = DraftSet.prototype;
    Object.defineProperty(p, "size", {
      get: function get() {
        return latest(this[DRAFT_STATE]).size;
      } // enumerable: true,
    });

    p.has = function (value) {
      var state = this[DRAFT_STATE];
      assertUnrevoked(state); // bit of trickery here, to be able to recognize both the value, and the draft of its value

      if (!state.copy_) {
        return state.base_.has(value);
      }
      if (state.copy_.has(value)) return true;
      if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value))) return true;
      return false;
    };
    p.add = function (value) {
      var state = this[DRAFT_STATE];
      assertUnrevoked(state);
      if (!this.has(value)) {
        prepareSetCopy(state);
        markChanged(state);
        state.copy_.add(value);
      }
      return this;
    };
    p.delete = function (value) {
      if (!this.has(value)) {
        return false;
      }
      var state = this[DRAFT_STATE];
      assertUnrevoked(state);
      prepareSetCopy(state);
      markChanged(state);
      return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) : /* istanbul ignore next */
      false);
    };
    p.clear = function () {
      var state = this[DRAFT_STATE];
      assertUnrevoked(state);
      if (latest(state).size) {
        prepareSetCopy(state);
        markChanged(state);
        state.copy_.clear();
      }
    };
    p.values = function () {
      var state = this[DRAFT_STATE];
      assertUnrevoked(state);
      prepareSetCopy(state);
      return state.copy_.values();
    };
    p.entries = function entries() {
      var state = this[DRAFT_STATE];
      assertUnrevoked(state);
      prepareSetCopy(state);
      return state.copy_.entries();
    };
    p.keys = function () {
      return this.values();
    };
    p[iteratorSymbol] = function () {
      return this.values();
    };
    p.forEach = function forEach(cb, thisArg) {
      var iterator = this.values();
      var result = iterator.next();
      while (!result.done) {
        cb.call(thisArg, result.value, result.value, this);
        result = iterator.next();
      }
    };
    return DraftSet;
  }(Set);
  function proxySet_(target, parent) {
    // @ts-ignore
    return new DraftSet(target, parent);
  }
  function prepareSetCopy(state) {
    if (!state.copy_) {
      // create drafts for all entries to preserve insertion order
      state.copy_ = new Set();
      state.base_.forEach(function (value) {
        if (isDraftable(value)) {
          var draft = createProxy(state.scope_.immer_, value, state);
          state.drafts_.set(value, draft);
          state.copy_.add(draft);
        } else {
          state.copy_.add(value);
        }
      });
    }
  }
  function assertUnrevoked(state
  /*ES5State | MapState | SetState*/) {
    if (state.revoked_) die(3, JSON.stringify(latest(state)));
  }
  loadPlugin("MapSet", {
    proxyMap_: proxyMap_,
    proxySet_: proxySet_
  });
}
function enableAllPlugins() {
  enableES5();
  enableMapSet();
  enablePatches();
}
var immer = /*#__PURE__*/
new Immer();
/**
 * The `produce` function takes a value and a "recipe function" (whose
 * return value often depends on the base state). The recipe function is
 * free to mutate its first argument however it wants. All mutations are
 * only ever applied to a __copy__ of the base state.
 *
 * Pass only a function to create a "curried producer" which relieves you
 * from passing the recipe function every time.
 *
 * Only plain objects and arrays are made mutable. All other objects are
 * considered uncopyable.
 *
 * Note: This function is __bound__ to its `Immer` instance.
 *
 * @param {any} base - the initial state
 * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
 * @param {Function} patchListener - optional function that will be called with all the patches produced here
 * @returns {any} a new state, or the initial state if nothing was modified
 */

var produce = immer.produce;
/**
 * Like `produce`, but `produceWithPatches` always returns a tuple
 * [nextState, patches, inversePatches] (instead of just the next state)
 */

var produceWithPatches = /*#__PURE__*/
immer.produceWithPatches.bind(immer);
/**
 * Pass true to automatically freeze all copies created by Immer.
 *
 * Always freeze by default, even in production mode
 */

var setAutoFreeze = /*#__PURE__*/
immer.setAutoFreeze.bind(immer);
/**
 * Pass true to use the ES2015 `Proxy` class when creating drafts, which is
 * always faster than using ES5 proxies.
 *
 * By default, feature detection is used, so calling this is rarely necessary.
 */

var setUseProxies = /*#__PURE__*/
immer.setUseProxies.bind(immer);
/**
 * Apply an array of Immer patches to the first argument.
 *
 * This function is a producer, which means copy-on-write is in effect.
 */

var applyPatches = /*#__PURE__*/
immer.applyPatches.bind(immer);
/**
 * Create an Immer draft from the given base state, which may be a draft itself.
 * The draft can be modified until you finalize it with the `finishDraft` function.
 */

var createDraft = /*#__PURE__*/
immer.createDraft.bind(immer);
/**
 * Finalize an Immer draft from a `createDraft` call, returning the base state
 * (if no changes were made) or a modified copy. The draft must *not* be
 * mutated afterwards.
 *
 * Pass a function as the 2nd argument to generate Immer patches based on the
 * changes that were made.
 */

var finishDraft = /*#__PURE__*/
immer.finishDraft.bind(immer);
/**
 * This function is actually a no-op, but can be used to cast an immutable type
 * to an draft type and make TypeScript happy
 *
 * @param value
 */

function castDraft(value) {
  return value;
}
/**
 * This function is actually a no-op, but can be used to cast a mutable type
 * to an immutable type and make TypeScript happy
 * @param value
 */

function castImmutable(value) {
  return value;
}
exports.Immer = Immer;
exports.applyPatches = applyPatches;
exports.castDraft = castDraft;
exports.castImmutable = castImmutable;
exports.createDraft = createDraft;
exports.current = current;
exports.default = produce;
exports.enableAllPlugins = enableAllPlugins;
exports.enableES5 = enableES5;
exports.enableMapSet = enableMapSet;
exports.enablePatches = enablePatches;
exports.finishDraft = finishDraft;
exports.freeze = freeze;
exports.immerable = DRAFTABLE;
exports.isDraft = isDraft;
exports.isDraftable = isDraftable;
exports.nothing = NOTHING;
exports.original = original;
exports.produce = produce;
exports.produceWithPatches = produceWithPatches;
exports.setAutoFreeze = setAutoFreeze;
exports.setUseProxies = setUseProxies;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJoYXNTeW1ib2wiLCJTeW1ib2wiLCJoYXNNYXAiLCJNYXAiLCJoYXNTZXQiLCJTZXQiLCJoYXNQcm94aWVzIiwiUHJveHkiLCJyZXZvY2FibGUiLCJSZWZsZWN0IiwiTk9USElORyIsImZvciIsIl9yZWYiLCJEUkFGVEFCTEUiLCJEUkFGVF9TVEFURSIsIml0ZXJhdG9yU3ltYm9sIiwiaXRlcmF0b3IiLCJlcnJvcnMiLCJfIiwiZGF0YSIsInBhdGgiLCJvcCIsInBsdWdpbiIsInRoaW5nIiwiZGllIiwiZXJyb3IiLCJhcmdzIiwiQXJyYXkiLCJfbGVuIiwiX2tleSIsImFyZ3VtZW50cyIsImUiLCJtc2ciLCJhcHBseSIsIkVycm9yIiwiaXNEcmFmdCIsInZhbHVlIiwiaXNEcmFmdGFibGUiLCJpc1BsYWluT2JqZWN0IiwiaXNBcnJheSIsIl92YWx1ZSRjb25zdHJ1Y3RvciIsImNvbnN0cnVjdG9yIiwiaXNNYXAiLCJpc1NldCIsIm9iamVjdEN0b3JTdHJpbmciLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsInByb3RvIiwiZ2V0UHJvdG90eXBlT2YiLCJDdG9yIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiRnVuY3Rpb24iLCJvcmlnaW5hbCIsImJhc2VfIiwib3duS2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsIm9iaiIsImdldE93blByb3BlcnR5TmFtZXMiLCJjb25jYXQiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwidGFyZ2V0IiwicmVzIiwiZm9yRWFjaCIsImtleSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVhY2giLCJpdGVyIiwiZW51bWVyYWJsZU9ubHkiLCJnZXRBcmNodHlwZSIsImtleXMiLCJlbnRyeSIsImluZGV4Iiwic3RhdGUiLCJ0eXBlXyIsImhhcyIsInByb3AiLCJnZXQiLCJzZXQiLCJwcm9wT3JPbGRWYWx1ZSIsInQiLCJhZGQiLCJpcyIsIngiLCJ5IiwibGF0ZXN0IiwiY29weV8iLCJzaGFsbG93Q29weSIsImJhc2UiLCJzbGljZSIsImRlc2NyaXB0b3JzIiwiaSIsImxlbmd0aCIsImRlc2MiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJjcmVhdGUiLCJmcmVlemUiLCJkZWVwIiwiaXNGcm96ZW4iLCJjbGVhciIsImRlbGV0ZSIsImRvbnRNdXRhdGVGcm96ZW5Db2xsZWN0aW9ucyIsInBsdWdpbnMiLCJnZXRQbHVnaW4iLCJwbHVnaW5LZXkiLCJsb2FkUGx1Z2luIiwiaW1wbGVtZW50YXRpb24iLCJjdXJyZW50U2NvcGUiLCJnZXRDdXJyZW50U2NvcGUiLCJjcmVhdGVTY29wZSIsInBhcmVudF8iLCJpbW1lcl8iLCJkcmFmdHNfIiwiY2FuQXV0b0ZyZWV6ZV8iLCJ1bmZpbmFsaXplZERyYWZ0c18iLCJ1c2VQYXRjaGVzSW5TY29wZSIsInNjb3BlIiwicGF0Y2hMaXN0ZW5lciIsInBhdGNoZXNfIiwiaW52ZXJzZVBhdGNoZXNfIiwicGF0Y2hMaXN0ZW5lcl8iLCJyZXZva2VTY29wZSIsImxlYXZlU2NvcGUiLCJyZXZva2VEcmFmdCIsImVudGVyU2NvcGUiLCJpbW1lciIsImRyYWZ0IiwicmV2b2tlXyIsInJldm9rZWRfIiwicHJvY2Vzc1Jlc3VsdCIsInJlc3VsdCIsImJhc2VEcmFmdCIsImlzUmVwbGFjZWQiLCJ1bmRlZmluZWQiLCJ1c2VQcm94aWVzXyIsIndpbGxGaW5hbGl6ZUVTNV8iLCJtb2RpZmllZF8iLCJmaW5hbGl6ZSIsIm1heWJlRnJlZXplIiwiZ2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfIiwicm9vdFNjb3BlIiwiY2hpbGRWYWx1ZSIsImZpbmFsaXplUHJvcGVydHkiLCJzY29wZV8iLCJmaW5hbGl6ZWRfIiwiZHJhZnRfIiwicmVzdWx0RWFjaCIsImdlbmVyYXRlUGF0Y2hlc18iLCJwYXJlbnRTdGF0ZSIsInRhcmdldE9iamVjdCIsInJvb3RQYXRoIiwidGFyZ2V0SXNTZXQiLCJhc3NpZ25lZF8iLCJhdXRvRnJlZXplXyIsImNyZWF0ZVByb3h5UHJveHkiLCJwYXJlbnQiLCJpc01hbnVhbF8iLCJ0cmFwcyIsIm9iamVjdFRyYXBzIiwiYXJyYXlUcmFwcyIsInJldm9rZSIsIl9Qcm94eSRyZXZvY2FibGUiLCJwcm94eSIsInNvdXJjZSIsInJlYWRQcm9wRnJvbVByb3RvIiwicGVlayIsInByZXBhcmVDb3B5IiwiY3JlYXRlUHJveHkiLCJnZXREZXNjcmlwdG9yRnJvbVByb3RvIiwiY3VycmVudCIsImN1cnJlbnRTdGF0ZSIsIm1hcmtDaGFuZ2VkIiwiTnVtYmVyIiwiaXNOYU4iLCJkZWxldGVQcm9wZXJ0eSIsIm93bmVyIiwiZGVmaW5lUHJvcGVydHkiLCJzZXRQcm90b3R5cGVPZiIsImZuIiwicGFyc2VJbnQiLCJfZGVzYyRnZXQiLCJJbW1lciIsImNvbmZpZyIsInByb2R1Y2UiLCJyZWNpcGUiLCJkZWZhdWx0QmFzZSIsInNlbGYiLCJfdGhpcyIsImN1cnJpZWRQcm9kdWNlIiwiX3JlY2lwZSIsIl90aGlzMiIsImhhc0Vycm9yIiwiUHJvbWlzZSIsInRoZW4iLCJwIiwiaXAiLCJwcm9kdWNlV2l0aFBhdGNoZXMiLCJfbGVuMiIsIl9rZXkyIiwicGF0Y2hlcyIsImludmVyc2VQYXRjaGVzIiwibmV4dFN0YXRlIiwidXNlUHJveGllcyIsInNldFVzZVByb3hpZXMiLCJhdXRvRnJlZXplIiwic2V0QXV0b0ZyZWV6ZSIsIl9wcm90byIsImNyZWF0ZURyYWZ0IiwiZmluaXNoRHJhZnQiLCJhcHBseVBhdGNoZXMiLCJwYXRjaCIsImFwcGx5UGF0Y2hlc0ltcGwiLCJhcHBseVBhdGNoZXNfIiwicHJveHlNYXBfIiwicHJveHlTZXRfIiwiY3JlYXRlRVM1UHJveHlfIiwicHVzaCIsImN1cnJlbnRJbXBsIiwiY29weSIsImFyY2hUeXBlIiwiaGFzQ2hhbmdlc18iLCJjb3B5SGVscGVyIiwiZnJvbSIsImVuYWJsZUVTNSIsIm1hcmtDaGFuZ2VzUmVjdXJzaXZlbHkiLCJtYXJrQ2hhbmdlc1N3ZWVwIiwiY3JlYXRlRVM1RHJhZnQiLCJwcm94eVByb3BlcnR5IiwiX2Rlc2NyaXB0b3JzIiwiX2kiLCJhc3NlcnRVbnJldm9rZWQiLCJkcmFmdHMiLCJoYXNBcnJheUNoYW5nZXMiLCJoYXNPYmplY3RDaGFuZ2VzIiwib2JqZWN0IiwiX2kyIiwibWluIiwiTWF0aCIsIl9pMyIsImJhc2VWYWx1ZSIsIl9zdGF0ZSIsImJhc2VJc0RyYWZ0IiwiZGVzY3JpcHRvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJlbmFibGVQYXRjaGVzIiwiUkVQTEFDRSIsIkFERCIsIlJFTU9WRSIsImJhc2VQYXRoIiwiZ2VuZXJhdGVQYXRjaGVzRnJvbUFzc2lnbmVkIiwiZ2VuZXJhdGVBcnJheVBhdGNoZXMiLCJnZW5lcmF0ZVNldFBhdGNoZXMiLCJfcmVmMiIsImNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkIiwiX3BhdGgiLCJhc3NpZ25lZFZhbHVlIiwib3JpZ1ZhbHVlIiwidW5zaGlmdCIsInJlcGxhY2VtZW50IiwicGFyZW50VHlwZSIsImpvaW4iLCJ0eXBlIiwiZGVlcENsb25lUGF0Y2hWYWx1ZSIsInNwbGljZSIsIm1hcCIsImVudHJpZXMiLCJfcmVmMyIsImsiLCJ2IiwiY2xvbmVkIiwiZW5hYmxlTWFwU2V0IiwiX2V4dGVuZFN0YXRpY3MiLCJleHRlbmRTdGF0aWNzIiwiZCIsImIiLCJfX3Byb3RvX18iLCJfX2V4dGVuZHMiLCJfXyIsIkRyYWZ0TWFwIiwiX3N1cGVyIiwic2l6ZSIsInByZXBhcmVNYXBDb3B5IiwiY2IiLCJ0aGlzQXJnIiwiX3ZhbHVlIiwiX21hcCIsInZhbHVlcyIsIm5leHQiLCJyIiwiZG9uZSIsIl90aGlzMyIsIkRyYWZ0U2V0IiwicHJlcGFyZVNldENvcHkiLCJlbmFibGVBbGxQbHVnaW5zIiwiYmluZCIsImNhc3REcmFmdCIsImNhc3RJbW11dGFibGUiXSwic291cmNlcyI6WyIuLi9zcmMvdXRpbHMvZW52LnRzIiwiLi4vc3JjL3V0aWxzL2Vycm9ycy50cyIsIi4uL3NyYy91dGlscy9jb21tb24udHMiLCIuLi9zcmMvdXRpbHMvcGx1Z2lucy50cyIsIi4uL3NyYy9jb3JlL3Njb3BlLnRzIiwiLi4vc3JjL2NvcmUvZmluYWxpemUudHMiLCIuLi9zcmMvY29yZS9wcm94eS50cyIsIi4uL3NyYy9jb3JlL2ltbWVyQ2xhc3MudHMiLCIuLi9zcmMvY29yZS9jdXJyZW50LnRzIiwiLi4vc3JjL3BsdWdpbnMvZXM1LnRzIiwiLi4vc3JjL3BsdWdpbnMvcGF0Y2hlcy50cyIsIi4uL3NyYy9wbHVnaW5zL21hcHNldC50cyIsIi4uL3NyYy9wbHVnaW5zL2FsbC50cyIsIi4uL3NyYy9pbW1lci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTaG91bGQgYmUgbm8gaW1wb3J0cyBoZXJlIVxuXG4vLyBTb21lIHRoaW5ncyB0aGF0IHNob3VsZCBiZSBldmFsdWF0ZWQgYmVmb3JlIGFsbCBlbHNlLi4uXG5cbi8vIFdlIG9ubHkgd2FudCB0byBrbm93IGlmIG5vbi1wb2x5ZmlsbGVkIHN5bWJvbHMgYXJlIGF2YWlsYWJsZVxuY29uc3QgaGFzU3ltYm9sID1cblx0dHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgU3ltYm9sKFwieFwiKSA9PT0gXCJzeW1ib2xcIlxuZXhwb3J0IGNvbnN0IGhhc01hcCA9IHR5cGVvZiBNYXAgIT09IFwidW5kZWZpbmVkXCJcbmV4cG9ydCBjb25zdCBoYXNTZXQgPSB0eXBlb2YgU2V0ICE9PSBcInVuZGVmaW5lZFwiXG5leHBvcnQgY29uc3QgaGFzUHJveGllcyA9XG5cdHR5cGVvZiBQcm94eSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHR0eXBlb2YgUHJveHkucmV2b2NhYmxlICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiXG5cbi8qKlxuICogVGhlIHNlbnRpbmVsIHZhbHVlIHJldHVybmVkIGJ5IHByb2R1Y2VycyB0byByZXBsYWNlIHRoZSBkcmFmdCB3aXRoIHVuZGVmaW5lZC5cbiAqL1xuZXhwb3J0IGNvbnN0IE5PVEhJTkc6IE5vdGhpbmcgPSBoYXNTeW1ib2xcblx0PyBTeW1ib2wuZm9yKFwiaW1tZXItbm90aGluZ1wiKVxuXHQ6ICh7W1wiaW1tZXItbm90aGluZ1wiXTogdHJ1ZX0gYXMgYW55KVxuXG4vKipcbiAqIFRvIGxldCBJbW1lciB0cmVhdCB5b3VyIGNsYXNzIGluc3RhbmNlcyBhcyBwbGFpbiBpbW11dGFibGUgb2JqZWN0c1xuICogKGFsYmVpdCB3aXRoIGEgY3VzdG9tIHByb3RvdHlwZSksIHlvdSBtdXN0IGRlZmluZSBlaXRoZXIgYW4gaW5zdGFuY2UgcHJvcGVydHlcbiAqIG9yIGEgc3RhdGljIHByb3BlcnR5IG9uIGVhY2ggb2YgeW91ciBjdXN0b20gY2xhc3Nlcy5cbiAqXG4gKiBPdGhlcndpc2UsIHlvdXIgY2xhc3MgaW5zdGFuY2Ugd2lsbCBuZXZlciBiZSBkcmFmdGVkLCB3aGljaCBtZWFucyBpdCB3b24ndCBiZVxuICogc2FmZSB0byBtdXRhdGUgaW4gYSBwcm9kdWNlIGNhbGxiYWNrLlxuICovXG5leHBvcnQgY29uc3QgRFJBRlRBQkxFOiB1bmlxdWUgc3ltYm9sID0gaGFzU3ltYm9sXG5cdD8gU3ltYm9sLmZvcihcImltbWVyLWRyYWZ0YWJsZVwiKVxuXHQ6IChcIl9fJGltbWVyX2RyYWZ0YWJsZVwiIGFzIGFueSlcblxuZXhwb3J0IGNvbnN0IERSQUZUX1NUQVRFOiB1bmlxdWUgc3ltYm9sID0gaGFzU3ltYm9sXG5cdD8gU3ltYm9sLmZvcihcImltbWVyLXN0YXRlXCIpXG5cdDogKFwiX18kaW1tZXJfc3RhdGVcIiBhcyBhbnkpXG5cbi8vIEV2ZW4gYSBwb2x5ZmlsbGVkIFN5bWJvbCBtaWdodCBwcm92aWRlIFN5bWJvbC5pdGVyYXRvclxuZXhwb3J0IGNvbnN0IGl0ZXJhdG9yU3ltYm9sOiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID1cblx0KHR5cGVvZiBTeW1ib2wgIT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IpIHx8IChcIkBAaXRlcmF0b3JcIiBhcyBhbnkpXG5cbi8qKiBVc2UgYSBjbGFzcyB0eXBlIGZvciBgbm90aGluZ2Agc28gaXRzIHR5cGUgaXMgdW5pcXVlICovXG5leHBvcnQgY2xhc3MgTm90aGluZyB7XG5cdC8vIFRoaXMgbGV0cyB1cyBkbyBgRXhjbHVkZTxULCBOb3RoaW5nPmBcblx0Ly8gQHRzLWlnbm9yZVxuXHRwcml2YXRlIF8hOiB1bmlxdWUgc3ltYm9sXG59XG4iLCJjb25zdCBlcnJvcnMgPSB7XG5cdDA6IFwiSWxsZWdhbCBzdGF0ZVwiLFxuXHQxOiBcIkltbWVyIGRyYWZ0cyBjYW5ub3QgaGF2ZSBjb21wdXRlZCBwcm9wZXJ0aWVzXCIsXG5cdDI6IFwiVGhpcyBvYmplY3QgaGFzIGJlZW4gZnJvemVuIGFuZCBzaG91bGQgbm90IGJlIG11dGF0ZWRcIixcblx0MyhkYXRhOiBhbnkpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0XCJDYW5ub3QgdXNlIGEgcHJveHkgdGhhdCBoYXMgYmVlbiByZXZva2VkLiBEaWQgeW91IHBhc3MgYW4gb2JqZWN0IGZyb20gaW5zaWRlIGFuIGltbWVyIGZ1bmN0aW9uIHRvIGFuIGFzeW5jIHByb2Nlc3M/IFwiICtcblx0XHRcdGRhdGFcblx0XHQpXG5cdH0sXG5cdDQ6IFwiQW4gaW1tZXIgcHJvZHVjZXIgcmV0dXJuZWQgYSBuZXcgdmFsdWUgKmFuZCogbW9kaWZpZWQgaXRzIGRyYWZ0LiBFaXRoZXIgcmV0dXJuIGEgbmV3IHZhbHVlICpvciogbW9kaWZ5IHRoZSBkcmFmdC5cIixcblx0NTogXCJJbW1lciBmb3JiaWRzIGNpcmN1bGFyIHJlZmVyZW5jZXNcIixcblx0NjogXCJUaGUgZmlyc3Qgb3Igc2Vjb25kIGFyZ3VtZW50IHRvIGBwcm9kdWNlYCBtdXN0IGJlIGEgZnVuY3Rpb25cIixcblx0NzogXCJUaGUgdGhpcmQgYXJndW1lbnQgdG8gYHByb2R1Y2VgIG11c3QgYmUgYSBmdW5jdGlvbiBvciB1bmRlZmluZWRcIixcblx0ODogXCJGaXJzdCBhcmd1bWVudCB0byBgY3JlYXRlRHJhZnRgIG11c3QgYmUgYSBwbGFpbiBvYmplY3QsIGFuIGFycmF5LCBvciBhbiBpbW1lcmFibGUgb2JqZWN0XCIsXG5cdDk6IFwiRmlyc3QgYXJndW1lbnQgdG8gYGZpbmlzaERyYWZ0YCBtdXN0IGJlIGEgZHJhZnQgcmV0dXJuZWQgYnkgYGNyZWF0ZURyYWZ0YFwiLFxuXHQxMDogXCJUaGUgZ2l2ZW4gZHJhZnQgaXMgYWxyZWFkeSBmaW5hbGl6ZWRcIixcblx0MTE6IFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KCkgY2Fubm90IGJlIHVzZWQgb24gYW4gSW1tZXIgZHJhZnRcIixcblx0MTI6IFwiT2JqZWN0LnNldFByb3RvdHlwZU9mKCkgY2Fubm90IGJlIHVzZWQgb24gYW4gSW1tZXIgZHJhZnRcIixcblx0MTM6IFwiSW1tZXIgb25seSBzdXBwb3J0cyBkZWxldGluZyBhcnJheSBpbmRpY2VzXCIsXG5cdDE0OiBcIkltbWVyIG9ubHkgc3VwcG9ydHMgc2V0dGluZyBhcnJheSBpbmRpY2VzIGFuZCB0aGUgJ2xlbmd0aCcgcHJvcGVydHlcIixcblx0MTUocGF0aDogc3RyaW5nKSB7XG5cdFx0cmV0dXJuIFwiQ2Fubm90IGFwcGx5IHBhdGNoLCBwYXRoIGRvZXNuJ3QgcmVzb2x2ZTogXCIgKyBwYXRoXG5cdH0sXG5cdDE2OiAnU2V0cyBjYW5ub3QgaGF2ZSBcInJlcGxhY2VcIiBwYXRjaGVzLicsXG5cdDE3KG9wOiBzdHJpbmcpIHtcblx0XHRyZXR1cm4gXCJVbnN1cHBvcnRlZCBwYXRjaCBvcGVyYXRpb246IFwiICsgb3Bcblx0fSxcblx0MTgocGx1Z2luOiBzdHJpbmcpIHtcblx0XHRyZXR1cm4gYFRoZSBwbHVnaW4gZm9yICcke3BsdWdpbn0nIGhhcyBub3QgYmVlbiBsb2FkZWQgaW50byBJbW1lci4gVG8gZW5hYmxlIHRoZSBwbHVnaW4sIGltcG9ydCBhbmQgY2FsbCBcXGBlbmFibGUke3BsdWdpbn0oKVxcYCB3aGVuIGluaXRpYWxpemluZyB5b3VyIGFwcGxpY2F0aW9uLmBcblx0fSxcblx0MjA6IFwiQ2Fubm90IHVzZSBwcm94aWVzIGlmIFByb3h5LCBQcm94eS5yZXZvY2FibGUgb3IgUmVmbGVjdCBhcmUgbm90IGF2YWlsYWJsZVwiLFxuXHQyMSh0aGluZzogc3RyaW5nKSB7XG5cdFx0cmV0dXJuIGBwcm9kdWNlIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiB0aGluZ3MgdGhhdCBhcmUgZHJhZnRhYmxlOiBwbGFpbiBvYmplY3RzLCBhcnJheXMsIE1hcCwgU2V0IG9yIGNsYXNzZXMgdGhhdCBhcmUgbWFya2VkIHdpdGggJ1tpbW1lcmFibGVdOiB0cnVlJy4gR290ICcke3RoaW5nfSdgXG5cdH0sXG5cdDIyKHRoaW5nOiBzdHJpbmcpIHtcblx0XHRyZXR1cm4gYCdjdXJyZW50JyBleHBlY3RzIGEgZHJhZnQsIGdvdDogJHt0aGluZ31gXG5cdH0sXG5cdDIzKHRoaW5nOiBzdHJpbmcpIHtcblx0XHRyZXR1cm4gYCdvcmlnaW5hbCcgZXhwZWN0cyBhIGRyYWZ0LCBnb3Q6ICR7dGhpbmd9YFxuXHR9LFxuXHQyNDogXCJQYXRjaGluZyByZXNlcnZlZCBhdHRyaWJ1dGVzIGxpa2UgX19wcm90b19fLCBwcm90b3R5cGUgYW5kIGNvbnN0cnVjdG9yIGlzIG5vdCBhbGxvd2VkXCJcbn0gYXMgY29uc3RcblxuZXhwb3J0IGZ1bmN0aW9uIGRpZShlcnJvcjoga2V5b2YgdHlwZW9mIGVycm9ycywgLi4uYXJnczogYW55W10pOiBuZXZlciB7XG5cdGlmIChfX0RFVl9fKSB7XG5cdFx0Y29uc3QgZSA9IGVycm9yc1tlcnJvcl1cblx0XHRjb25zdCBtc2cgPSAhZVxuXHRcdFx0PyBcInVua25vd24gZXJyb3IgbnI6IFwiICsgZXJyb3Jcblx0XHRcdDogdHlwZW9mIGUgPT09IFwiZnVuY3Rpb25cIlxuXHRcdFx0PyBlLmFwcGx5KG51bGwsIGFyZ3MgYXMgYW55KVxuXHRcdFx0OiBlXG5cdFx0dGhyb3cgbmV3IEVycm9yKGBbSW1tZXJdICR7bXNnfWApXG5cdH1cblx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdGBbSW1tZXJdIG1pbmlmaWVkIGVycm9yIG5yOiAke2Vycm9yfSR7XG5cdFx0XHRhcmdzLmxlbmd0aCA/IFwiIFwiICsgYXJncy5tYXAocyA9PiBgJyR7c30nYCkuam9pbihcIixcIikgOiBcIlwiXG5cdFx0fS4gRmluZCB0aGUgZnVsbCBlcnJvciBhdDogaHR0cHM6Ly9iaXQubHkvM2NYRUtXZmBcblx0KVxufVxuIiwiaW1wb3J0IHtcblx0RFJBRlRfU1RBVEUsXG5cdERSQUZUQUJMRSxcblx0aGFzU2V0LFxuXHRPYmplY3Rpc2gsXG5cdERyYWZ0ZWQsXG5cdEFueU9iamVjdCxcblx0QW55TWFwLFxuXHRBbnlTZXQsXG5cdEltbWVyU3RhdGUsXG5cdGhhc01hcCxcblx0QXJjaHR5cGUsXG5cdGRpZVxufSBmcm9tIFwiLi4vaW50ZXJuYWxcIlxuXG4vKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBJbW1lciBkcmFmdCAqL1xuLyojX19QVVJFX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRHJhZnQodmFsdWU6IGFueSk6IGJvb2xlYW4ge1xuXHRyZXR1cm4gISF2YWx1ZSAmJiAhIXZhbHVlW0RSQUZUX1NUQVRFXVxufVxuXG4vKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBjYW4gYmUgZHJhZnRlZCBieSBJbW1lciAqL1xuLyojX19QVVJFX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRHJhZnRhYmxlKHZhbHVlOiBhbnkpOiBib29sZWFuIHtcblx0aWYgKCF2YWx1ZSkgcmV0dXJuIGZhbHNlXG5cdHJldHVybiAoXG5cdFx0aXNQbGFpbk9iamVjdCh2YWx1ZSkgfHxcblx0XHRBcnJheS5pc0FycmF5KHZhbHVlKSB8fFxuXHRcdCEhdmFsdWVbRFJBRlRBQkxFXSB8fFxuXHRcdCEhdmFsdWUuY29uc3RydWN0b3I/LltEUkFGVEFCTEVdIHx8XG5cdFx0aXNNYXAodmFsdWUpIHx8XG5cdFx0aXNTZXQodmFsdWUpXG5cdClcbn1cblxuY29uc3Qgb2JqZWN0Q3RvclN0cmluZyA9IE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IudG9TdHJpbmcoKVxuLyojX19QVVJFX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWU6IGFueSk6IGJvb2xlYW4ge1xuXHRpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIGZhbHNlXG5cdGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKVxuXHRpZiAocHJvdG8gPT09IG51bGwpIHtcblx0XHRyZXR1cm4gdHJ1ZVxuXHR9XG5cdGNvbnN0IEN0b3IgPVxuXHRcdE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCBcImNvbnN0cnVjdG9yXCIpICYmIHByb3RvLmNvbnN0cnVjdG9yXG5cblx0aWYgKEN0b3IgPT09IE9iamVjdCkgcmV0dXJuIHRydWVcblxuXHRyZXR1cm4gKFxuXHRcdHR5cGVvZiBDdG9yID09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoQ3RvcikgPT09IG9iamVjdEN0b3JTdHJpbmdcblx0KVxufVxuXG4vKiogR2V0IHRoZSB1bmRlcmx5aW5nIG9iamVjdCB0aGF0IGlzIHJlcHJlc2VudGVkIGJ5IHRoZSBnaXZlbiBkcmFmdCAqL1xuLyojX19QVVJFX18qL1xuZXhwb3J0IGZ1bmN0aW9uIG9yaWdpbmFsPFQ+KHZhbHVlOiBUKTogVCB8IHVuZGVmaW5lZFxuZXhwb3J0IGZ1bmN0aW9uIG9yaWdpbmFsKHZhbHVlOiBEcmFmdGVkPGFueT4pOiBhbnkge1xuXHRpZiAoIWlzRHJhZnQodmFsdWUpKSBkaWUoMjMsIHZhbHVlKVxuXHRyZXR1cm4gdmFsdWVbRFJBRlRfU1RBVEVdLmJhc2VfXG59XG5cbi8qI19fUFVSRV9fKi9cbmV4cG9ydCBjb25zdCBvd25LZXlzOiAodGFyZ2V0OiBBbnlPYmplY3QpID0+IFByb3BlcnR5S2V5W10gPVxuXHR0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0Lm93bktleXNcblx0XHQ/IFJlZmxlY3Qub3duS2V5c1xuXHRcdDogdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgIT09IFwidW5kZWZpbmVkXCJcblx0XHQ/IG9iaiA9PlxuXHRcdFx0XHRPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmNvbmNhdChcblx0XHRcdFx0XHRPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iaikgYXMgYW55XG5cdFx0XHRcdClcblx0XHQ6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG5cbmV4cG9ydCBjb25zdCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID1cblx0T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgfHxcblx0ZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0YXJnZXQ6IGFueSkge1xuXHRcdC8vIFBvbHlmaWxsIG5lZWRlZCBmb3IgSGVybWVzIGFuZCBJRSwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9oZXJtZXMvaXNzdWVzLzI3NFxuXHRcdGNvbnN0IHJlczogYW55ID0ge31cblx0XHRvd25LZXlzKHRhcmdldCkuZm9yRWFjaChrZXkgPT4ge1xuXHRcdFx0cmVzW2tleV0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KVxuXHRcdH0pXG5cdFx0cmV0dXJuIHJlc1xuXHR9XG5cbmV4cG9ydCBmdW5jdGlvbiBlYWNoPFQgZXh0ZW5kcyBPYmplY3Rpc2g+KFxuXHRvYmo6IFQsXG5cdGl0ZXI6IChrZXk6IHN0cmluZyB8IG51bWJlciwgdmFsdWU6IGFueSwgc291cmNlOiBUKSA9PiB2b2lkLFxuXHRlbnVtZXJhYmxlT25seT86IGJvb2xlYW5cbik6IHZvaWRcbmV4cG9ydCBmdW5jdGlvbiBlYWNoKG9iajogYW55LCBpdGVyOiBhbnksIGVudW1lcmFibGVPbmx5ID0gZmFsc2UpIHtcblx0aWYgKGdldEFyY2h0eXBlKG9iaikgPT09IEFyY2h0eXBlLk9iamVjdCkge1xuXHRcdDsoZW51bWVyYWJsZU9ubHkgPyBPYmplY3Qua2V5cyA6IG93bktleXMpKG9iaikuZm9yRWFjaChrZXkgPT4ge1xuXHRcdFx0aWYgKCFlbnVtZXJhYmxlT25seSB8fCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiKSBpdGVyKGtleSwgb2JqW2tleV0sIG9iailcblx0XHR9KVxuXHR9IGVsc2Uge1xuXHRcdG9iai5mb3JFYWNoKChlbnRyeTogYW55LCBpbmRleDogYW55KSA9PiBpdGVyKGluZGV4LCBlbnRyeSwgb2JqKSlcblx0fVxufVxuXG4vKiNfX1BVUkVfXyovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXJjaHR5cGUodGhpbmc6IGFueSk6IEFyY2h0eXBlIHtcblx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0Y29uc3Qgc3RhdGU6IHVuZGVmaW5lZCB8IEltbWVyU3RhdGUgPSB0aGluZ1tEUkFGVF9TVEFURV1cblx0cmV0dXJuIHN0YXRlXG5cdFx0PyBzdGF0ZS50eXBlXyA+IDNcblx0XHRcdD8gc3RhdGUudHlwZV8gLSA0IC8vIGNhdXNlIE9iamVjdCBhbmQgQXJyYXkgbWFwIGJhY2sgZnJvbSA0IGFuZCA1XG5cdFx0XHQ6IChzdGF0ZS50eXBlXyBhcyBhbnkpIC8vIG90aGVycyBhcmUgdGhlIHNhbWVcblx0XHQ6IEFycmF5LmlzQXJyYXkodGhpbmcpXG5cdFx0PyBBcmNodHlwZS5BcnJheVxuXHRcdDogaXNNYXAodGhpbmcpXG5cdFx0PyBBcmNodHlwZS5NYXBcblx0XHQ6IGlzU2V0KHRoaW5nKVxuXHRcdD8gQXJjaHR5cGUuU2V0XG5cdFx0OiBBcmNodHlwZS5PYmplY3Rcbn1cblxuLyojX19QVVJFX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGhhcyh0aGluZzogYW55LCBwcm9wOiBQcm9wZXJ0eUtleSk6IGJvb2xlYW4ge1xuXHRyZXR1cm4gZ2V0QXJjaHR5cGUodGhpbmcpID09PSBBcmNodHlwZS5NYXBcblx0XHQ/IHRoaW5nLmhhcyhwcm9wKVxuXHRcdDogT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaW5nLCBwcm9wKVxufVxuXG4vKiNfX1BVUkVfXyovXG5leHBvcnQgZnVuY3Rpb24gZ2V0KHRoaW5nOiBBbnlNYXAgfCBBbnlPYmplY3QsIHByb3A6IFByb3BlcnR5S2V5KTogYW55IHtcblx0Ly8gQHRzLWlnbm9yZVxuXHRyZXR1cm4gZ2V0QXJjaHR5cGUodGhpbmcpID09PSBBcmNodHlwZS5NYXAgPyB0aGluZy5nZXQocHJvcCkgOiB0aGluZ1twcm9wXVxufVxuXG4vKiNfX1BVUkVfXyovXG5leHBvcnQgZnVuY3Rpb24gc2V0KHRoaW5nOiBhbnksIHByb3BPck9sZFZhbHVlOiBQcm9wZXJ0eUtleSwgdmFsdWU6IGFueSkge1xuXHRjb25zdCB0ID0gZ2V0QXJjaHR5cGUodGhpbmcpXG5cdGlmICh0ID09PSBBcmNodHlwZS5NYXApIHRoaW5nLnNldChwcm9wT3JPbGRWYWx1ZSwgdmFsdWUpXG5cdGVsc2UgaWYgKHQgPT09IEFyY2h0eXBlLlNldCkge1xuXHRcdHRoaW5nLmFkZCh2YWx1ZSlcblx0fSBlbHNlIHRoaW5nW3Byb3BPck9sZFZhbHVlXSA9IHZhbHVlXG59XG5cbi8qI19fUFVSRV9fKi9cbmV4cG9ydCBmdW5jdGlvbiBpcyh4OiBhbnksIHk6IGFueSk6IGJvb2xlYW4ge1xuXHQvLyBGcm9tOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmJqcy9ibG9iL2M2OTkwNGE1MTFiOTAwMjY2OTM1MTY4MjIzMDYzZGQ4NzcyZGZjNDAvcGFja2FnZXMvZmJqcy9zcmMvY29yZS9zaGFsbG93RXF1YWwuanNcblx0aWYgKHggPT09IHkpIHtcblx0XHRyZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHlcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5XG5cdH1cbn1cblxuLyojX19QVVJFX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTWFwKHRhcmdldDogYW55KTogdGFyZ2V0IGlzIEFueU1hcCB7XG5cdHJldHVybiBoYXNNYXAgJiYgdGFyZ2V0IGluc3RhbmNlb2YgTWFwXG59XG5cbi8qI19fUFVSRV9fKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1NldCh0YXJnZXQ6IGFueSk6IHRhcmdldCBpcyBBbnlTZXQge1xuXHRyZXR1cm4gaGFzU2V0ICYmIHRhcmdldCBpbnN0YW5jZW9mIFNldFxufVxuLyojX19QVVJFX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGxhdGVzdChzdGF0ZTogSW1tZXJTdGF0ZSk6IGFueSB7XG5cdHJldHVybiBzdGF0ZS5jb3B5XyB8fCBzdGF0ZS5iYXNlX1xufVxuXG4vKiNfX1BVUkVfXyovXG5leHBvcnQgZnVuY3Rpb24gc2hhbGxvd0NvcHkoYmFzZTogYW55KSB7XG5cdGlmIChBcnJheS5pc0FycmF5KGJhc2UpKSByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYmFzZSlcblx0Y29uc3QgZGVzY3JpcHRvcnMgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKGJhc2UpXG5cdGRlbGV0ZSBkZXNjcmlwdG9yc1tEUkFGVF9TVEFURSBhcyBhbnldXG5cdGxldCBrZXlzID0gb3duS2V5cyhkZXNjcmlwdG9ycylcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y29uc3Qga2V5OiBhbnkgPSBrZXlzW2ldXG5cdFx0Y29uc3QgZGVzYyA9IGRlc2NyaXB0b3JzW2tleV1cblx0XHRpZiAoZGVzYy53cml0YWJsZSA9PT0gZmFsc2UpIHtcblx0XHRcdGRlc2Mud3JpdGFibGUgPSB0cnVlXG5cdFx0XHRkZXNjLmNvbmZpZ3VyYWJsZSA9IHRydWVcblx0XHR9XG5cdFx0Ly8gbGlrZSBvYmplY3QuYXNzaWduLCB3ZSB3aWxsIHJlYWQgYW55IF9vd25fLCBnZXQvc2V0IGFjY2Vzc29ycy4gVGhpcyBoZWxwcyBpbiBkZWFsaW5nXG5cdFx0Ly8gd2l0aCBsaWJyYXJpZXMgdGhhdCB0cmFwIHZhbHVlcywgbGlrZSBtb2J4IG9yIHZ1ZVxuXHRcdC8vIHVubGlrZSBvYmplY3QuYXNzaWduLCBub24tZW51bWVyYWJsZXMgd2lsbCBiZSBjb3BpZWQgYXMgd2VsbFxuXHRcdGlmIChkZXNjLmdldCB8fCBkZXNjLnNldClcblx0XHRcdGRlc2NyaXB0b3JzW2tleV0gPSB7XG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0d3JpdGFibGU6IHRydWUsIC8vIGNvdWxkIGxpdmUgd2l0aCAhIWRlc2Muc2V0IGFzIHdlbGwgaGVyZS4uLlxuXHRcdFx0XHRlbnVtZXJhYmxlOiBkZXNjLmVudW1lcmFibGUsXG5cdFx0XHRcdHZhbHVlOiBiYXNlW2tleV1cblx0XHRcdH1cblx0fVxuXHRyZXR1cm4gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YoYmFzZSksIGRlc2NyaXB0b3JzKVxufVxuXG4vKipcbiAqIEZyZWV6ZXMgZHJhZnRhYmxlIG9iamVjdHMuIFJldHVybnMgdGhlIG9yaWdpbmFsIG9iamVjdC5cbiAqIEJ5IGRlZmF1bHQgZnJlZXplcyBzaGFsbG93bHksIGJ1dCBpZiB0aGUgc2Vjb25kIGFyZ3VtZW50IGlzIGB0cnVlYCBpdCB3aWxsIGZyZWV6ZSByZWN1cnNpdmVseS5cbiAqXG4gKiBAcGFyYW0gb2JqXG4gKiBAcGFyYW0gZGVlcFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJlZXplPFQ+KG9iajogVCwgZGVlcD86IGJvb2xlYW4pOiBUXG5leHBvcnQgZnVuY3Rpb24gZnJlZXplPFQ+KG9iajogYW55LCBkZWVwOiBib29sZWFuID0gZmFsc2UpOiBUIHtcblx0aWYgKGlzRnJvemVuKG9iaikgfHwgaXNEcmFmdChvYmopIHx8ICFpc0RyYWZ0YWJsZShvYmopKSByZXR1cm4gb2JqXG5cdGlmIChnZXRBcmNodHlwZShvYmopID4gMSAvKiBNYXAgb3IgU2V0ICovKSB7XG5cdFx0b2JqLnNldCA9IG9iai5hZGQgPSBvYmouY2xlYXIgPSBvYmouZGVsZXRlID0gZG9udE11dGF0ZUZyb3plbkNvbGxlY3Rpb25zIGFzIGFueVxuXHR9XG5cdE9iamVjdC5mcmVlemUob2JqKVxuXHRpZiAoZGVlcCkgZWFjaChvYmosIChrZXksIHZhbHVlKSA9PiBmcmVlemUodmFsdWUsIHRydWUpLCB0cnVlKVxuXHRyZXR1cm4gb2JqXG59XG5cbmZ1bmN0aW9uIGRvbnRNdXRhdGVGcm96ZW5Db2xsZWN0aW9ucygpIHtcblx0ZGllKDIpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Zyb3plbihvYmo6IGFueSk6IGJvb2xlYW4ge1xuXHRpZiAob2JqID09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHRydWVcblx0Ly8gU2VlICM2MDAsIElFIGRpZXMgb24gbm9uLW9iamVjdHMgaW4gT2JqZWN0LmlzRnJvemVuXG5cdHJldHVybiBPYmplY3QuaXNGcm96ZW4ob2JqKVxufVxuIiwiaW1wb3J0IHtcblx0SW1tZXJTdGF0ZSxcblx0UGF0Y2gsXG5cdEltbWVyU2NvcGUsXG5cdERyYWZ0ZWQsXG5cdEFueU9iamVjdCxcblx0SW1tZXJCYXNlU3RhdGUsXG5cdEFueU1hcCxcblx0QW55U2V0LFxuXHRQcm94eVR5cGUsXG5cdGRpZVxufSBmcm9tIFwiLi4vaW50ZXJuYWxcIlxuXG4vKiogUGx1Z2luIHV0aWxpdGllcyAqL1xuY29uc3QgcGx1Z2luczoge1xuXHRQYXRjaGVzPzoge1xuXHRcdGdlbmVyYXRlUGF0Y2hlc18oXG5cdFx0XHRzdGF0ZTogSW1tZXJTdGF0ZSxcblx0XHRcdGJhc2VQYXRoOiBQYXRjaFBhdGgsXG5cdFx0XHRwYXRjaGVzOiBQYXRjaFtdLFxuXHRcdFx0aW52ZXJzZVBhdGNoZXM6IFBhdGNoW11cblx0XHQpOiB2b2lkXG5cdFx0Z2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfKFxuXHRcdFx0YmFzZTogYW55LFxuXHRcdFx0cmVwbGFjZW1lbnQ6IGFueSxcblx0XHRcdHBhdGNoZXM6IFBhdGNoW10sXG5cdFx0XHRpbnZlcnNlUGF0Y2hlczogUGF0Y2hbXVxuXHRcdCk6IHZvaWRcblx0XHRhcHBseVBhdGNoZXNfPFQ+KGRyYWZ0OiBULCBwYXRjaGVzOiBQYXRjaFtdKTogVFxuXHR9XG5cdEVTNT86IHtcblx0XHR3aWxsRmluYWxpemVFUzVfKHNjb3BlOiBJbW1lclNjb3BlLCByZXN1bHQ6IGFueSwgaXNSZXBsYWNlZDogYm9vbGVhbik6IHZvaWRcblx0XHRjcmVhdGVFUzVQcm94eV88VD4oXG5cdFx0XHRiYXNlOiBULFxuXHRcdFx0cGFyZW50PzogSW1tZXJTdGF0ZVxuXHRcdCk6IERyYWZ0ZWQ8VCwgRVM1T2JqZWN0U3RhdGUgfCBFUzVBcnJheVN0YXRlPlxuXHRcdGhhc0NoYW5nZXNfKHN0YXRlOiBFUzVBcnJheVN0YXRlIHwgRVM1T2JqZWN0U3RhdGUpOiBib29sZWFuXG5cdH1cblx0TWFwU2V0Pzoge1xuXHRcdHByb3h5TWFwXzxUIGV4dGVuZHMgQW55TWFwPih0YXJnZXQ6IFQsIHBhcmVudD86IEltbWVyU3RhdGUpOiBUXG5cdFx0cHJveHlTZXRfPFQgZXh0ZW5kcyBBbnlTZXQ+KHRhcmdldDogVCwgcGFyZW50PzogSW1tZXJTdGF0ZSk6IFRcblx0fVxufSA9IHt9XG5cbnR5cGUgUGx1Z2lucyA9IHR5cGVvZiBwbHVnaW5zXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQbHVnaW48SyBleHRlbmRzIGtleW9mIFBsdWdpbnM+KFxuXHRwbHVnaW5LZXk6IEtcbik6IEV4Y2x1ZGU8UGx1Z2luc1tLXSwgdW5kZWZpbmVkPiB7XG5cdGNvbnN0IHBsdWdpbiA9IHBsdWdpbnNbcGx1Z2luS2V5XVxuXHRpZiAoIXBsdWdpbikge1xuXHRcdGRpZSgxOCwgcGx1Z2luS2V5KVxuXHR9XG5cdC8vIEB0cy1pZ25vcmVcblx0cmV0dXJuIHBsdWdpblxufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9hZFBsdWdpbjxLIGV4dGVuZHMga2V5b2YgUGx1Z2lucz4oXG5cdHBsdWdpbktleTogSyxcblx0aW1wbGVtZW50YXRpb246IFBsdWdpbnNbS11cbik6IHZvaWQge1xuXHRpZiAoIXBsdWdpbnNbcGx1Z2luS2V5XSkgcGx1Z2luc1twbHVnaW5LZXldID0gaW1wbGVtZW50YXRpb25cbn1cblxuLyoqIEVTNSBQbHVnaW4gKi9cblxuaW50ZXJmYWNlIEVTNUJhc2VTdGF0ZSBleHRlbmRzIEltbWVyQmFzZVN0YXRlIHtcblx0YXNzaWduZWRfOiB7W2tleTogc3RyaW5nXTogYW55fVxuXHRwYXJlbnRfPzogSW1tZXJTdGF0ZVxuXHRyZXZva2VkXzogYm9vbGVhblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVTNU9iamVjdFN0YXRlIGV4dGVuZHMgRVM1QmFzZVN0YXRlIHtcblx0dHlwZV86IFByb3h5VHlwZS5FUzVPYmplY3Rcblx0ZHJhZnRfOiBEcmFmdGVkPEFueU9iamVjdCwgRVM1T2JqZWN0U3RhdGU+XG5cdGJhc2VfOiBBbnlPYmplY3Rcblx0Y29weV86IEFueU9iamVjdCB8IG51bGxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFUzVBcnJheVN0YXRlIGV4dGVuZHMgRVM1QmFzZVN0YXRlIHtcblx0dHlwZV86IFByb3h5VHlwZS5FUzVBcnJheVxuXHRkcmFmdF86IERyYWZ0ZWQ8QW55T2JqZWN0LCBFUzVBcnJheVN0YXRlPlxuXHRiYXNlXzogYW55XG5cdGNvcHlfOiBhbnlcbn1cblxuLyoqIE1hcCAvIFNldCBwbHVnaW4gKi9cblxuZXhwb3J0IGludGVyZmFjZSBNYXBTdGF0ZSBleHRlbmRzIEltbWVyQmFzZVN0YXRlIHtcblx0dHlwZV86IFByb3h5VHlwZS5NYXBcblx0Y29weV86IEFueU1hcCB8IHVuZGVmaW5lZFxuXHRhc3NpZ25lZF86IE1hcDxhbnksIGJvb2xlYW4+IHwgdW5kZWZpbmVkXG5cdGJhc2VfOiBBbnlNYXBcblx0cmV2b2tlZF86IGJvb2xlYW5cblx0ZHJhZnRfOiBEcmFmdGVkPEFueU1hcCwgTWFwU3RhdGU+XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2V0U3RhdGUgZXh0ZW5kcyBJbW1lckJhc2VTdGF0ZSB7XG5cdHR5cGVfOiBQcm94eVR5cGUuU2V0XG5cdGNvcHlfOiBBbnlTZXQgfCB1bmRlZmluZWRcblx0YmFzZV86IEFueVNldFxuXHRkcmFmdHNfOiBNYXA8YW55LCBEcmFmdGVkPiAvLyBtYXBzIHRoZSBvcmlnaW5hbCB2YWx1ZSB0byB0aGUgZHJhZnQgdmFsdWUgaW4gdGhlIG5ldyBzZXRcblx0cmV2b2tlZF86IGJvb2xlYW5cblx0ZHJhZnRfOiBEcmFmdGVkPEFueVNldCwgU2V0U3RhdGU+XG59XG5cbi8qKiBQYXRjaGVzIHBsdWdpbiAqL1xuXG5leHBvcnQgdHlwZSBQYXRjaFBhdGggPSAoc3RyaW5nIHwgbnVtYmVyKVtdXG4iLCJpbXBvcnQge1xuXHRQYXRjaCxcblx0UGF0Y2hMaXN0ZW5lcixcblx0RHJhZnRlZCxcblx0SW1tZXIsXG5cdERSQUZUX1NUQVRFLFxuXHRJbW1lclN0YXRlLFxuXHRQcm94eVR5cGUsXG5cdGdldFBsdWdpblxufSBmcm9tIFwiLi4vaW50ZXJuYWxcIlxuaW1wb3J0IHtkaWV9IGZyb20gXCIuLi91dGlscy9lcnJvcnNcIlxuXG4vKiogRWFjaCBzY29wZSByZXByZXNlbnRzIGEgYHByb2R1Y2VgIGNhbGwuICovXG5cbmV4cG9ydCBpbnRlcmZhY2UgSW1tZXJTY29wZSB7XG5cdHBhdGNoZXNfPzogUGF0Y2hbXVxuXHRpbnZlcnNlUGF0Y2hlc18/OiBQYXRjaFtdXG5cdGNhbkF1dG9GcmVlemVfOiBib29sZWFuXG5cdGRyYWZ0c186IGFueVtdXG5cdHBhcmVudF8/OiBJbW1lclNjb3BlXG5cdHBhdGNoTGlzdGVuZXJfPzogUGF0Y2hMaXN0ZW5lclxuXHRpbW1lcl86IEltbWVyXG5cdHVuZmluYWxpemVkRHJhZnRzXzogbnVtYmVyXG59XG5cbmxldCBjdXJyZW50U2NvcGU6IEltbWVyU2NvcGUgfCB1bmRlZmluZWRcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEN1cnJlbnRTY29wZSgpIHtcblx0aWYgKF9fREVWX18gJiYgIWN1cnJlbnRTY29wZSkgZGllKDApXG5cdHJldHVybiBjdXJyZW50U2NvcGUhXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNjb3BlKFxuXHRwYXJlbnRfOiBJbW1lclNjb3BlIHwgdW5kZWZpbmVkLFxuXHRpbW1lcl86IEltbWVyXG4pOiBJbW1lclNjb3BlIHtcblx0cmV0dXJuIHtcblx0XHRkcmFmdHNfOiBbXSxcblx0XHRwYXJlbnRfLFxuXHRcdGltbWVyXyxcblx0XHQvLyBXaGVuZXZlciB0aGUgbW9kaWZpZWQgZHJhZnQgY29udGFpbnMgYSBkcmFmdCBmcm9tIGFub3RoZXIgc2NvcGUsIHdlXG5cdFx0Ly8gbmVlZCB0byBwcmV2ZW50IGF1dG8tZnJlZXppbmcgc28gdGhlIHVub3duZWQgZHJhZnQgY2FuIGJlIGZpbmFsaXplZC5cblx0XHRjYW5BdXRvRnJlZXplXzogdHJ1ZSxcblx0XHR1bmZpbmFsaXplZERyYWZ0c186IDBcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlUGF0Y2hlc0luU2NvcGUoXG5cdHNjb3BlOiBJbW1lclNjb3BlLFxuXHRwYXRjaExpc3RlbmVyPzogUGF0Y2hMaXN0ZW5lclxuKSB7XG5cdGlmIChwYXRjaExpc3RlbmVyKSB7XG5cdFx0Z2V0UGx1Z2luKFwiUGF0Y2hlc1wiKSAvLyBhc3NlcnQgd2UgaGF2ZSB0aGUgcGx1Z2luXG5cdFx0c2NvcGUucGF0Y2hlc18gPSBbXVxuXHRcdHNjb3BlLmludmVyc2VQYXRjaGVzXyA9IFtdXG5cdFx0c2NvcGUucGF0Y2hMaXN0ZW5lcl8gPSBwYXRjaExpc3RlbmVyXG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJldm9rZVNjb3BlKHNjb3BlOiBJbW1lclNjb3BlKSB7XG5cdGxlYXZlU2NvcGUoc2NvcGUpXG5cdHNjb3BlLmRyYWZ0c18uZm9yRWFjaChyZXZva2VEcmFmdClcblx0Ly8gQHRzLWlnbm9yZVxuXHRzY29wZS5kcmFmdHNfID0gbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gbGVhdmVTY29wZShzY29wZTogSW1tZXJTY29wZSkge1xuXHRpZiAoc2NvcGUgPT09IGN1cnJlbnRTY29wZSkge1xuXHRcdGN1cnJlbnRTY29wZSA9IHNjb3BlLnBhcmVudF9cblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZW50ZXJTY29wZShpbW1lcjogSW1tZXIpIHtcblx0cmV0dXJuIChjdXJyZW50U2NvcGUgPSBjcmVhdGVTY29wZShjdXJyZW50U2NvcGUsIGltbWVyKSlcbn1cblxuZnVuY3Rpb24gcmV2b2tlRHJhZnQoZHJhZnQ6IERyYWZ0ZWQpIHtcblx0Y29uc3Qgc3RhdGU6IEltbWVyU3RhdGUgPSBkcmFmdFtEUkFGVF9TVEFURV1cblx0aWYgKFxuXHRcdHN0YXRlLnR5cGVfID09PSBQcm94eVR5cGUuUHJveHlPYmplY3QgfHxcblx0XHRzdGF0ZS50eXBlXyA9PT0gUHJveHlUeXBlLlByb3h5QXJyYXlcblx0KVxuXHRcdHN0YXRlLnJldm9rZV8oKVxuXHRlbHNlIHN0YXRlLnJldm9rZWRfID0gdHJ1ZVxufVxuIiwiaW1wb3J0IHtcblx0SW1tZXJTY29wZSxcblx0RFJBRlRfU1RBVEUsXG5cdGlzRHJhZnRhYmxlLFxuXHROT1RISU5HLFxuXHRQYXRjaFBhdGgsXG5cdGVhY2gsXG5cdGhhcyxcblx0ZnJlZXplLFxuXHRJbW1lclN0YXRlLFxuXHRpc0RyYWZ0LFxuXHRTZXRTdGF0ZSxcblx0c2V0LFxuXHRQcm94eVR5cGUsXG5cdGdldFBsdWdpbixcblx0ZGllLFxuXHRyZXZva2VTY29wZSxcblx0aXNGcm96ZW4sXG5cdHNoYWxsb3dDb3B5XG59IGZyb20gXCIuLi9pbnRlcm5hbFwiXG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzUmVzdWx0KHJlc3VsdDogYW55LCBzY29wZTogSW1tZXJTY29wZSkge1xuXHRzY29wZS51bmZpbmFsaXplZERyYWZ0c18gPSBzY29wZS5kcmFmdHNfLmxlbmd0aFxuXHRjb25zdCBiYXNlRHJhZnQgPSBzY29wZS5kcmFmdHNfIVswXVxuXHRjb25zdCBpc1JlcGxhY2VkID0gcmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgcmVzdWx0ICE9PSBiYXNlRHJhZnRcblx0aWYgKCFzY29wZS5pbW1lcl8udXNlUHJveGllc18pXG5cdFx0Z2V0UGx1Z2luKFwiRVM1XCIpLndpbGxGaW5hbGl6ZUVTNV8oc2NvcGUsIHJlc3VsdCwgaXNSZXBsYWNlZClcblx0aWYgKGlzUmVwbGFjZWQpIHtcblx0XHRpZiAoYmFzZURyYWZ0W0RSQUZUX1NUQVRFXS5tb2RpZmllZF8pIHtcblx0XHRcdHJldm9rZVNjb3BlKHNjb3BlKVxuXHRcdFx0ZGllKDQpXG5cdFx0fVxuXHRcdGlmIChpc0RyYWZ0YWJsZShyZXN1bHQpKSB7XG5cdFx0XHQvLyBGaW5hbGl6ZSB0aGUgcmVzdWx0IGluIGNhc2UgaXQgY29udGFpbnMgKG9yIGlzKSBhIHN1YnNldCBvZiB0aGUgZHJhZnQuXG5cdFx0XHRyZXN1bHQgPSBmaW5hbGl6ZShzY29wZSwgcmVzdWx0KVxuXHRcdFx0aWYgKCFzY29wZS5wYXJlbnRfKSBtYXliZUZyZWV6ZShzY29wZSwgcmVzdWx0KVxuXHRcdH1cblx0XHRpZiAoc2NvcGUucGF0Y2hlc18pIHtcblx0XHRcdGdldFBsdWdpbihcIlBhdGNoZXNcIikuZ2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfKFxuXHRcdFx0XHRiYXNlRHJhZnRbRFJBRlRfU1RBVEVdLmJhc2VfLFxuXHRcdFx0XHRyZXN1bHQsXG5cdFx0XHRcdHNjb3BlLnBhdGNoZXNfLFxuXHRcdFx0XHRzY29wZS5pbnZlcnNlUGF0Y2hlc18hXG5cdFx0XHQpXG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdC8vIEZpbmFsaXplIHRoZSBiYXNlIGRyYWZ0LlxuXHRcdHJlc3VsdCA9IGZpbmFsaXplKHNjb3BlLCBiYXNlRHJhZnQsIFtdKVxuXHR9XG5cdHJldm9rZVNjb3BlKHNjb3BlKVxuXHRpZiAoc2NvcGUucGF0Y2hlc18pIHtcblx0XHRzY29wZS5wYXRjaExpc3RlbmVyXyEoc2NvcGUucGF0Y2hlc18sIHNjb3BlLmludmVyc2VQYXRjaGVzXyEpXG5cdH1cblx0cmV0dXJuIHJlc3VsdCAhPT0gTk9USElORyA/IHJlc3VsdCA6IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBmaW5hbGl6ZShyb290U2NvcGU6IEltbWVyU2NvcGUsIHZhbHVlOiBhbnksIHBhdGg/OiBQYXRjaFBhdGgpIHtcblx0Ly8gRG9uJ3QgcmVjdXJzZSBpbiB0aG8gcmVjdXJzaXZlIGRhdGEgc3RydWN0dXJlc1xuXHRpZiAoaXNGcm96ZW4odmFsdWUpKSByZXR1cm4gdmFsdWVcblxuXHRjb25zdCBzdGF0ZTogSW1tZXJTdGF0ZSA9IHZhbHVlW0RSQUZUX1NUQVRFXVxuXHQvLyBBIHBsYWluIG9iamVjdCwgbWlnaHQgbmVlZCBmcmVlemluZywgbWlnaHQgY29udGFpbiBkcmFmdHNcblx0aWYgKCFzdGF0ZSkge1xuXHRcdGVhY2goXG5cdFx0XHR2YWx1ZSxcblx0XHRcdChrZXksIGNoaWxkVmFsdWUpID0+XG5cdFx0XHRcdGZpbmFsaXplUHJvcGVydHkocm9vdFNjb3BlLCBzdGF0ZSwgdmFsdWUsIGtleSwgY2hpbGRWYWx1ZSwgcGF0aCksXG5cdFx0XHR0cnVlIC8vIFNlZSAjNTkwLCBkb24ndCByZWN1cnNlIGludG8gbm9uLWVudW1lcmFibGUgb2Ygbm9uIGRyYWZ0ZWQgb2JqZWN0c1xuXHRcdClcblx0XHRyZXR1cm4gdmFsdWVcblx0fVxuXHQvLyBOZXZlciBmaW5hbGl6ZSBkcmFmdHMgb3duZWQgYnkgYW5vdGhlciBzY29wZS5cblx0aWYgKHN0YXRlLnNjb3BlXyAhPT0gcm9vdFNjb3BlKSByZXR1cm4gdmFsdWVcblx0Ly8gVW5tb2RpZmllZCBkcmFmdCwgcmV0dXJuIHRoZSAoZnJvemVuKSBvcmlnaW5hbFxuXHRpZiAoIXN0YXRlLm1vZGlmaWVkXykge1xuXHRcdG1heWJlRnJlZXplKHJvb3RTY29wZSwgc3RhdGUuYmFzZV8sIHRydWUpXG5cdFx0cmV0dXJuIHN0YXRlLmJhc2VfXG5cdH1cblx0Ly8gTm90IGZpbmFsaXplZCB5ZXQsIGxldCdzIGRvIHRoYXQgbm93XG5cdGlmICghc3RhdGUuZmluYWxpemVkXykge1xuXHRcdHN0YXRlLmZpbmFsaXplZF8gPSB0cnVlXG5cdFx0c3RhdGUuc2NvcGVfLnVuZmluYWxpemVkRHJhZnRzXy0tXG5cdFx0Y29uc3QgcmVzdWx0ID1cblx0XHRcdC8vIEZvciBFUzUsIGNyZWF0ZSBhIGdvb2QgY29weSBmcm9tIHRoZSBkcmFmdCBmaXJzdCwgd2l0aCBhZGRlZCBrZXlzIGFuZCB3aXRob3V0IGRlbGV0ZWQga2V5cy5cblx0XHRcdHN0YXRlLnR5cGVfID09PSBQcm94eVR5cGUuRVM1T2JqZWN0IHx8IHN0YXRlLnR5cGVfID09PSBQcm94eVR5cGUuRVM1QXJyYXlcblx0XHRcdFx0PyAoc3RhdGUuY29weV8gPSBzaGFsbG93Q29weShzdGF0ZS5kcmFmdF8pKVxuXHRcdFx0XHQ6IHN0YXRlLmNvcHlfXG5cdFx0Ly8gRmluYWxpemUgYWxsIGNoaWxkcmVuIG9mIHRoZSBjb3B5XG5cdFx0Ly8gRm9yIHNldHMgd2UgY2xvbmUgYmVmb3JlIGl0ZXJhdGluZywgb3RoZXJ3aXNlIHdlIGNhbiBnZXQgaW4gZW5kbGVzcyBsb29wIGR1ZSB0byBtb2RpZnlpbmcgZHVyaW5nIGl0ZXJhdGlvbiwgc2VlICM2Mjhcblx0XHQvLyBUbyBwcmVzZXJ2ZSBpbnNlcnRpb24gb3JkZXIgaW4gYWxsIGNhc2VzIHdlIHRoZW4gY2xlYXIgdGhlIHNldFxuXHRcdC8vIEFuZCB3ZSBsZXQgZmluYWxpemVQcm9wZXJ0eSBrbm93IGl0IG5lZWRzIHRvIHJlLWFkZCBub24tZHJhZnQgY2hpbGRyZW4gYmFjayB0byB0aGUgdGFyZ2V0XG5cdFx0bGV0IHJlc3VsdEVhY2ggPSByZXN1bHRcblx0XHRsZXQgaXNTZXQgPSBmYWxzZVxuXHRcdGlmIChzdGF0ZS50eXBlXyA9PT0gUHJveHlUeXBlLlNldCkge1xuXHRcdFx0cmVzdWx0RWFjaCA9IG5ldyBTZXQocmVzdWx0KVxuXHRcdFx0cmVzdWx0LmNsZWFyKClcblx0XHRcdGlzU2V0ID0gdHJ1ZVxuXHRcdH1cblx0XHRlYWNoKHJlc3VsdEVhY2gsIChrZXksIGNoaWxkVmFsdWUpID0+XG5cdFx0XHRmaW5hbGl6ZVByb3BlcnR5KHJvb3RTY29wZSwgc3RhdGUsIHJlc3VsdCwga2V5LCBjaGlsZFZhbHVlLCBwYXRoLCBpc1NldClcblx0XHQpXG5cdFx0Ly8gZXZlcnl0aGluZyBpbnNpZGUgaXMgZnJvemVuLCB3ZSBjYW4gZnJlZXplIGhlcmVcblx0XHRtYXliZUZyZWV6ZShyb290U2NvcGUsIHJlc3VsdCwgZmFsc2UpXG5cdFx0Ly8gZmlyc3QgdGltZSBmaW5hbGl6aW5nLCBsZXQncyBjcmVhdGUgdGhvc2UgcGF0Y2hlc1xuXHRcdGlmIChwYXRoICYmIHJvb3RTY29wZS5wYXRjaGVzXykge1xuXHRcdFx0Z2V0UGx1Z2luKFwiUGF0Y2hlc1wiKS5nZW5lcmF0ZVBhdGNoZXNfKFxuXHRcdFx0XHRzdGF0ZSxcblx0XHRcdFx0cGF0aCxcblx0XHRcdFx0cm9vdFNjb3BlLnBhdGNoZXNfLFxuXHRcdFx0XHRyb290U2NvcGUuaW52ZXJzZVBhdGNoZXNfIVxuXHRcdFx0KVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gc3RhdGUuY29weV9cbn1cblxuZnVuY3Rpb24gZmluYWxpemVQcm9wZXJ0eShcblx0cm9vdFNjb3BlOiBJbW1lclNjb3BlLFxuXHRwYXJlbnRTdGF0ZTogdW5kZWZpbmVkIHwgSW1tZXJTdGF0ZSxcblx0dGFyZ2V0T2JqZWN0OiBhbnksXG5cdHByb3A6IHN0cmluZyB8IG51bWJlcixcblx0Y2hpbGRWYWx1ZTogYW55LFxuXHRyb290UGF0aD86IFBhdGNoUGF0aCxcblx0dGFyZ2V0SXNTZXQ/OiBib29sZWFuXG4pIHtcblx0aWYgKF9fREVWX18gJiYgY2hpbGRWYWx1ZSA9PT0gdGFyZ2V0T2JqZWN0KSBkaWUoNSlcblx0aWYgKGlzRHJhZnQoY2hpbGRWYWx1ZSkpIHtcblx0XHRjb25zdCBwYXRoID1cblx0XHRcdHJvb3RQYXRoICYmXG5cdFx0XHRwYXJlbnRTdGF0ZSAmJlxuXHRcdFx0cGFyZW50U3RhdGUhLnR5cGVfICE9PSBQcm94eVR5cGUuU2V0ICYmIC8vIFNldCBvYmplY3RzIGFyZSBhdG9taWMgc2luY2UgdGhleSBoYXZlIG5vIGtleXMuXG5cdFx0XHQhaGFzKChwYXJlbnRTdGF0ZSBhcyBFeGNsdWRlPEltbWVyU3RhdGUsIFNldFN0YXRlPikuYXNzaWduZWRfISwgcHJvcCkgLy8gU2tpcCBkZWVwIHBhdGNoZXMgZm9yIGFzc2lnbmVkIGtleXMuXG5cdFx0XHRcdD8gcm9vdFBhdGghLmNvbmNhdChwcm9wKVxuXHRcdFx0XHQ6IHVuZGVmaW5lZFxuXHRcdC8vIERyYWZ0cyBvd25lZCBieSBgc2NvcGVgIGFyZSBmaW5hbGl6ZWQgaGVyZS5cblx0XHRjb25zdCByZXMgPSBmaW5hbGl6ZShyb290U2NvcGUsIGNoaWxkVmFsdWUsIHBhdGgpXG5cdFx0c2V0KHRhcmdldE9iamVjdCwgcHJvcCwgcmVzKVxuXHRcdC8vIERyYWZ0cyBmcm9tIGFub3RoZXIgc2NvcGUgbXVzdCBwcmV2ZW50ZWQgdG8gYmUgZnJvemVuXG5cdFx0Ly8gaWYgd2UgZ290IGEgZHJhZnQgYmFjayBmcm9tIGZpbmFsaXplLCB3ZSdyZSBpbiBhIG5lc3RlZCBwcm9kdWNlIGFuZCBzaG91bGRuJ3QgZnJlZXplXG5cdFx0aWYgKGlzRHJhZnQocmVzKSkge1xuXHRcdFx0cm9vdFNjb3BlLmNhbkF1dG9GcmVlemVfID0gZmFsc2Vcblx0XHR9IGVsc2UgcmV0dXJuXG5cdH0gZWxzZSBpZiAodGFyZ2V0SXNTZXQpIHtcblx0XHR0YXJnZXRPYmplY3QuYWRkKGNoaWxkVmFsdWUpXG5cdH1cblx0Ly8gU2VhcmNoIG5ldyBvYmplY3RzIGZvciB1bmZpbmFsaXplZCBkcmFmdHMuIEZyb3plbiBvYmplY3RzIHNob3VsZCBuZXZlciBjb250YWluIGRyYWZ0cy5cblx0aWYgKGlzRHJhZnRhYmxlKGNoaWxkVmFsdWUpICYmICFpc0Zyb3plbihjaGlsZFZhbHVlKSkge1xuXHRcdGlmICghcm9vdFNjb3BlLmltbWVyXy5hdXRvRnJlZXplXyAmJiByb290U2NvcGUudW5maW5hbGl6ZWREcmFmdHNfIDwgMSkge1xuXHRcdFx0Ly8gb3B0aW1pemF0aW9uOiBpZiBhbiBvYmplY3QgaXMgbm90IGEgZHJhZnQsIGFuZCB3ZSBkb24ndCBoYXZlIHRvXG5cdFx0XHQvLyBkZWVwZnJlZXplIGV2ZXJ5dGhpbmcsIGFuZCB3ZSBhcmUgc3VyZSB0aGF0IG5vIGRyYWZ0cyBhcmUgbGVmdCBpbiB0aGUgcmVtYWluaW5nIG9iamVjdFxuXHRcdFx0Ly8gY2F1c2Ugd2Ugc2F3IGFuZCBmaW5hbGl6ZWQgYWxsIGRyYWZ0cyBhbHJlYWR5OyB3ZSBjYW4gc3RvcCB2aXNpdGluZyB0aGUgcmVzdCBvZiB0aGUgdHJlZS5cblx0XHRcdC8vIFRoaXMgYmVuZWZpdHMgZXNwZWNpYWxseSBhZGRpbmcgbGFyZ2UgZGF0YSB0cmVlJ3Mgd2l0aG91dCBmdXJ0aGVyIHByb2Nlc3NpbmcuXG5cdFx0XHQvLyBTZWUgYWRkLWRhdGEuanMgcGVyZiB0ZXN0XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0ZmluYWxpemUocm9vdFNjb3BlLCBjaGlsZFZhbHVlKVxuXHRcdC8vIGltbWVyIGRlZXAgZnJlZXplcyBwbGFpbiBvYmplY3RzLCBzbyBpZiB0aGVyZSBpcyBubyBwYXJlbnQgc3RhdGUsIHdlIGZyZWV6ZSBhcyB3ZWxsXG5cdFx0aWYgKCFwYXJlbnRTdGF0ZSB8fCAhcGFyZW50U3RhdGUuc2NvcGVfLnBhcmVudF8pXG5cdFx0XHRtYXliZUZyZWV6ZShyb290U2NvcGUsIGNoaWxkVmFsdWUpXG5cdH1cbn1cblxuZnVuY3Rpb24gbWF5YmVGcmVlemUoc2NvcGU6IEltbWVyU2NvcGUsIHZhbHVlOiBhbnksIGRlZXAgPSBmYWxzZSkge1xuXHQvLyB3ZSBuZXZlciBmcmVlemUgZm9yIGEgbm9uLXJvb3Qgc2NvcGU7IGFzIGl0IHdvdWxkIHByZXZlbnQgcHJ1bmluZyBmb3IgZHJhZnRzIGluc2lkZSB3cmFwcGluZyBvYmplY3RzXG5cdGlmICghc2NvcGUucGFyZW50XyAmJiBzY29wZS5pbW1lcl8uYXV0b0ZyZWV6ZV8gJiYgc2NvcGUuY2FuQXV0b0ZyZWV6ZV8pIHtcblx0XHRmcmVlemUodmFsdWUsIGRlZXApXG5cdH1cbn1cbiIsImltcG9ydCB7XG5cdGVhY2gsXG5cdGhhcyxcblx0aXMsXG5cdGlzRHJhZnRhYmxlLFxuXHRzaGFsbG93Q29weSxcblx0bGF0ZXN0LFxuXHRJbW1lckJhc2VTdGF0ZSxcblx0SW1tZXJTdGF0ZSxcblx0RHJhZnRlZCxcblx0QW55T2JqZWN0LFxuXHRBbnlBcnJheSxcblx0T2JqZWN0aXNoLFxuXHRnZXRDdXJyZW50U2NvcGUsXG5cdERSQUZUX1NUQVRFLFxuXHRkaWUsXG5cdGNyZWF0ZVByb3h5LFxuXHRQcm94eVR5cGVcbn0gZnJvbSBcIi4uL2ludGVybmFsXCJcblxuaW50ZXJmYWNlIFByb3h5QmFzZVN0YXRlIGV4dGVuZHMgSW1tZXJCYXNlU3RhdGUge1xuXHRhc3NpZ25lZF86IHtcblx0XHRbcHJvcGVydHk6IHN0cmluZ106IGJvb2xlYW5cblx0fVxuXHRwYXJlbnRfPzogSW1tZXJTdGF0ZVxuXHRyZXZva2VfKCk6IHZvaWRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm94eU9iamVjdFN0YXRlIGV4dGVuZHMgUHJveHlCYXNlU3RhdGUge1xuXHR0eXBlXzogUHJveHlUeXBlLlByb3h5T2JqZWN0XG5cdGJhc2VfOiBhbnlcblx0Y29weV86IGFueVxuXHRkcmFmdF86IERyYWZ0ZWQ8QW55T2JqZWN0LCBQcm94eU9iamVjdFN0YXRlPlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb3h5QXJyYXlTdGF0ZSBleHRlbmRzIFByb3h5QmFzZVN0YXRlIHtcblx0dHlwZV86IFByb3h5VHlwZS5Qcm94eUFycmF5XG5cdGJhc2VfOiBBbnlBcnJheVxuXHRjb3B5XzogQW55QXJyYXkgfCBudWxsXG5cdGRyYWZ0XzogRHJhZnRlZDxBbnlBcnJheSwgUHJveHlBcnJheVN0YXRlPlxufVxuXG50eXBlIFByb3h5U3RhdGUgPSBQcm94eU9iamVjdFN0YXRlIHwgUHJveHlBcnJheVN0YXRlXG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBkcmFmdCBvZiB0aGUgYGJhc2VgIG9iamVjdC5cbiAqXG4gKiBUaGUgc2Vjb25kIGFyZ3VtZW50IGlzIHRoZSBwYXJlbnQgZHJhZnQtc3RhdGUgKHVzZWQgaW50ZXJuYWxseSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQcm94eVByb3h5PFQgZXh0ZW5kcyBPYmplY3Rpc2g+KFxuXHRiYXNlOiBULFxuXHRwYXJlbnQ/OiBJbW1lclN0YXRlXG4pOiBEcmFmdGVkPFQsIFByb3h5U3RhdGU+IHtcblx0Y29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoYmFzZSlcblx0Y29uc3Qgc3RhdGU6IFByb3h5U3RhdGUgPSB7XG5cdFx0dHlwZV86IGlzQXJyYXkgPyBQcm94eVR5cGUuUHJveHlBcnJheSA6IChQcm94eVR5cGUuUHJveHlPYmplY3QgYXMgYW55KSxcblx0XHQvLyBUcmFjayB3aGljaCBwcm9kdWNlIGNhbGwgdGhpcyBpcyBhc3NvY2lhdGVkIHdpdGguXG5cdFx0c2NvcGVfOiBwYXJlbnQgPyBwYXJlbnQuc2NvcGVfIDogZ2V0Q3VycmVudFNjb3BlKCkhLFxuXHRcdC8vIFRydWUgZm9yIGJvdGggc2hhbGxvdyBhbmQgZGVlcCBjaGFuZ2VzLlxuXHRcdG1vZGlmaWVkXzogZmFsc2UsXG5cdFx0Ly8gVXNlZCBkdXJpbmcgZmluYWxpemF0aW9uLlxuXHRcdGZpbmFsaXplZF86IGZhbHNlLFxuXHRcdC8vIFRyYWNrIHdoaWNoIHByb3BlcnRpZXMgaGF2ZSBiZWVuIGFzc2lnbmVkICh0cnVlKSBvciBkZWxldGVkIChmYWxzZSkuXG5cdFx0YXNzaWduZWRfOiB7fSxcblx0XHQvLyBUaGUgcGFyZW50IGRyYWZ0IHN0YXRlLlxuXHRcdHBhcmVudF86IHBhcmVudCxcblx0XHQvLyBUaGUgYmFzZSBzdGF0ZS5cblx0XHRiYXNlXzogYmFzZSxcblx0XHQvLyBUaGUgYmFzZSBwcm94eS5cblx0XHRkcmFmdF86IG51bGwgYXMgYW55LCAvLyBzZXQgYmVsb3dcblx0XHQvLyBUaGUgYmFzZSBjb3B5IHdpdGggYW55IHVwZGF0ZWQgdmFsdWVzLlxuXHRcdGNvcHlfOiBudWxsLFxuXHRcdC8vIENhbGxlZCBieSB0aGUgYHByb2R1Y2VgIGZ1bmN0aW9uLlxuXHRcdHJldm9rZV86IG51bGwgYXMgYW55LFxuXHRcdGlzTWFudWFsXzogZmFsc2Vcblx0fVxuXG5cdC8vIHRoZSB0cmFwcyBtdXN0IHRhcmdldCBzb21ldGhpbmcsIGEgYml0IGxpa2UgdGhlICdyZWFsJyBiYXNlLlxuXHQvLyBidXQgYWxzbywgd2UgbmVlZCB0byBiZSBhYmxlIHRvIGRldGVybWluZSBmcm9tIHRoZSB0YXJnZXQgd2hhdCB0aGUgcmVsZXZhbnQgc3RhdGUgaXNcblx0Ly8gKHRvIGF2b2lkIGNyZWF0aW5nIHRyYXBzIHBlciBpbnN0YW5jZSB0byBjYXB0dXJlIHRoZSBzdGF0ZSBpbiBjbG9zdXJlLFxuXHQvLyBhbmQgdG8gYXZvaWQgY3JlYXRpbmcgd2VpcmQgaGlkZGVuIHByb3BlcnRpZXMgYXMgd2VsbClcblx0Ly8gU28gdGhlIHRyaWNrIGlzIHRvIHVzZSAnc3RhdGUnIGFzIHRoZSBhY3R1YWwgJ3RhcmdldCchIChhbmQgbWFrZSBzdXJlIHdlIGludGVyY2VwdCBldmVyeXRoaW5nKVxuXHQvLyBOb3RlIHRoYXQgaW4gdGhlIGNhc2Ugb2YgYW4gYXJyYXksIHdlIHB1dCB0aGUgc3RhdGUgaW4gYW4gYXJyYXkgdG8gaGF2ZSBiZXR0ZXIgUmVmbGVjdCBkZWZhdWx0cyBvb3RiXG5cdGxldCB0YXJnZXQ6IFQgPSBzdGF0ZSBhcyBhbnlcblx0bGV0IHRyYXBzOiBQcm94eUhhbmRsZXI8b2JqZWN0IHwgQXJyYXk8YW55Pj4gPSBvYmplY3RUcmFwc1xuXHRpZiAoaXNBcnJheSkge1xuXHRcdHRhcmdldCA9IFtzdGF0ZV0gYXMgYW55XG5cdFx0dHJhcHMgPSBhcnJheVRyYXBzXG5cdH1cblxuXHRjb25zdCB7cmV2b2tlLCBwcm94eX0gPSBQcm94eS5yZXZvY2FibGUodGFyZ2V0LCB0cmFwcylcblx0c3RhdGUuZHJhZnRfID0gcHJveHkgYXMgYW55XG5cdHN0YXRlLnJldm9rZV8gPSByZXZva2Vcblx0cmV0dXJuIHByb3h5IGFzIGFueVxufVxuXG4vKipcbiAqIE9iamVjdCBkcmFmdHNcbiAqL1xuZXhwb3J0IGNvbnN0IG9iamVjdFRyYXBzOiBQcm94eUhhbmRsZXI8UHJveHlTdGF0ZT4gPSB7XG5cdGdldChzdGF0ZSwgcHJvcCkge1xuXHRcdGlmIChwcm9wID09PSBEUkFGVF9TVEFURSkgcmV0dXJuIHN0YXRlXG5cblx0XHRjb25zdCBzb3VyY2UgPSBsYXRlc3Qoc3RhdGUpXG5cdFx0aWYgKCFoYXMoc291cmNlLCBwcm9wKSkge1xuXHRcdFx0Ly8gbm9uLWV4aXN0aW5nIG9yIG5vbi1vd24gcHJvcGVydHkuLi5cblx0XHRcdHJldHVybiByZWFkUHJvcEZyb21Qcm90byhzdGF0ZSwgc291cmNlLCBwcm9wKVxuXHRcdH1cblx0XHRjb25zdCB2YWx1ZSA9IHNvdXJjZVtwcm9wXVxuXHRcdGlmIChzdGF0ZS5maW5hbGl6ZWRfIHx8ICFpc0RyYWZ0YWJsZSh2YWx1ZSkpIHtcblx0XHRcdHJldHVybiB2YWx1ZVxuXHRcdH1cblx0XHQvLyBDaGVjayBmb3IgZXhpc3RpbmcgZHJhZnQgaW4gbW9kaWZpZWQgc3RhdGUuXG5cdFx0Ly8gQXNzaWduZWQgdmFsdWVzIGFyZSBuZXZlciBkcmFmdGVkLiBUaGlzIGNhdGNoZXMgYW55IGRyYWZ0cyB3ZSBjcmVhdGVkLCB0b28uXG5cdFx0aWYgKHZhbHVlID09PSBwZWVrKHN0YXRlLmJhc2VfLCBwcm9wKSkge1xuXHRcdFx0cHJlcGFyZUNvcHkoc3RhdGUpXG5cdFx0XHRyZXR1cm4gKHN0YXRlLmNvcHlfIVtwcm9wIGFzIGFueV0gPSBjcmVhdGVQcm94eShcblx0XHRcdFx0c3RhdGUuc2NvcGVfLmltbWVyXyxcblx0XHRcdFx0dmFsdWUsXG5cdFx0XHRcdHN0YXRlXG5cdFx0XHQpKVxuXHRcdH1cblx0XHRyZXR1cm4gdmFsdWVcblx0fSxcblx0aGFzKHN0YXRlLCBwcm9wKSB7XG5cdFx0cmV0dXJuIHByb3AgaW4gbGF0ZXN0KHN0YXRlKVxuXHR9LFxuXHRvd25LZXlzKHN0YXRlKSB7XG5cdFx0cmV0dXJuIFJlZmxlY3Qub3duS2V5cyhsYXRlc3Qoc3RhdGUpKVxuXHR9LFxuXHRzZXQoXG5cdFx0c3RhdGU6IFByb3h5T2JqZWN0U3RhdGUsXG5cdFx0cHJvcDogc3RyaW5nIC8qIHN0cmljdGx5IG5vdCwgYnV0IGhlbHBzIFRTICovLFxuXHRcdHZhbHVlXG5cdCkge1xuXHRcdGNvbnN0IGRlc2MgPSBnZXREZXNjcmlwdG9yRnJvbVByb3RvKGxhdGVzdChzdGF0ZSksIHByb3ApXG5cdFx0aWYgKGRlc2M/LnNldCkge1xuXHRcdFx0Ly8gc3BlY2lhbCBjYXNlOiBpZiB0aGlzIHdyaXRlIGlzIGNhcHR1cmVkIGJ5IGEgc2V0dGVyLCB3ZSBoYXZlXG5cdFx0XHQvLyB0byB0cmlnZ2VyIGl0IHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuXHRcdFx0ZGVzYy5zZXQuY2FsbChzdGF0ZS5kcmFmdF8sIHZhbHVlKVxuXHRcdFx0cmV0dXJuIHRydWVcblx0XHR9XG5cdFx0aWYgKCFzdGF0ZS5tb2RpZmllZF8pIHtcblx0XHRcdC8vIHRoZSBsYXN0IGNoZWNrIGlzIGJlY2F1c2Ugd2UgbmVlZCB0byBiZSBhYmxlIHRvIGRpc3Rpbmd1aXNoIHNldHRpbmcgYSBub24tZXhpc3RpbmcgdG8gdW5kZWZpbmVkICh3aGljaCBpcyBhIGNoYW5nZSlcblx0XHRcdC8vIGZyb20gc2V0dGluZyBhbiBleGlzdGluZyBwcm9wZXJ0eSB3aXRoIHZhbHVlIHVuZGVmaW5lZCB0byB1bmRlZmluZWQgKHdoaWNoIGlzIG5vdCBhIGNoYW5nZSlcblx0XHRcdGNvbnN0IGN1cnJlbnQgPSBwZWVrKGxhdGVzdChzdGF0ZSksIHByb3ApXG5cdFx0XHQvLyBzcGVjaWFsIGNhc2UsIGlmIHdlIGFzc2lnbmluZyB0aGUgb3JpZ2luYWwgdmFsdWUgdG8gYSBkcmFmdCwgd2UgY2FuIGlnbm9yZSB0aGUgYXNzaWdubWVudFxuXHRcdFx0Y29uc3QgY3VycmVudFN0YXRlOiBQcm94eU9iamVjdFN0YXRlID0gY3VycmVudD8uW0RSQUZUX1NUQVRFXVxuXHRcdFx0aWYgKGN1cnJlbnRTdGF0ZSAmJiBjdXJyZW50U3RhdGUuYmFzZV8gPT09IHZhbHVlKSB7XG5cdFx0XHRcdHN0YXRlLmNvcHlfIVtwcm9wXSA9IHZhbHVlXG5cdFx0XHRcdHN0YXRlLmFzc2lnbmVkX1twcm9wXSA9IGZhbHNlXG5cdFx0XHRcdHJldHVybiB0cnVlXG5cdFx0XHR9XG5cdFx0XHRpZiAoaXModmFsdWUsIGN1cnJlbnQpICYmICh2YWx1ZSAhPT0gdW5kZWZpbmVkIHx8IGhhcyhzdGF0ZS5iYXNlXywgcHJvcCkpKVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdFx0cHJlcGFyZUNvcHkoc3RhdGUpXG5cdFx0XHRtYXJrQ2hhbmdlZChzdGF0ZSlcblx0XHR9XG5cblx0XHRpZiAoXG5cdFx0XHQoc3RhdGUuY29weV8hW3Byb3BdID09PSB2YWx1ZSAmJlxuXHRcdFx0XHQvLyBzcGVjaWFsIGNhc2U6IGhhbmRsZSBuZXcgcHJvcHMgd2l0aCB2YWx1ZSAndW5kZWZpbmVkJ1xuXHRcdFx0XHQodmFsdWUgIT09IHVuZGVmaW5lZCB8fCBwcm9wIGluIHN0YXRlLmNvcHlfKSkgfHxcblx0XHRcdC8vIHNwZWNpYWwgY2FzZTogTmFOXG5cdFx0XHQoTnVtYmVyLmlzTmFOKHZhbHVlKSAmJiBOdW1iZXIuaXNOYU4oc3RhdGUuY29weV8hW3Byb3BdKSlcblx0XHQpXG5cdFx0XHRyZXR1cm4gdHJ1ZVxuXG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHN0YXRlLmNvcHlfIVtwcm9wXSA9IHZhbHVlXG5cdFx0c3RhdGUuYXNzaWduZWRfW3Byb3BdID0gdHJ1ZVxuXHRcdHJldHVybiB0cnVlXG5cdH0sXG5cdGRlbGV0ZVByb3BlcnR5KHN0YXRlLCBwcm9wOiBzdHJpbmcpIHtcblx0XHQvLyBUaGUgYHVuZGVmaW5lZGAgY2hlY2sgaXMgYSBmYXN0IHBhdGggZm9yIHByZS1leGlzdGluZyBrZXlzLlxuXHRcdGlmIChwZWVrKHN0YXRlLmJhc2VfLCBwcm9wKSAhPT0gdW5kZWZpbmVkIHx8IHByb3AgaW4gc3RhdGUuYmFzZV8pIHtcblx0XHRcdHN0YXRlLmFzc2lnbmVkX1twcm9wXSA9IGZhbHNlXG5cdFx0XHRwcmVwYXJlQ29weShzdGF0ZSlcblx0XHRcdG1hcmtDaGFuZ2VkKHN0YXRlKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpZiBhbiBvcmlnaW5hbGx5IG5vdCBhc3NpZ25lZCBwcm9wZXJ0eSB3YXMgZGVsZXRlZFxuXHRcdFx0ZGVsZXRlIHN0YXRlLmFzc2lnbmVkX1twcm9wXVxuXHRcdH1cblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0aWYgKHN0YXRlLmNvcHlfKSBkZWxldGUgc3RhdGUuY29weV9bcHJvcF1cblx0XHRyZXR1cm4gdHJ1ZVxuXHR9LFxuXHQvLyBOb3RlOiBXZSBuZXZlciBjb2VyY2UgYGRlc2MudmFsdWVgIGludG8gYW4gSW1tZXIgZHJhZnQsIGJlY2F1c2Ugd2UgY2FuJ3QgbWFrZVxuXHQvLyB0aGUgc2FtZSBndWFyYW50ZWUgaW4gRVM1IG1vZGUuXG5cdGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzdGF0ZSwgcHJvcCkge1xuXHRcdGNvbnN0IG93bmVyID0gbGF0ZXN0KHN0YXRlKVxuXHRcdGNvbnN0IGRlc2MgPSBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvd25lciwgcHJvcClcblx0XHRpZiAoIWRlc2MpIHJldHVybiBkZXNjXG5cdFx0cmV0dXJuIHtcblx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiBzdGF0ZS50eXBlXyAhPT0gUHJveHlUeXBlLlByb3h5QXJyYXkgfHwgcHJvcCAhPT0gXCJsZW5ndGhcIixcblx0XHRcdGVudW1lcmFibGU6IGRlc2MuZW51bWVyYWJsZSxcblx0XHRcdHZhbHVlOiBvd25lcltwcm9wXVxuXHRcdH1cblx0fSxcblx0ZGVmaW5lUHJvcGVydHkoKSB7XG5cdFx0ZGllKDExKVxuXHR9LFxuXHRnZXRQcm90b3R5cGVPZihzdGF0ZSkge1xuXHRcdHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc3RhdGUuYmFzZV8pXG5cdH0sXG5cdHNldFByb3RvdHlwZU9mKCkge1xuXHRcdGRpZSgxMilcblx0fVxufVxuXG4vKipcbiAqIEFycmF5IGRyYWZ0c1xuICovXG5cbmNvbnN0IGFycmF5VHJhcHM6IFByb3h5SGFuZGxlcjxbUHJveHlBcnJheVN0YXRlXT4gPSB7fVxuZWFjaChvYmplY3RUcmFwcywgKGtleSwgZm4pID0+IHtcblx0Ly8gQHRzLWlnbm9yZVxuXHRhcnJheVRyYXBzW2tleV0gPSBmdW5jdGlvbigpIHtcblx0XHRhcmd1bWVudHNbMF0gPSBhcmd1bWVudHNbMF1bMF1cblx0XHRyZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuXHR9XG59KVxuYXJyYXlUcmFwcy5kZWxldGVQcm9wZXJ0eSA9IGZ1bmN0aW9uKHN0YXRlLCBwcm9wKSB7XG5cdGlmIChfX0RFVl9fICYmIGlzTmFOKHBhcnNlSW50KHByb3AgYXMgYW55KSkpIGRpZSgxMylcblx0Ly8gQHRzLWlnbm9yZVxuXHRyZXR1cm4gYXJyYXlUcmFwcy5zZXQhLmNhbGwodGhpcywgc3RhdGUsIHByb3AsIHVuZGVmaW5lZClcbn1cbmFycmF5VHJhcHMuc2V0ID0gZnVuY3Rpb24oc3RhdGUsIHByb3AsIHZhbHVlKSB7XG5cdGlmIChfX0RFVl9fICYmIHByb3AgIT09IFwibGVuZ3RoXCIgJiYgaXNOYU4ocGFyc2VJbnQocHJvcCBhcyBhbnkpKSkgZGllKDE0KVxuXHRyZXR1cm4gb2JqZWN0VHJhcHMuc2V0IS5jYWxsKHRoaXMsIHN0YXRlWzBdLCBwcm9wLCB2YWx1ZSwgc3RhdGVbMF0pXG59XG5cbi8vIEFjY2VzcyBhIHByb3BlcnR5IHdpdGhvdXQgY3JlYXRpbmcgYW4gSW1tZXIgZHJhZnQuXG5mdW5jdGlvbiBwZWVrKGRyYWZ0OiBEcmFmdGVkLCBwcm9wOiBQcm9wZXJ0eUtleSkge1xuXHRjb25zdCBzdGF0ZSA9IGRyYWZ0W0RSQUZUX1NUQVRFXVxuXHRjb25zdCBzb3VyY2UgPSBzdGF0ZSA/IGxhdGVzdChzdGF0ZSkgOiBkcmFmdFxuXHRyZXR1cm4gc291cmNlW3Byb3BdXG59XG5cbmZ1bmN0aW9uIHJlYWRQcm9wRnJvbVByb3RvKHN0YXRlOiBJbW1lclN0YXRlLCBzb3VyY2U6IGFueSwgcHJvcDogUHJvcGVydHlLZXkpIHtcblx0Y29uc3QgZGVzYyA9IGdldERlc2NyaXB0b3JGcm9tUHJvdG8oc291cmNlLCBwcm9wKVxuXHRyZXR1cm4gZGVzY1xuXHRcdD8gYHZhbHVlYCBpbiBkZXNjXG5cdFx0XHQ/IGRlc2MudmFsdWVcblx0XHRcdDogLy8gVGhpcyBpcyBhIHZlcnkgc3BlY2lhbCBjYXNlLCBpZiB0aGUgcHJvcCBpcyBhIGdldHRlciBkZWZpbmVkIGJ5IHRoZVxuXHRcdFx0ICAvLyBwcm90b3R5cGUsIHdlIHNob3VsZCBpbnZva2UgaXQgd2l0aCB0aGUgZHJhZnQgYXMgY29udGV4dCFcblx0XHRcdCAgZGVzYy5nZXQ/LmNhbGwoc3RhdGUuZHJhZnRfKVxuXHRcdDogdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGdldERlc2NyaXB0b3JGcm9tUHJvdG8oXG5cdHNvdXJjZTogYW55LFxuXHRwcm9wOiBQcm9wZXJ0eUtleVxuKTogUHJvcGVydHlEZXNjcmlwdG9yIHwgdW5kZWZpbmVkIHtcblx0Ly8gJ2luJyBjaGVja3MgcHJvdG8hXG5cdGlmICghKHByb3AgaW4gc291cmNlKSkgcmV0dXJuIHVuZGVmaW5lZFxuXHRsZXQgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc291cmNlKVxuXHR3aGlsZSAocHJvdG8pIHtcblx0XHRjb25zdCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90bywgcHJvcClcblx0XHRpZiAoZGVzYykgcmV0dXJuIGRlc2Ncblx0XHRwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bylcblx0fVxuXHRyZXR1cm4gdW5kZWZpbmVkXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXJrQ2hhbmdlZChzdGF0ZTogSW1tZXJTdGF0ZSkge1xuXHRpZiAoIXN0YXRlLm1vZGlmaWVkXykge1xuXHRcdHN0YXRlLm1vZGlmaWVkXyA9IHRydWVcblx0XHRpZiAoc3RhdGUucGFyZW50Xykge1xuXHRcdFx0bWFya0NoYW5nZWQoc3RhdGUucGFyZW50Xylcblx0XHR9XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByZXBhcmVDb3B5KHN0YXRlOiB7YmFzZV86IGFueTsgY29weV86IGFueX0pIHtcblx0aWYgKCFzdGF0ZS5jb3B5Xykge1xuXHRcdHN0YXRlLmNvcHlfID0gc2hhbGxvd0NvcHkoc3RhdGUuYmFzZV8pXG5cdH1cbn1cbiIsImltcG9ydCB7XG5cdElQcm9kdWNlV2l0aFBhdGNoZXMsXG5cdElQcm9kdWNlLFxuXHRJbW1lclN0YXRlLFxuXHREcmFmdGVkLFxuXHRpc0RyYWZ0YWJsZSxcblx0cHJvY2Vzc1Jlc3VsdCxcblx0UGF0Y2gsXG5cdE9iamVjdGlzaCxcblx0RFJBRlRfU1RBVEUsXG5cdERyYWZ0LFxuXHRQYXRjaExpc3RlbmVyLFxuXHRpc0RyYWZ0LFxuXHRpc01hcCxcblx0aXNTZXQsXG5cdGNyZWF0ZVByb3h5UHJveHksXG5cdGdldFBsdWdpbixcblx0ZGllLFxuXHRoYXNQcm94aWVzLFxuXHRlbnRlclNjb3BlLFxuXHRyZXZva2VTY29wZSxcblx0bGVhdmVTY29wZSxcblx0dXNlUGF0Y2hlc0luU2NvcGUsXG5cdGdldEN1cnJlbnRTY29wZSxcblx0Tk9USElORyxcblx0ZnJlZXplLFxuXHRjdXJyZW50XG59IGZyb20gXCIuLi9pbnRlcm5hbFwiXG5cbmludGVyZmFjZSBQcm9kdWNlcnNGbnMge1xuXHRwcm9kdWNlOiBJUHJvZHVjZVxuXHRwcm9kdWNlV2l0aFBhdGNoZXM6IElQcm9kdWNlV2l0aFBhdGNoZXNcbn1cblxuZXhwb3J0IGNsYXNzIEltbWVyIGltcGxlbWVudHMgUHJvZHVjZXJzRm5zIHtcblx0dXNlUHJveGllc186IGJvb2xlYW4gPSBoYXNQcm94aWVzXG5cblx0YXV0b0ZyZWV6ZV86IGJvb2xlYW4gPSB0cnVlXG5cblx0Y29uc3RydWN0b3IoY29uZmlnPzoge3VzZVByb3hpZXM/OiBib29sZWFuOyBhdXRvRnJlZXplPzogYm9vbGVhbn0pIHtcblx0XHRpZiAodHlwZW9mIGNvbmZpZz8udXNlUHJveGllcyA9PT0gXCJib29sZWFuXCIpXG5cdFx0XHR0aGlzLnNldFVzZVByb3hpZXMoY29uZmlnIS51c2VQcm94aWVzKVxuXHRcdGlmICh0eXBlb2YgY29uZmlnPy5hdXRvRnJlZXplID09PSBcImJvb2xlYW5cIilcblx0XHRcdHRoaXMuc2V0QXV0b0ZyZWV6ZShjb25maWchLmF1dG9GcmVlemUpXG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwcm9kdWNlYCBmdW5jdGlvbiB0YWtlcyBhIHZhbHVlIGFuZCBhIFwicmVjaXBlIGZ1bmN0aW9uXCIgKHdob3NlXG5cdCAqIHJldHVybiB2YWx1ZSBvZnRlbiBkZXBlbmRzIG9uIHRoZSBiYXNlIHN0YXRlKS4gVGhlIHJlY2lwZSBmdW5jdGlvbiBpc1xuXHQgKiBmcmVlIHRvIG11dGF0ZSBpdHMgZmlyc3QgYXJndW1lbnQgaG93ZXZlciBpdCB3YW50cy4gQWxsIG11dGF0aW9ucyBhcmVcblx0ICogb25seSBldmVyIGFwcGxpZWQgdG8gYSBfX2NvcHlfXyBvZiB0aGUgYmFzZSBzdGF0ZS5cblx0ICpcblx0ICogUGFzcyBvbmx5IGEgZnVuY3Rpb24gdG8gY3JlYXRlIGEgXCJjdXJyaWVkIHByb2R1Y2VyXCIgd2hpY2ggcmVsaWV2ZXMgeW91XG5cdCAqIGZyb20gcGFzc2luZyB0aGUgcmVjaXBlIGZ1bmN0aW9uIGV2ZXJ5IHRpbWUuXG5cdCAqXG5cdCAqIE9ubHkgcGxhaW4gb2JqZWN0cyBhbmQgYXJyYXlzIGFyZSBtYWRlIG11dGFibGUuIEFsbCBvdGhlciBvYmplY3RzIGFyZVxuXHQgKiBjb25zaWRlcmVkIHVuY29weWFibGUuXG5cdCAqXG5cdCAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgX19ib3VuZF9fIHRvIGl0cyBgSW1tZXJgIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge2FueX0gYmFzZSAtIHRoZSBpbml0aWFsIHN0YXRlXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IHJlY2lwZSAtIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgYSBwcm94eSBvZiB0aGUgYmFzZSBzdGF0ZSBhcyBmaXJzdCBhcmd1bWVudCBhbmQgd2hpY2ggY2FuIGJlIGZyZWVseSBtb2RpZmllZFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwYXRjaExpc3RlbmVyIC0gb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGFsbCB0aGUgcGF0Y2hlcyBwcm9kdWNlZCBoZXJlXG5cdCAqIEByZXR1cm5zIHthbnl9IGEgbmV3IHN0YXRlLCBvciB0aGUgaW5pdGlhbCBzdGF0ZSBpZiBub3RoaW5nIHdhcyBtb2RpZmllZFxuXHQgKi9cblx0cHJvZHVjZTogSVByb2R1Y2UgPSAoYmFzZTogYW55LCByZWNpcGU/OiBhbnksIHBhdGNoTGlzdGVuZXI/OiBhbnkpID0+IHtcblx0XHQvLyBjdXJyaWVkIGludm9jYXRpb25cblx0XHRpZiAodHlwZW9mIGJhc2UgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgcmVjaXBlICE9PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdGNvbnN0IGRlZmF1bHRCYXNlID0gcmVjaXBlXG5cdFx0XHRyZWNpcGUgPSBiYXNlXG5cblx0XHRcdGNvbnN0IHNlbGYgPSB0aGlzXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gY3VycmllZFByb2R1Y2UoXG5cdFx0XHRcdHRoaXM6IGFueSxcblx0XHRcdFx0YmFzZSA9IGRlZmF1bHRCYXNlLFxuXHRcdFx0XHQuLi5hcmdzOiBhbnlbXVxuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybiBzZWxmLnByb2R1Y2UoYmFzZSwgKGRyYWZ0OiBEcmFmdGVkKSA9PiByZWNpcGUuY2FsbCh0aGlzLCBkcmFmdCwgLi4uYXJncykpIC8vIHByZXR0aWVyLWlnbm9yZVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YgcmVjaXBlICE9PSBcImZ1bmN0aW9uXCIpIGRpZSg2KVxuXHRcdGlmIChwYXRjaExpc3RlbmVyICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHBhdGNoTGlzdGVuZXIgIT09IFwiZnVuY3Rpb25cIilcblx0XHRcdGRpZSg3KVxuXG5cdFx0bGV0IHJlc3VsdFxuXG5cdFx0Ly8gT25seSBwbGFpbiBvYmplY3RzLCBhcnJheXMsIGFuZCBcImltbWVyYWJsZSBjbGFzc2VzXCIgYXJlIGRyYWZ0ZWQuXG5cdFx0aWYgKGlzRHJhZnRhYmxlKGJhc2UpKSB7XG5cdFx0XHRjb25zdCBzY29wZSA9IGVudGVyU2NvcGUodGhpcylcblx0XHRcdGNvbnN0IHByb3h5ID0gY3JlYXRlUHJveHkodGhpcywgYmFzZSwgdW5kZWZpbmVkKVxuXHRcdFx0bGV0IGhhc0Vycm9yID0gdHJ1ZVxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmVzdWx0ID0gcmVjaXBlKHByb3h5KVxuXHRcdFx0XHRoYXNFcnJvciA9IGZhbHNlXG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHQvLyBmaW5hbGx5IGluc3RlYWQgb2YgY2F0Y2ggKyByZXRocm93IGJldHRlciBwcmVzZXJ2ZXMgb3JpZ2luYWwgc3RhY2tcblx0XHRcdFx0aWYgKGhhc0Vycm9yKSByZXZva2VTY29wZShzY29wZSlcblx0XHRcdFx0ZWxzZSBsZWF2ZVNjb3BlKHNjb3BlKVxuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiICYmIHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdC50aGVuKFxuXHRcdFx0XHRcdHJlc3VsdCA9PiB7XG5cdFx0XHRcdFx0XHR1c2VQYXRjaGVzSW5TY29wZShzY29wZSwgcGF0Y2hMaXN0ZW5lcilcblx0XHRcdFx0XHRcdHJldHVybiBwcm9jZXNzUmVzdWx0KHJlc3VsdCwgc2NvcGUpXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRlcnJvciA9PiB7XG5cdFx0XHRcdFx0XHRyZXZva2VTY29wZShzY29wZSlcblx0XHRcdFx0XHRcdHRocm93IGVycm9yXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpXG5cdFx0XHR9XG5cdFx0XHR1c2VQYXRjaGVzSW5TY29wZShzY29wZSwgcGF0Y2hMaXN0ZW5lcilcblx0XHRcdHJldHVybiBwcm9jZXNzUmVzdWx0KHJlc3VsdCwgc2NvcGUpXG5cdFx0fSBlbHNlIGlmICghYmFzZSB8fCB0eXBlb2YgYmFzZSAhPT0gXCJvYmplY3RcIikge1xuXHRcdFx0cmVzdWx0ID0gcmVjaXBlKGJhc2UpXG5cdFx0XHRpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHJlc3VsdCA9IGJhc2Vcblx0XHRcdGlmIChyZXN1bHQgPT09IE5PVEhJTkcpIHJlc3VsdCA9IHVuZGVmaW5lZFxuXHRcdFx0aWYgKHRoaXMuYXV0b0ZyZWV6ZV8pIGZyZWV6ZShyZXN1bHQsIHRydWUpXG5cdFx0XHRpZiAocGF0Y2hMaXN0ZW5lcikge1xuXHRcdFx0XHRjb25zdCBwOiBQYXRjaFtdID0gW11cblx0XHRcdFx0Y29uc3QgaXA6IFBhdGNoW10gPSBbXVxuXHRcdFx0XHRnZXRQbHVnaW4oXCJQYXRjaGVzXCIpLmdlbmVyYXRlUmVwbGFjZW1lbnRQYXRjaGVzXyhiYXNlLCByZXN1bHQsIHAsIGlwKVxuXHRcdFx0XHRwYXRjaExpc3RlbmVyKHAsIGlwKVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdFxuXHRcdH0gZWxzZSBkaWUoMjEsIGJhc2UpXG5cdH1cblxuXHRwcm9kdWNlV2l0aFBhdGNoZXM6IElQcm9kdWNlV2l0aFBhdGNoZXMgPSAoYmFzZTogYW55LCByZWNpcGU/OiBhbnkpOiBhbnkgPT4ge1xuXHRcdC8vIGN1cnJpZWQgaW52b2NhdGlvblxuXHRcdGlmICh0eXBlb2YgYmFzZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRyZXR1cm4gKHN0YXRlOiBhbnksIC4uLmFyZ3M6IGFueVtdKSA9PlxuXHRcdFx0XHR0aGlzLnByb2R1Y2VXaXRoUGF0Y2hlcyhzdGF0ZSwgKGRyYWZ0OiBhbnkpID0+IGJhc2UoZHJhZnQsIC4uLmFyZ3MpKVxuXHRcdH1cblxuXHRcdGxldCBwYXRjaGVzOiBQYXRjaFtdLCBpbnZlcnNlUGF0Y2hlczogUGF0Y2hbXVxuXHRcdGNvbnN0IHJlc3VsdCA9IHRoaXMucHJvZHVjZShiYXNlLCByZWNpcGUsIChwOiBQYXRjaFtdLCBpcDogUGF0Y2hbXSkgPT4ge1xuXHRcdFx0cGF0Y2hlcyA9IHBcblx0XHRcdGludmVyc2VQYXRjaGVzID0gaXBcblx0XHR9KVxuXG5cdFx0aWYgKHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiICYmIHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcblx0XHRcdHJldHVybiByZXN1bHQudGhlbihuZXh0U3RhdGUgPT4gW25leHRTdGF0ZSwgcGF0Y2hlcyEsIGludmVyc2VQYXRjaGVzIV0pXG5cdFx0fVxuXHRcdHJldHVybiBbcmVzdWx0LCBwYXRjaGVzISwgaW52ZXJzZVBhdGNoZXMhXVxuXHR9XG5cblx0Y3JlYXRlRHJhZnQ8VCBleHRlbmRzIE9iamVjdGlzaD4oYmFzZTogVCk6IERyYWZ0PFQ+IHtcblx0XHRpZiAoIWlzRHJhZnRhYmxlKGJhc2UpKSBkaWUoOClcblx0XHRpZiAoaXNEcmFmdChiYXNlKSkgYmFzZSA9IGN1cnJlbnQoYmFzZSlcblx0XHRjb25zdCBzY29wZSA9IGVudGVyU2NvcGUodGhpcylcblx0XHRjb25zdCBwcm94eSA9IGNyZWF0ZVByb3h5KHRoaXMsIGJhc2UsIHVuZGVmaW5lZClcblx0XHRwcm94eVtEUkFGVF9TVEFURV0uaXNNYW51YWxfID0gdHJ1ZVxuXHRcdGxlYXZlU2NvcGUoc2NvcGUpXG5cdFx0cmV0dXJuIHByb3h5IGFzIGFueVxuXHR9XG5cblx0ZmluaXNoRHJhZnQ8RCBleHRlbmRzIERyYWZ0PGFueT4+KFxuXHRcdGRyYWZ0OiBELFxuXHRcdHBhdGNoTGlzdGVuZXI/OiBQYXRjaExpc3RlbmVyXG5cdCk6IEQgZXh0ZW5kcyBEcmFmdDxpbmZlciBUPiA/IFQgOiBuZXZlciB7XG5cdFx0Y29uc3Qgc3RhdGU6IEltbWVyU3RhdGUgPSBkcmFmdCAmJiAoZHJhZnQgYXMgYW55KVtEUkFGVF9TVEFURV1cblx0XHRpZiAoX19ERVZfXykge1xuXHRcdFx0aWYgKCFzdGF0ZSB8fCAhc3RhdGUuaXNNYW51YWxfKSBkaWUoOSlcblx0XHRcdGlmIChzdGF0ZS5maW5hbGl6ZWRfKSBkaWUoMTApXG5cdFx0fVxuXHRcdGNvbnN0IHtzY29wZV86IHNjb3BlfSA9IHN0YXRlXG5cdFx0dXNlUGF0Y2hlc0luU2NvcGUoc2NvcGUsIHBhdGNoTGlzdGVuZXIpXG5cdFx0cmV0dXJuIHByb2Nlc3NSZXN1bHQodW5kZWZpbmVkLCBzY29wZSlcblx0fVxuXG5cdC8qKlxuXHQgKiBQYXNzIHRydWUgdG8gYXV0b21hdGljYWxseSBmcmVlemUgYWxsIGNvcGllcyBjcmVhdGVkIGJ5IEltbWVyLlxuXHQgKlxuXHQgKiBCeSBkZWZhdWx0LCBhdXRvLWZyZWV6aW5nIGlzIGVuYWJsZWQuXG5cdCAqL1xuXHRzZXRBdXRvRnJlZXplKHZhbHVlOiBib29sZWFuKSB7XG5cdFx0dGhpcy5hdXRvRnJlZXplXyA9IHZhbHVlXG5cdH1cblxuXHQvKipcblx0ICogUGFzcyB0cnVlIHRvIHVzZSB0aGUgRVMyMDE1IGBQcm94eWAgY2xhc3Mgd2hlbiBjcmVhdGluZyBkcmFmdHMsIHdoaWNoIGlzXG5cdCAqIGFsd2F5cyBmYXN0ZXIgdGhhbiB1c2luZyBFUzUgcHJveGllcy5cblx0ICpcblx0ICogQnkgZGVmYXVsdCwgZmVhdHVyZSBkZXRlY3Rpb24gaXMgdXNlZCwgc28gY2FsbGluZyB0aGlzIGlzIHJhcmVseSBuZWNlc3NhcnkuXG5cdCAqL1xuXHRzZXRVc2VQcm94aWVzKHZhbHVlOiBib29sZWFuKSB7XG5cdFx0aWYgKHZhbHVlICYmICFoYXNQcm94aWVzKSB7XG5cdFx0XHRkaWUoMjApXG5cdFx0fVxuXHRcdHRoaXMudXNlUHJveGllc18gPSB2YWx1ZVxuXHR9XG5cblx0YXBwbHlQYXRjaGVzPFQgZXh0ZW5kcyBPYmplY3Rpc2g+KGJhc2U6IFQsIHBhdGNoZXM6IFBhdGNoW10pOiBUIHtcblx0XHQvLyBJZiBhIHBhdGNoIHJlcGxhY2VzIHRoZSBlbnRpcmUgc3RhdGUsIHRha2UgdGhhdCByZXBsYWNlbWVudCBhcyBiYXNlXG5cdFx0Ly8gYmVmb3JlIGFwcGx5aW5nIHBhdGNoZXNcblx0XHRsZXQgaTogbnVtYmVyXG5cdFx0Zm9yIChpID0gcGF0Y2hlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0Y29uc3QgcGF0Y2ggPSBwYXRjaGVzW2ldXG5cdFx0XHRpZiAocGF0Y2gucGF0aC5sZW5ndGggPT09IDAgJiYgcGF0Y2gub3AgPT09IFwicmVwbGFjZVwiKSB7XG5cdFx0XHRcdGJhc2UgPSBwYXRjaC52YWx1ZVxuXHRcdFx0XHRicmVha1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBJZiB0aGVyZSB3YXMgYSBwYXRjaCB0aGF0IHJlcGxhY2VkIHRoZSBlbnRpcmUgc3RhdGUsIHN0YXJ0IGZyb20gdGhlXG5cdFx0Ly8gcGF0Y2ggYWZ0ZXIgdGhhdC5cblx0XHRpZiAoaSA+IC0xKSB7XG5cdFx0XHRwYXRjaGVzID0gcGF0Y2hlcy5zbGljZShpICsgMSlcblx0XHR9XG5cblx0XHRjb25zdCBhcHBseVBhdGNoZXNJbXBsID0gZ2V0UGx1Z2luKFwiUGF0Y2hlc1wiKS5hcHBseVBhdGNoZXNfXG5cdFx0aWYgKGlzRHJhZnQoYmFzZSkpIHtcblx0XHRcdC8vIE4uQjogbmV2ZXIgaGl0cyBpZiBzb21lIHBhdGNoIGEgcmVwbGFjZW1lbnQsIHBhdGNoZXMgYXJlIG5ldmVyIGRyYWZ0c1xuXHRcdFx0cmV0dXJuIGFwcGx5UGF0Y2hlc0ltcGwoYmFzZSwgcGF0Y2hlcylcblx0XHR9XG5cdFx0Ly8gT3RoZXJ3aXNlLCBwcm9kdWNlIGEgY29weSBvZiB0aGUgYmFzZSBzdGF0ZS5cblx0XHRyZXR1cm4gdGhpcy5wcm9kdWNlKGJhc2UsIChkcmFmdDogRHJhZnRlZCkgPT5cblx0XHRcdGFwcGx5UGF0Y2hlc0ltcGwoZHJhZnQsIHBhdGNoZXMpXG5cdFx0KVxuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQcm94eTxUIGV4dGVuZHMgT2JqZWN0aXNoPihcblx0aW1tZXI6IEltbWVyLFxuXHR2YWx1ZTogVCxcblx0cGFyZW50PzogSW1tZXJTdGF0ZVxuKTogRHJhZnRlZDxULCBJbW1lclN0YXRlPiB7XG5cdC8vIHByZWNvbmRpdGlvbjogY3JlYXRlUHJveHkgc2hvdWxkIGJlIGd1YXJkZWQgYnkgaXNEcmFmdGFibGUsIHNvIHdlIGtub3cgd2UgY2FuIHNhZmVseSBkcmFmdFxuXHRjb25zdCBkcmFmdDogRHJhZnRlZCA9IGlzTWFwKHZhbHVlKVxuXHRcdD8gZ2V0UGx1Z2luKFwiTWFwU2V0XCIpLnByb3h5TWFwXyh2YWx1ZSwgcGFyZW50KVxuXHRcdDogaXNTZXQodmFsdWUpXG5cdFx0PyBnZXRQbHVnaW4oXCJNYXBTZXRcIikucHJveHlTZXRfKHZhbHVlLCBwYXJlbnQpXG5cdFx0OiBpbW1lci51c2VQcm94aWVzX1xuXHRcdD8gY3JlYXRlUHJveHlQcm94eSh2YWx1ZSwgcGFyZW50KVxuXHRcdDogZ2V0UGx1Z2luKFwiRVM1XCIpLmNyZWF0ZUVTNVByb3h5Xyh2YWx1ZSwgcGFyZW50KVxuXG5cdGNvbnN0IHNjb3BlID0gcGFyZW50ID8gcGFyZW50LnNjb3BlXyA6IGdldEN1cnJlbnRTY29wZSgpXG5cdHNjb3BlLmRyYWZ0c18ucHVzaChkcmFmdClcblx0cmV0dXJuIGRyYWZ0XG59XG4iLCJpbXBvcnQge1xuXHRkaWUsXG5cdGlzRHJhZnQsXG5cdHNoYWxsb3dDb3B5LFxuXHRlYWNoLFxuXHREUkFGVF9TVEFURSxcblx0Z2V0LFxuXHRzZXQsXG5cdEltbWVyU3RhdGUsXG5cdGlzRHJhZnRhYmxlLFxuXHRBcmNodHlwZSxcblx0Z2V0QXJjaHR5cGUsXG5cdGdldFBsdWdpblxufSBmcm9tIFwiLi4vaW50ZXJuYWxcIlxuXG4vKiogVGFrZXMgYSBzbmFwc2hvdCBvZiB0aGUgY3VycmVudCBzdGF0ZSBvZiBhIGRyYWZ0IGFuZCBmaW5hbGl6ZXMgaXQgKGJ1dCB3aXRob3V0IGZyZWV6aW5nKS4gVGhpcyBpcyBhIGdyZWF0IHV0aWxpdHkgdG8gcHJpbnQgdGhlIGN1cnJlbnQgc3RhdGUgZHVyaW5nIGRlYnVnZ2luZyAobm8gUHJveGllcyBpbiB0aGUgd2F5KS4gVGhlIG91dHB1dCBvZiBjdXJyZW50IGNhbiBhbHNvIGJlIHNhZmVseSBsZWFrZWQgb3V0c2lkZSB0aGUgcHJvZHVjZXIuICovXG5leHBvcnQgZnVuY3Rpb24gY3VycmVudDxUPih2YWx1ZTogVCk6IFRcbmV4cG9ydCBmdW5jdGlvbiBjdXJyZW50KHZhbHVlOiBhbnkpOiBhbnkge1xuXHRpZiAoIWlzRHJhZnQodmFsdWUpKSBkaWUoMjIsIHZhbHVlKVxuXHRyZXR1cm4gY3VycmVudEltcGwodmFsdWUpXG59XG5cbmZ1bmN0aW9uIGN1cnJlbnRJbXBsKHZhbHVlOiBhbnkpOiBhbnkge1xuXHRpZiAoIWlzRHJhZnRhYmxlKHZhbHVlKSkgcmV0dXJuIHZhbHVlXG5cdGNvbnN0IHN0YXRlOiBJbW1lclN0YXRlIHwgdW5kZWZpbmVkID0gdmFsdWVbRFJBRlRfU1RBVEVdXG5cdGxldCBjb3B5OiBhbnlcblx0Y29uc3QgYXJjaFR5cGUgPSBnZXRBcmNodHlwZSh2YWx1ZSlcblx0aWYgKHN0YXRlKSB7XG5cdFx0aWYgKFxuXHRcdFx0IXN0YXRlLm1vZGlmaWVkXyAmJlxuXHRcdFx0KHN0YXRlLnR5cGVfIDwgNCB8fCAhZ2V0UGx1Z2luKFwiRVM1XCIpLmhhc0NoYW5nZXNfKHN0YXRlIGFzIGFueSkpXG5cdFx0KVxuXHRcdFx0cmV0dXJuIHN0YXRlLmJhc2VfXG5cdFx0Ly8gT3B0aW1pemF0aW9uOiBhdm9pZCBnZW5lcmF0aW5nIG5ldyBkcmFmdHMgZHVyaW5nIGNvcHlpbmdcblx0XHRzdGF0ZS5maW5hbGl6ZWRfID0gdHJ1ZVxuXHRcdGNvcHkgPSBjb3B5SGVscGVyKHZhbHVlLCBhcmNoVHlwZSlcblx0XHRzdGF0ZS5maW5hbGl6ZWRfID0gZmFsc2Vcblx0fSBlbHNlIHtcblx0XHRjb3B5ID0gY29weUhlbHBlcih2YWx1ZSwgYXJjaFR5cGUpXG5cdH1cblxuXHRlYWNoKGNvcHksIChrZXksIGNoaWxkVmFsdWUpID0+IHtcblx0XHRpZiAoc3RhdGUgJiYgZ2V0KHN0YXRlLmJhc2VfLCBrZXkpID09PSBjaGlsZFZhbHVlKSByZXR1cm4gLy8gbm8gbmVlZCB0byBjb3B5IG9yIHNlYXJjaCBpbiBzb21ldGhpbmcgdGhhdCBkaWRuJ3QgY2hhbmdlXG5cdFx0c2V0KGNvcHksIGtleSwgY3VycmVudEltcGwoY2hpbGRWYWx1ZSkpXG5cdH0pXG5cdC8vIEluIHRoZSBmdXR1cmUsIHdlIG1pZ2h0IGNvbnNpZGVyIGZyZWV6aW5nIGhlcmUsIGJhc2VkIG9uIHRoZSBjdXJyZW50IHNldHRpbmdzXG5cdHJldHVybiBhcmNoVHlwZSA9PT0gQXJjaHR5cGUuU2V0ID8gbmV3IFNldChjb3B5KSA6IGNvcHlcbn1cblxuZnVuY3Rpb24gY29weUhlbHBlcih2YWx1ZTogYW55LCBhcmNoVHlwZTogbnVtYmVyKTogYW55IHtcblx0Ly8gY3JlYXRlcyBhIHNoYWxsb3cgY29weSwgZXZlbiBpZiBpdCBpcyBhIG1hcCBvciBzZXRcblx0c3dpdGNoIChhcmNoVHlwZSkge1xuXHRcdGNhc2UgQXJjaHR5cGUuTWFwOlxuXHRcdFx0cmV0dXJuIG5ldyBNYXAodmFsdWUpXG5cdFx0Y2FzZSBBcmNodHlwZS5TZXQ6XG5cdFx0XHQvLyBTZXQgd2lsbCBiZSBjbG9uZWQgYXMgYXJyYXkgdGVtcG9yYXJpbHksIHNvIHRoYXQgd2UgY2FuIHJlcGxhY2UgaW5kaXZpZHVhbCBpdGVtc1xuXHRcdFx0cmV0dXJuIEFycmF5LmZyb20odmFsdWUpXG5cdH1cblx0cmV0dXJuIHNoYWxsb3dDb3B5KHZhbHVlKVxufVxuIiwiaW1wb3J0IHtcblx0SW1tZXJTdGF0ZSxcblx0RHJhZnRlZCxcblx0RVM1QXJyYXlTdGF0ZSxcblx0RVM1T2JqZWN0U3RhdGUsXG5cdGVhY2gsXG5cdGhhcyxcblx0aXNEcmFmdCxcblx0bGF0ZXN0LFxuXHREUkFGVF9TVEFURSxcblx0aXMsXG5cdGxvYWRQbHVnaW4sXG5cdEltbWVyU2NvcGUsXG5cdFByb3h5VHlwZSxcblx0Z2V0Q3VycmVudFNjb3BlLFxuXHRkaWUsXG5cdG1hcmtDaGFuZ2VkLFxuXHRvYmplY3RUcmFwcyxcblx0b3duS2V5cyxcblx0Z2V0T3duUHJvcGVydHlEZXNjcmlwdG9yc1xufSBmcm9tIFwiLi4vaW50ZXJuYWxcIlxuXG50eXBlIEVTNVN0YXRlID0gRVM1QXJyYXlTdGF0ZSB8IEVTNU9iamVjdFN0YXRlXG5cbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVFUzUoKSB7XG5cdGZ1bmN0aW9uIHdpbGxGaW5hbGl6ZUVTNV8oXG5cdFx0c2NvcGU6IEltbWVyU2NvcGUsXG5cdFx0cmVzdWx0OiBhbnksXG5cdFx0aXNSZXBsYWNlZDogYm9vbGVhblxuXHQpIHtcblx0XHRpZiAoIWlzUmVwbGFjZWQpIHtcblx0XHRcdGlmIChzY29wZS5wYXRjaGVzXykge1xuXHRcdFx0XHRtYXJrQ2hhbmdlc1JlY3Vyc2l2ZWx5KHNjb3BlLmRyYWZ0c18hWzBdKVxuXHRcdFx0fVxuXHRcdFx0Ly8gVGhpcyBpcyBmYXN0ZXIgd2hlbiB3ZSBkb24ndCBjYXJlIGFib3V0IHdoaWNoIGF0dHJpYnV0ZXMgY2hhbmdlZC5cblx0XHRcdG1hcmtDaGFuZ2VzU3dlZXAoc2NvcGUuZHJhZnRzXylcblx0XHR9XG5cdFx0Ly8gV2hlbiBhIGNoaWxkIGRyYWZ0IGlzIHJldHVybmVkLCBsb29rIGZvciBjaGFuZ2VzLlxuXHRcdGVsc2UgaWYgKFxuXHRcdFx0aXNEcmFmdChyZXN1bHQpICYmXG5cdFx0XHQocmVzdWx0W0RSQUZUX1NUQVRFXSBhcyBFUzVTdGF0ZSkuc2NvcGVfID09PSBzY29wZVxuXHRcdCkge1xuXHRcdFx0bWFya0NoYW5nZXNTd2VlcChzY29wZS5kcmFmdHNfKVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUVTNURyYWZ0KGlzQXJyYXk6IGJvb2xlYW4sIGJhc2U6IGFueSkge1xuXHRcdGlmIChpc0FycmF5KSB7XG5cdFx0XHRjb25zdCBkcmFmdCA9IG5ldyBBcnJheShiYXNlLmxlbmd0aClcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYmFzZS5sZW5ndGg7IGkrKylcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGRyYWZ0LCBcIlwiICsgaSwgcHJveHlQcm9wZXJ0eShpLCB0cnVlKSlcblx0XHRcdHJldHVybiBkcmFmdFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCBkZXNjcmlwdG9ycyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoYmFzZSlcblx0XHRcdGRlbGV0ZSBkZXNjcmlwdG9yc1tEUkFGVF9TVEFURSBhcyBhbnldXG5cdFx0XHRjb25zdCBrZXlzID0gb3duS2V5cyhkZXNjcmlwdG9ycylcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRjb25zdCBrZXk6IGFueSA9IGtleXNbaV1cblx0XHRcdFx0ZGVzY3JpcHRvcnNba2V5XSA9IHByb3h5UHJvcGVydHkoXG5cdFx0XHRcdFx0a2V5LFxuXHRcdFx0XHRcdGlzQXJyYXkgfHwgISFkZXNjcmlwdG9yc1trZXldLmVudW1lcmFibGVcblx0XHRcdFx0KVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKGJhc2UpLCBkZXNjcmlwdG9ycylcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVFUzVQcm94eV88VD4oXG5cdFx0YmFzZTogVCxcblx0XHRwYXJlbnQ/OiBJbW1lclN0YXRlXG5cdCk6IERyYWZ0ZWQ8VCwgRVM1T2JqZWN0U3RhdGUgfCBFUzVBcnJheVN0YXRlPiB7XG5cdFx0Y29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoYmFzZSlcblx0XHRjb25zdCBkcmFmdCA9IGNyZWF0ZUVTNURyYWZ0KGlzQXJyYXksIGJhc2UpXG5cblx0XHRjb25zdCBzdGF0ZTogRVM1T2JqZWN0U3RhdGUgfCBFUzVBcnJheVN0YXRlID0ge1xuXHRcdFx0dHlwZV86IGlzQXJyYXkgPyBQcm94eVR5cGUuRVM1QXJyYXkgOiAoUHJveHlUeXBlLkVTNU9iamVjdCBhcyBhbnkpLFxuXHRcdFx0c2NvcGVfOiBwYXJlbnQgPyBwYXJlbnQuc2NvcGVfIDogZ2V0Q3VycmVudFNjb3BlKCksXG5cdFx0XHRtb2RpZmllZF86IGZhbHNlLFxuXHRcdFx0ZmluYWxpemVkXzogZmFsc2UsXG5cdFx0XHRhc3NpZ25lZF86IHt9LFxuXHRcdFx0cGFyZW50XzogcGFyZW50LFxuXHRcdFx0Ly8gYmFzZSBpcyB0aGUgb2JqZWN0IHdlIGFyZSBkcmFmdGluZ1xuXHRcdFx0YmFzZV86IGJhc2UsXG5cdFx0XHQvLyBkcmFmdCBpcyB0aGUgZHJhZnQgb2JqZWN0IGl0c2VsZiwgdGhhdCB0cmFwcyBhbGwgcmVhZHMgYW5kIHJlYWRzIGZyb20gZWl0aGVyIHRoZSBiYXNlIChpZiB1bm1vZGlmaWVkKSBvciBjb3B5IChpZiBtb2RpZmllZClcblx0XHRcdGRyYWZ0XzogZHJhZnQsXG5cdFx0XHRjb3B5XzogbnVsbCxcblx0XHRcdHJldm9rZWRfOiBmYWxzZSxcblx0XHRcdGlzTWFudWFsXzogZmFsc2Vcblx0XHR9XG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZHJhZnQsIERSQUZUX1NUQVRFLCB7XG5cdFx0XHR2YWx1ZTogc3RhdGUsXG5cdFx0XHQvLyBlbnVtZXJhYmxlOiBmYWxzZSA8LSB0aGUgZGVmYXVsdFxuXHRcdFx0d3JpdGFibGU6IHRydWVcblx0XHR9KVxuXHRcdHJldHVybiBkcmFmdFxuXHR9XG5cblx0Ly8gcHJvcGVydHkgZGVzY3JpcHRvcnMgYXJlIHJlY3ljbGVkIHRvIG1ha2Ugc3VyZSB3ZSBkb24ndCBjcmVhdGUgYSBnZXQgYW5kIHNldCBjbG9zdXJlIHBlciBwcm9wZXJ0eSxcblx0Ly8gYnV0IHNoYXJlIHRoZW0gYWxsIGluc3RlYWRcblx0Y29uc3QgZGVzY3JpcHRvcnM6IHtbcHJvcDogc3RyaW5nXTogUHJvcGVydHlEZXNjcmlwdG9yfSA9IHt9XG5cblx0ZnVuY3Rpb24gcHJveHlQcm9wZXJ0eShcblx0XHRwcm9wOiBzdHJpbmcgfCBudW1iZXIsXG5cdFx0ZW51bWVyYWJsZTogYm9vbGVhblxuXHQpOiBQcm9wZXJ0eURlc2NyaXB0b3Ige1xuXHRcdGxldCBkZXNjID0gZGVzY3JpcHRvcnNbcHJvcF1cblx0XHRpZiAoZGVzYykge1xuXHRcdFx0ZGVzYy5lbnVtZXJhYmxlID0gZW51bWVyYWJsZVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZXNjcmlwdG9yc1twcm9wXSA9IGRlc2MgPSB7XG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0ZW51bWVyYWJsZSxcblx0XHRcdFx0Z2V0KHRoaXM6IGFueSkge1xuXHRcdFx0XHRcdGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV1cblx0XHRcdFx0XHRpZiAoX19ERVZfXykgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKVxuXHRcdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0XHRyZXR1cm4gb2JqZWN0VHJhcHMuZ2V0KHN0YXRlLCBwcm9wKVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZXQodGhpczogYW55LCB2YWx1ZSkge1xuXHRcdFx0XHRcdGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV1cblx0XHRcdFx0XHRpZiAoX19ERVZfXykgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKVxuXHRcdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0XHRvYmplY3RUcmFwcy5zZXQoc3RhdGUsIHByb3AsIHZhbHVlKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBkZXNjXG5cdH1cblxuXHQvLyBUaGlzIGxvb2tzIGV4cGVuc2l2ZSwgYnV0IG9ubHkgcHJveGllcyBhcmUgdmlzaXRlZCwgYW5kIG9ubHkgb2JqZWN0cyB3aXRob3V0IGtub3duIGNoYW5nZXMgYXJlIHNjYW5uZWQuXG5cdGZ1bmN0aW9uIG1hcmtDaGFuZ2VzU3dlZXAoZHJhZnRzOiBEcmFmdGVkPGFueSwgSW1tZXJTdGF0ZT5bXSkge1xuXHRcdC8vIFRoZSBuYXR1cmFsIG9yZGVyIG9mIGRyYWZ0cyBpbiB0aGUgYHNjb3BlYCBhcnJheSBpcyBiYXNlZCBvbiB3aGVuIHRoZXlcblx0XHQvLyB3ZXJlIGFjY2Vzc2VkLiBCeSBwcm9jZXNzaW5nIGRyYWZ0cyBpbiByZXZlcnNlIG5hdHVyYWwgb3JkZXIsIHdlIGhhdmUgYVxuXHRcdC8vIGJldHRlciBjaGFuY2Ugb2YgcHJvY2Vzc2luZyBsZWFmIG5vZGVzIGZpcnN0LiBXaGVuIGEgbGVhZiBub2RlIGlzIGtub3duIHRvXG5cdFx0Ly8gaGF2ZSBjaGFuZ2VkLCB3ZSBjYW4gYXZvaWQgYW55IHRyYXZlcnNhbCBvZiBpdHMgYW5jZXN0b3Igbm9kZXMuXG5cdFx0Zm9yIChsZXQgaSA9IGRyYWZ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0Y29uc3Qgc3RhdGU6IEVTNVN0YXRlID0gZHJhZnRzW2ldW0RSQUZUX1NUQVRFXVxuXHRcdFx0aWYgKCFzdGF0ZS5tb2RpZmllZF8pIHtcblx0XHRcdFx0c3dpdGNoIChzdGF0ZS50eXBlXykge1xuXHRcdFx0XHRcdGNhc2UgUHJveHlUeXBlLkVTNUFycmF5OlxuXHRcdFx0XHRcdFx0aWYgKGhhc0FycmF5Q2hhbmdlcyhzdGF0ZSkpIG1hcmtDaGFuZ2VkKHN0YXRlKVxuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHRjYXNlIFByb3h5VHlwZS5FUzVPYmplY3Q6XG5cdFx0XHRcdFx0XHRpZiAoaGFzT2JqZWN0Q2hhbmdlcyhzdGF0ZSkpIG1hcmtDaGFuZ2VkKHN0YXRlKVxuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIG1hcmtDaGFuZ2VzUmVjdXJzaXZlbHkob2JqZWN0OiBhbnkpIHtcblx0XHRpZiAoIW9iamVjdCB8fCB0eXBlb2Ygb2JqZWN0ICE9PSBcIm9iamVjdFwiKSByZXR1cm5cblx0XHRjb25zdCBzdGF0ZTogRVM1U3RhdGUgfCB1bmRlZmluZWQgPSBvYmplY3RbRFJBRlRfU1RBVEVdXG5cdFx0aWYgKCFzdGF0ZSkgcmV0dXJuXG5cdFx0Y29uc3Qge2Jhc2VfLCBkcmFmdF8sIGFzc2lnbmVkXywgdHlwZV99ID0gc3RhdGVcblx0XHRpZiAodHlwZV8gPT09IFByb3h5VHlwZS5FUzVPYmplY3QpIHtcblx0XHRcdC8vIExvb2sgZm9yIGFkZGVkIGtleXMuXG5cdFx0XHQvLyBwcm9iYWJseSB0aGVyZSBpcyBhIGZhc3RlciB3YXkgdG8gZGV0ZWN0IGNoYW5nZXMsIGFzIHN3ZWVwICsgcmVjdXJzZSBzZWVtcyB0byBkbyBzb21lXG5cdFx0XHQvLyB1bm5lY2Vzc2FyeSB3b3JrLlxuXHRcdFx0Ly8gYWxzbzogcHJvYmFibHkgd2UgY2FuIHN0b3JlIHRoZSBpbmZvcm1hdGlvbiB3ZSBkZXRlY3QgaGVyZSwgdG8gc3BlZWQgdXAgdHJlZSBmaW5hbGl6YXRpb24hXG5cdFx0XHRlYWNoKGRyYWZ0Xywga2V5ID0+IHtcblx0XHRcdFx0aWYgKChrZXkgYXMgYW55KSA9PT0gRFJBRlRfU1RBVEUpIHJldHVyblxuXHRcdFx0XHQvLyBUaGUgYHVuZGVmaW5lZGAgY2hlY2sgaXMgYSBmYXN0IHBhdGggZm9yIHByZS1leGlzdGluZyBrZXlzLlxuXHRcdFx0XHRpZiAoKGJhc2VfIGFzIGFueSlba2V5XSA9PT0gdW5kZWZpbmVkICYmICFoYXMoYmFzZV8sIGtleSkpIHtcblx0XHRcdFx0XHRhc3NpZ25lZF9ba2V5XSA9IHRydWVcblx0XHRcdFx0XHRtYXJrQ2hhbmdlZChzdGF0ZSlcblx0XHRcdFx0fSBlbHNlIGlmICghYXNzaWduZWRfW2tleV0pIHtcblx0XHRcdFx0XHQvLyBPbmx5IHVudG91Y2hlZCBwcm9wZXJ0aWVzIHRyaWdnZXIgcmVjdXJzaW9uLlxuXHRcdFx0XHRcdG1hcmtDaGFuZ2VzUmVjdXJzaXZlbHkoZHJhZnRfW2tleV0pXG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0XHQvLyBMb29rIGZvciByZW1vdmVkIGtleXMuXG5cdFx0XHRlYWNoKGJhc2VfLCBrZXkgPT4ge1xuXHRcdFx0XHQvLyBUaGUgYHVuZGVmaW5lZGAgY2hlY2sgaXMgYSBmYXN0IHBhdGggZm9yIHByZS1leGlzdGluZyBrZXlzLlxuXHRcdFx0XHRpZiAoZHJhZnRfW2tleV0gPT09IHVuZGVmaW5lZCAmJiAhaGFzKGRyYWZ0Xywga2V5KSkge1xuXHRcdFx0XHRcdGFzc2lnbmVkX1trZXldID0gZmFsc2Vcblx0XHRcdFx0XHRtYXJrQ2hhbmdlZChzdGF0ZSlcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHR9IGVsc2UgaWYgKHR5cGVfID09PSBQcm94eVR5cGUuRVM1QXJyYXkpIHtcblx0XHRcdGlmIChoYXNBcnJheUNoYW5nZXMoc3RhdGUgYXMgRVM1QXJyYXlTdGF0ZSkpIHtcblx0XHRcdFx0bWFya0NoYW5nZWQoc3RhdGUpXG5cdFx0XHRcdGFzc2lnbmVkXy5sZW5ndGggPSB0cnVlXG5cdFx0XHR9XG5cblx0XHRcdGlmIChkcmFmdF8ubGVuZ3RoIDwgYmFzZV8ubGVuZ3RoKSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSBkcmFmdF8ubGVuZ3RoOyBpIDwgYmFzZV8ubGVuZ3RoOyBpKyspIGFzc2lnbmVkX1tpXSA9IGZhbHNlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gYmFzZV8ubGVuZ3RoOyBpIDwgZHJhZnRfLmxlbmd0aDsgaSsrKSBhc3NpZ25lZF9baV0gPSB0cnVlXG5cdFx0XHR9XG5cblx0XHRcdC8vIE1pbmltdW0gY291bnQgaXMgZW5vdWdoLCB0aGUgb3RoZXIgcGFydHMgaGFzIGJlZW4gcHJvY2Vzc2VkLlxuXHRcdFx0Y29uc3QgbWluID0gTWF0aC5taW4oZHJhZnRfLmxlbmd0aCwgYmFzZV8ubGVuZ3RoKVxuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG1pbjsgaSsrKSB7XG5cdFx0XHRcdC8vIE9ubHkgdW50b3VjaGVkIGluZGljZXMgdHJpZ2dlciByZWN1cnNpb24uXG5cdFx0XHRcdGlmICghZHJhZnRfLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0YXNzaWduZWRfW2ldID0gdHJ1ZVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChhc3NpZ25lZF9baV0gPT09IHVuZGVmaW5lZCkgbWFya0NoYW5nZXNSZWN1cnNpdmVseShkcmFmdF9baV0pXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gaGFzT2JqZWN0Q2hhbmdlcyhzdGF0ZTogRVM1T2JqZWN0U3RhdGUpIHtcblx0XHRjb25zdCB7YmFzZV8sIGRyYWZ0X30gPSBzdGF0ZVxuXG5cdFx0Ly8gU2VhcmNoIGZvciBhZGRlZCBrZXlzIGFuZCBjaGFuZ2VkIGtleXMuIFN0YXJ0IGF0IHRoZSBiYWNrLCBiZWNhdXNlXG5cdFx0Ly8gbm9uLW51bWVyaWMga2V5cyBhcmUgb3JkZXJlZCBieSB0aW1lIG9mIGRlZmluaXRpb24gb24gdGhlIG9iamVjdC5cblx0XHRjb25zdCBrZXlzID0gb3duS2V5cyhkcmFmdF8pXG5cdFx0Zm9yIChsZXQgaSA9IGtleXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdGNvbnN0IGtleTogYW55ID0ga2V5c1tpXVxuXHRcdFx0aWYgKGtleSA9PT0gRFJBRlRfU1RBVEUpIGNvbnRpbnVlXG5cdFx0XHRjb25zdCBiYXNlVmFsdWUgPSBiYXNlX1trZXldXG5cdFx0XHQvLyBUaGUgYHVuZGVmaW5lZGAgY2hlY2sgaXMgYSBmYXN0IHBhdGggZm9yIHByZS1leGlzdGluZyBrZXlzLlxuXHRcdFx0aWYgKGJhc2VWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICFoYXMoYmFzZV8sIGtleSkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWVcblx0XHRcdH1cblx0XHRcdC8vIE9uY2UgYSBiYXNlIGtleSBpcyBkZWxldGVkLCBmdXR1cmUgY2hhbmdlcyBnbyB1bmRldGVjdGVkLCBiZWNhdXNlIGl0c1xuXHRcdFx0Ly8gZGVzY3JpcHRvciBpcyBlcmFzZWQuIFRoaXMgYnJhbmNoIGRldGVjdHMgYW55IG1pc3NlZCBjaGFuZ2VzLlxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGNvbnN0IHZhbHVlID0gZHJhZnRfW2tleV1cblx0XHRcdFx0Y29uc3Qgc3RhdGU6IEltbWVyU3RhdGUgPSB2YWx1ZSAmJiB2YWx1ZVtEUkFGVF9TVEFURV1cblx0XHRcdFx0aWYgKHN0YXRlID8gc3RhdGUuYmFzZV8gIT09IGJhc2VWYWx1ZSA6ICFpcyh2YWx1ZSwgYmFzZVZhbHVlKSkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBdCB0aGlzIHBvaW50LCBubyBrZXlzIHdlcmUgYWRkZWQgb3IgY2hhbmdlZC5cblx0XHQvLyBDb21wYXJlIGtleSBjb3VudCB0byBkZXRlcm1pbmUgaWYga2V5cyB3ZXJlIGRlbGV0ZWQuXG5cdFx0Y29uc3QgYmFzZUlzRHJhZnQgPSAhIWJhc2VfW0RSQUZUX1NUQVRFIGFzIGFueV1cblx0XHRyZXR1cm4ga2V5cy5sZW5ndGggIT09IG93bktleXMoYmFzZV8pLmxlbmd0aCArIChiYXNlSXNEcmFmdCA/IDAgOiAxKSAvLyArIDEgdG8gY29ycmVjdCBmb3IgRFJBRlRfU1RBVEVcblx0fVxuXG5cdGZ1bmN0aW9uIGhhc0FycmF5Q2hhbmdlcyhzdGF0ZTogRVM1QXJyYXlTdGF0ZSkge1xuXHRcdGNvbnN0IHtkcmFmdF99ID0gc3RhdGVcblx0XHRpZiAoZHJhZnRfLmxlbmd0aCAhPT0gc3RhdGUuYmFzZV8ubGVuZ3RoKSByZXR1cm4gdHJ1ZVxuXHRcdC8vIFNlZSAjMTE2XG5cdFx0Ly8gSWYgd2UgZmlyc3Qgc2hvcnRlbiB0aGUgbGVuZ3RoLCBvdXIgYXJyYXkgaW50ZXJjZXB0b3JzIHdpbGwgYmUgcmVtb3ZlZC5cblx0XHQvLyBJZiBhZnRlciB0aGF0IG5ldyBpdGVtcyBhcmUgYWRkZWQsIHJlc3VsdCBpbiB0aGUgc2FtZSBvcmlnaW5hbCBsZW5ndGgsXG5cdFx0Ly8gdGhvc2UgbGFzdCBpdGVtcyB3aWxsIGhhdmUgbm8gaW50ZXJjZXB0aW5nIHByb3BlcnR5LlxuXHRcdC8vIFNvIGlmIHRoZXJlIGlzIG5vIG93biBkZXNjcmlwdG9yIG9uIHRoZSBsYXN0IHBvc2l0aW9uLCB3ZSBrbm93IHRoYXQgaXRlbXMgd2VyZSByZW1vdmVkIGFuZCBhZGRlZFxuXHRcdC8vIE4uQi46IHNwbGljZSwgdW5zaGlmdCwgZXRjIG9ubHkgc2hpZnQgdmFsdWVzIGFyb3VuZCwgYnV0IG5vdCBwcm9wIGRlc2NyaXB0b3JzLCBzbyB3ZSBvbmx5IGhhdmUgdG8gY2hlY2tcblx0XHQvLyB0aGUgbGFzdCBvbmVcblx0XHQvLyBsYXN0IGRlc2NyaXB0b3IgY2FuIGJlIG5vdCBhIHRyYXAsIGlmIHRoZSBhcnJheSB3YXMgZXh0ZW5kZWRcblx0XHRjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcblx0XHRcdGRyYWZ0Xyxcblx0XHRcdGRyYWZ0Xy5sZW5ndGggLSAxXG5cdFx0KVxuXHRcdC8vIGRlc2NyaXB0b3IgY2FuIGJlIG51bGwsIGJ1dCBvbmx5IGZvciBuZXdseSBjcmVhdGVkIHNwYXJzZSBhcnJheXMsIGVnLiBuZXcgQXJyYXkoMTApXG5cdFx0aWYgKGRlc2NyaXB0b3IgJiYgIWRlc2NyaXB0b3IuZ2V0KSByZXR1cm4gdHJ1ZVxuXHRcdC8vIGlmIHdlIG1pc3MgYSBwcm9wZXJ0eSwgaXQgaGFzIGJlZW4gZGVsZXRlZCwgc28gYXJyYXkgcHJvYm9iYWx5IGNoYW5nZWRcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGRyYWZ0Xy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKCFkcmFmdF8uaGFzT3duUHJvcGVydHkoaSkpIHJldHVybiB0cnVlXG5cdFx0fVxuXHRcdC8vIEZvciBhbGwgb3RoZXIgY2FzZXMsIHdlIGRvbid0IGhhdmUgdG8gY29tcGFyZSwgYXMgdGhleSB3b3VsZCBoYXZlIGJlZW4gcGlja2VkIHVwIGJ5IHRoZSBpbmRleCBzZXR0ZXJzXG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cblxuXHRmdW5jdGlvbiBoYXNDaGFuZ2VzXyhzdGF0ZTogRVM1U3RhdGUpIHtcblx0XHRyZXR1cm4gc3RhdGUudHlwZV8gPT09IFByb3h5VHlwZS5FUzVPYmplY3Rcblx0XHRcdD8gaGFzT2JqZWN0Q2hhbmdlcyhzdGF0ZSlcblx0XHRcdDogaGFzQXJyYXlDaGFuZ2VzKHN0YXRlKVxuXHR9XG5cblx0ZnVuY3Rpb24gYXNzZXJ0VW5yZXZva2VkKHN0YXRlOiBhbnkgLypFUzVTdGF0ZSB8IE1hcFN0YXRlIHwgU2V0U3RhdGUqLykge1xuXHRcdGlmIChzdGF0ZS5yZXZva2VkXykgZGllKDMsIEpTT04uc3RyaW5naWZ5KGxhdGVzdChzdGF0ZSkpKVxuXHR9XG5cblx0bG9hZFBsdWdpbihcIkVTNVwiLCB7XG5cdFx0Y3JlYXRlRVM1UHJveHlfLFxuXHRcdHdpbGxGaW5hbGl6ZUVTNV8sXG5cdFx0aGFzQ2hhbmdlc19cblx0fSlcbn1cbiIsImltcG9ydCB7aW1tZXJhYmxlfSBmcm9tIFwiLi4vaW1tZXJcIlxuaW1wb3J0IHtcblx0SW1tZXJTdGF0ZSxcblx0UGF0Y2gsXG5cdFNldFN0YXRlLFxuXHRFUzVBcnJheVN0YXRlLFxuXHRQcm94eUFycmF5U3RhdGUsXG5cdE1hcFN0YXRlLFxuXHRFUzVPYmplY3RTdGF0ZSxcblx0UHJveHlPYmplY3RTdGF0ZSxcblx0UGF0Y2hQYXRoLFxuXHRnZXQsXG5cdGVhY2gsXG5cdGhhcyxcblx0Z2V0QXJjaHR5cGUsXG5cdGlzU2V0LFxuXHRpc01hcCxcblx0bG9hZFBsdWdpbixcblx0UHJveHlUeXBlLFxuXHRBcmNodHlwZSxcblx0ZGllLFxuXHRpc0RyYWZ0LFxuXHRpc0RyYWZ0YWJsZSxcblx0Tk9USElOR1xufSBmcm9tIFwiLi4vaW50ZXJuYWxcIlxuXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlUGF0Y2hlcygpIHtcblx0Y29uc3QgUkVQTEFDRSA9IFwicmVwbGFjZVwiXG5cdGNvbnN0IEFERCA9IFwiYWRkXCJcblx0Y29uc3QgUkVNT1ZFID0gXCJyZW1vdmVcIlxuXG5cdGZ1bmN0aW9uIGdlbmVyYXRlUGF0Y2hlc18oXG5cdFx0c3RhdGU6IEltbWVyU3RhdGUsXG5cdFx0YmFzZVBhdGg6IFBhdGNoUGF0aCxcblx0XHRwYXRjaGVzOiBQYXRjaFtdLFxuXHRcdGludmVyc2VQYXRjaGVzOiBQYXRjaFtdXG5cdCk6IHZvaWQge1xuXHRcdHN3aXRjaCAoc3RhdGUudHlwZV8pIHtcblx0XHRcdGNhc2UgUHJveHlUeXBlLlByb3h5T2JqZWN0OlxuXHRcdFx0Y2FzZSBQcm94eVR5cGUuRVM1T2JqZWN0OlxuXHRcdFx0Y2FzZSBQcm94eVR5cGUuTWFwOlxuXHRcdFx0XHRyZXR1cm4gZ2VuZXJhdGVQYXRjaGVzRnJvbUFzc2lnbmVkKFxuXHRcdFx0XHRcdHN0YXRlLFxuXHRcdFx0XHRcdGJhc2VQYXRoLFxuXHRcdFx0XHRcdHBhdGNoZXMsXG5cdFx0XHRcdFx0aW52ZXJzZVBhdGNoZXNcblx0XHRcdFx0KVxuXHRcdFx0Y2FzZSBQcm94eVR5cGUuRVM1QXJyYXk6XG5cdFx0XHRjYXNlIFByb3h5VHlwZS5Qcm94eUFycmF5OlxuXHRcdFx0XHRyZXR1cm4gZ2VuZXJhdGVBcnJheVBhdGNoZXMoc3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcylcblx0XHRcdGNhc2UgUHJveHlUeXBlLlNldDpcblx0XHRcdFx0cmV0dXJuIGdlbmVyYXRlU2V0UGF0Y2hlcyhcblx0XHRcdFx0XHQoc3RhdGUgYXMgYW55KSBhcyBTZXRTdGF0ZSxcblx0XHRcdFx0XHRiYXNlUGF0aCxcblx0XHRcdFx0XHRwYXRjaGVzLFxuXHRcdFx0XHRcdGludmVyc2VQYXRjaGVzXG5cdFx0XHRcdClcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBnZW5lcmF0ZUFycmF5UGF0Y2hlcyhcblx0XHRzdGF0ZTogRVM1QXJyYXlTdGF0ZSB8IFByb3h5QXJyYXlTdGF0ZSxcblx0XHRiYXNlUGF0aDogUGF0Y2hQYXRoLFxuXHRcdHBhdGNoZXM6IFBhdGNoW10sXG5cdFx0aW52ZXJzZVBhdGNoZXM6IFBhdGNoW11cblx0KSB7XG5cdFx0bGV0IHtiYXNlXywgYXNzaWduZWRffSA9IHN0YXRlXG5cdFx0bGV0IGNvcHlfID0gc3RhdGUuY29weV8hXG5cblx0XHQvLyBSZWR1Y2UgY29tcGxleGl0eSBieSBlbnN1cmluZyBgYmFzZWAgaXMgbmV2ZXIgbG9uZ2VyLlxuXHRcdGlmIChjb3B5Xy5sZW5ndGggPCBiYXNlXy5sZW5ndGgpIHtcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdDtbYmFzZV8sIGNvcHlfXSA9IFtjb3B5XywgYmFzZV9dXG5cdFx0XHQ7W3BhdGNoZXMsIGludmVyc2VQYXRjaGVzXSA9IFtpbnZlcnNlUGF0Y2hlcywgcGF0Y2hlc11cblx0XHR9XG5cblx0XHQvLyBQcm9jZXNzIHJlcGxhY2VkIGluZGljZXMuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBiYXNlXy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKGFzc2lnbmVkX1tpXSAmJiBjb3B5X1tpXSAhPT0gYmFzZV9baV0pIHtcblx0XHRcdFx0Y29uc3QgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChbaV0pXG5cdFx0XHRcdHBhdGNoZXMucHVzaCh7XG5cdFx0XHRcdFx0b3A6IFJFUExBQ0UsXG5cdFx0XHRcdFx0cGF0aCxcblx0XHRcdFx0XHQvLyBOZWVkIHRvIG1heWJlIGNsb25lIGl0LCBhcyBpdCBjYW4gaW4gZmFjdCBiZSB0aGUgb3JpZ2luYWwgdmFsdWVcblx0XHRcdFx0XHQvLyBkdWUgdG8gdGhlIGJhc2UvY29weSBpbnZlcnNpb24gYXQgdGhlIHN0YXJ0IG9mIHRoaXMgZnVuY3Rpb25cblx0XHRcdFx0XHR2YWx1ZTogY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQoY29weV9baV0pXG5cdFx0XHRcdH0pXG5cdFx0XHRcdGludmVyc2VQYXRjaGVzLnB1c2goe1xuXHRcdFx0XHRcdG9wOiBSRVBMQUNFLFxuXHRcdFx0XHRcdHBhdGgsXG5cdFx0XHRcdFx0dmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKGJhc2VfW2ldKVxuXHRcdFx0XHR9KVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByb2Nlc3MgYWRkZWQgaW5kaWNlcy5cblx0XHRmb3IgKGxldCBpID0gYmFzZV8ubGVuZ3RoOyBpIDwgY29weV8ubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKVxuXHRcdFx0cGF0Y2hlcy5wdXNoKHtcblx0XHRcdFx0b3A6IEFERCxcblx0XHRcdFx0cGF0aCxcblx0XHRcdFx0Ly8gTmVlZCB0byBtYXliZSBjbG9uZSBpdCwgYXMgaXQgY2FuIGluIGZhY3QgYmUgdGhlIG9yaWdpbmFsIHZhbHVlXG5cdFx0XHRcdC8vIGR1ZSB0byB0aGUgYmFzZS9jb3B5IGludmVyc2lvbiBhdCB0aGUgc3RhcnQgb2YgdGhpcyBmdW5jdGlvblxuXHRcdFx0XHR2YWx1ZTogY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQoY29weV9baV0pXG5cdFx0XHR9KVxuXHRcdH1cblx0XHRpZiAoYmFzZV8ubGVuZ3RoIDwgY29weV8ubGVuZ3RoKSB7XG5cdFx0XHRpbnZlcnNlUGF0Y2hlcy5wdXNoKHtcblx0XHRcdFx0b3A6IFJFUExBQ0UsXG5cdFx0XHRcdHBhdGg6IGJhc2VQYXRoLmNvbmNhdChbXCJsZW5ndGhcIl0pLFxuXHRcdFx0XHR2YWx1ZTogYmFzZV8ubGVuZ3RoXG5cdFx0XHR9KVxuXHRcdH1cblx0fVxuXG5cdC8vIFRoaXMgaXMgdXNlZCBmb3IgYm90aCBNYXAgb2JqZWN0cyBhbmQgbm9ybWFsIG9iamVjdHMuXG5cdGZ1bmN0aW9uIGdlbmVyYXRlUGF0Y2hlc0Zyb21Bc3NpZ25lZChcblx0XHRzdGF0ZTogTWFwU3RhdGUgfCBFUzVPYmplY3RTdGF0ZSB8IFByb3h5T2JqZWN0U3RhdGUsXG5cdFx0YmFzZVBhdGg6IFBhdGNoUGF0aCxcblx0XHRwYXRjaGVzOiBQYXRjaFtdLFxuXHRcdGludmVyc2VQYXRjaGVzOiBQYXRjaFtdXG5cdCkge1xuXHRcdGNvbnN0IHtiYXNlXywgY29weV99ID0gc3RhdGVcblx0XHRlYWNoKHN0YXRlLmFzc2lnbmVkXyEsIChrZXksIGFzc2lnbmVkVmFsdWUpID0+IHtcblx0XHRcdGNvbnN0IG9yaWdWYWx1ZSA9IGdldChiYXNlXywga2V5KVxuXHRcdFx0Y29uc3QgdmFsdWUgPSBnZXQoY29weV8hLCBrZXkpXG5cdFx0XHRjb25zdCBvcCA9ICFhc3NpZ25lZFZhbHVlID8gUkVNT1ZFIDogaGFzKGJhc2VfLCBrZXkpID8gUkVQTEFDRSA6IEFERFxuXHRcdFx0aWYgKG9yaWdWYWx1ZSA9PT0gdmFsdWUgJiYgb3AgPT09IFJFUExBQ0UpIHJldHVyblxuXHRcdFx0Y29uc3QgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChrZXkgYXMgYW55KVxuXHRcdFx0cGF0Y2hlcy5wdXNoKG9wID09PSBSRU1PVkUgPyB7b3AsIHBhdGh9IDoge29wLCBwYXRoLCB2YWx1ZX0pXG5cdFx0XHRpbnZlcnNlUGF0Y2hlcy5wdXNoKFxuXHRcdFx0XHRvcCA9PT0gQUREXG5cdFx0XHRcdFx0PyB7b3A6IFJFTU9WRSwgcGF0aH1cblx0XHRcdFx0XHQ6IG9wID09PSBSRU1PVkVcblx0XHRcdFx0XHQ/IHtvcDogQURELCBwYXRoLCB2YWx1ZTogY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQob3JpZ1ZhbHVlKX1cblx0XHRcdFx0XHQ6IHtvcDogUkVQTEFDRSwgcGF0aCwgdmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKG9yaWdWYWx1ZSl9XG5cdFx0XHQpXG5cdFx0fSlcblx0fVxuXG5cdGZ1bmN0aW9uIGdlbmVyYXRlU2V0UGF0Y2hlcyhcblx0XHRzdGF0ZTogU2V0U3RhdGUsXG5cdFx0YmFzZVBhdGg6IFBhdGNoUGF0aCxcblx0XHRwYXRjaGVzOiBQYXRjaFtdLFxuXHRcdGludmVyc2VQYXRjaGVzOiBQYXRjaFtdXG5cdCkge1xuXHRcdGxldCB7YmFzZV8sIGNvcHlffSA9IHN0YXRlXG5cblx0XHRsZXQgaSA9IDBcblx0XHRiYXNlXy5mb3JFYWNoKCh2YWx1ZTogYW55KSA9PiB7XG5cdFx0XHRpZiAoIWNvcHlfIS5oYXModmFsdWUpKSB7XG5cdFx0XHRcdGNvbnN0IHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKVxuXHRcdFx0XHRwYXRjaGVzLnB1c2goe1xuXHRcdFx0XHRcdG9wOiBSRU1PVkUsXG5cdFx0XHRcdFx0cGF0aCxcblx0XHRcdFx0XHR2YWx1ZVxuXHRcdFx0XHR9KVxuXHRcdFx0XHRpbnZlcnNlUGF0Y2hlcy51bnNoaWZ0KHtcblx0XHRcdFx0XHRvcDogQURELFxuXHRcdFx0XHRcdHBhdGgsXG5cdFx0XHRcdFx0dmFsdWVcblx0XHRcdFx0fSlcblx0XHRcdH1cblx0XHRcdGkrK1xuXHRcdH0pXG5cdFx0aSA9IDBcblx0XHRjb3B5XyEuZm9yRWFjaCgodmFsdWU6IGFueSkgPT4ge1xuXHRcdFx0aWYgKCFiYXNlXy5oYXModmFsdWUpKSB7XG5cdFx0XHRcdGNvbnN0IHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKVxuXHRcdFx0XHRwYXRjaGVzLnB1c2goe1xuXHRcdFx0XHRcdG9wOiBBREQsXG5cdFx0XHRcdFx0cGF0aCxcblx0XHRcdFx0XHR2YWx1ZVxuXHRcdFx0XHR9KVxuXHRcdFx0XHRpbnZlcnNlUGF0Y2hlcy51bnNoaWZ0KHtcblx0XHRcdFx0XHRvcDogUkVNT1ZFLFxuXHRcdFx0XHRcdHBhdGgsXG5cdFx0XHRcdFx0dmFsdWVcblx0XHRcdFx0fSlcblx0XHRcdH1cblx0XHRcdGkrK1xuXHRcdH0pXG5cdH1cblxuXHRmdW5jdGlvbiBnZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc18oXG5cdFx0YmFzZVZhbHVlOiBhbnksXG5cdFx0cmVwbGFjZW1lbnQ6IGFueSxcblx0XHRwYXRjaGVzOiBQYXRjaFtdLFxuXHRcdGludmVyc2VQYXRjaGVzOiBQYXRjaFtdXG5cdCk6IHZvaWQge1xuXHRcdHBhdGNoZXMucHVzaCh7XG5cdFx0XHRvcDogUkVQTEFDRSxcblx0XHRcdHBhdGg6IFtdLFxuXHRcdFx0dmFsdWU6IHJlcGxhY2VtZW50ID09PSBOT1RISU5HID8gdW5kZWZpbmVkIDogcmVwbGFjZW1lbnRcblx0XHR9KVxuXHRcdGludmVyc2VQYXRjaGVzLnB1c2goe1xuXHRcdFx0b3A6IFJFUExBQ0UsXG5cdFx0XHRwYXRoOiBbXSxcblx0XHRcdHZhbHVlOiBiYXNlVmFsdWVcblx0XHR9KVxuXHR9XG5cblx0ZnVuY3Rpb24gYXBwbHlQYXRjaGVzXzxUPihkcmFmdDogVCwgcGF0Y2hlczogUGF0Y2hbXSk6IFQge1xuXHRcdHBhdGNoZXMuZm9yRWFjaChwYXRjaCA9PiB7XG5cdFx0XHRjb25zdCB7cGF0aCwgb3B9ID0gcGF0Y2hcblxuXHRcdFx0bGV0IGJhc2U6IGFueSA9IGRyYWZ0XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoIC0gMTsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IHBhcmVudFR5cGUgPSBnZXRBcmNodHlwZShiYXNlKVxuXHRcdFx0XHRjb25zdCBwID0gXCJcIiArIHBhdGhbaV1cblx0XHRcdFx0Ly8gU2VlICM3MzgsIGF2b2lkIHByb3RvdHlwZSBwb2xsdXRpb25cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdChwYXJlbnRUeXBlID09PSBBcmNodHlwZS5PYmplY3QgfHwgcGFyZW50VHlwZSA9PT0gQXJjaHR5cGUuQXJyYXkpICYmXG5cdFx0XHRcdFx0KHAgPT09IFwiX19wcm90b19fXCIgfHwgcCA9PT0gXCJjb25zdHJ1Y3RvclwiKVxuXHRcdFx0XHQpXG5cdFx0XHRcdFx0ZGllKDI0KVxuXHRcdFx0XHRpZiAodHlwZW9mIGJhc2UgPT09IFwiZnVuY3Rpb25cIiAmJiBwID09PSBcInByb3RvdHlwZVwiKSBkaWUoMjQpXG5cdFx0XHRcdGJhc2UgPSBnZXQoYmFzZSwgcClcblx0XHRcdFx0aWYgKHR5cGVvZiBiYXNlICE9PSBcIm9iamVjdFwiKSBkaWUoMTUsIHBhdGguam9pbihcIi9cIikpXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHR5cGUgPSBnZXRBcmNodHlwZShiYXNlKVxuXHRcdFx0Y29uc3QgdmFsdWUgPSBkZWVwQ2xvbmVQYXRjaFZhbHVlKHBhdGNoLnZhbHVlKSAvLyB1c2VkIHRvIGNsb25lIHBhdGNoIHRvIGVuc3VyZSBvcmlnaW5hbCBwYXRjaCBpcyBub3QgbW9kaWZpZWQsIHNlZSAjNDExXG5cdFx0XHRjb25zdCBrZXkgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV1cblx0XHRcdHN3aXRjaCAob3ApIHtcblx0XHRcdFx0Y2FzZSBSRVBMQUNFOlxuXHRcdFx0XHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0XHRcdFx0Y2FzZSBBcmNodHlwZS5NYXA6XG5cdFx0XHRcdFx0XHRcdHJldHVybiBiYXNlLnNldChrZXksIHZhbHVlKVxuXHRcdFx0XHRcdFx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0XHRcdFx0XHRcdGNhc2UgQXJjaHR5cGUuU2V0OlxuXHRcdFx0XHRcdFx0XHRkaWUoMTYpXG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHQvLyBpZiB2YWx1ZSBpcyBhbiBvYmplY3QsIHRoZW4gaXQncyBhc3NpZ25lZCBieSByZWZlcmVuY2Vcblx0XHRcdFx0XHRcdFx0Ly8gaW4gdGhlIGZvbGxvd2luZyBhZGQgb3IgcmVtb3ZlIG9wcywgdGhlIHZhbHVlIGZpZWxkIGluc2lkZSB0aGUgcGF0Y2ggd2lsbCBhbHNvIGJlIG1vZGlmeWVkXG5cdFx0XHRcdFx0XHRcdC8vIHNvIHdlIHVzZSB2YWx1ZSBmcm9tIHRoZSBjbG9uZWQgcGF0Y2hcblx0XHRcdFx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gKGJhc2Vba2V5XSA9IHZhbHVlKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0Y2FzZSBBREQ6XG5cdFx0XHRcdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRcdFx0XHRjYXNlIEFyY2h0eXBlLkFycmF5OlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4ga2V5ID09PSBcIi1cIlxuXHRcdFx0XHRcdFx0XHRcdD8gYmFzZS5wdXNoKHZhbHVlKVxuXHRcdFx0XHRcdFx0XHRcdDogYmFzZS5zcGxpY2Uoa2V5IGFzIGFueSwgMCwgdmFsdWUpXG5cdFx0XHRcdFx0XHRjYXNlIEFyY2h0eXBlLk1hcDpcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGJhc2Uuc2V0KGtleSwgdmFsdWUpXG5cdFx0XHRcdFx0XHRjYXNlIEFyY2h0eXBlLlNldDpcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGJhc2UuYWRkKHZhbHVlKVxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0cmV0dXJuIChiYXNlW2tleV0gPSB2YWx1ZSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdGNhc2UgUkVNT1ZFOlxuXHRcdFx0XHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0XHRcdFx0Y2FzZSBBcmNodHlwZS5BcnJheTpcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGJhc2Uuc3BsaWNlKGtleSBhcyBhbnksIDEpXG5cdFx0XHRcdFx0XHRjYXNlIEFyY2h0eXBlLk1hcDpcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGJhc2UuZGVsZXRlKGtleSlcblx0XHRcdFx0XHRcdGNhc2UgQXJjaHR5cGUuU2V0OlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gYmFzZS5kZWxldGUocGF0Y2gudmFsdWUpXG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZGVsZXRlIGJhc2Vba2V5XVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRkaWUoMTcsIG9wKVxuXHRcdFx0fVxuXHRcdH0pXG5cblx0XHRyZXR1cm4gZHJhZnRcblx0fVxuXG5cdC8vIG9wdGltaXplOiB0aGlzIGlzIHF1aXRlIGEgcGVyZm9ybWFuY2UgaGl0LCBjYW4gd2UgZGV0ZWN0IGludGVsbGlnZW50bHkgd2hlbiBpdCBpcyBuZWVkZWQ/XG5cdC8vIEUuZy4gYXV0by1kcmFmdCB3aGVuIG5ldyBvYmplY3RzIGZyb20gb3V0c2lkZSBhcmUgYXNzaWduZWQgYW5kIG1vZGlmaWVkP1xuXHQvLyAoU2VlIGZhaWxpbmcgdGVzdCB3aGVuIGRlZXBDbG9uZSBqdXN0IHJldHVybnMgb2JqKVxuXHRmdW5jdGlvbiBkZWVwQ2xvbmVQYXRjaFZhbHVlPFQ+KG9iajogVCk6IFRcblx0ZnVuY3Rpb24gZGVlcENsb25lUGF0Y2hWYWx1ZShvYmo6IGFueSkge1xuXHRcdGlmICghaXNEcmFmdGFibGUob2JqKSkgcmV0dXJuIG9ialxuXHRcdGlmIChBcnJheS5pc0FycmF5KG9iaikpIHJldHVybiBvYmoubWFwKGRlZXBDbG9uZVBhdGNoVmFsdWUpXG5cdFx0aWYgKGlzTWFwKG9iaikpXG5cdFx0XHRyZXR1cm4gbmV3IE1hcChcblx0XHRcdFx0QXJyYXkuZnJvbShvYmouZW50cmllcygpKS5tYXAoKFtrLCB2XSkgPT4gW2ssIGRlZXBDbG9uZVBhdGNoVmFsdWUodildKVxuXHRcdFx0KVxuXHRcdGlmIChpc1NldChvYmopKSByZXR1cm4gbmV3IFNldChBcnJheS5mcm9tKG9iaikubWFwKGRlZXBDbG9uZVBhdGNoVmFsdWUpKVxuXHRcdGNvbnN0IGNsb25lZCA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikpXG5cdFx0Zm9yIChjb25zdCBrZXkgaW4gb2JqKSBjbG9uZWRba2V5XSA9IGRlZXBDbG9uZVBhdGNoVmFsdWUob2JqW2tleV0pXG5cdFx0aWYgKGhhcyhvYmosIGltbWVyYWJsZSkpIGNsb25lZFtpbW1lcmFibGVdID0gb2JqW2ltbWVyYWJsZV1cblx0XHRyZXR1cm4gY2xvbmVkXG5cdH1cblxuXHRmdW5jdGlvbiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZDxUPihvYmo6IFQpOiBUIHtcblx0XHRpZiAoaXNEcmFmdChvYmopKSB7XG5cdFx0XHRyZXR1cm4gZGVlcENsb25lUGF0Y2hWYWx1ZShvYmopXG5cdFx0fSBlbHNlIHJldHVybiBvYmpcblx0fVxuXG5cdGxvYWRQbHVnaW4oXCJQYXRjaGVzXCIsIHtcblx0XHRhcHBseVBhdGNoZXNfLFxuXHRcdGdlbmVyYXRlUGF0Y2hlc18sXG5cdFx0Z2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfXG5cdH0pXG59XG4iLCIvLyB0eXBlcyBvbmx5IVxuaW1wb3J0IHtcblx0SW1tZXJTdGF0ZSxcblx0QW55TWFwLFxuXHRBbnlTZXQsXG5cdE1hcFN0YXRlLFxuXHRTZXRTdGF0ZSxcblx0RFJBRlRfU1RBVEUsXG5cdGdldEN1cnJlbnRTY29wZSxcblx0bGF0ZXN0LFxuXHRpdGVyYXRvclN5bWJvbCxcblx0aXNEcmFmdGFibGUsXG5cdGNyZWF0ZVByb3h5LFxuXHRsb2FkUGx1Z2luLFxuXHRtYXJrQ2hhbmdlZCxcblx0UHJveHlUeXBlLFxuXHRkaWUsXG5cdGVhY2hcbn0gZnJvbSBcIi4uL2ludGVybmFsXCJcblxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZU1hcFNldCgpIHtcblx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0dmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkOiBhbnksIGI6IGFueSk6IGFueSB7XG5cdFx0ZXh0ZW5kU3RhdGljcyA9XG5cdFx0XHRPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0XHRcdCh7X19wcm90b19fOiBbXX0gaW5zdGFuY2VvZiBBcnJheSAmJlxuXHRcdFx0XHRmdW5jdGlvbihkLCBiKSB7XG5cdFx0XHRcdFx0ZC5fX3Byb3RvX18gPSBiXG5cdFx0XHRcdH0pIHx8XG5cdFx0XHRmdW5jdGlvbihkLCBiKSB7XG5cdFx0XHRcdGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdXG5cdFx0XHR9XG5cdFx0cmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYilcblx0fVxuXG5cdC8vIFVnbHkgaGFjayB0byByZXNvbHZlICM1MDIgYW5kIGluaGVyaXQgYnVpbHQgaW4gTWFwIC8gU2V0XG5cdGZ1bmN0aW9uIF9fZXh0ZW5kcyhkOiBhbnksIGI6IGFueSk6IGFueSB7XG5cdFx0ZXh0ZW5kU3RhdGljcyhkLCBiKVxuXHRcdGZ1bmN0aW9uIF9fKHRoaXM6IGFueSk6IGFueSB7XG5cdFx0XHR0aGlzLmNvbnN0cnVjdG9yID0gZFxuXHRcdH1cblx0XHRkLnByb3RvdHlwZSA9XG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHQoKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlKSwgbmV3IF9fKCkpXG5cdH1cblxuXHRjb25zdCBEcmFmdE1hcCA9IChmdW5jdGlvbihfc3VwZXIpIHtcblx0XHRfX2V4dGVuZHMoRHJhZnRNYXAsIF9zdXBlcilcblx0XHQvLyBDcmVhdGUgY2xhc3MgbWFudWFsbHksIGNhdXNlICM1MDJcblx0XHRmdW5jdGlvbiBEcmFmdE1hcCh0aGlzOiBhbnksIHRhcmdldDogQW55TWFwLCBwYXJlbnQ/OiBJbW1lclN0YXRlKTogYW55IHtcblx0XHRcdHRoaXNbRFJBRlRfU1RBVEVdID0ge1xuXHRcdFx0XHR0eXBlXzogUHJveHlUeXBlLk1hcCxcblx0XHRcdFx0cGFyZW50XzogcGFyZW50LFxuXHRcdFx0XHRzY29wZV86IHBhcmVudCA/IHBhcmVudC5zY29wZV8gOiBnZXRDdXJyZW50U2NvcGUoKSEsXG5cdFx0XHRcdG1vZGlmaWVkXzogZmFsc2UsXG5cdFx0XHRcdGZpbmFsaXplZF86IGZhbHNlLFxuXHRcdFx0XHRjb3B5XzogdW5kZWZpbmVkLFxuXHRcdFx0XHRhc3NpZ25lZF86IHVuZGVmaW5lZCxcblx0XHRcdFx0YmFzZV86IHRhcmdldCxcblx0XHRcdFx0ZHJhZnRfOiB0aGlzIGFzIGFueSxcblx0XHRcdFx0aXNNYW51YWxfOiBmYWxzZSxcblx0XHRcdFx0cmV2b2tlZF86IGZhbHNlXG5cdFx0XHR9IGFzIE1hcFN0YXRlXG5cdFx0XHRyZXR1cm4gdGhpc1xuXHRcdH1cblx0XHRjb25zdCBwID0gRHJhZnRNYXAucHJvdG90eXBlXG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkocCwgXCJzaXplXCIsIHtcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBsYXRlc3QodGhpc1tEUkFGVF9TVEFURV0pLnNpemVcblx0XHRcdH1cblx0XHRcdC8vIGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdFx0Ly8gY29uZmlndXJhYmxlOiB0cnVlXG5cdFx0fSlcblxuXHRcdHAuaGFzID0gZnVuY3Rpb24oa2V5OiBhbnkpOiBib29sZWFuIHtcblx0XHRcdHJldHVybiBsYXRlc3QodGhpc1tEUkFGVF9TVEFURV0pLmhhcyhrZXkpXG5cdFx0fVxuXG5cdFx0cC5zZXQgPSBmdW5jdGlvbihrZXk6IGFueSwgdmFsdWU6IGFueSkge1xuXHRcdFx0Y29uc3Qgc3RhdGU6IE1hcFN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV1cblx0XHRcdGFzc2VydFVucmV2b2tlZChzdGF0ZSlcblx0XHRcdGlmICghbGF0ZXN0KHN0YXRlKS5oYXMoa2V5KSB8fCBsYXRlc3Qoc3RhdGUpLmdldChrZXkpICE9PSB2YWx1ZSkge1xuXHRcdFx0XHRwcmVwYXJlTWFwQ29weShzdGF0ZSlcblx0XHRcdFx0bWFya0NoYW5nZWQoc3RhdGUpXG5cdFx0XHRcdHN0YXRlLmFzc2lnbmVkXyEuc2V0KGtleSwgdHJ1ZSlcblx0XHRcdFx0c3RhdGUuY29weV8hLnNldChrZXksIHZhbHVlKVxuXHRcdFx0XHRzdGF0ZS5hc3NpZ25lZF8hLnNldChrZXksIHRydWUpXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpc1xuXHRcdH1cblxuXHRcdHAuZGVsZXRlID0gZnVuY3Rpb24oa2V5OiBhbnkpOiBib29sZWFuIHtcblx0XHRcdGlmICghdGhpcy5oYXMoa2V5KSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2Vcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc3RhdGU6IE1hcFN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV1cblx0XHRcdGFzc2VydFVucmV2b2tlZChzdGF0ZSlcblx0XHRcdHByZXBhcmVNYXBDb3B5KHN0YXRlKVxuXHRcdFx0bWFya0NoYW5nZWQoc3RhdGUpXG5cdFx0XHRpZiAoc3RhdGUuYmFzZV8uaGFzKGtleSkpIHtcblx0XHRcdFx0c3RhdGUuYXNzaWduZWRfIS5zZXQoa2V5LCBmYWxzZSlcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHN0YXRlLmFzc2lnbmVkXyEuZGVsZXRlKGtleSlcblx0XHRcdH1cblx0XHRcdHN0YXRlLmNvcHlfIS5kZWxldGUoa2V5KVxuXHRcdFx0cmV0dXJuIHRydWVcblx0XHR9XG5cblx0XHRwLmNsZWFyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRjb25zdCBzdGF0ZTogTWFwU3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXVxuXHRcdFx0YXNzZXJ0VW5yZXZva2VkKHN0YXRlKVxuXHRcdFx0aWYgKGxhdGVzdChzdGF0ZSkuc2l6ZSkge1xuXHRcdFx0XHRwcmVwYXJlTWFwQ29weShzdGF0ZSlcblx0XHRcdFx0bWFya0NoYW5nZWQoc3RhdGUpXG5cdFx0XHRcdHN0YXRlLmFzc2lnbmVkXyA9IG5ldyBNYXAoKVxuXHRcdFx0XHRlYWNoKHN0YXRlLmJhc2VfLCBrZXkgPT4ge1xuXHRcdFx0XHRcdHN0YXRlLmFzc2lnbmVkXyEuc2V0KGtleSwgZmFsc2UpXG5cdFx0XHRcdH0pXG5cdFx0XHRcdHN0YXRlLmNvcHlfIS5jbGVhcigpXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cC5mb3JFYWNoID0gZnVuY3Rpb24oXG5cdFx0XHRjYjogKHZhbHVlOiBhbnksIGtleTogYW55LCBzZWxmOiBhbnkpID0+IHZvaWQsXG5cdFx0XHR0aGlzQXJnPzogYW55XG5cdFx0KSB7XG5cdFx0XHRjb25zdCBzdGF0ZTogTWFwU3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXVxuXHRcdFx0bGF0ZXN0KHN0YXRlKS5mb3JFYWNoKChfdmFsdWU6IGFueSwga2V5OiBhbnksIF9tYXA6IGFueSkgPT4ge1xuXHRcdFx0XHRjYi5jYWxsKHRoaXNBcmcsIHRoaXMuZ2V0KGtleSksIGtleSwgdGhpcylcblx0XHRcdH0pXG5cdFx0fVxuXG5cdFx0cC5nZXQgPSBmdW5jdGlvbihrZXk6IGFueSk6IGFueSB7XG5cdFx0XHRjb25zdCBzdGF0ZTogTWFwU3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXVxuXHRcdFx0YXNzZXJ0VW5yZXZva2VkKHN0YXRlKVxuXHRcdFx0Y29uc3QgdmFsdWUgPSBsYXRlc3Qoc3RhdGUpLmdldChrZXkpXG5cdFx0XHRpZiAoc3RhdGUuZmluYWxpemVkXyB8fCAhaXNEcmFmdGFibGUodmFsdWUpKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZVxuXHRcdFx0fVxuXHRcdFx0aWYgKHZhbHVlICE9PSBzdGF0ZS5iYXNlXy5nZXQoa2V5KSkge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWUgLy8gZWl0aGVyIGFscmVhZHkgZHJhZnRlZCBvciByZWFzc2lnbmVkXG5cdFx0XHR9XG5cdFx0XHQvLyBkZXNwaXRlIHdoYXQgaXQgbG9va3MsIHRoaXMgY3JlYXRlcyBhIGRyYWZ0IG9ubHkgb25jZSwgc2VlIGFib3ZlIGNvbmRpdGlvblxuXHRcdFx0Y29uc3QgZHJhZnQgPSBjcmVhdGVQcm94eShzdGF0ZS5zY29wZV8uaW1tZXJfLCB2YWx1ZSwgc3RhdGUpXG5cdFx0XHRwcmVwYXJlTWFwQ29weShzdGF0ZSlcblx0XHRcdHN0YXRlLmNvcHlfIS5zZXQoa2V5LCBkcmFmdClcblx0XHRcdHJldHVybiBkcmFmdFxuXHRcdH1cblxuXHRcdHAua2V5cyA9IGZ1bmN0aW9uKCk6IEl0ZXJhYmxlSXRlcmF0b3I8YW55PiB7XG5cdFx0XHRyZXR1cm4gbGF0ZXN0KHRoaXNbRFJBRlRfU1RBVEVdKS5rZXlzKClcblx0XHR9XG5cblx0XHRwLnZhbHVlcyA9IGZ1bmN0aW9uKCk6IEl0ZXJhYmxlSXRlcmF0b3I8YW55PiB7XG5cdFx0XHRjb25zdCBpdGVyYXRvciA9IHRoaXMua2V5cygpXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRbaXRlcmF0b3JTeW1ib2xdOiAoKSA9PiB0aGlzLnZhbHVlcygpLFxuXHRcdFx0XHRuZXh0OiAoKSA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgciA9IGl0ZXJhdG9yLm5leHQoKVxuXHRcdFx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdFx0XHRcdFx0aWYgKHIuZG9uZSkgcmV0dXJuIHJcblx0XHRcdFx0XHRjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0KHIudmFsdWUpXG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdGRvbmU6IGZhbHNlLFxuXHRcdFx0XHRcdFx0dmFsdWVcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gYXMgYW55XG5cdFx0fVxuXG5cdFx0cC5lbnRyaWVzID0gZnVuY3Rpb24oKTogSXRlcmFibGVJdGVyYXRvcjxbYW55LCBhbnldPiB7XG5cdFx0XHRjb25zdCBpdGVyYXRvciA9IHRoaXMua2V5cygpXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRbaXRlcmF0b3JTeW1ib2xdOiAoKSA9PiB0aGlzLmVudHJpZXMoKSxcblx0XHRcdFx0bmV4dDogKCkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IHIgPSBpdGVyYXRvci5uZXh0KClcblx0XHRcdFx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHRcdFx0XHRcdGlmIChyLmRvbmUpIHJldHVybiByXG5cdFx0XHRcdFx0Y29uc3QgdmFsdWUgPSB0aGlzLmdldChyLnZhbHVlKVxuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRkb25lOiBmYWxzZSxcblx0XHRcdFx0XHRcdHZhbHVlOiBbci52YWx1ZSwgdmFsdWVdXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGFzIGFueVxuXHRcdH1cblxuXHRcdHBbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lbnRyaWVzKClcblx0XHR9XG5cblx0XHRyZXR1cm4gRHJhZnRNYXBcblx0fSkoTWFwKVxuXG5cdGZ1bmN0aW9uIHByb3h5TWFwXzxUIGV4dGVuZHMgQW55TWFwPih0YXJnZXQ6IFQsIHBhcmVudD86IEltbWVyU3RhdGUpOiBUIHtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0cmV0dXJuIG5ldyBEcmFmdE1hcCh0YXJnZXQsIHBhcmVudClcblx0fVxuXG5cdGZ1bmN0aW9uIHByZXBhcmVNYXBDb3B5KHN0YXRlOiBNYXBTdGF0ZSkge1xuXHRcdGlmICghc3RhdGUuY29weV8pIHtcblx0XHRcdHN0YXRlLmFzc2lnbmVkXyA9IG5ldyBNYXAoKVxuXHRcdFx0c3RhdGUuY29weV8gPSBuZXcgTWFwKHN0YXRlLmJhc2VfKVxuXHRcdH1cblx0fVxuXG5cdGNvbnN0IERyYWZ0U2V0ID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuXHRcdF9fZXh0ZW5kcyhEcmFmdFNldCwgX3N1cGVyKVxuXHRcdC8vIENyZWF0ZSBjbGFzcyBtYW51YWxseSwgY2F1c2UgIzUwMlxuXHRcdGZ1bmN0aW9uIERyYWZ0U2V0KHRoaXM6IGFueSwgdGFyZ2V0OiBBbnlTZXQsIHBhcmVudD86IEltbWVyU3RhdGUpIHtcblx0XHRcdHRoaXNbRFJBRlRfU1RBVEVdID0ge1xuXHRcdFx0XHR0eXBlXzogUHJveHlUeXBlLlNldCxcblx0XHRcdFx0cGFyZW50XzogcGFyZW50LFxuXHRcdFx0XHRzY29wZV86IHBhcmVudCA/IHBhcmVudC5zY29wZV8gOiBnZXRDdXJyZW50U2NvcGUoKSEsXG5cdFx0XHRcdG1vZGlmaWVkXzogZmFsc2UsXG5cdFx0XHRcdGZpbmFsaXplZF86IGZhbHNlLFxuXHRcdFx0XHRjb3B5XzogdW5kZWZpbmVkLFxuXHRcdFx0XHRiYXNlXzogdGFyZ2V0LFxuXHRcdFx0XHRkcmFmdF86IHRoaXMsXG5cdFx0XHRcdGRyYWZ0c186IG5ldyBNYXAoKSxcblx0XHRcdFx0cmV2b2tlZF86IGZhbHNlLFxuXHRcdFx0XHRpc01hbnVhbF86IGZhbHNlXG5cdFx0XHR9IGFzIFNldFN0YXRlXG5cdFx0XHRyZXR1cm4gdGhpc1xuXHRcdH1cblx0XHRjb25zdCBwID0gRHJhZnRTZXQucHJvdG90eXBlXG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkocCwgXCJzaXplXCIsIHtcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBsYXRlc3QodGhpc1tEUkFGVF9TVEFURV0pLnNpemVcblx0XHRcdH1cblx0XHRcdC8vIGVudW1lcmFibGU6IHRydWUsXG5cdFx0fSlcblxuXHRcdHAuaGFzID0gZnVuY3Rpb24odmFsdWU6IGFueSk6IGJvb2xlYW4ge1xuXHRcdFx0Y29uc3Qgc3RhdGU6IFNldFN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV1cblx0XHRcdGFzc2VydFVucmV2b2tlZChzdGF0ZSlcblx0XHRcdC8vIGJpdCBvZiB0cmlja2VyeSBoZXJlLCB0byBiZSBhYmxlIHRvIHJlY29nbml6ZSBib3RoIHRoZSB2YWx1ZSwgYW5kIHRoZSBkcmFmdCBvZiBpdHMgdmFsdWVcblx0XHRcdGlmICghc3RhdGUuY29weV8pIHtcblx0XHRcdFx0cmV0dXJuIHN0YXRlLmJhc2VfLmhhcyh2YWx1ZSlcblx0XHRcdH1cblx0XHRcdGlmIChzdGF0ZS5jb3B5Xy5oYXModmFsdWUpKSByZXR1cm4gdHJ1ZVxuXHRcdFx0aWYgKHN0YXRlLmRyYWZ0c18uaGFzKHZhbHVlKSAmJiBzdGF0ZS5jb3B5Xy5oYXMoc3RhdGUuZHJhZnRzXy5nZXQodmFsdWUpKSlcblx0XHRcdFx0cmV0dXJuIHRydWVcblx0XHRcdHJldHVybiBmYWxzZVxuXHRcdH1cblxuXHRcdHAuYWRkID0gZnVuY3Rpb24odmFsdWU6IGFueSk6IGFueSB7XG5cdFx0XHRjb25zdCBzdGF0ZTogU2V0U3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXVxuXHRcdFx0YXNzZXJ0VW5yZXZva2VkKHN0YXRlKVxuXHRcdFx0aWYgKCF0aGlzLmhhcyh2YWx1ZSkpIHtcblx0XHRcdFx0cHJlcGFyZVNldENvcHkoc3RhdGUpXG5cdFx0XHRcdG1hcmtDaGFuZ2VkKHN0YXRlKVxuXHRcdFx0XHRzdGF0ZS5jb3B5XyEuYWRkKHZhbHVlKVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXNcblx0XHR9XG5cblx0XHRwLmRlbGV0ZSA9IGZ1bmN0aW9uKHZhbHVlOiBhbnkpOiBhbnkge1xuXHRcdFx0aWYgKCF0aGlzLmhhcyh2YWx1ZSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHN0YXRlOiBTZXRTdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdXG5cdFx0XHRhc3NlcnRVbnJldm9rZWQoc3RhdGUpXG5cdFx0XHRwcmVwYXJlU2V0Q29weShzdGF0ZSlcblx0XHRcdG1hcmtDaGFuZ2VkKHN0YXRlKVxuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0c3RhdGUuY29weV8hLmRlbGV0ZSh2YWx1ZSkgfHxcblx0XHRcdFx0KHN0YXRlLmRyYWZ0c18uaGFzKHZhbHVlKVxuXHRcdFx0XHRcdD8gc3RhdGUuY29weV8hLmRlbGV0ZShzdGF0ZS5kcmFmdHNfLmdldCh2YWx1ZSkpXG5cdFx0XHRcdFx0OiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmYWxzZSlcblx0XHRcdClcblx0XHR9XG5cblx0XHRwLmNsZWFyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRjb25zdCBzdGF0ZTogU2V0U3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXVxuXHRcdFx0YXNzZXJ0VW5yZXZva2VkKHN0YXRlKVxuXHRcdFx0aWYgKGxhdGVzdChzdGF0ZSkuc2l6ZSkge1xuXHRcdFx0XHRwcmVwYXJlU2V0Q29weShzdGF0ZSlcblx0XHRcdFx0bWFya0NoYW5nZWQoc3RhdGUpXG5cdFx0XHRcdHN0YXRlLmNvcHlfIS5jbGVhcigpXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cC52YWx1ZXMgPSBmdW5jdGlvbigpOiBJdGVyYWJsZUl0ZXJhdG9yPGFueT4ge1xuXHRcdFx0Y29uc3Qgc3RhdGU6IFNldFN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV1cblx0XHRcdGFzc2VydFVucmV2b2tlZChzdGF0ZSlcblx0XHRcdHByZXBhcmVTZXRDb3B5KHN0YXRlKVxuXHRcdFx0cmV0dXJuIHN0YXRlLmNvcHlfIS52YWx1ZXMoKVxuXHRcdH1cblxuXHRcdHAuZW50cmllcyA9IGZ1bmN0aW9uIGVudHJpZXMoKTogSXRlcmFibGVJdGVyYXRvcjxbYW55LCBhbnldPiB7XG5cdFx0XHRjb25zdCBzdGF0ZTogU2V0U3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXVxuXHRcdFx0YXNzZXJ0VW5yZXZva2VkKHN0YXRlKVxuXHRcdFx0cHJlcGFyZVNldENvcHkoc3RhdGUpXG5cdFx0XHRyZXR1cm4gc3RhdGUuY29weV8hLmVudHJpZXMoKVxuXHRcdH1cblxuXHRcdHAua2V5cyA9IGZ1bmN0aW9uKCk6IEl0ZXJhYmxlSXRlcmF0b3I8YW55PiB7XG5cdFx0XHRyZXR1cm4gdGhpcy52YWx1ZXMoKVxuXHRcdH1cblxuXHRcdHBbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy52YWx1ZXMoKVxuXHRcdH1cblxuXHRcdHAuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goY2I6IGFueSwgdGhpc0FyZz86IGFueSkge1xuXHRcdFx0Y29uc3QgaXRlcmF0b3IgPSB0aGlzLnZhbHVlcygpXG5cdFx0XHRsZXQgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpXG5cdFx0XHR3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG5cdFx0XHRcdGNiLmNhbGwodGhpc0FyZywgcmVzdWx0LnZhbHVlLCByZXN1bHQudmFsdWUsIHRoaXMpXG5cdFx0XHRcdHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBEcmFmdFNldFxuXHR9KShTZXQpXG5cblx0ZnVuY3Rpb24gcHJveHlTZXRfPFQgZXh0ZW5kcyBBbnlTZXQ+KHRhcmdldDogVCwgcGFyZW50PzogSW1tZXJTdGF0ZSk6IFQge1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRyZXR1cm4gbmV3IERyYWZ0U2V0KHRhcmdldCwgcGFyZW50KVxuXHR9XG5cblx0ZnVuY3Rpb24gcHJlcGFyZVNldENvcHkoc3RhdGU6IFNldFN0YXRlKSB7XG5cdFx0aWYgKCFzdGF0ZS5jb3B5Xykge1xuXHRcdFx0Ly8gY3JlYXRlIGRyYWZ0cyBmb3IgYWxsIGVudHJpZXMgdG8gcHJlc2VydmUgaW5zZXJ0aW9uIG9yZGVyXG5cdFx0XHRzdGF0ZS5jb3B5XyA9IG5ldyBTZXQoKVxuXHRcdFx0c3RhdGUuYmFzZV8uZm9yRWFjaCh2YWx1ZSA9PiB7XG5cdFx0XHRcdGlmIChpc0RyYWZ0YWJsZSh2YWx1ZSkpIHtcblx0XHRcdFx0XHRjb25zdCBkcmFmdCA9IGNyZWF0ZVByb3h5KHN0YXRlLnNjb3BlXy5pbW1lcl8sIHZhbHVlLCBzdGF0ZSlcblx0XHRcdFx0XHRzdGF0ZS5kcmFmdHNfLnNldCh2YWx1ZSwgZHJhZnQpXG5cdFx0XHRcdFx0c3RhdGUuY29weV8hLmFkZChkcmFmdClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0ZS5jb3B5XyEuYWRkKHZhbHVlKVxuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGFzc2VydFVucmV2b2tlZChzdGF0ZTogYW55IC8qRVM1U3RhdGUgfCBNYXBTdGF0ZSB8IFNldFN0YXRlKi8pIHtcblx0XHRpZiAoc3RhdGUucmV2b2tlZF8pIGRpZSgzLCBKU09OLnN0cmluZ2lmeShsYXRlc3Qoc3RhdGUpKSlcblx0fVxuXG5cdGxvYWRQbHVnaW4oXCJNYXBTZXRcIiwge3Byb3h5TWFwXywgcHJveHlTZXRffSlcbn1cbiIsImltcG9ydCB7ZW5hYmxlRVM1fSBmcm9tIFwiLi9lczVcIlxuaW1wb3J0IHtlbmFibGVNYXBTZXR9IGZyb20gXCIuL21hcHNldFwiXG5pbXBvcnQge2VuYWJsZVBhdGNoZXN9IGZyb20gXCIuL3BhdGNoZXNcIlxuXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlQWxsUGx1Z2lucygpIHtcblx0ZW5hYmxlRVM1KClcblx0ZW5hYmxlTWFwU2V0KClcblx0ZW5hYmxlUGF0Y2hlcygpXG59XG4iLCJpbXBvcnQge1xuXHRJUHJvZHVjZSxcblx0SVByb2R1Y2VXaXRoUGF0Y2hlcyxcblx0SW1tZXIsXG5cdERyYWZ0LFxuXHRJbW11dGFibGVcbn0gZnJvbSBcIi4vaW50ZXJuYWxcIlxuXG5leHBvcnQge1xuXHREcmFmdCxcblx0SW1tdXRhYmxlLFxuXHRQYXRjaCxcblx0UGF0Y2hMaXN0ZW5lcixcblx0b3JpZ2luYWwsXG5cdGN1cnJlbnQsXG5cdGlzRHJhZnQsXG5cdGlzRHJhZnRhYmxlLFxuXHROT1RISU5HIGFzIG5vdGhpbmcsXG5cdERSQUZUQUJMRSBhcyBpbW1lcmFibGUsXG5cdGZyZWV6ZVxufSBmcm9tIFwiLi9pbnRlcm5hbFwiXG5cbmNvbnN0IGltbWVyID0gbmV3IEltbWVyKClcblxuLyoqXG4gKiBUaGUgYHByb2R1Y2VgIGZ1bmN0aW9uIHRha2VzIGEgdmFsdWUgYW5kIGEgXCJyZWNpcGUgZnVuY3Rpb25cIiAod2hvc2VcbiAqIHJldHVybiB2YWx1ZSBvZnRlbiBkZXBlbmRzIG9uIHRoZSBiYXNlIHN0YXRlKS4gVGhlIHJlY2lwZSBmdW5jdGlvbiBpc1xuICogZnJlZSB0byBtdXRhdGUgaXRzIGZpcnN0IGFyZ3VtZW50IGhvd2V2ZXIgaXQgd2FudHMuIEFsbCBtdXRhdGlvbnMgYXJlXG4gKiBvbmx5IGV2ZXIgYXBwbGllZCB0byBhIF9fY29weV9fIG9mIHRoZSBiYXNlIHN0YXRlLlxuICpcbiAqIFBhc3Mgb25seSBhIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIFwiY3VycmllZCBwcm9kdWNlclwiIHdoaWNoIHJlbGlldmVzIHlvdVxuICogZnJvbSBwYXNzaW5nIHRoZSByZWNpcGUgZnVuY3Rpb24gZXZlcnkgdGltZS5cbiAqXG4gKiBPbmx5IHBsYWluIG9iamVjdHMgYW5kIGFycmF5cyBhcmUgbWFkZSBtdXRhYmxlLiBBbGwgb3RoZXIgb2JqZWN0cyBhcmVcbiAqIGNvbnNpZGVyZWQgdW5jb3B5YWJsZS5cbiAqXG4gKiBOb3RlOiBUaGlzIGZ1bmN0aW9uIGlzIF9fYm91bmRfXyB0byBpdHMgYEltbWVyYCBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge2FueX0gYmFzZSAtIHRoZSBpbml0aWFsIHN0YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcm9kdWNlciAtIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgYSBwcm94eSBvZiB0aGUgYmFzZSBzdGF0ZSBhcyBmaXJzdCBhcmd1bWVudCBhbmQgd2hpY2ggY2FuIGJlIGZyZWVseSBtb2RpZmllZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcGF0Y2hMaXN0ZW5lciAtIG9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBhbGwgdGhlIHBhdGNoZXMgcHJvZHVjZWQgaGVyZVxuICogQHJldHVybnMge2FueX0gYSBuZXcgc3RhdGUsIG9yIHRoZSBpbml0aWFsIHN0YXRlIGlmIG5vdGhpbmcgd2FzIG1vZGlmaWVkXG4gKi9cbmV4cG9ydCBjb25zdCBwcm9kdWNlOiBJUHJvZHVjZSA9IGltbWVyLnByb2R1Y2VcbmV4cG9ydCBkZWZhdWx0IHByb2R1Y2VcblxuLyoqXG4gKiBMaWtlIGBwcm9kdWNlYCwgYnV0IGBwcm9kdWNlV2l0aFBhdGNoZXNgIGFsd2F5cyByZXR1cm5zIGEgdHVwbGVcbiAqIFtuZXh0U3RhdGUsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzXSAoaW5zdGVhZCBvZiBqdXN0IHRoZSBuZXh0IHN0YXRlKVxuICovXG5leHBvcnQgY29uc3QgcHJvZHVjZVdpdGhQYXRjaGVzOiBJUHJvZHVjZVdpdGhQYXRjaGVzID0gaW1tZXIucHJvZHVjZVdpdGhQYXRjaGVzLmJpbmQoXG5cdGltbWVyXG4pXG5cbi8qKlxuICogUGFzcyB0cnVlIHRvIGF1dG9tYXRpY2FsbHkgZnJlZXplIGFsbCBjb3BpZXMgY3JlYXRlZCBieSBJbW1lci5cbiAqXG4gKiBBbHdheXMgZnJlZXplIGJ5IGRlZmF1bHQsIGV2ZW4gaW4gcHJvZHVjdGlvbiBtb2RlXG4gKi9cbmV4cG9ydCBjb25zdCBzZXRBdXRvRnJlZXplID0gaW1tZXIuc2V0QXV0b0ZyZWV6ZS5iaW5kKGltbWVyKVxuXG4vKipcbiAqIFBhc3MgdHJ1ZSB0byB1c2UgdGhlIEVTMjAxNSBgUHJveHlgIGNsYXNzIHdoZW4gY3JlYXRpbmcgZHJhZnRzLCB3aGljaCBpc1xuICogYWx3YXlzIGZhc3RlciB0aGFuIHVzaW5nIEVTNSBwcm94aWVzLlxuICpcbiAqIEJ5IGRlZmF1bHQsIGZlYXR1cmUgZGV0ZWN0aW9uIGlzIHVzZWQsIHNvIGNhbGxpbmcgdGhpcyBpcyByYXJlbHkgbmVjZXNzYXJ5LlxuICovXG5leHBvcnQgY29uc3Qgc2V0VXNlUHJveGllcyA9IGltbWVyLnNldFVzZVByb3hpZXMuYmluZChpbW1lcilcblxuLyoqXG4gKiBBcHBseSBhbiBhcnJheSBvZiBJbW1lciBwYXRjaGVzIHRvIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGEgcHJvZHVjZXIsIHdoaWNoIG1lYW5zIGNvcHktb24td3JpdGUgaXMgaW4gZWZmZWN0LlxuICovXG5leHBvcnQgY29uc3QgYXBwbHlQYXRjaGVzID0gaW1tZXIuYXBwbHlQYXRjaGVzLmJpbmQoaW1tZXIpXG5cbi8qKlxuICogQ3JlYXRlIGFuIEltbWVyIGRyYWZ0IGZyb20gdGhlIGdpdmVuIGJhc2Ugc3RhdGUsIHdoaWNoIG1heSBiZSBhIGRyYWZ0IGl0c2VsZi5cbiAqIFRoZSBkcmFmdCBjYW4gYmUgbW9kaWZpZWQgdW50aWwgeW91IGZpbmFsaXplIGl0IHdpdGggdGhlIGBmaW5pc2hEcmFmdGAgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVEcmFmdCA9IGltbWVyLmNyZWF0ZURyYWZ0LmJpbmQoaW1tZXIpXG5cbi8qKlxuICogRmluYWxpemUgYW4gSW1tZXIgZHJhZnQgZnJvbSBhIGBjcmVhdGVEcmFmdGAgY2FsbCwgcmV0dXJuaW5nIHRoZSBiYXNlIHN0YXRlXG4gKiAoaWYgbm8gY2hhbmdlcyB3ZXJlIG1hZGUpIG9yIGEgbW9kaWZpZWQgY29weS4gVGhlIGRyYWZ0IG11c3QgKm5vdCogYmVcbiAqIG11dGF0ZWQgYWZ0ZXJ3YXJkcy5cbiAqXG4gKiBQYXNzIGEgZnVuY3Rpb24gYXMgdGhlIDJuZCBhcmd1bWVudCB0byBnZW5lcmF0ZSBJbW1lciBwYXRjaGVzIGJhc2VkIG9uIHRoZVxuICogY2hhbmdlcyB0aGF0IHdlcmUgbWFkZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGZpbmlzaERyYWZ0ID0gaW1tZXIuZmluaXNoRHJhZnQuYmluZChpbW1lcilcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGFjdHVhbGx5IGEgbm8tb3AsIGJ1dCBjYW4gYmUgdXNlZCB0byBjYXN0IGFuIGltbXV0YWJsZSB0eXBlXG4gKiB0byBhbiBkcmFmdCB0eXBlIGFuZCBtYWtlIFR5cGVTY3JpcHQgaGFwcHlcbiAqXG4gKiBAcGFyYW0gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhc3REcmFmdDxUPih2YWx1ZTogVCk6IERyYWZ0PFQ+IHtcblx0cmV0dXJuIHZhbHVlIGFzIGFueVxufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYWN0dWFsbHkgYSBuby1vcCwgYnV0IGNhbiBiZSB1c2VkIHRvIGNhc3QgYSBtdXRhYmxlIHR5cGVcbiAqIHRvIGFuIGltbXV0YWJsZSB0eXBlIGFuZCBtYWtlIFR5cGVTY3JpcHQgaGFwcHlcbiAqIEBwYXJhbSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FzdEltbXV0YWJsZTxUPih2YWx1ZTogVCk6IEltbXV0YWJsZTxUPiB7XG5cdHJldHVybiB2YWx1ZSBhcyBhbnlcbn1cblxuZXhwb3J0IHtJbW1lcn1cblxuZXhwb3J0IHtlbmFibGVFUzV9IGZyb20gXCIuL3BsdWdpbnMvZXM1XCJcbmV4cG9ydCB7ZW5hYmxlUGF0Y2hlc30gZnJvbSBcIi4vcGx1Z2lucy9wYXRjaGVzXCJcbmV4cG9ydCB7ZW5hYmxlTWFwU2V0fSBmcm9tIFwiLi9wbHVnaW5zL21hcHNldFwiXG5leHBvcnQge2VuYWJsZUFsbFBsdWdpbnN9IGZyb20gXCIuL3BsdWdpbnMvYWxsXCJcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBRUE7QUFFQTtBQUNBLElBQU1BLFNBQVMsR0FDZCxPQUFPQyxNQUFQLEtBQWtCLFdBQWxCLElBQWlDO0FBQU9BLE1BQU0sQ0FBQyxHQUFELENBQWIsS0FBdUIsUUFEekQ7QUFFTyxJQUFNQyxNQUFNLEdBQUcsT0FBT0MsR0FBUCxLQUFlLFdBQTlCO0FBQ0EsSUFBTUMsTUFBTSxHQUFHLE9BQU9DLEdBQVAsS0FBZSxXQUE5QjtBQUNBLElBQU1DLFVBQVUsR0FDdEIsT0FBT0MsS0FBUCxLQUFpQixXQUFqQixJQUNBLE9BQU9BLEtBQUssQ0FBQ0MsU0FBYixLQUEyQixXQUQzQixJQUVBLE9BQU9DLE9BQVAsS0FBbUIsV0FIYjtBQUtQOzs7O0lBR2FDLE9BQU8sR0FBWVYsU0FBUztBQUN0Q0MsTUFBTSxDQUFDVSxHQUFQLENBQVcs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