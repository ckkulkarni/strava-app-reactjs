f5e573ec2e22fb71a914ccc1af4efd59
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

// these aren't really private, but nor are they really useful to document

/**
 * @private
 */
class LuxonError extends Error {}

/**
 * @private
 */
class InvalidDateTimeError extends LuxonError {
  constructor(reason) {
    super(`Invalid DateTime: ${reason.toMessage()}`);
  }
}

/**
 * @private
 */
class InvalidIntervalError extends LuxonError {
  constructor(reason) {
    super(`Invalid Interval: ${reason.toMessage()}`);
  }
}

/**
 * @private
 */
class InvalidDurationError extends LuxonError {
  constructor(reason) {
    super(`Invalid Duration: ${reason.toMessage()}`);
  }
}

/**
 * @private
 */
class ConflictingSpecificationError extends LuxonError {}

/**
 * @private
 */
class InvalidUnitError extends LuxonError {
  constructor(unit) {
    super(`Invalid unit ${unit}`);
  }
}

/**
 * @private
 */
class InvalidArgumentError extends LuxonError {}

/**
 * @private
 */
class ZoneIsAbstractError extends LuxonError {
  constructor() {
    super("Zone is an abstract class");
  }
}

/**
 * @private
 */

const n = "numeric",
  s = "short",
  l = "long";
const DATE_SHORT = {
  year: n,
  month: n,
  day: n
};
const DATE_MED = {
  year: n,
  month: s,
  day: n
};
const DATE_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s
};
const DATE_FULL = {
  year: n,
  month: l,
  day: n
};
const DATE_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l
};
const TIME_SIMPLE = {
  hour: n,
  minute: n
};
const TIME_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n
};
const TIME_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s
};
const TIME_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};
const TIME_24_SIMPLE = {
  hour: n,
  minute: n,
  hourCycle: "h23"
};
const TIME_24_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23"
};
const TIME_24_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: s
};
const TIME_24_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: l
};
const DATETIME_SHORT = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n
};
const DATETIME_SHORT_WITH_SECONDS = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n,
  second: n
};
const DATETIME_MED = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n
};
const DATETIME_MED_WITH_SECONDS = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n,
  second: n
};
const DATETIME_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s,
  hour: n,
  minute: n
};
const DATETIME_FULL = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  timeZoneName: s
};
const DATETIME_FULL_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s
};
const DATETIME_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  timeZoneName: l
};
const DATETIME_HUGE_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};

/**
 * @interface
 */
class Zone {
  /**
   * The type of zone
   * @abstract
   * @type {string}
   */
  get type() {
    throw new ZoneIsAbstractError();
  }

  /**
   * The name of this zone.
   * @abstract
   * @type {string}
   */
  get name() {
    throw new ZoneIsAbstractError();
  }
  get ianaName() {
    return this.name;
  }

  /**
   * Returns whether the offset is known to be fixed for the whole year.
   * @abstract
   * @type {boolean}
   */
  get isUniversal() {
    throw new ZoneIsAbstractError();
  }

  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(ts, opts) {
    throw new ZoneIsAbstractError();
  }

  /**
   * Returns the offset's value as a string
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(ts, format) {
    throw new ZoneIsAbstractError();
  }

  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(ts) {
    throw new ZoneIsAbstractError();
  }

  /**
   * Return whether this Zone is equal to another zone
   * @abstract
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(otherZone) {
    throw new ZoneIsAbstractError();
  }

  /**
   * Return whether this Zone is valid.
   * @abstract
   * @type {boolean}
   */
  get isValid() {
    throw new ZoneIsAbstractError();
  }
}
let singleton$1 = null;

/**
 * Represents the local zone for this JavaScript environment.
 * @implements {Zone}
 */
class SystemZone extends Zone {
  /**
   * Get a singleton instance of the local zone
   * @return {SystemZone}
   */
  static get instance() {
    if (singleton$1 === null) {
      singleton$1 = new SystemZone();
    }
    return singleton$1;
  }

  /** @override **/
  get type() {
    return "system";
  }

  /** @override **/
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }

  /** @override **/
  get isUniversal() {
    return false;
  }

  /** @override **/
  offsetName(ts, {
    format,
    locale
  }) {
    return parseZoneInfo(ts, format, locale);
  }

  /** @override **/
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }

  /** @override **/
  offset(ts) {
    return -new Date(ts).getTimezoneOffset();
  }

  /** @override **/
  equals(otherZone) {
    return otherZone.type === "system";
  }

  /** @override **/
  get isValid() {
    return true;
  }
}
let dtfCache = {};
function makeDTF(zone) {
  if (!dtfCache[zone]) {
    dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone: zone,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      era: "short"
    });
  }
  return dtfCache[zone];
}
const typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function hackyOffset(dtf, date) {
  const formatted = dtf.format(date).replace(/\u200E/g, ""),
    parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted),
    [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
}
function partsOffset(dtf, date) {
  const formatted = dtf.formatToParts(date);
  const filled = [];
  for (let i = 0; i < formatted.length; i++) {
    const {
      type,
      value
    } = formatted[i];
    const pos = typeToPos[type];
    if (type === "era") {
      filled[pos] = value;
    } else if (!isUndefined(pos)) {
      filled[pos] = parseInt(value, 10);
    }
  }
  return filled;
}
let ianaZoneCache = {};
/**
 * A zone identified by an IANA identifier, like America/New_York
 * @implements {Zone}
 */
class IANAZone extends Zone {
  /**
   * @param {string} name - Zone name
   * @return {IANAZone}
   */
  static create(name) {
    if (!ianaZoneCache[name]) {
      ianaZoneCache[name] = new IANAZone(name);
    }
    return ianaZoneCache[name];
  }

  /**
   * Reset local caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCache() {
    ianaZoneCache = {};
    dtfCache = {};
  }

  /**
   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
   * @param {string} s - The string to check validity on
   * @example IANAZone.isValidSpecifier("America/New_York") //=> true
   * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
   * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.
   * @return {boolean}
   */
  static isValidSpecifier(s) {
    return this.isValidZone(s);
  }

  /**
   * Returns whether the provided string identifies a real zone
   * @param {string} zone - The string to check
   * @example IANAZone.isValidZone("America/New_York") //=> true
   * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
   * @example IANAZone.isValidZone("Sport~~blorp") //=> false
   * @return {boolean}
   */
  static isValidZone(zone) {
    if (!zone) {
      return false;
    }
    try {
      new Intl.DateTimeFormat("en-US", {
        timeZone: zone
      }).format();
      return true;
    } catch (e) {
      return false;
    }
  }
  constructor(name) {
    super();
    /** @private **/
    this.zoneName = name;
    /** @private **/
    this.valid = IANAZone.isValidZone(name);
  }

  /** @override **/
  get type() {
    return "iana";
  }

  /** @override **/
  get name() {
    return this.zoneName;
  }

  /** @override **/
  get isUniversal() {
    return false;
  }

  /** @override **/
  offsetName(ts, {
    format,
    locale
  }) {
    return parseZoneInfo(ts, format, locale, this.name);
  }

  /** @override **/
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }

  /** @override **/
  offset(ts) {
    const date = new Date(ts);
    if (isNaN(date)) return NaN;
    const dtf = makeDTF(this.name);
    let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);
    if (adOrBc === "BC") {
      year = -Math.abs(year) + 1;
    }

    // because we're using hour12 and https://bugs.chromium.org/p/chromium/issues/detail?id=1025564&can=2&q=%2224%3A00%22%20datetimeformat
    const adjustedHour = hour === 24 ? 0 : hour;
    const asUTC = objToLocalTS({
      year,
      month,
      day,
      hour: adjustedHour,
      minute,
      second,
      millisecond: 0
    });
    let asTS = +date;
    const over = asTS % 1000;
    asTS -= over >= 0 ? over : 1000 + over;
    return (asUTC - asTS) / (60 * 1000);
  }

  /** @override **/
  equals(otherZone) {
    return otherZone.type === "iana" && otherZone.name === this.name;
  }

  /** @override **/
  get isValid() {
    return this.valid;
  }
}

// todo - remap caching

let intlLFCache = {};
function getCachedLF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlLFCache[key];
  if (!dtf) {
    dtf = new Intl.ListFormat(locString, opts);
    intlLFCache[key] = dtf;
  }
  return dtf;
}
let intlDTCache = {};
function getCachedDTF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlDTCache[key];
  if (!dtf) {
    dtf = new Intl.DateTimeFormat(locString, opts);
    intlDTCache[key] = dtf;
  }
  return dtf;
}
let intlNumCache = {};
function getCachedINF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let inf = intlNumCache[key];
  if (!inf) {
    inf = new Intl.NumberFormat(locString, opts);
    intlNumCache[key] = inf;
  }
  return inf;
}
let intlRelCache = {};
function getCachedRTF(locString, opts = {}) {
  const {
    base,
    ...cacheKeyOpts
  } = opts; // exclude `base` from the options
  const key = JSON.stringify([locString, cacheKeyOpts]);
  let inf = intlRelCache[key];
  if (!inf) {
    inf = new Intl.RelativeTimeFormat(locString, opts);
    intlRelCache[key] = inf;
  }
  return inf;
}
let sysLocaleCache = null;
function systemLocale() {
  if (sysLocaleCache) {
    return sysLocaleCache;
  } else {
    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
    return sysLocaleCache;
  }
}
function parseLocaleString(localeStr) {
  // I really want to avoid writing a BCP 47 parser
  // see, e.g. https://github.com/wooorm/bcp-47
  // Instead, we'll do this:

  // a) if the string has no -u extensions, just leave it alone
  // b) if it does, use Intl to resolve everything
  // c) if Intl fails, try again without the -u

  // private subtags and unicode subtags have ordering requirements,
  // and we're not properly parsing this, so just strip out the
  // private ones if they exist.
  const xIndex = localeStr.indexOf("-x-");
  if (xIndex !== -1) {
    localeStr = localeStr.substring(0, xIndex);
  }
  const uIndex = localeStr.indexOf("-u-");
  if (uIndex === -1) {
    return [localeStr];
  } else {
    let options;
    let selectedStr;
    try {
      options = getCachedDTF(localeStr).resolvedOptions();
      selectedStr = localeStr;
    } catch (e) {
      const smaller = localeStr.substring(0, uIndex);
      options = getCachedDTF(smaller).resolvedOptions();
      selectedStr = smaller;
    }
    const {
      numberingSystem,
      calendar
    } = options;
    return [selectedStr, numberingSystem, calendar];
  }
}
function intlConfigString(localeStr, numberingSystem, outputCalendar) {
  if (outputCalendar || numberingSystem) {
    if (!localeStr.includes("-u-")) {
      localeStr += "-u";
    }
    if (outputCalendar) {
      localeStr += `-ca-${outputCalendar}`;
    }
    if (numberingSystem) {
      localeStr += `-nu-${numberingSystem}`;
    }
    return localeStr;
  } else {
    return localeStr;
  }
}
function mapMonths(f) {
  const ms = [];
  for (let i = 1; i <= 12; i++) {
    const dt = DateTime.utc(2016, i, 1);
    ms.push(f(dt));
  }
  return ms;
}
function mapWeekdays(f) {
  const ms = [];
  for (let i = 1; i <= 7; i++) {
    const dt = DateTime.utc(2016, 11, 13 + i);
    ms.push(f(dt));
  }
  return ms;
}
function listStuff(loc, length, defaultOK, englishFn, intlFn) {
  const mode = loc.listingMode(defaultOK);
  if (mode === "error") {
    return null;
  } else if (mode === "en") {
    return englishFn(length);
  } else {
    return intlFn(length);
  }
}
function supportsFastNumbers(loc) {
  if (loc.numberingSystem && loc.numberingSystem !== "latn") {
    return false;
  } else {
    return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
  }
}

/**
 * @private
 */

class PolyNumberFormatter {
  constructor(intl, forceSimple, opts) {
    this.padTo = opts.padTo || 0;
    this.floor = opts.floor || false;
    const {
      padTo,
      floor,
      ...otherOpts
    } = opts;
    if (!forceSimple || Object.keys(otherOpts).length > 0) {
      const intlOpts = {
        useGrouping: false,
        ...opts
      };
      if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo;
      this.inf = getCachedINF(intl, intlOpts);
    }
  }
  format(i) {
    if (this.inf) {
      const fixed = this.floor ? Math.floor(i) : i;
      return this.inf.format(fixed);
    } else {
      // to match the browser's numberformatter defaults
      const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);
      return padStart(fixed, this.padTo);
    }
  }
}

/**
 * @private
 */

class PolyDateFormatter {
  constructor(dt, intl, opts) {
    this.opts = opts;
    let z = undefined;
    if (dt.zone.isUniversal) {
      // UTC-8 or Etc/UTC-8 are not part of tzdata, only Etc/GMT+8 and the like.
      // That is why fixed-offset TZ is set to that unless it is:
      // 1. Representing offset 0 when UTC is used to maintain previous behavior and does not become GMT.
      // 2. Unsupported by the browser:
      //    - some do not support Etc/
      //    - < Etc/GMT-14, > Etc/GMT+12, and 30-minute or 45-minute offsets are not part of tzdata
      const gmtOffset = -1 * (dt.offset / 60);
      const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
      if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
        z = offsetZ;
        this.dt = dt;
      } else {
        // Not all fixed-offset zones like Etc/+4:30 are present in tzdata.
        // So we have to make do. Two cases:
        // 1. The format options tell us to show the zone. We can't do that, so the best
        // we can do is format the date in UTC.
        // 2. The format options don't tell us to show the zone. Then we can adjust them
        // the time and tell the formatter to show it to us in UTC, so that the time is right
        // and the bad zone doesn't show up.
        z = "UTC";
        if (opts.timeZoneName) {
          this.dt = dt;
        } else {
          this.dt = dt.offset === 0 ? dt : DateTime.fromMillis(dt.ts + dt.offset * 60 * 1000);
        }
      }
    } else if (dt.zone.type === "system") {
      this.dt = dt;
    } else {
      this.dt = dt;
      z = dt.zone.name;
    }
    const intlOpts = {
      ...this.opts
    };
    intlOpts.timeZone = intlOpts.timeZone || z;
    this.dtf = getCachedDTF(intl, intlOpts);
  }
  format() {
    return this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    return this.dtf.formatToParts(this.dt.toJSDate());
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
}

/**
 * @private
 */
class PolyRelFormatter {
  constructor(intl, isEnglish, opts) {
    this.opts = {
      style: "long",
      ...opts
    };
    if (!isEnglish && hasRelative()) {
      this.rtf = getCachedRTF(intl, opts);
    }
  }
  format(count, unit) {
    if (this.rtf) {
      return this.rtf.format(count, unit);
    } else {
      return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
    }
  }
  formatToParts(count, unit) {
    if (this.rtf) {
      return this.rtf.formatToParts(count, unit);
    } else {
      return [];
    }
  }
}

/**
 * @private
 */

class Locale {
  static fromOpts(opts) {
    return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);
  }
  static create(locale, numberingSystem, outputCalendar, defaultToEN = false) {
    const specifiedLocale = locale || Settings.defaultLocale;
    // the system locale is useful for human readable strings but annoying for parsing/formatting known formats
    const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
    const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
    const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
    return new Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);
  }
  static resetCache() {
    sysLocaleCache = null;
    intlDTCache = {};
    intlNumCache = {};
    intlRelCache = {};
  }
  static fromObject({
    locale,
    numberingSystem,
    outputCalendar
  } = {}) {
    return Locale.create(locale, numberingSystem, outputCalendar);
  }
  constructor(locale, numbering, outputCalendar, specifiedLocale) {
    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);
    this.locale = parsedLocale;
    this.numberingSystem = numbering || parsedNumberingSystem || null;
    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
    this.weekdaysCache = {
      format: {},
      standalone: {}
    };
    this.monthsCache = {
      format: {},
      standalone: {}
    };
    this.meridiemCache = null;
    this.eraCache = {};
    this.specifiedLocale = specifiedLocale;
    this.fastNumbersCached = null;
  }
  get fastNumbers() {
    if (this.fastNumbersCached == null) {
      this.fastNumbersCached = supportsFastNumbers(this);
    }
    return this.fastNumbersCached;
  }
  listingMode() {
    const isActuallyEn = this.isEnglish();
    const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return isActuallyEn && hasNoWeirdness ? "en" : "intl";
  }
  clone(alts) {
    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
      return this;
    } else {
      return Locale.create(alts.locale || this.specifiedLocale, alts.numberingSystem || this.numberingSystem, alts.outputCalendar || this.outputCalendar, alts.defaultToEN || false);
    }
  }
  redefaultToEN(alts = {}) {
    return this.clone({
      ...alts,
      defaultToEN: true
    });
  }
  redefaultToSystem(alts = {}) {
    return this.clone({
      ...alts,
      defaultToEN: false
    });
  }
  months(length, format = false, defaultOK = true) {
    return listStuff(this, length, defaultOK, months, () => {
      const intl = format ? {
          month: length,
          day: "numeric"
        } : {
          month: length
        },
        formatStr = format ? "format" : "standalone";
      if (!this.monthsCache[formatStr][length]) {
        this.monthsCache[formatStr][length] = mapMonths(dt => this.extract(dt, intl, "month"));
      }
      return this.monthsCache[formatStr][length];
    });
  }
  weekdays(length, format = false, defaultOK = true) {
    return listStuff(this, length, defaultOK, weekdays, () => {
      const intl = format ? {
          weekday: length,
          year: "numeric",
          month: "long",
          day: "numeric"
        } : {
          weekday: length
        },
        formatStr = format ? "format" : "standalone";
      if (!this.weekdaysCache[formatStr][length]) {
        this.weekdaysCache[formatStr][length] = mapWeekdays(dt => this.extract(dt, intl, "weekday"));
      }
      return this.weekdaysCache[formatStr][length];
    });
  }
  meridiems(defaultOK = true) {
    return listStuff(this, undefined, defaultOK, () => meridiems, () => {
      // In theory there could be aribitrary day periods. We're gonna assume there are exactly two
      // for AM and PM. This is probably wrong, but it's makes parsing way easier.
      if (!this.meridiemCache) {
        const intl = {
          hour: "numeric",
          hourCycle: "h12"
        };
        this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(dt => this.extract(dt, intl, "dayperiod"));
      }
      return this.meridiemCache;
    });
  }
  eras(length, defaultOK = true) {
    return listStuff(this, length, defaultOK, eras, () => {
      const intl = {
        era: length
      };

      // This is problematic. Different calendars are going to define eras totally differently. What I need is the minimum set of dates
      // to definitely enumerate them.
      if (!this.eraCache[length]) {
        this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(dt => this.extract(dt, intl, "era"));
      }
      return this.eraCache[length];
    });
  }
  extract(dt, intlOpts, field) {
    const df = this.dtFormatter(dt, intlOpts),
      results = df.formatToParts(),
      matching = results.find(m => m.type.toLowerCase() === field);
    return matching ? matching.value : null;
  }
  numberFormatter(opts = {}) {
    // this forcesimple option is never used (the only caller short-circuits on it, but it seems safer to leave)
    // (in contrast, the rest of the condition is used heavily)
    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
  }
  dtFormatter(dt, intlOpts = {}) {
    return new PolyDateFormatter(dt, this.intl, intlOpts);
  }
  relFormatter(opts = {}) {
    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
  }
  listFormatter(opts = {}) {
    return getCachedLF(this.intl, opts);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }
  equals(other) {
    return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
  }
}
let singleton = null;

/**
 * A zone with a fixed offset (meaning no DST)
 * @implements {Zone}
 */
class FixedOffsetZone extends Zone {
  /**
   * Get a singleton instance of UTC
   * @return {FixedOffsetZone}
   */
  static get utcInstance() {
    if (singleton === null) {
      singleton = new FixedOffsetZone(0);
    }
    return singleton;
  }

  /**
   * Get an instance with a specified offset
   * @param {number} offset - The offset in minutes
   * @return {FixedOffsetZone}
   */
  static instance(offset) {
    return offset === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset);
  }

  /**
   * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
   * @param {string} s - The offset string to parse
   * @example FixedOffsetZone.parseSpecifier("UTC+6")
   * @example FixedOffsetZone.parseSpecifier("UTC+06")
   * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
   * @return {FixedOffsetZone}
   */
  static parseSpecifier(s) {
    if (s) {
      const r = s.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (r) {
        return new FixedOffsetZone(signedOffset(r[1], r[2]));
      }
    }
    return null;
  }
  constructor(offset) {
    super();
    /** @private **/
    this.fixed = offset;
  }

  /** @override **/
  get type() {
    return "fixed";
  }

  /** @override **/
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
  }
  get ianaName() {
    if (this.fixed === 0) {
      return "Etc/UTC";
    } else {
      return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
    }
  }

  /** @override **/
  offsetName() {
    return this.name;
  }

  /** @override **/
  formatOffset(ts, format) {
    return formatOffset(this.fixed, format);
  }

  /** @override **/
  get isUniversal() {
    return true;
  }

  /** @override **/
  offset() {
    return this.fixed;
  }

  /** @override **/
  equals(otherZone) {
    return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
  }

  /** @override **/
  get isValid() {
    return true;
  }
}

/**
 * A zone that failed to parse. You should never need to instantiate this.
 * @implements {Zone}
 */
class InvalidZone extends Zone {
  constructor(zoneName) {
    super();
    /**  @private */
    this.zoneName = zoneName;
  }

  /** @override **/
  get type() {
    return "invalid";
  }

  /** @override **/
  get name() {
    return this.zoneName;
  }

  /** @override **/
  get isUniversal() {
    return false;
  }

  /** @override **/
  offsetName() {
    return null;
  }

  /** @override **/
  formatOffset() {
    return "";
  }

  /** @override **/
  offset() {
    return NaN;
  }

  /** @override **/
  equals() {
    return false;
  }

  /** @override **/
  get isValid() {
    return false;
  }
}

/**
 * @private
 */
function normalizeZone(input, defaultZone) {
  if (isUndefined(input) || input === null) {
    return defaultZone;
  } else if (input instanceof Zone) {
    return input;
  } else if (isString(input)) {
    const lowered = input.toLowerCase();
    if (lowered === "default") return defaultZone;else if (lowered === "local" || lowered === "system") return SystemZone.instance;else if (lowered === "utc" || lowered === "gmt") return FixedOffsetZone.utcInstance;else return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);
  } else if (isNumber(input)) {
    return FixedOffsetZone.instance(input);
  } else if (typeof input === "object" && input.offset && typeof input.offset === "number") {
    // This is dumb, but the instanceof check above doesn't seem to really work
    // so we're duck checking it
    return input;
  } else {
    return new InvalidZone(input);
  }
}
let now = () => Date.now(),
  defaultZone = "system",
  defaultLocale = null,
  defaultNumberingSystem = null,
  defaultOutputCalendar = null,
  twoDigitCutoffYear = 60,
  throwOnInvalid;

/**
 * Settings contains static getters and setters that control Luxon's overall behavior. Luxon is a simple library with few options, but the ones it does have live here.
 */
class Settings {
  /**
   * Get the callback for returning the current timestamp.
   * @type {function}
   */
  static get now() {
    return now;
  }

  /**
   * Set the callback for returning the current timestamp.
   * The function should return a number, which will be interpreted as an Epoch millisecond count
   * @type {function}
   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
   */
  static set now(n) {
    now = n;
  }

  /**
   * Set the default time zone to create DateTimes in. Does not affect existing instances.
   * Use the value "system" to reset this value to the system's time zone.
   * @type {string}
   */
  static set defaultZone(zone) {
    defaultZone = zone;
  }

  /**
   * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
   * The default value is the system's time zone (the one set on the machine that runs this code).
   * @type {Zone}
   */
  static get defaultZone() {
    return normalizeZone(defaultZone, SystemZone.instance);
  }

  /**
   * Get the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultLocale() {
    return defaultLocale;
  }

  /**
   * Set the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultLocale(locale) {
    defaultLocale = locale;
  }

  /**
   * Get the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultNumberingSystem() {
    return defaultNumberingSystem;
  }

  /**
   * Set the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultNumberingSystem(numberingSystem) {
    defaultNumberingSystem = numberingSystem;
  }

  /**
   * Get the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultOutputCalendar() {
    return defaultOutputCalendar;
  }

  /**
   * Set the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultOutputCalendar(outputCalendar) {
    defaultOutputCalendar = outputCalendar;
  }

  /**
   * Get the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
   * @type {number}
   */
  static get twoDigitCutoffYear() {
    return twoDigitCutoffYear;
  }

  /**
   * Set the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
   * @type {number}
   * @example Settings.twoDigitCutoffYear = 0 // cut-off year is 0, so all 'yy' are interpretted as current century
   * @example Settings.twoDigitCutoffYear = 50 // '49' -> 1949; '50' -> 2050
   * @example Settings.twoDigitCutoffYear = 1950 // interpretted as 50
   * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpretted as 50
   */
  static set twoDigitCutoffYear(cutoffYear) {
    twoDigitCutoffYear = cutoffYear % 100;
  }

  /**
   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static get throwOnInvalid() {
    return throwOnInvalid;
  }

  /**
   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static set throwOnInvalid(t) {
    throwOnInvalid = t;
  }

  /**
   * Reset Luxon's global caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCaches() {
    Locale.resetCache();
    IANAZone.resetCache();
  }
}

/*
  This is just a junk drawer, containing anything used across multiple classes.
  Because Luxon is small(ish), this should stay small and we won't worry about splitting
  it up into, say, parsingUtil.js and basicUtil.js and so on. But they are divided up by feature area.
*/

/**
 * @private
 */

// TYPES

function isUndefined(o) {
  return typeof o === "undefined";
}
function isNumber(o) {
  return typeof o === "number";
}
function isInteger(o) {
  return typeof o === "number" && o % 1 === 0;
}
function isString(o) {
  return typeof o === "string";
}
function isDate(o) {
  return Object.prototype.toString.call(o) === "[object Date]";
}

// CAPABILITIES

function hasRelative() {
  try {
    return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
  } catch (e) {
    return false;
  }
}

// OBJECTS AND ARRAYS

function maybeArray(thing) {
  return Array.isArray(thing) ? thing : [thing];
}
function bestBy(arr, by, compare) {
  if (arr.length === 0) {
    return undefined;
  }
  return arr.reduce((best, next) => {
    const pair = [by(next), next];
    if (!best) {
      return pair;
    } else if (compare(best[0], pair[0]) === best[0]) {
      return best;
    } else {
      return pair;
    }
  }, null)[1];
}
function pick(obj, keys) {
  return keys.reduce((a, k) => {
    a[k] = obj[k];
    return a;
  }, {});
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

// NUMBERS AND STRINGS

function integerBetween(thing, bottom, top) {
  return isInteger(thing) && thing >= bottom && thing <= top;
}

// x % n but takes the sign of n instead of x
function floorMod(x, n) {
  return x - n * Math.floor(x / n);
}
function padStart(input, n = 2) {
  const isNeg = input < 0;
  let padded;
  if (isNeg) {
    padded = "-" + ("" + -input).padStart(n, "0");
  } else {
    padded = ("" + input).padStart(n, "0");
  }
  return padded;
}
function parseInteger(string) {
  if (isUndefined(string) || string === null || string === "") {
    return undefined;
  } else {
    return parseInt(string, 10);
  }
}
function parseFloating(string) {
  if (isUndefined(string) || string === null || string === "") {
    return undefined;
  } else {
    return parseFloat(string);
  }
}
function parseMillis(fraction) {
  // Return undefined (instead of 0) in these cases, where fraction is not set
  if (isUndefined(fraction) || fraction === null || fraction === "") {
    return undefined;
  } else {
    const f = parseFloat("0." + fraction) * 1000;
    return Math.floor(f);
  }
}
function roundTo(number, digits, towardZero = false) {
  const factor = 10 ** digits,
    rounder = towardZero ? Math.trunc : Math.round;
  return rounder(number * factor) / factor;
}

// DATE BASICS

function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
function daysInMonth(year, month) {
  const modMonth = floorMod(month - 1, 12) + 1,
    modYear = year + (month - modMonth) / 12;
  if (modMonth === 2) {
    return isLeapYear(modYear) ? 29 : 28;
  } else {
    return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
  }
}

// covert a calendar object to a local timestamp (epoch, but with the offset baked in)
function objToLocalTS(obj) {
  let d = Date.UTC(obj.year, obj.month - 1, obj.day, obj.hour, obj.minute, obj.second, obj.millisecond);

  // for legacy reasons, years between 0 and 99 are interpreted as 19XX; revert that
  if (obj.year < 100 && obj.year >= 0) {
    d = new Date(d);
    d.setUTCFullYear(d.getUTCFullYear() - 1900);
  }
  return +d;
}
function weeksInWeekYear(weekYear) {
  const p1 = (weekYear + Math.floor(weekYear / 4) - Math.floor(weekYear / 100) + Math.floor(weekYear / 400)) % 7,
    last = weekYear - 1,
    p2 = (last + Math.floor(last / 4) - Math.floor(last / 100) + Math.floor(last / 400)) % 7;
  return p1 === 4 || p2 === 3 ? 53 : 52;
}
function untruncateYear(year) {
  if (year > 99) {
    return year;
  } else return year > Settings.twoDigitCutoffYear ? 1900 + year : 2000 + year;
}

// PARSING

function parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {
  const date = new Date(ts),
    intlOpts = {
      hourCycle: "h23",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit"
    };
  if (timeZone) {
    intlOpts.timeZone = timeZone;
  }
  const modified = {
    timeZoneName: offsetFormat,
    ...intlOpts
  };
  const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find(m => m.type.toLowerCase() === "timezonename");
  return parsed ? parsed.value : null;
}

// signedOffset('-5', '30') -> -330
function signedOffset(offHourStr, offMinuteStr) {
  let offHour = parseInt(offHourStr, 10);

  // don't || this because we want to preserve -0
  if (Number.isNaN(offHour)) {
    offHour = 0;
  }
  const offMin = parseInt(offMinuteStr, 10) || 0,
    offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
  return offHour * 60 + offMinSigned;
}

// COERCION

function asNumber(value) {
  const numericValue = Number(value);
  if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue)) throw new InvalidArgumentError(`Invalid unit value ${value}`);
  return numericValue;
}
function normalizeObject(obj, normalizer) {
  const normalized = {};
  for (const u in obj) {
    if (hasOwnProperty(obj, u)) {
      const v = obj[u];
      if (v === undefined || v === null) continue;
      normalized[normalizer(u)] = asNumber(v);
    }
  }
  return normalized;
}
function formatOffset(offset, format) {
  const hours = Math.trunc(Math.abs(offset / 60)),
    minutes = Math.trunc(Math.abs(offset % 60)),
    sign = offset >= 0 ? "+" : "-";
  switch (format) {
    case "short":
      return `${sign}${padStart(hours, 2)}:${padStart(minutes, 2)}`;
    case "narrow":
      return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
    case "techie":
      return `${sign}${padStart(hours, 2)}${padStart(minutes, 2)}`;
    default:
      throw new RangeError(`Value format ${format} is out of range for property format`);
  }
}
function timeObject(obj) {
  return pick(obj, ["hour", "minute", "second", "millisecond"]);
}

/**
 * @private
 */

const monthsLong = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
const monthsShort = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
const monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function months(length) {
  switch (length) {
    case "narrow":
      return [...monthsNarrow];
    case "short":
      return [...monthsShort];
    case "long":
      return [...monthsLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
const weekdaysLong = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
const weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
const weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
function weekdays(length) {
  switch (length) {
    case "narrow":
      return [...weekdaysNarrow];
    case "short":
      return [...weekdaysShort];
    case "long":
      return [...weekdaysLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
const meridiems = ["AM", "PM"];
const erasLong = ["Before Christ", "Anno Domini"];
const erasShort = ["BC", "AD"];
const erasNarrow = ["B", "A"];
function eras(length) {
  switch (length) {
    case "narrow":
      return [...erasNarrow];
    case "short":
      return [...erasShort];
    case "long":
      return [...erasLong];
    default:
      return null;
  }
}
function meridiemForDateTime(dt) {
  return meridiems[dt.hour < 12 ? 0 : 1];
}
function weekdayForDateTime(dt, length) {
  return weekdays(length)[dt.weekday - 1];
}
function monthForDateTime(dt, length) {
  return months(length)[dt.month - 1];
}
function eraForDateTime(dt, length) {
  return eras(length)[dt.year < 0 ? 0 : 1];
}
function formatRelativeTime(unit, count, numeric = "always", narrow = false) {
  const units = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  };
  const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
  if (numeric === "auto" && lastable) {
    const isDay = unit === "days";
    switch (count) {
      case 1:
        return isDay ? "tomorrow" : `next ${units[unit][0]}`;
      case -1:
        return isDay ? "yesterday" : `last ${units[unit][0]}`;
      case 0:
        return isDay ? "today" : `this ${units[unit][0]}`;
    }
  }
  const isInPast = Object.is(count, -0) || count < 0,
    fmtValue = Math.abs(count),
    singular = fmtValue === 1,
    lilUnits = units[unit],
    fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
  return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
}
function stringifyTokens(splits, tokenToString) {
  let s = "";
  for (const token of splits) {
    if (token.literal) {
      s += token.val;
    } else {
      s += tokenToString(token.val);
    }
  }
  return s;
}
const macroTokenToFormatOpts = {
  D: DATE_SHORT,
  DD: DATE_MED,
  DDD: DATE_FULL,
  DDDD: DATE_HUGE,
  t: TIME_SIMPLE,
  tt: TIME_WITH_SECONDS,
  ttt: TIME_WITH_SHORT_OFFSET,
  tttt: TIME_WITH_LONG_OFFSET,
  T: TIME_24_SIMPLE,
  TT: TIME_24_WITH_SECONDS,
  TTT: TIME_24_WITH_SHORT_OFFSET,
  TTTT: TIME_24_WITH_LONG_OFFSET,
  f: DATETIME_SHORT,
  ff: DATETIME_MED,
  fff: DATETIME_FULL,
  ffff: DATETIME_HUGE,
  F: DATETIME_SHORT_WITH_SECONDS,
  FF: DATETIME_MED_WITH_SECONDS,
  FFF: DATETIME_FULL_WITH_SECONDS,
  FFFF: DATETIME_HUGE_WITH_SECONDS
};

/**
 * @private
 */

class Formatter {
  static create(locale, opts = {}) {
    return new Formatter(locale, opts);
  }
  static parseFormat(fmt) {
    let current = null,
      currentFull = "",
      bracketed = false;
    const splits = [];
    for (let i = 0; i < fmt.length; i++) {
      const c = fmt.charAt(i);
      if (c === "'") {
        if (currentFull.length > 0) {
          splits.push({
            literal: bracketed,
            val: currentFull
          });
        }
        current = null;
        currentFull = "";
        bracketed = !bracketed;
      } else if (bracketed) {
        currentFull += c;
      } else if (c === current) {
        currentFull += c;
      } else {
        if (currentFull.length > 0) {
          splits.push({
            literal: false,
            val: currentFull
          });
        }
        currentFull = c;
        current = c;
      }
    }
    if (currentFull.length > 0) {
      splits.push({
        literal: bracketed,
        val: currentFull
      });
    }
    return splits;
  }
  static macroTokenToFormatOpts(token) {
    return macroTokenToFormatOpts[token];
  }
  constructor(locale, formatOpts) {
    this.opts = formatOpts;
    this.loc = locale;
    this.systemLoc = null;
  }
  formatWithSystemDefault(dt, opts) {
    if (this.systemLoc === null) {
      this.systemLoc = this.loc.redefaultToSystem();
    }
    const df = this.systemLoc.dtFormatter(dt, {
      ...this.opts,
      ...opts
    });
    return df.format();
  }
  formatDateTime(dt, opts = {}) {
    const df = this.loc.dtFormatter(dt, {
      ...this.opts,
      ...opts
    });
    return df.format();
  }
  formatDateTimeParts(dt, opts = {}) {
    const df = this.loc.dtFormatter(dt, {
      ...this.opts,
      ...opts
    });
    return df.formatToParts();
  }
  formatInterval(interval, opts = {}) {
    const df = this.loc.dtFormatter(interval.start, {
      ...this.opts,
      ...opts
    });
    return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
  }
  resolvedOptions(dt, opts = {}) {
    const df = this.loc.dtFormatter(dt, {
      ...this.opts,
      ...opts
    });
    return df.resolvedOptions();
  }
  num(n, p = 0) {
    // we get some perf out of doing this here, annoyingly
    if (this.opts.forceSimple) {
      return padStart(n, p);
    }
    const opts = {
      ...this.opts
    };
    if (p > 0) {
      opts.padTo = p;
    }
    return this.loc.numberFormatter(opts).format(n);
  }
  formatDateTimeFromString(dt, fmt) {
    const knownEnglish = this.loc.listingMode() === "en",
      useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory",
      string = (opts, extract) => this.loc.extract(dt, opts, extract),
      formatOffset = opts => {
        if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
          return "Z";
        }
        return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
      },
      meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string({
        hour: "numeric",
        hourCycle: "h12"
      }, "dayperiod"),
      month = (length, standalone) => knownEnglish ? monthForDateTime(dt, length) : string(standalone ? {
        month: length
      } : {
        month: length,
        day: "numeric"
      }, "month"),
      weekday = (length, standalone) => knownEnglish ? weekdayForDateTime(dt, length) : string(standalone ? {
        weekday: length
      } : {
        weekday: length,
        month: "long",
        day: "numeric"
      }, "weekday"),
      maybeMacro = token => {
        const formatOpts = Formatter.macroTokenToFormatOpts(token);
        if (formatOpts) {
          return this.formatWithSystemDefault(dt, formatOpts);
        } else {
          return token;
        }
      },
      era = length => knownEnglish ? eraForDateTime(dt, length) : string({
        era: length
      }, "era"),
      tokenToString = token => {
        // Where possible: http://cldr.unicode.org/translation/date-time-1/date-time#TOC-Standalone-vs.-Format-Styles
        switch (token) {
          // ms
          case "S":
            return this.num(dt.millisecond);
          case "u":
          // falls through
          case "SSS":
            return this.num(dt.millisecond, 3);
          // seconds
          case "s":
            return this.num(dt.second);
          case "ss":
            return this.num(dt.second, 2);
          // fractional seconds
          case "uu":
            return this.num(Math.floor(dt.millisecond / 10), 2);
          case "uuu":
            return this.num(Math.floor(dt.millisecond / 100));
          // minutes
          case "m":
            return this.num(dt.minute);
          case "mm":
            return this.num(dt.minute, 2);
          // hours
          case "h":
            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
          case "hh":
            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
          case "H":
            return this.num(dt.hour);
          case "HH":
            return this.num(dt.hour, 2);
          // offset
          case "Z":
            // like +6
            return formatOffset({
              format: "narrow",
              allowZ: this.opts.allowZ
            });
          case "ZZ":
            // like +06:00
            return formatOffset({
              format: "short",
              allowZ: this.opts.allowZ
            });
          case "ZZZ":
            // like +0600
            return formatOffset({
              format: "techie",
              allowZ: this.opts.allowZ
            });
          case "ZZZZ":
            // like EST
            return dt.zone.offsetName(dt.ts, {
              format: "short",
              locale: this.loc.locale
            });
          case "ZZZZZ":
            // like Eastern Standard Time
            return dt.zone.offsetName(dt.ts, {
              format: "long",
              locale: this.loc.locale
            });
          // zone
          case "z":
            // like America/New_York
            return dt.zoneName;
          // meridiems
          case "a":
            return meridiem();
          // dates
          case "d":
            return useDateTimeFormatter ? string({
              day: "numeric"
            }, "day") : this.num(dt.day);
          case "dd":
            return useDateTimeFormatter ? string({
              day: "2-digit"
            }, "day") : this.num(dt.day, 2);
          // weekdays - standalone
          case "c":
            // like 1
            return this.num(dt.weekday);
          case "ccc":
            // like 'Tues'
            return weekday("short", true);
          case "cccc":
            // like 'Tuesday'
            return weekday("long", true);
          case "ccccc":
            // like 'T'
            return weekday("narrow", true);
          // weekdays - format
          case "E":
            // like 1
            return this.num(dt.weekday);
          case "EEE":
            // like 'Tues'
            return weekday("short", false);
          case "EEEE":
            // like 'Tuesday'
            return weekday("long", false);
          case "EEEEE":
            // like 'T'
            return weekday("narrow", false);
          // months - standalone
          case "L":
            // like 1
            return useDateTimeFormatter ? string({
              month: "numeric",
              day: "numeric"
            }, "month") : this.num(dt.month);
          case "LL":
            // like 01, doesn't seem to work
            return useDateTimeFormatter ? string({
              month: "2-digit",
              day: "numeric"
            }, "month") : this.num(dt.month, 2);
          case "LLL":
            // like Jan
            return month("short", true);
          case "LLLL":
            // like January
            return month("long", true);
          case "LLLLL":
            // like J
            return month("narrow", true);
          // months - format
          case "M":
            // like 1
            return useDateTimeFormatter ? string({
              month: "numeric"
            }, "month") : this.num(dt.month);
          case "MM":
            // like 01
            return useDateTimeFormatter ? string({
              month: "2-digit"
            }, "month") : this.num(dt.month, 2);
          case "MMM":
            // like Jan
            return month("short", false);
          case "MMMM":
            // like January
            return month("long", false);
          case "MMMMM":
            // like J
            return month("narrow", false);
          // years
          case "y":
            // like 2014
            return useDateTimeFormatter ? string({
              year: "numeric"
            }, "year") : this.num(dt.year);
          case "yy":
            // like 14
            return useDateTimeFormatter ? string({
              year: "2-digit"
            }, "year") : this.num(dt.year.toString().slice(-2), 2);
          case "yyyy":
            // like 0012
            return useDateTimeFormatter ? string({
              year: "numeric"
            }, "year") : this.num(dt.year, 4);
          case "yyyyyy":
            // like 000012
            return useDateTimeFormatter ? string({
              year: "numeric"
            }, "year") : this.num(dt.year, 6);
          // eras
          case "G":
            // like AD
            return era("short");
          case "GG":
            // like Anno Domini
            return era("long");
          case "GGGGG":
            return era("narrow");
          case "kk":
            return this.num(dt.weekYear.toString().slice(-2), 2);
          case "kkkk":
            return this.num(dt.weekYear, 4);
          case "W":
            return this.num(dt.weekNumber);
          case "WW":
            return this.num(dt.weekNumber, 2);
          case "o":
            return this.num(dt.ordinal);
          case "ooo":
            return this.num(dt.ordinal, 3);
          case "q":
            // like 1
            return this.num(dt.quarter);
          case "qq":
            // like 01
            return this.num(dt.quarter, 2);
          case "X":
            return this.num(Math.floor(dt.ts / 1000));
          case "x":
            return this.num(dt.ts);
          default:
            return maybeMacro(token);
        }
      };
    return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);
  }
  formatDurationFromString(dur, fmt) {
    const tokenToField = token => {
        switch (token[0]) {
          case "S":
            return "millisecond";
          case "s":
            return "second";
          case "m":
            return "minute";
          case "h":
            return "hour";
          case "d":
            return "day";
          case "w":
            return "week";
          case "M":
            return "month";
          case "y":
            return "year";
          default:
            return null;
        }
      },
      tokenToString = lildur => token => {
        const mapped = tokenToField(token);
        if (mapped) {
          return this.num(lildur.get(mapped), token.length);
        } else {
          return token;
        }
      },
      tokens = Formatter.parseFormat(fmt),
      realTokens = tokens.reduce((found, {
        literal,
        val
      }) => literal ? found : found.concat(val), []),
      collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter(t => t));
    return stringifyTokens(tokens, tokenToString(collapsed));
  }
}
class Invalid {
  constructor(reason, explanation) {
    this.reason = reason;
    this.explanation = explanation;
  }
  toMessage() {
    if (this.explanation) {
      return `${this.reason}: ${this.explanation}`;
    } else {
      return this.reason;
    }
  }
}

/*
 * This file handles parsing for well-specified formats. Here's how it works:
 * Two things go into parsing: a regex to match with and an extractor to take apart the groups in the match.
 * An extractor is just a function that takes a regex match array and returns a { year: ..., month: ... } object
 * parse() does the work of executing the regex and applying the extractor. It takes multiple regex/extractor pairs to try in sequence.
 * Extractors can take a "cursor" representing the offset in the match to look at. This makes it easy to combine extractors.
 * combineExtractors() does the work of combining them, keeping track of the cursor through multiple extractions.
 * Some extractions are super dumb and simpleParse and fromStrings help DRY them.
 */

const ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
function combineRegexes(...regexes) {
  const full = regexes.reduce((f, r) => f + r.source, "");
  return RegExp(`^${full}$`);
}
function combineExtractors(...extractors) {
  return m => extractors.reduce(([mergedVals, mergedZone, cursor], ex) => {
    const [val, zone, next] = ex(m, cursor);
    return [{
      ...mergedVals,
      ...val
    }, zone || mergedZone, next];
  }, [{}, null, 1]).slice(0, 2);
}
function parse(s, ...patterns) {
  if (s == null) {
    return [null, null];
  }
  for (const [regex, extractor] of patterns) {
    const m = regex.exec(s);
    if (m) {
      return extractor(m);
    }
  }
  return [null, null];
}
function simpleParse(...keys) {
  return (match, cursor) => {
    const ret = {};
    let i;
    for (i = 0; i < keys.length; i++) {
      ret[keys[i]] = parseInteger(match[cursor + i]);
    }
    return [ret, null, cursor + i];
  };
}

// ISO and SQL parsing
const offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
const isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
const isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
const isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
const isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
const isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
const isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
const isoOrdinalRegex = /(\d{4})-?(\d{3})/;
const extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
const extractISOOrdinalData = simpleParse("year", "ordinal");
const sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/; // dumbed-down version of the ISO one
const sqlTimeRegex = RegExp(`${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`);
const sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
function int(match, pos, fallback) {
  const m = match[pos];
  return isUndefined(m) ? fallback : parseInteger(m);
}
function extractISOYmd(match, cursor) {
  const item = {
    year: int(match, cursor),
    month: int(match, cursor + 1, 1),
    day: int(match, cursor + 2, 1)
  };
  return [item, null, cursor + 3];
}
function extractISOTime(match, cursor) {
  const item = {
    hours: int(match, cursor, 0),
    minutes: int(match, cursor + 1, 0),
    seconds: int(match, cursor + 2, 0),
    milliseconds: parseMillis(match[cursor + 3])
  };
  return [item, null, cursor + 4];
}
function extractISOOffset(match, cursor) {
  const local = !match[cursor] && !match[cursor + 1],
    fullOffset = signedOffset(match[cursor + 1], match[cursor + 2]),
    zone = local ? null : FixedOffsetZone.instance(fullOffset);
  return [{}, zone, cursor + 3];
}
function extractIANAZone(match, cursor) {
  const zone = match[cursor] ? IANAZone.create(match[cursor]) : null;
  return [{}, zone, cursor + 1];
}

// ISO time parsing

const isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);

// ISO duration parsing

const isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function extractISODuration(match) {
  const [s, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match;
  const hasNegativePrefix = s[0] === "-";
  const negativeSeconds = secondStr && secondStr[0] === "-";
  const maybeNegate = (num, force = false) => num !== undefined && (force || num && hasNegativePrefix) ? -num : num;
  return [{
    years: maybeNegate(parseFloating(yearStr)),
    months: maybeNegate(parseFloating(monthStr)),
    weeks: maybeNegate(parseFloating(weekStr)),
    days: maybeNegate(parseFloating(dayStr)),
    hours: maybeNegate(parseFloating(hourStr)),
    minutes: maybeNegate(parseFloating(minuteStr)),
    seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
    milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
  }];
}

// These are a little braindead. EDT *should* tell us that we're in, say, America/New_York
// and not just that we're in -240 *right now*. But since I don't think these are used that often
// I'm just going to ignore that
const obsOffsets = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  const result = {
    year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
    month: monthsShort.indexOf(monthStr) + 1,
    day: parseInteger(dayStr),
    hour: parseInteger(hourStr),
    minute: parseInteger(minuteStr)
  };
  if (secondStr) result.second = parseInteger(secondStr);
  if (weekdayStr) {
    result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
  }
  return result;
}

// RFC 2822/5322
const rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function extractRFC2822(match) {
  const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr, obsOffset, milOffset, offHourStr, offMinuteStr] = match,
    result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  let offset;
  if (obsOffset) {
    offset = obsOffsets[obsOffset];
  } else if (milOffset) {
    offset = 0;
  } else {
    offset = signedOffset(offHourStr, offMinuteStr);
  }
  return [result, new FixedOffsetZone(offset)];
}
function preprocessRFC2822(s) {
  // Remove comments and folding whitespace and replace multiple-spaces with a single space
  return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}

// http date

const rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/,
  rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/,
  ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function extractRFC1123Or850(match) {
  const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match,
    result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
function extractASCII(match) {
  const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match,
    result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
const isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
const isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
const isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
const isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
const extractISOYmdTimeAndOffset = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset, extractIANAZone);
const extractISOWeekTimeAndOffset = combineExtractors(extractISOWeekData, extractISOTime, extractISOOffset, extractIANAZone);
const extractISOOrdinalDateAndTime = combineExtractors(extractISOOrdinalData, extractISOTime, extractISOOffset, extractIANAZone);
const extractISOTimeAndOffset = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);

/*
 * @private
 */

function parseISODate(s) {
  return parse(s, [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset], [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime], [isoTimeCombinedRegex, extractISOTimeAndOffset]);
}
function parseRFC2822Date(s) {
  return parse(preprocessRFC2822(s), [rfc2822, extractRFC2822]);
}
function parseHTTPDate(s) {
  return parse(s, [rfc1123, extractRFC1123Or850], [rfc850, extractRFC1123Or850], [ascii, extractASCII]);
}
function parseISODuration(s) {
  return parse(s, [isoDuration, extractISODuration]);
}
const extractISOTimeOnly = combineExtractors(extractISOTime);
function parseISOTimeOnly(s) {
  return parse(s, [isoTimeOnly, extractISOTimeOnly]);
}
const sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
const sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
const extractISOTimeOffsetAndIANAZone = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
function parseSQL(s) {
  return parse(s, [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]);
}
const INVALID$2 = "Invalid Duration";

// unit conversion constants
const lowOrderMatrix = {
    weeks: {
      days: 7,
      hours: 7 * 24,
      minutes: 7 * 24 * 60,
      seconds: 7 * 24 * 60 * 60,
      milliseconds: 7 * 24 * 60 * 60 * 1000
    },
    days: {
      hours: 24,
      minutes: 24 * 60,
      seconds: 24 * 60 * 60,
      milliseconds: 24 * 60 * 60 * 1000
    },
    hours: {
      minutes: 60,
      seconds: 60 * 60,
      milliseconds: 60 * 60 * 1000
    },
    minutes: {
      seconds: 60,
      milliseconds: 60 * 1000
    },
    seconds: {
      milliseconds: 1000
    }
  },
  casualMatrix = {
    years: {
      quarters: 4,
      months: 12,
      weeks: 52,
      days: 365,
      hours: 365 * 24,
      minutes: 365 * 24 * 60,
      seconds: 365 * 24 * 60 * 60,
      milliseconds: 365 * 24 * 60 * 60 * 1000
    },
    quarters: {
      months: 3,
      weeks: 13,
      days: 91,
      hours: 91 * 24,
      minutes: 91 * 24 * 60,
      seconds: 91 * 24 * 60 * 60,
      milliseconds: 91 * 24 * 60 * 60 * 1000
    },
    months: {
      weeks: 4,
      days: 30,
      hours: 30 * 24,
      minutes: 30 * 24 * 60,
      seconds: 30 * 24 * 60 * 60,
      milliseconds: 30 * 24 * 60 * 60 * 1000
    },
    ...lowOrderMatrix
  },
  daysInYearAccurate = 146097.0 / 400,
  daysInMonthAccurate = 146097.0 / 4800,
  accurateMatrix = {
    years: {
      quarters: 4,
      months: 12,
      weeks: daysInYearAccurate / 7,
      days: daysInYearAccurate,
      hours: daysInYearAccurate * 24,
      minutes: daysInYearAccurate * 24 * 60,
      seconds: daysInYearAccurate * 24 * 60 * 60,
      milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000
    },
    quarters: {
      months: 3,
      weeks: daysInYearAccurate / 28,
      days: daysInYearAccurate / 4,
      hours: daysInYearAccurate * 24 / 4,
      minutes: daysInYearAccurate * 24 * 60 / 4,
      seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
      milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000 / 4
    },
    months: {
      weeks: daysInMonthAccurate / 7,
      days: daysInMonthAccurate,
      hours: daysInMonthAccurate * 24,
      minutes: daysInMonthAccurate * 24 * 60,
      seconds: daysInMonthAccurate * 24 * 60 * 60,
      milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1000
    },
    ...lowOrderMatrix
  };

// units ordered by size
const orderedUnits$1 = ["years", "quarters", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds"];
const reverseUnits = orderedUnits$1.slice(0).reverse();

// clone really means "create another instance just like this one, but with these changes"
function clone$1(dur, alts, clear = false) {
  // deep merge for vals
  const conf = {
    values: clear ? alts.values : {
      ...dur.values,
      ...(alts.values || {})
    },
    loc: dur.loc.clone(alts.loc),
    conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
    matrix: alts.matrix || dur.matrix
  };
  return new Duration(conf);
}
function antiTrunc(n) {
  return n < 0 ? Math.floor(n) : Math.ceil(n);
}

// NB: mutates parameters
function convert(matrix, fromMap, fromUnit, toMap, toUnit) {
  const conv = matrix[toUnit][fromUnit],
    raw = fromMap[fromUnit] / conv,
    sameSign = Math.sign(raw) === Math.sign(toMap[toUnit]),
    // ok, so this is wild, but see the matrix in the tests
    added = !sameSign && toMap[toUnit] !== 0 && Math.abs(raw) <= 1 ? antiTrunc(raw) : Math.trunc(raw);
  toMap[toUnit] += added;
  fromMap[fromUnit] -= added * conv;
}

// NB: mutates parameters
function normalizeValues(matrix, vals) {
  reverseUnits.reduce((previous, current) => {
    if (!isUndefined(vals[current])) {
      if (previous) {
        convert(matrix, vals, previous, vals, current);
      }
      return current;
    } else {
      return previous;
    }
  }, null);
}

// Remove all properties with a value of 0 from an object
function removeZeroes(vals) {
  const newVals = {};
  for (const [key, value] of Object.entries(vals)) {
    if (value !== 0) {
      newVals[key] = value;
    }
  }
  return newVals;
}

/**
 * A Duration object represents a period of time, like "2 months" or "1 day, 1 hour". Conceptually, it's just a map of units to their quantities, accompanied by some additional configuration and methods for creating, parsing, interrogating, transforming, and formatting them. They can be used on their own or in conjunction with other Luxon types; for example, you can use {@link DateTime#plus} to add a Duration object to a DateTime, producing another DateTime.
 *
 * Here is a brief overview of commonly used methods and getters in Duration:
 *
 * * **Creation** To create a Duration, use {@link Duration.fromMillis}, {@link Duration.fromObject}, or {@link Duration.fromISO}.
 * * **Unit values** See the {@link Duration#years}, {@link Duration#months}, {@link Duration#weeks}, {@link Duration#days}, {@link Duration#hours}, {@link Duration#minutes}, {@link Duration#seconds}, {@link Duration#milliseconds} accessors.
 * * **Configuration** See  {@link Duration#locale} and {@link Duration#numberingSystem} accessors.
 * * **Transformation** To create new Durations out of old ones use {@link Duration#plus}, {@link Duration#minus}, {@link Duration#normalize}, {@link Duration#set}, {@link Duration#reconfigure}, {@link Duration#shiftTo}, and {@link Duration#negate}.
 * * **Output** To convert the Duration into other representations, see {@link Duration#as}, {@link Duration#toISO}, {@link Duration#toFormat}, and {@link Duration#toJSON}
 *
 * There's are more methods documented below. In addition, for more information on subtler topics like internationalization and validity, see the external documentation.
 */
class Duration {
  /**
   * @private
   */
  constructor(config) {
    const accurate = config.conversionAccuracy === "longterm" || false;
    let matrix = accurate ? accurateMatrix : casualMatrix;
    if (config.matrix) {
      matrix = config.matrix;
    }

    /**
     * @access private
     */
    this.values = config.values;
    /**
     * @access private
     */
    this.loc = config.loc || Locale.create();
    /**
     * @access private
     */
    this.conversionAccuracy = accurate ? "longterm" : "casual";
    /**
     * @access private
     */
    this.invalid = config.invalid || null;
    /**
     * @access private
     */
    this.matrix = matrix;
    /**
     * @access private
     */
    this.isLuxonDuration = true;
  }

  /**
   * Create Duration from a number of milliseconds.
   * @param {number} count of milliseconds
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromMillis(count, opts) {
    return Duration.fromObject({
      milliseconds: count
    }, opts);
  }

  /**
   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
   * If this object is empty then a zero milliseconds duration is returned.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.years
   * @param {number} obj.quarters
   * @param {number} obj.months
   * @param {number} obj.weeks
   * @param {number} obj.days
   * @param {number} obj.hours
   * @param {number} obj.minutes
   * @param {number} obj.seconds
   * @param {number} obj.milliseconds
   * @param {Object} [opts=[]] - options for creating this Duration
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the custom conversion system to use
   * @return {Duration}
   */
  static fromObject(obj, opts = {}) {
    if (obj == null || typeof obj !== "object") {
      throw new InvalidArgumentError(`Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`);
    }
    return new Duration({
      values: normalizeObject(obj, Duration.normalizeUnit),
      loc: Locale.fromObject(opts),
      conversionAccuracy: opts.conversionAccuracy,
      matrix: opts.matrix
    });
  }

  /**
   * Create a Duration from DurationLike.
   *
   * @param {Object | number | Duration} durationLike
   * One of:
   * - object with keys like 'years' and 'hours'.
   * - number representing milliseconds
   * - Duration instance
   * @return {Duration}
   */
  static fromDurationLike(durationLike) {
    if (isNumber(durationLike)) {
      return Duration.fromMillis(durationLike);
    } else if (Duration.isDuration(durationLike)) {
      return durationLike;
    } else if (typeof durationLike === "object") {
      return Duration.fromObject(durationLike);
    } else {
      throw new InvalidArgumentError(`Unknown duration argument ${durationLike} of type ${typeof durationLike}`);
    }
  }

  /**
   * Create a Duration from an ISO 8601 duration string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the preset conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
   * @return {Duration}
   */
  static fromISO(text, opts) {
    const [parsed] = parseISODuration(text);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
  }

  /**
   * Create a Duration from an ISO 8601 time string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @return {Duration}
   */
  static fromISOTime(text, opts) {
    const [parsed] = parseISOTimeOnly(text);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
  }

  /**
   * Create an invalid Duration.
   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Duration}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDurationError(invalid);
    } else {
      return new Duration({
        invalid
      });
    }
  }

  /**
   * @private
   */
  static normalizeUnit(unit) {
    const normalized = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[unit ? unit.toLowerCase() : unit];
    if (!normalized) throw new InvalidUnitError(unit);
    return normalized;
  }

  /**
   * Check if an object is a Duration. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDuration(o) {
    return o && o.isLuxonDuration || false;
  }

  /**
   * Get  the locale of a Duration, such 'en-GB'
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }

  /**
   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }

  /**
   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
   * * `S` for milliseconds
   * * `s` for seconds
   * * `m` for minutes
   * * `h` for hours
   * * `d` for days
   * * `w` for weeks
   * * `M` for months
   * * `y` for years
   * Notes:
   * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
   * * Tokens can be escaped by wrapping with single quotes.
   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
   * @param {string} fmt - the format string
   * @param {Object} opts - options
   * @param {boolean} [opts.floor=true] - floor numerical values
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
   * @return {string}
   */
  toFormat(fmt, opts = {}) {
    // reverse-compat since 1.2; we always round down now, never up, and we do it by default
    const fmtOpts = {
      ...opts,
      floor: opts.round !== false && opts.floor !== false
    };
    return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID$2;
  }

  /**
   * Returns a string representation of a Duration with all units included.
   * To modify its behavior use the `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat
   * @param opts - On option object to override the formatting. Accepts the same keys as the options parameter of the native `Int.NumberFormat` constructor, as well as `listStyle`.
   * @example
   * ```js
   * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
   * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
   * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
   * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
   * ```
   */
  toHuman(opts = {}) {
    const l = orderedUnits$1.map(unit => {
      const val = this.values[unit];
      if (isUndefined(val)) {
        return null;
      }
      return this.loc.numberFormatter({
        style: "unit",
        unitDisplay: "long",
        ...opts,
        unit: unit.slice(0, -1)
      }).format(val);
    }).filter(n => n);
    return this.loc.listFormatter({
      type: "conjunction",
      style: opts.listStyle || "narrow",
      ...opts
    }).format(l);
  }

  /**
   * Returns a JavaScript object with this Duration's values.
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
   * @return {Object}
   */
  toObject() {
    if (!this.isValid) return {};
    return {
      ...this.values
    };
  }

  /**
   * Returns an ISO 8601-compliant string representation of this Duration.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
   * @return {string}
   */
  toISO() {
    // we could use the formatter, but this is an easier way to get the minimum string
    if (!this.isValid) return null;
    let s = "P";
    if (this.years !== 0) s += this.years + "Y";
    if (this.months !== 0 || this.quarters !== 0) s += this.months + this.quarters * 3 + "M";
    if (this.weeks !== 0) s += this.weeks + "W";
    if (this.days !== 0) s += this.days + "D";
    if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0) s += "T";
    if (this.hours !== 0) s += this.hours + "H";
    if (this.minutes !== 0) s += this.minutes + "M";
    if (this.seconds !== 0 || this.milliseconds !== 0)
      // this will handle "floating point madness" by removing extra decimal places
      // https://stackoverflow.com/questions/588004/is-floating-point-math-broken
      s += roundTo(this.seconds + this.milliseconds / 1000, 3) + "S";
    if (s === "P") s += "T0S";
    return s;
  }

  /**
   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
   * @return {string}
   */
  toISOTime(opts = {}) {
    if (!this.isValid) return null;
    const millis = this.toMillis();
    if (millis < 0 || millis >= 86400000) return null;
    opts = {
      suppressMilliseconds: false,
      suppressSeconds: false,
      includePrefix: false,
      format: "extended",
      ...opts
    };
    const value = this.shiftTo("hours", "minutes", "seconds", "milliseconds");
    let fmt = opts.format === "basic" ? "hhmm" : "hh:mm";
    if (!opts.suppressSeconds || value.seconds !== 0 || value.milliseconds !== 0) {
      fmt += opts.format === "basic" ? "ss" : ":ss";
      if (!opts.suppressMilliseconds || value.milliseconds !== 0) {
        fmt += ".SSS";
      }
    }
    let str = value.toFormat(fmt);
    if (opts.includePrefix) {
      str = "T" + str;
    }
    return str;
  }

  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }

  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
   * @return {string}
   */
  toString() {
    return this.toISO();
  }

  /**
   * Returns an milliseconds value of this Duration.
   * @return {number}
   */
  toMillis() {
    return this.as("milliseconds");
  }

  /**
   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }

  /**
   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  plus(duration) {
    if (!this.isValid) return this;
    const dur = Duration.fromDurationLike(duration),
      result = {};
    for (const k of orderedUnits$1) {
      if (hasOwnProperty(dur.values, k) || hasOwnProperty(this.values, k)) {
        result[k] = dur.get(k) + this.get(k);
      }
    }
    return clone$1(this, {
      values: result
    }, true);
  }

  /**
   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  minus(duration) {
    if (!this.isValid) return this;
    const dur = Duration.fromDurationLike(duration);
    return this.plus(dur.negate());
  }

  /**
   * Scale this Duration by the specified amount. Return a newly-constructed Duration.
   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
   * @return {Duration}
   */
  mapUnits(fn) {
    if (!this.isValid) return this;
    const result = {};
    for (const k of Object.keys(this.values)) {
      result[k] = asNumber(fn(this.values[k], k));
    }
    return clone$1(this, {
      values: result
    }, true);
  }

  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
   * @return {number}
   */
  get(unit) {
    return this[Duration.normalizeUnit(unit)];
  }

  /**
   * "Set" the values of specified units. Return a newly-constructed Duration.
   * @param {Object} values - a mapping of units to numbers
   * @example dur.set({ years: 2017 })
   * @example dur.set({ hours: 8, minutes: 30 })
   * @return {Duration}
   */
  set(values) {
    if (!this.isValid) return this;
    const mixed = {
      ...this.values,
      ...normalizeObject(values, Duration.normalizeUnit)
    };
    return clone$1(this, {
      values: mixed
    });
  }

  /**
   * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
   * @example dur.reconfigure({ locale: 'en-GB' })
   * @return {Duration}
   */
  reconfigure({
    locale,
    numberingSystem,
    conversionAccuracy,
    matrix
  } = {}) {
    const loc = this.loc.clone({
      locale,
      numberingSystem
    });
    const opts = {
      loc,
      matrix,
      conversionAccuracy
    };
    return clone$1(this, opts);
  }

  /**
   * Return the length of the duration in the specified unit.
   * @param {string} unit - a unit such as 'minutes' or 'days'
   * @example Duration.fromObject({years: 1}).as('days') //=> 365
   * @example Duration.fromObject({years: 1}).as('months') //=> 12
   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
   * @return {number}
   */
  as(unit) {
    return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
  }

  /**
   * Reduce this Duration to its canonical representation in its current units.
   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
   * @return {Duration}
   */
  normalize() {
    if (!this.isValid) return this;
    const vals = this.toObject();
    normalizeValues(this.matrix, vals);
    return clone$1(this, {
      values: vals
    }, true);
  }

  /**
   * Rescale units to its largest representation
   * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
   * @return {Duration}
   */
  rescale() {
    if (!this.isValid) return this;
    const vals = removeZeroes(this.normalize().shiftToAll().toObject());
    return clone$1(this, {
      values: vals
    }, true);
  }

  /**
   * Convert this Duration into its representation in a different set of units.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
   * @return {Duration}
   */
  shiftTo(...units) {
    if (!this.isValid) return this;
    if (units.length === 0) {
      return this;
    }
    units = units.map(u => Duration.normalizeUnit(u));
    const built = {},
      accumulated = {},
      vals = this.toObject();
    let lastUnit;
    for (const k of orderedUnits$1) {
      if (units.indexOf(k) >= 0) {
        lastUnit = k;
        let own = 0;

        // anything we haven't boiled down yet should get boiled to this unit
        for (const ak in accumulated) {
          own += this.matrix[ak][k] * accumulated[ak];
          accumulated[ak] = 0;
        }

        // plus anything that's already in this unit
        if (isNumber(vals[k])) {
          own += vals[k];
        }
        const i = Math.trunc(own);
        built[k] = i;
        accumulated[k] = (own * 1000 - i * 1000) / 1000;

        // plus anything further down the chain that should be rolled up in to this
        for (const down in vals) {
          if (orderedUnits$1.indexOf(down) > orderedUnits$1.indexOf(k)) {
            convert(this.matrix, vals, down, built, k);
          }
        }
        // otherwise, keep it in the wings to boil it later
      } else if (isNumber(vals[k])) {
        accumulated[k] = vals[k];
      }
    }

    // anything leftover becomes the decimal for the last unit
    // lastUnit must be defined since units is not empty
    for (const key in accumulated) {
      if (accumulated[key] !== 0) {
        built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
      }
    }
    return clone$1(this, {
      values: built
    }, true).normalize();
  }

  /**
   * Shift this Duration to all available units.
   * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
   * @return {Duration}
   */
  shiftToAll() {
    if (!this.isValid) return this;
    return this.shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds");
  }

  /**
   * Return the negative of this Duration.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
   * @return {Duration}
   */
  negate() {
    if (!this.isValid) return this;
    const negated = {};
    for (const k of Object.keys(this.values)) {
      negated[k] = this.values[k] === 0 ? 0 : -this.values[k];
    }
    return clone$1(this, {
      values: negated
    }, true);
  }

  /**
   * Get the years.
   * @type {number}
   */
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }

  /**
   * Get the quarters.
   * @type {number}
   */
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }

  /**
   * Get the months.
   * @type {number}
   */
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }

  /**
   * Get the weeks
   * @type {number}
   */
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }

  /**
   * Get the days.
   * @type {number}
   */
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }

  /**
   * Get the hours.
   * @type {number}
   */
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }

  /**
   * Get the minutes.
   * @type {number}
   */
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }

  /**
   * Get the seconds.
   * @return {number}
   */
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }

  /**
   * Get the milliseconds.
   * @return {number}
   */
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }

  /**
   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
   * on invalid DateTimes or Intervals.
   * @return {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }

  /**
   * Returns an error code if this Duration became invalid, or null if the Duration is valid
   * @return {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }

  /**
   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }

  /**
   * Equality check
   * Two Durations are equal iff they have the same units and the same values for each unit.
   * @param {Duration} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    if (!this.loc.equals(other.loc)) {
      return false;
    }
    function eq(v1, v2) {
      // Consider 0 and undefined as equal
      if (v1 === undefined || v1 === 0) return v2 === undefined || v2 === 0;
      return v1 === v2;
    }
    for (const u of orderedUnits$1) {
      if (!eq(this.values[u], other.values[u])) {
        return false;
      }
    }
    return true;
  }
}
const INVALID$1 = "Invalid Interval";

// checks if the start is equal to or before the end
function validateStartEnd(start, end) {
  if (!start || !start.isValid) {
    return Interval.invalid("missing or invalid start");
  } else if (!end || !end.isValid) {
    return Interval.invalid("missing or invalid end");
  } else if (end < start) {
    return Interval.invalid("end before start", `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`);
  } else {
    return null;
  }
}

/**
 * An Interval object represents a half-open interval of time, where each endpoint is a {@link DateTime}. Conceptually, it's a container for those two endpoints, accompanied by methods for creating, parsing, interrogating, comparing, transforming, and formatting them.
 *
 * Here is a brief overview of the most commonly used methods and getters in Interval:
 *
 * * **Creation** To create an Interval, use {@link Interval.fromDateTimes}, {@link Interval.after}, {@link Interval.before}, or {@link Interval.fromISO}.
 * * **Accessors** Use {@link Interval#start} and {@link Interval#end} to get the start and end.
 * * **Interrogation** To analyze the Interval, use {@link Interval#count}, {@link Interval#length}, {@link Interval#hasSame}, {@link Interval#contains}, {@link Interval#isAfter}, or {@link Interval#isBefore}.
 * * **Transformation** To create other Intervals out of this one, use {@link Interval#set}, {@link Interval#splitAt}, {@link Interval#splitBy}, {@link Interval#divideEqually}, {@link Interval.merge}, {@link Interval.xor}, {@link Interval#union}, {@link Interval#intersection}, or {@link Interval#difference}.
 * * **Comparison** To compare this Interval to another one, use {@link Interval#equals}, {@link Interval#overlaps}, {@link Interval#abutsStart}, {@link Interval#abutsEnd}, {@link Interval#engulfs}
 * * **Output** To convert the Interval into other representations, see {@link Interval#toString}, {@link Interval#toLocaleString}, {@link Interval#toISO}, {@link Interval#toISODate}, {@link Interval#toISOTime}, {@link Interval#toFormat}, and {@link Interval#toDuration}.
 */
class Interval {
  /**
   * @private
   */
  constructor(config) {
    /**
     * @access private
     */
    this.s = config.start;
    /**
     * @access private
     */
    this.e = config.end;
    /**
     * @access private
     */
    this.invalid = config.invalid || null;
    /**
     * @access private
     */
    this.isLuxonInterval = true;
  }

  /**
   * Create an invalid Interval.
   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Interval}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidIntervalError(invalid);
    } else {
      return new Interval({
        invalid
      });
    }
  }

  /**
   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
   * @param {DateTime|Date|Object} start
   * @param {DateTime|Date|Object} end
   * @return {Interval}
   */
  static fromDateTimes(start, end) {
    const builtStart = friendlyDateTime(start),
      builtEnd = friendlyDateTime(end);
    const validateError = validateStartEnd(builtStart, builtEnd);
    if (validateError == null) {
      return new Interval({
        start: builtStart,
        end: builtEnd
      });
    } else {
      return validateError;
    }
  }

  /**
   * Create an Interval from a start DateTime and a Duration to extend to.
   * @param {DateTime|Date|Object} start
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static after(start, duration) {
    const dur = Duration.fromDurationLike(duration),
      dt = friendlyDateTime(start);
    return Interval.fromDateTimes(dt, dt.plus(dur));
  }

  /**
   * Create an Interval from an end DateTime and a Duration to extend backwards to.
   * @param {DateTime|Date|Object} end
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static before(end, duration) {
    const dur = Duration.fromDurationLike(duration),
      dt = friendlyDateTime(end);
    return Interval.fromDateTimes(dt.minus(dur), dt);
  }

  /**
   * Create an Interval from an ISO 8601 string.
   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
   * @param {string} text - the ISO string to parse
   * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {Interval}
   */
  static fromISO(text, opts) {
    const [s, e] = (text || "").split("/", 2);
    if (s && e) {
      let start, startIsValid;
      try {
        start = DateTime.fromISO(s, opts);
        startIsValid = start.isValid;
      } catch (e) {
        startIsValid = false;
      }
      let end, endIsValid;
      try {
        end = DateTime.fromISO(e, opts);
        endIsValid = end.isValid;
      } catch (e) {
        endIsValid = false;
      }
      if (startIsValid && endIsValid) {
        return Interval.fromDateTimes(start, end);
      }
      if (startIsValid) {
        const dur = Duration.fromISO(e, opts);
        if (dur.isValid) {
          return Interval.after(start, dur);
        }
      } else if (endIsValid) {
        const dur = Duration.fromISO(s, opts);
        if (dur.isValid) {
          return Interval.before(end, dur);
        }
      }
    }
    return Interval.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
  }

  /**
   * Check if an object is an Interval. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isInterval(o) {
    return o && o.isLuxonInterval || false;
  }

  /**
   * Returns the start of the Interval
   * @type {DateTime}
   */
  get start() {
    return this.isValid ? this.s : null;
  }

  /**
   * Returns the end of the Interval
   * @type {DateTime}
   */
  get end() {
    return this.isValid ? this.e : null;
  }

  /**
   * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
   * @type {boolean}
   */
  get isValid() {
    return this.invalidReason === null;
  }

  /**
   * Returns an error code if this Interval is invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }

  /**
   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }

  /**
   * Returns the length of the Interval in the specified unit.
   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
   * @return {number}
   */
  length(unit = "milliseconds") {
    return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
  }

  /**
   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
   * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
   * @param {string} [unit='milliseconds'] - the unit of time to count.
   * @return {number}
   */
  count(unit = "milliseconds") {
    if (!this.isValid) return NaN;
    const start = this.start.startOf(unit),
      end = this.end.startOf(unit);
    return Math.floor(end.diff(start, unit).get(unit)) + 1;
  }

  /**
   * Returns whether this Interval's start and end are both in the same unit of time
   * @param {string} unit - the unit of time to check sameness on
   * @return {boolean}
   */
  hasSame(unit) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
  }

  /**
   * Return whether this Interval has the same start and end DateTimes.
   * @return {boolean}
   */
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }

  /**
   * Return whether this Interval's start is after the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isAfter(dateTime) {
    if (!this.isValid) return false;
    return this.s > dateTime;
  }

  /**
   * Return whether this Interval's end is before the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isBefore(dateTime) {
    if (!this.isValid) return false;
    return this.e <= dateTime;
  }

  /**
   * Return whether this Interval contains the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  contains(dateTime) {
    if (!this.isValid) return false;
    return this.s <= dateTime && this.e > dateTime;
  }

  /**
   * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
   * @param {Object} values - the values to set
   * @param {DateTime} values.start - the starting DateTime
   * @param {DateTime} values.end - the ending DateTime
   * @return {Interval}
   */
  set({
    start,
    end
  } = {}) {
    if (!this.isValid) return this;
    return Interval.fromDateTimes(start || this.s, end || this.e);
  }

  /**
   * Split this Interval at each of the specified DateTimes
   * @param {...DateTime} dateTimes - the unit of time to count.
   * @return {Array}
   */
  splitAt(...dateTimes) {
    if (!this.isValid) return [];
    const sorted = dateTimes.map(friendlyDateTime).filter(d => this.contains(d)).sort(),
      results = [];
    let {
        s
      } = this,
      i = 0;
    while (s < this.e) {
      const added = sorted[i] || this.e,
        next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s, next));
      s = next;
      i += 1;
    }
    return results;
  }

  /**
   * Split this Interval into smaller Intervals, each of the specified length.
   * Left over time is grouped into a smaller interval
   * @param {Duration|Object|number} duration - The length of each resulting interval.
   * @return {Array}
   */
  splitBy(duration) {
    const dur = Duration.fromDurationLike(duration);
    if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
      return [];
    }
    let {
        s
      } = this,
      idx = 1,
      next;
    const results = [];
    while (s < this.e) {
      const added = this.start.plus(dur.mapUnits(x => x * idx));
      next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s, next));
      s = next;
      idx += 1;
    }
    return results;
  }

  /**
   * Split this Interval into the specified number of smaller intervals.
   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
   * @return {Array}
   */
  divideEqually(numberOfParts) {
    if (!this.isValid) return [];
    return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
  }

  /**
   * Return whether this Interval overlaps with the specified Interval
   * @param {Interval} other
   * @return {boolean}
   */
  overlaps(other) {
    return this.e > other.s && this.s < other.e;
  }

  /**
   * Return whether this Interval's end is adjacent to the specified Interval's start.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsStart(other) {
    if (!this.isValid) return false;
    return +this.e === +other.s;
  }

  /**
   * Return whether this Interval's start is adjacent to the specified Interval's end.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsEnd(other) {
    if (!this.isValid) return false;
    return +other.e === +this.s;
  }

  /**
   * Return whether this Interval engulfs the start and end of the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  engulfs(other) {
    if (!this.isValid) return false;
    return this.s <= other.s && this.e >= other.e;
  }

  /**
   * Return whether this Interval has the same start and end as the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    return this.s.equals(other.s) && this.e.equals(other.e);
  }

  /**
   * Return an Interval representing the intersection of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
   * Returns null if the intersection is empty, meaning, the intervals don't intersect.
   * @param {Interval} other
   * @return {Interval}
   */
  intersection(other) {
    if (!this.isValid) return this;
    const s = this.s > other.s ? this.s : other.s,
      e = this.e < other.e ? this.e : other.e;
    if (s >= e) {
      return null;
    } else {
      return Interval.fromDateTimes(s, e);
    }
  }

  /**
   * Return an Interval representing the union of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
   * @param {Interval} other
   * @return {Interval}
   */
  union(other) {
    if (!this.isValid) return this;
    const s = this.s < other.s ? this.s : other.s,
      e = this.e > other.e ? this.e : other.e;
    return Interval.fromDateTimes(s, e);
  }

  /**
   * Merge an array of Intervals into a equivalent minimal set of Intervals.
   * Combines overlapping and adjacent Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static merge(intervals) {
    const [found, final] = intervals.sort((a, b) => a.s - b.s).reduce(([sofar, current], item) => {
      if (!current) {
        return [sofar, item];
      } else if (current.overlaps(item) || current.abutsStart(item)) {
        return [sofar, current.union(item)];
      } else {
        return [sofar.concat([current]), item];
      }
    }, [[], null]);
    if (final) {
      found.push(final);
    }
    return found;
  }

  /**
   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static xor(intervals) {
    let start = null,
      currentCount = 0;
    const results = [],
      ends = intervals.map(i => [{
        time: i.s,
        type: "s"
      }, {
        time: i.e,
        type: "e"
      }]),
      flattened = Array.prototype.concat(...ends),
      arr = flattened.sort((a, b) => a.time - b.time);
    for (const i of arr) {
      currentCount += i.type === "s" ? 1 : -1;
      if (currentCount === 1) {
        start = i.time;
      } else {
        if (start && +start !== +i.time) {
          results.push(Interval.fromDateTimes(start, i.time));
        }
        start = null;
      }
    }
    return Interval.merge(results);
  }

  /**
   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
   * @param {...Interval} intervals
   * @return {Array}
   */
  difference(...intervals) {
    return Interval.xor([this].concat(intervals)).map(i => this.intersection(i)).filter(i => i && !i.isEmpty());
  }

  /**
   * Returns a string representation of this Interval appropriate for debugging.
   * @return {string}
   */
  toString() {
    if (!this.isValid) return INVALID$1;
    return `[${this.s.toISO()} – ${this.e.toISO()})`;
  }

  /**
   * Returns a localized string representing this Interval. Accepts the same options as the
   * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
   * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
   * is browser-specific, but in general it will return an appropriate representation of the
   * Interval in the assigned locale. Defaults to the system's locale if no locale has been
   * specified.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
   * Intl.DateTimeFormat constructor options.
   * @param {Object} opts - Options to override the configuration of the start DateTime.
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022 – 11/8/2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7 – 8, 2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 7–8 novembre 2022
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00 – 8:00 PM
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00 – 8:00 p
   * @return {string}
   */
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid ? Formatter.create(this.s.loc.clone(opts), formatOpts).formatInterval(this) : INVALID$1;
  }

  /**
   * Returns an ISO 8601-compliant string representation of this Interval.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISO(opts) {
    if (!this.isValid) return INVALID$1;
    return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
  }

  /**
   * Returns an ISO 8601-compliant string representation of date of this Interval.
   * The time components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {string}
   */
  toISODate() {
    if (!this.isValid) return INVALID$1;
    return `${this.s.toISODate()}/${this.e.toISODate()}`;
  }

  /**
   * Returns an ISO 8601-compliant string representation of time of this Interval.
   * The date components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISOTime(opts) {
    if (!this.isValid) return INVALID$1;
    return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
  }

  /**
   * Returns a string representation of this Interval formatted according to the specified format
   * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
   * formatting tool.
   * @param {string} dateFormat - The format string. This string formats the start and end time.
   * See {@link DateTime#toFormat} for details.
   * @param {Object} opts - Options.
   * @param {string} [opts.separator =  ' – '] - A separator to place between the start and end
   * representations.
   * @return {string}
   */
  toFormat(dateFormat, {
    separator = " – "
  } = {}) {
    if (!this.isValid) return INVALID$1;
    return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
  }

  /**
   * Return a Duration representing the time spanned by this interval.
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
   * @return {Duration}
   */
  toDuration(unit, opts) {
    if (!this.isValid) {
      return Duration.invalid(this.invalidReason);
    }
    return this.e.diff(this.s, unit, opts);
  }

  /**
   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
   * @param {function} mapFn
   * @return {Interval}
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
   */
  mapEndpoints(mapFn) {
    return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
  }
}

/**
 * The Info class contains static methods for retrieving general time and date related data. For example, it has methods for finding out if a time zone has a DST, for listing the months in any supported locale, and for discovering which of Luxon features are available in the current environment.
 */
class Info {
  /**
   * Return whether the specified zone contains a DST.
   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
   * @return {boolean}
   */
  static hasDST(zone = Settings.defaultZone) {
    const proto = DateTime.now().setZone(zone).set({
      month: 12
    });
    return !zone.isUniversal && proto.offset !== proto.set({
      month: 6
    }).offset;
  }

  /**
   * Return whether the specified zone is a valid IANA specifier.
   * @param {string} zone - Zone to check
   * @return {boolean}
   */
  static isValidIANAZone(zone) {
    return IANAZone.isValidZone(zone);
  }

  /**
   * Converts the input into a {@link Zone} instance.
   *
   * * If `input` is already a Zone instance, it is returned unchanged.
   * * If `input` is a string containing a valid time zone name, a Zone instance
   *   with that name is returned.
   * * If `input` is a string that doesn't refer to a known time zone, a Zone
   *   instance with {@link Zone#isValid} == false is returned.
   * * If `input is a number, a Zone instance with the specified fixed offset
   *   in minutes is returned.
   * * If `input` is `null` or `undefined`, the default zone is returned.
   * @param {string|Zone|number} [input] - the value to be converted
   * @return {Zone}
   */
  static normalizeZone(input) {
    return normalizeZone(input, Settings.defaultZone);
  }

  /**
   * Return an array of standalone month names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @example Info.months()[0] //=> 'January'
   * @example Info.months('short')[0] //=> 'Jan'
   * @example Info.months('numeric')[0] //=> '1'
   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
   * @example Info.months('numeric', { locale: 'ar' })[0] //=> '١'
   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabiʻ I'
   * @return {Array}
   */
  static months(length = "long", {
    locale = null,
    numberingSystem = null,
    locObj = null,
    outputCalendar = "gregory"
  } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length);
  }

  /**
   * Return an array of format month names.
   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
   * changes the string.
   * See {@link Info#months}
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @return {Array}
   */
  static monthsFormat(length = "long", {
    locale = null,
    numberingSystem = null,
    locObj = null,
    outputCalendar = "gregory"
  } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length, true);
  }

  /**
   * Return an array of standalone week names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @example Info.weekdays()[0] //=> 'Monday'
   * @example Info.weekdays('short')[0] //=> 'Mon'
   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> 'الاثنين'
   * @return {Array}
   */
  static weekdays(length = "long", {
    locale = null,
    numberingSystem = null,
    locObj = null
  } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length);
  }

  /**
   * Return an array of format week names.
   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
   * changes the string.
   * See {@link Info#weekdays}
   * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale=null] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @return {Array}
   */
  static weekdaysFormat(length = "long", {
    locale = null,
    numberingSystem = null,
    locObj = null
  } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length, true);
  }

  /**
   * Return an array of meridiems.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.meridiems() //=> [ 'AM', 'PM' ]
   * @example Info.meridiems({ locale: 'my' }) //=> [ 'နံနက်', 'ညနေ' ]
   * @return {Array}
   */
  static meridiems({
    locale = null
  } = {}) {
    return Locale.create(locale).meridiems();
  }

  /**
   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
   * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.eras() //=> [ 'BC', 'AD' ]
   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jésus-Christ', 'après Jésus-Christ' ]
   * @return {Array}
   */
  static eras(length = "short", {
    locale = null
  } = {}) {
    return Locale.create(locale, null, "gregory").eras(length);
  }

  /**
   * Return the set of available features in this environment.
   * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
   * Keys:
   * * `relative`: whether this environment supports relative time formatting
   * @example Info.features() //=> { relative: false }
   * @return {Object}
   */
  static features() {
    return {
      relative: hasRelative()
    };
  }
}
function dayDiff(earlier, later) {
  const utcDayStart = dt => dt.toUTC(0, {
      keepLocalTime: true
    }).startOf("day").valueOf(),
    ms = utcDayStart(later) - utcDayStart(earlier);
  return Math.floor(Duration.fromMillis(ms).as("days"));
}
function highOrderDiffs(cursor, later, units) {
  const differs = [["years", (a, b) => b.year - a.year], ["quarters", (a, b) => b.quarter - a.quarter + (b.year - a.year) * 4], ["months", (a, b) => b.month - a.month + (b.year - a.year) * 12], ["weeks", (a, b) => {
    const days = dayDiff(a, b);
    return (days - days % 7) / 7;
  }], ["days", dayDiff]];
  const results = {};
  const earlier = cursor;
  let lowestOrder, highWater;
  for (const [unit, differ] of differs) {
    if (units.indexOf(unit) >= 0) {
      lowestOrder = unit;
      results[unit] = differ(cursor, later);
      highWater = earlier.plus(results);
      if (highWater > later) {
        results[unit]--;
        cursor = earlier.plus(results);
      } else {
        cursor = highWater;
      }
    }
  }
  return [cursor, results, highWater, lowestOrder];
}
function diff(earlier, later, units, opts) {
  let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
  const remainingMillis = later - cursor;
  const lowerOrderUnits = units.filter(u => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0);
  if (lowerOrderUnits.length === 0) {
    if (highWater < later) {
      highWater = cursor.plus({
        [lowestOrder]: 1
      });
    }
    if (highWater !== cursor) {
      results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
    }
  }
  const duration = Duration.fromObject(results, opts);
  if (lowerOrderUnits.length > 0) {
    return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration);
  } else {
    return duration;
  }
}
const numberingSystems = {
  arab: "[\u0660-\u0669]",
  arabext: "[\u06F0-\u06F9]",
  bali: "[\u1B50-\u1B59]",
  beng: "[\u09E6-\u09EF]",
  deva: "[\u0966-\u096F]",
  fullwide: "[\uFF10-\uFF19]",
  gujr: "[\u0AE6-\u0AEF]",
  hanidec: "[〇|一|二|三|四|五|六|七|八|九]",
  khmr: "[\u17E0-\u17E9]",
  knda: "[\u0CE6-\u0CEF]",
  laoo: "[\u0ED0-\u0ED9]",
  limb: "[\u1946-\u194F]",
  mlym: "[\u0D66-\u0D6F]",
  mong: "[\u1810-\u1819]",
  mymr: "[\u1040-\u1049]",
  orya: "[\u0B66-\u0B6F]",
  tamldec: "[\u0BE6-\u0BEF]",
  telu: "[\u0C66-\u0C6F]",
  thai: "[\u0E50-\u0E59]",
  tibt: "[\u0F20-\u0F29]",
  latn: "\\d"
};
const numberingSystemsUTF16 = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
};
const hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
function parseDigits(str) {
  let value = parseInt(str, 10);
  if (isNaN(value)) {
    value = "";
    for (let i = 0; i < str.length; i++) {
      const code = str.charCodeAt(i);
      if (str[i].search(numberingSystems.hanidec) !== -1) {
        value += hanidecChars.indexOf(str[i]);
      } else {
        for (const key in numberingSystemsUTF16) {
          const [min, max] = numberingSystemsUTF16[key];
          if (code >= min && code <= max) {
            value += code - min;
          }
        }
      }
    }
    return parseInt(value, 10);
  } else {
    return value;
  }
}
function digitRegex({
  numberingSystem
}, append = "") {
  return new RegExp(`${numberingSystems[numberingSystem || "latn"]}${append}`);
}
const MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
function intUnit(regex, post = i => i) {
  return {
    regex,
    deser: ([s]) => post(parseDigits(s))
  };
}
const NBSP = String.fromCharCode(160);
const spaceOrNBSP = `[ ${NBSP}]`;
const spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
function fixListRegex(s) {
  // make dots optional and also make them literal
  // make space and non breakable space characters interchangeable
  return s.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
}
function stripInsensitivities(s) {
  return s.replace(/\./g, "") // ignore dots that were made optional
  .replace(spaceOrNBSPRegExp, " ") // interchange space and nbsp
  .toLowerCase();
}
function oneOf(strings, startIndex) {
  if (strings === null) {
    return null;
  } else {
    return {
      regex: RegExp(strings.map(fixListRegex).join("|")),
      deser: ([s]) => strings.findIndex(i => stripInsensitivities(s) === stripInsensitivities(i)) + startIndex
    };
  }
}
function offset(regex, groups) {
  return {
    regex,
    deser: ([, h, m]) => signedOffset(h, m),
    groups
  };
}
function simple(regex) {
  return {
    regex,
    deser: ([s]) => s
  };
}
function escapeToken(value) {
  return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function unitForToken(token, loc) {
  const one = digitRegex(loc),
    two = digitRegex(loc, "{2}"),
    three = digitRegex(loc, "{3}"),
    four = digitRegex(loc, "{4}"),
    six = digitRegex(loc, "{6}"),
    oneOrTwo = digitRegex(loc, "{1,2}"),
    oneToThree = digitRegex(loc, "{1,3}"),
    oneToSix = digitRegex(loc, "{1,6}"),
    oneToNine = digitRegex(loc, "{1,9}"),
    twoToFour = digitRegex(loc, "{2,4}"),
    fourToSix = digitRegex(loc, "{4,6}"),
    literal = t => ({
      regex: RegExp(escapeToken(t.val)),
      deser: ([s]) => s,
      literal: true
    }),
    unitate = t => {
      if (token.literal) {
        return literal(t);
      }
      switch (t.val) {
        // era
        case "G":
          return oneOf(loc.eras("short", false), 0);
        case "GG":
          return oneOf(loc.eras("long", false), 0);
        // years
        case "y":
          return intUnit(oneToSix);
        case "yy":
          return intUnit(twoToFour, untruncateYear);
        case "yyyy":
          return intUnit(four);
        case "yyyyy":
          return intUnit(fourToSix);
        case "yyyyyy":
          return intUnit(six);
        // months
        case "M":
          return intUnit(oneOrTwo);
        case "MM":
          return intUnit(two);
        case "MMM":
          return oneOf(loc.months("short", true, false), 1);
        case "MMMM":
          return oneOf(loc.months("long", true, false), 1);
        case "L":
          return intUnit(oneOrTwo);
        case "LL":
          return intUnit(two);
        case "LLL":
          return oneOf(loc.months("short", false, false), 1);
        case "LLLL":
          return oneOf(loc.months("long", false, false), 1);
        // dates
        case "d":
          return intUnit(oneOrTwo);
        case "dd":
          return intUnit(two);
        // ordinals
        case "o":
          return intUnit(oneToThree);
        case "ooo":
          return intUnit(three);
        // time
        case "HH":
          return intUnit(two);
        case "H":
          return intUnit(oneOrTwo);
        case "hh":
          return intUnit(two);
        case "h":
          return intUnit(oneOrTwo);
        case "mm":
          return intUnit(two);
        case "m":
          return intUnit(oneOrTwo);
        case "q":
          return intUnit(oneOrTwo);
        case "qq":
          return intUnit(two);
        case "s":
          return intUnit(oneOrTwo);
        case "ss":
          return intUnit(two);
        case "S":
          return intUnit(oneToThree);
        case "SSS":
          return intUnit(three);
        case "u":
          return simple(oneToNine);
        case "uu":
          return simple(oneOrTwo);
        case "uuu":
          return intUnit(one);
        // meridiem
        case "a":
          return oneOf(loc.meridiems(), 0);
        // weekYear (k)
        case "kkkk":
          return intUnit(four);
        case "kk":
          return intUnit(twoToFour, untruncateYear);
        // weekNumber (W)
        case "W":
          return intUnit(oneOrTwo);
        case "WW":
          return intUnit(two);
        // weekdays
        case "E":
        case "c":
          return intUnit(one);
        case "EEE":
          return oneOf(loc.weekdays("short", false, false), 1);
        case "EEEE":
          return oneOf(loc.weekdays("long", false, false), 1);
        case "ccc":
          return oneOf(loc.weekdays("short", true, false), 1);
        case "cccc":
          return oneOf(loc.weekdays("long", true, false), 1);
        // offset/zone
        case "Z":
        case "ZZ":
          return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
        case "ZZZ":
          return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
        // we don't support ZZZZ (PST) or ZZZZZ (Pacific Standard Time) in parsing
        // because we don't have any way to figure out what they are
        case "z":
          return simple(/[a-z_+-/]{1,256}?/i);
        default:
          return literal(t);
      }
    };
  const unit = unitate(token) || {
    invalidReason: MISSING_FTP
  };
  unit.token = token;
  return unit;
}
const partTypeStyleToTokenVal = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour: {
    numeric: "h",
    "2-digit": "hh"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  },
  timeZoneName: {
    long: "ZZZZZ",
    short: "ZZZ"
  }
};
function tokenForPart(part, formatOpts) {
  const {
    type,
    value
  } = part;
  if (type === "literal") {
    return {
      literal: true,
      val: value
    };
  }
  const style = formatOpts[type];
  let val = partTypeStyleToTokenVal[type];
  if (typeof val === "object") {
    val = val[style];
  }
  if (val) {
    return {
      literal: false,
      val
    };
  }
  return undefined;
}
function buildRegex(units) {
  const re = units.map(u => u.regex).reduce((f, r) => `${f}(${r.source})`, "");
  return [`^${re}$`, units];
}
function match(input, regex, handlers) {
  const matches = input.match(regex);
  if (matches) {
    const all = {};
    let matchIndex = 1;
    for (const i in handlers) {
      if (hasOwnProperty(handlers, i)) {
        const h = handlers[i],
          groups = h.groups ? h.groups + 1 : 1;
        if (!h.literal && h.token) {
          all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
        }
        matchIndex += groups;
      }
    }
    return [matches, all];
  } else {
    return [matches, {}];
  }
}
function dateTimeFromMatches(matches) {
  const toField = token => {
    switch (token) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let zone = null;
  let specificOffset;
  if (!isUndefined(matches.z)) {
    zone = IANAZone.create(matches.z);
  }
  if (!isUndefined(matches.Z)) {
    if (!zone) {
      zone = new FixedOffsetZone(matches.Z);
    }
    specificOffset = matches.Z;
  }
  if (!isUndefined(matches.q)) {
    matches.M = (matches.q - 1) * 3 + 1;
  }
  if (!isUndefined(matches.h)) {
    if (matches.h < 12 && matches.a === 1) {
      matches.h += 12;
    } else if (matches.h === 12 && matches.a === 0) {
      matches.h = 0;
    }
  }
  if (matches.G === 0 && matches.y) {
    matches.y = -matches.y;
  }
  if (!isUndefined(matches.u)) {
    matches.S = parseMillis(matches.u);
  }
  const vals = Object.keys(matches).reduce((r, k) => {
    const f = toField(k);
    if (f) {
      r[f] = matches[k];
    }
    return r;
  }, {});
  return [vals, zone, specificOffset];
}
let dummyDateTimeCache = null;
function getDummyDateTime() {
  if (!dummyDateTimeCache) {
    dummyDateTimeCache = DateTime.fromMillis(1555555555555);
  }
  return dummyDateTimeCache;
}
function maybeExpandMacroToken(token, locale) {
  if (token.literal) {
    return token;
  }
  const formatOpts = Formatter.macroTokenToFormatOpts(token.val);
  const tokens = formatOptsToTokens(formatOpts, locale);
  if (tokens == null || tokens.includes(undefined)) {
    return token;
  }
  return tokens;
}
function expandMacroTokens(tokens, locale) {
  return Array.prototype.concat(...tokens.map(t => maybeExpandMacroToken(t, locale)));
}

/**
 * @private
 */

function explainFromTokens(locale, input, format) {
  const tokens = expandMacroTokens(Formatter.parseFormat(format), locale),
    units = tokens.map(t => unitForToken(t, locale)),
    disqualifyingUnit = units.find(t => t.invalidReason);
  if (disqualifyingUnit) {
    return {
      input,
      tokens,
      invalidReason: disqualifyingUnit.invalidReason
    };
  } else {
    const [regexString, handlers] = buildRegex(units),
      regex = RegExp(regexString, "i"),
      [rawMatches, matches] = match(input, regex, handlers),
      [result, zone, specificOffset] = matches ? dateTimeFromMatches(matches) : [null, null, undefined];
    if (hasOwnProperty(matches, "a") && hasOwnProperty(matches, "H")) {
      throw new ConflictingSpecificationError("Can't include meridiem when specifying 24-hour format");
    }
    return {
      input,
      tokens,
      regex,
      rawMatches,
      matches,
      result,
      zone,
      specificOffset
    };
  }
}
function parseFromTokens(locale, input, format) {
  const {
    result,
    zone,
    specificOffset,
    invalidReason
  } = explainFromTokens(locale, input, format);
  return [result, zone, specificOffset, invalidReason];
}
function formatOptsToTokens(formatOpts, locale) {
  if (!formatOpts) {
    return null;
  }
  const formatter = Formatter.create(locale, formatOpts);
  const parts = formatter.formatDateTimeParts(getDummyDateTime());
  return parts.map(p => tokenForPart(p, formatOpts));
}
const nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],
  leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function unitOutOfRange(unit, value) {
  return new Invalid("unit out of range", `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`);
}
function dayOfWeek(year, month, day) {
  const d = new Date(Date.UTC(year, month - 1, day));
  if (year < 100 && year >= 0) {
    d.setUTCFullYear(d.getUTCFullYear() - 1900);
  }
  const js = d.getUTCDay();
  return js === 0 ? 7 : js;
}
function computeOrdinal(year, month, day) {
  return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
}
function uncomputeOrdinal(year, ordinal) {
  const table = isLeapYear(year) ? leapLadder : nonLeapLadder,
    month0 = table.findIndex(i => i < ordinal),
    day = ordinal - table[month0];
  return {
    month: month0 + 1,
    day
  };
}

/**
 * @private
 */

function gregorianToWeek(gregObj) {
  const {
      year,
      month,
      day
    } = gregObj,
    ordinal = computeOrdinal(year, month, day),
    weekday = dayOfWeek(year, month, day);
  let weekNumber = Math.floor((ordinal - weekday + 10) / 7),
    weekYear;
  if (weekNumber < 1) {
    weekYear = year - 1;
    weekNumber = weeksInWeekYear(weekYear);
  } else if (weekNumber > weeksInWeekYear(year)) {
    weekYear = year + 1;
    weekNumber = 1;
  } else {
    weekYear = year;
  }
  return {
    weekYear,
    weekNumber,
    weekday,
    ...timeObject(gregObj)
  };
}
function weekToGregorian(weekData) {
  const {
      weekYear,
      weekNumber,
      weekday
    } = weekData,
    weekdayOfJan4 = dayOfWeek(weekYear, 1, 4),
    yearInDays = daysInYear(weekYear);
  let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 3,
    year;
  if (ordinal < 1) {
    year = weekYear - 1;
    ordinal += daysInYear(year);
  } else if (ordinal > yearInDays) {
    year = weekYear + 1;
    ordinal -= daysInYear(weekYear);
  } else {
    year = weekYear;
  }
  const {
    month,
    day
  } = uncomputeOrdinal(year, ordinal);
  return {
    year,
    month,
    day,
    ...timeObject(weekData)
  };
}
function gregorianToOrdinal(gregData) {
  const {
    year,
    month,
    day
  } = gregData;
  const ordinal = computeOrdinal(year, month, day);
  return {
    year,
    ordinal,
    ...timeObject(gregData)
  };
}
function ordinalToGregorian(ordinalData) {
  const {
    year,
    ordinal
  } = ordinalData;
  const {
    month,
    day
  } = uncomputeOrdinal(year, ordinal);
  return {
    year,
    month,
    day,
    ...timeObject(ordinalData)
  };
}
function hasInvalidWeekData(obj) {
  const validYear = isInteger(obj.weekYear),
    validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear)),
    validWeekday = integerBetween(obj.weekday, 1, 7);
  if (!validYear) {
    return unitOutOfRange("weekYear", obj.weekYear);
  } else if (!validWeek) {
    return unitOutOfRange("week", obj.week);
  } else if (!validWeekday) {
    return unitOutOfRange("weekday", obj.weekday);
  } else return false;
}
function hasInvalidOrdinalData(obj) {
  const validYear = isInteger(obj.year),
    validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validOrdinal) {
    return unitOutOfRange("ordinal", obj.ordinal);
  } else return false;
}
function hasInvalidGregorianData(obj) {
  const validYear = isInteger(obj.year),
    validMonth = integerBetween(obj.month, 1, 12),
    validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validMonth) {
    return unitOutOfRange("month", obj.month);
  } else if (!validDay) {
    return unitOutOfRange("day", obj.day);
  } else return false;
}
function hasInvalidTimeData(obj) {
  const {
    hour,
    minute,
    second,
    millisecond
  } = obj;
  const validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0,
    validMinute = integerBetween(minute, 0, 59),
    validSecond = integerBetween(second, 0, 59),
    validMillisecond = integerBetween(millisecond, 0, 999);
  if (!validHour) {
    return unitOutOfRange("hour", hour);
  } else if (!validMinute) {
    return unitOutOfRange("minute", minute);
  } else if (!validSecond) {
    return unitOutOfRange("second", second);
  } else if (!validMillisecond) {
    return unitOutOfRange("millisecond", millisecond);
  } else return false;
}
const INVALID = "Invalid DateTime";
const MAX_DATE = 8.64e15;
function unsupportedZone(zone) {
  return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
}

// we cache week data on the DT object and this intermediates the cache
function possiblyCachedWeekData(dt) {
  if (dt.weekData === null) {
    dt.weekData = gregorianToWeek(dt.c);
  }
  return dt.weekData;
}

// clone really means, "make a new object with these modifications". all "setters" really use this
// to create a new object while only changing some of the properties
function clone(inst, alts) {
  const current = {
    ts: inst.ts,
    zone: inst.zone,
    c: inst.c,
    o: inst.o,
    loc: inst.loc,
    invalid: inst.invalid
  };
  return new DateTime({
    ...current,
    ...alts,
    old: current
  });
}

// find the right offset a given local time. The o input is our guess, which determines which
// offset we'll pick in ambiguous cases (e.g. there are two 3 AMs b/c Fallback DST)
function fixOffset(localTS, o, tz) {
  // Our UTC time is just a guess because our offset is just a guess
  let utcGuess = localTS - o * 60 * 1000;

  // Test whether the zone matches the offset for this ts
  const o2 = tz.offset(utcGuess);

  // If so, offset didn't change and we're done
  if (o === o2) {
    return [utcGuess, o];
  }

  // If not, change the ts by the difference in the offset
  utcGuess -= (o2 - o) * 60 * 1000;

  // If that gives us the local time we want, we're done
  const o3 = tz.offset(utcGuess);
  if (o2 === o3) {
    return [utcGuess, o2];
  }

  // If it's different, we're in a hole time. The offset has changed, but the we don't adjust the time
  return [localTS - Math.min(o2, o3) * 60 * 1000, Math.max(o2, o3)];
}

// convert an epoch timestamp into a calendar object with the given offset
function tsToObj(ts, offset) {
  ts += offset * 60 * 1000;
  const d = new Date(ts);
  return {
    year: d.getUTCFullYear(),
    month: d.getUTCMonth() + 1,
    day: d.getUTCDate(),
    hour: d.getUTCHours(),
    minute: d.getUTCMinutes(),
    second: d.getUTCSeconds(),
    millisecond: d.getUTCMilliseconds()
  };
}

// convert a calendar object to a epoch timestamp
function objToTS(obj, offset, zone) {
  return fixOffset(objToLocalTS(obj), offset, zone);
}

// create a new DT instance by adding a duration, adjusting for DSTs
function adjustTime(inst, dur) {
  const oPre = inst.o,
    year = inst.c.year + Math.trunc(dur.years),
    month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3,
    c = {
      ...inst.c,
      year,
      month,
      day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
    },
    millisToAdd = Duration.fromObject({
      years: dur.years - Math.trunc(dur.years),
      quarters: dur.quarters - Math.trunc(dur.quarters),
      months: dur.months - Math.trunc(dur.months),
      weeks: dur.weeks - Math.trunc(dur.weeks),
      days: dur.days - Math.trunc(dur.days),
      hours: dur.hours,
      minutes: dur.minutes,
      seconds: dur.seconds,
      milliseconds: dur.milliseconds
    }).as("milliseconds"),
    localTS = objToLocalTS(c);
  let [ts, o] = fixOffset(localTS, oPre, inst.zone);
  if (millisToAdd !== 0) {
    ts += millisToAdd;
    // that could have changed the offset by going over a DST, but we want to keep the ts the same
    o = inst.zone.offset(ts);
  }
  return {
    ts,
    o
  };
}

// helper useful in turning the results of parsing into real dates
// by handling the zone options
function parseDataToDateTime(parsed, parsedZone, opts, format, text, specificOffset) {
  const {
    setZone,
    zone
  } = opts;
  if (parsed && Object.keys(parsed).length !== 0) {
    const interpretationZone = parsedZone || zone,
      inst = DateTime.fromObject(parsed, {
        ...opts,
        zone: interpretationZone,
        specificOffset
      });
    return setZone ? inst : inst.setZone(zone);
  } else {
    return DateTime.invalid(new Invalid("unparsable", `the input "${text}" can't be parsed as ${format}`));
  }
}

// if you want to output a technical format (e.g. RFC 2822), this helper
// helps handle the details
function toTechFormat(dt, format, allowZ = true) {
  return dt.isValid ? Formatter.create(Locale.create("en-US"), {
    allowZ,
    forceSimple: true
  }).formatDateTimeFromString(dt, format) : null;
}
function toISODate(o, extended) {
  const longFormat = o.c.year > 9999 || o.c.year < 0;
  let c = "";
  if (longFormat && o.c.year >= 0) c += "+";
  c += padStart(o.c.year, longFormat ? 6 : 4);
  if (extended) {
    c += "-";
    c += padStart(o.c.month);
    c += "-";
    c += padStart(o.c.day);
  } else {
    c += padStart(o.c.month);
    c += padStart(o.c.day);
  }
  return c;
}
function toISOTime(o, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
  let c = padStart(o.c.hour);
  if (extended) {
    c += ":";
    c += padStart(o.c.minute);
    if (o.c.second !== 0 || !suppressSeconds) {
      c += ":";
    }
  } else {
    c += padStart(o.c.minute);
  }
  if (o.c.second !== 0 || !suppressSeconds) {
    c += padStart(o.c.second);
    if (o.c.millisecond !== 0 || !suppressMilliseconds) {
      c += ".";
      c += padStart(o.c.millisecond, 3);
    }
  }
  if (includeOffset) {
    if (o.isOffsetFixed && o.offset === 0 && !extendedZone) {
      c += "Z";
    } else if (o.o < 0) {
      c += "-";
      c += padStart(Math.trunc(-o.o / 60));
      c += ":";
      c += padStart(Math.trunc(-o.o % 60));
    } else {
      c += "+";
      c += padStart(Math.trunc(o.o / 60));
      c += ":";
      c += padStart(Math.trunc(o.o % 60));
    }
  }
  if (extendedZone) {
    c += "[" + o.zone.ianaName + "]";
  }
  return c;
}

// defaults for unspecified units in the supported calendars
const defaultUnitValues = {
    month: 1,
    day: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  },
  defaultWeekUnitValues = {
    weekNumber: 1,
    weekday: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  },
  defaultOrdinalUnitValues = {
    ordinal: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  };

// Units in the supported calendars, sorted by bigness
const orderedUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"],
  orderedWeekUnits = ["weekYear", "weekNumber", "weekday", "hour", "minute", "second", "millisecond"],
  orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];

// standardize case and plurality in units
function normalizeUnit(unit) {
  const normalized = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[unit.toLowerCase()];
  if (!normalized) throw new InvalidUnitError(unit);
  return normalized;
}

// this is a dumbed down version of fromObject() that runs about 60% faster
// but doesn't do any validation, makes a bunch of assumptions about what units
// are present, and so on.
function quickDT(obj, opts) {
  const zone = normalizeZone(opts.zone, Settings.defaultZone),
    loc = Locale.fromObject(opts),
    tsNow = Settings.now();
  let ts, o;

  // assume we have the higher-order units
  if (!isUndefined(obj.year)) {
    for (const u of orderedUnits) {
      if (isUndefined(obj[u])) {
        obj[u] = defaultUnitValues[u];
      }
    }
    const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
    if (invalid) {
      return DateTime.invalid(invalid);
    }
    const offsetProvis = zone.offset(tsNow);
    [ts, o] = objToTS(obj, offsetProvis, zone);
  } else {
    ts = tsNow;
  }
  return new DateTime({
    ts,
    zone,
    loc,
    o
  });
}
function diffRelative(start, end, opts) {
  const round = isUndefined(opts.round) ? true : opts.round,
    format = (c, unit) => {
      c = roundTo(c, round || opts.calendary ? 0 : 2, true);
      const formatter = end.loc.clone(opts).relFormatter(opts);
      return formatter.format(c, unit);
    },
    differ = unit => {
      if (opts.calendary) {
        if (!end.hasSame(start, unit)) {
          return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
        } else return 0;
      } else {
        return end.diff(start, unit).get(unit);
      }
    };
  if (opts.unit) {
    return format(differ(opts.unit), opts.unit);
  }
  for (const unit of opts.units) {
    const count = differ(unit);
    if (Math.abs(count) >= 1) {
      return format(count, unit);
    }
  }
  return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
}
function lastOpts(argList) {
  let opts = {},
    args;
  if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
    opts = argList[argList.length - 1];
    args = Array.from(argList).slice(0, argList.length - 1);
  } else {
    args = Array.from(argList);
  }
  return [opts, args];
}

/**
 * A DateTime is an immutable data structure representing a specific date and time and accompanying methods. It contains class and instance methods for creating, parsing, interrogating, transforming, and formatting them.
 *
 * A DateTime comprises of:
 * * A timestamp. Each DateTime instance refers to a specific millisecond of the Unix epoch.
 * * A time zone. Each instance is considered in the context of a specific zone (by default the local system's zone).
 * * Configuration properties that effect how output strings are formatted, such as `locale`, `numberingSystem`, and `outputCalendar`.
 *
 * Here is a brief overview of the most commonly used functionality it provides:
 *
 * * **Creation**: To create a DateTime from its components, use one of its factory class methods: {@link DateTime.local}, {@link DateTime.utc}, and (most flexibly) {@link DateTime.fromObject}. To create one from a standard string format, use {@link DateTime.fromISO}, {@link DateTime.fromHTTP}, and {@link DateTime.fromRFC2822}. To create one from a custom string format, use {@link DateTime.fromFormat}. To create one from a native JS date, use {@link DateTime.fromJSDate}.
 * * **Gregorian calendar and time**: To examine the Gregorian properties of a DateTime individually (i.e as opposed to collectively through {@link DateTime#toObject}), use the {@link DateTime#year}, {@link DateTime#month},
 * {@link DateTime#day}, {@link DateTime#hour}, {@link DateTime#minute}, {@link DateTime#second}, {@link DateTime#millisecond} accessors.
 * * **Week calendar**: For ISO week calendar attributes, see the {@link DateTime#weekYear}, {@link DateTime#weekNumber}, and {@link DateTime#weekday} accessors.
 * * **Configuration** See the {@link DateTime#locale} and {@link DateTime#numberingSystem} accessors.
 * * **Transformation**: To transform the DateTime into other DateTimes, use {@link DateTime#set}, {@link DateTime#reconfigure}, {@link DateTime#setZone}, {@link DateTime#setLocale}, {@link DateTime.plus}, {@link DateTime#minus}, {@link DateTime#endOf}, {@link DateTime#startOf}, {@link DateTime#toUTC}, and {@link DateTime#toLocal}.
 * * **Output**: To convert the DateTime to other representations, use the {@link DateTime#toRelative}, {@link DateTime#toRelativeCalendar}, {@link DateTime#toJSON}, {@link DateTime#toISO}, {@link DateTime#toHTTP}, {@link DateTime#toObject}, {@link DateTime#toRFC2822}, {@link DateTime#toString}, {@link DateTime#toLocaleString}, {@link DateTime#toFormat}, {@link DateTime#toMillis} and {@link DateTime#toJSDate}.
 *
 * There's plenty others documented below. In addition, for more information on subtler topics like internationalization, time zones, alternative calendars, validity, and so on, see the external documentation.
 */
class DateTime {
  /**
   * @access private
   */
  constructor(config) {
    const zone = config.zone || Settings.defaultZone;
    let invalid = config.invalid || (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
    /**
     * @access private
     */
    this.ts = isUndefined(config.ts) ? Settings.now() : config.ts;
    let c = null,
      o = null;
    if (!invalid) {
      const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);
      if (unchanged) {
        [c, o] = [config.old.c, config.old.o];
      } else {
        const ot = zone.offset(this.ts);
        c = tsToObj(this.ts, ot);
        invalid = Number.isNaN(c.year) ? new Invalid("invalid input") : null;
        c = invalid ? null : c;
        o = invalid ? null : ot;
      }
    }

    /**
     * @access private
     */
    this._zone = zone;
    /**
     * @access private
     */
    this.loc = config.loc || Locale.create();
    /**
     * @access private
     */
    this.invalid = invalid;
    /**
     * @access private
     */
    this.weekData = null;
    /**
     * @access private
     */
    this.c = c;
    /**
     * @access private
     */
    this.o = o;
    /**
     * @access private
     */
    this.isLuxonDateTime = true;
  }

  // CONSTRUCT

  /**
   * Create a DateTime for the current instant, in the system's time zone.
   *
   * Use Settings to override these default values if needed.
   * @example DateTime.now().toISO() //~> now in the ISO format
   * @return {DateTime}
   */
  static now() {
    return new DateTime({});
  }

  /**
   * Create a local DateTime
   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month, 1-indexed
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @example DateTime.local()                                  //~> now
   * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
   * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
   * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
   * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
   * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
   * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
   * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
   * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
   * @return {DateTime}
   */
  static local() {
    const [opts, args] = lastOpts(arguments),
      [year, month, day, hour, minute, second, millisecond] = args;
    return quickDT({
      year,
      month,
      day,
      hour,
      minute,
      second,
      millisecond
    }, opts);
  }

  /**
   * Create a DateTime in UTC
   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @param {Object} options - configuration options for the DateTime
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.utc()                                              //~> now
   * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
   * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
   * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
   * @return {DateTime}
   */
  static utc() {
    const [opts, args] = lastOpts(arguments),
      [year, month, day, hour, minute, second, millisecond] = args;
    opts.zone = FixedOffsetZone.utcInstance;
    return quickDT({
      year,
      month,
      day,
      hour,
      minute,
      second,
      millisecond
    }, opts);
  }

  /**
   * Create a DateTime from a JavaScript Date object. Uses the default zone.
   * @param {Date} date - a JavaScript Date object
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @return {DateTime}
   */
  static fromJSDate(date, options = {}) {
    const ts = isDate(date) ? date.valueOf() : NaN;
    if (Number.isNaN(ts)) {
      return DateTime.invalid("invalid input");
    }
    const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }
    return new DateTime({
      ts: ts,
      zone: zoneToUse,
      loc: Locale.fromObject(options)
    });
  }

  /**
   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} milliseconds - a number of milliseconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromMillis(milliseconds, options = {}) {
    if (!isNumber(milliseconds)) {
      throw new InvalidArgumentError(`fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`);
    } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
      // this isn't perfect because because we can still end up out of range because of additional shifting, but it's a start
      return DateTime.invalid("Timestamp out of range");
    } else {
      return new DateTime({
        ts: milliseconds,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }

  /**
   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} seconds - a number of seconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromSeconds(seconds, options = {}) {
    if (!isNumber(seconds)) {
      throw new InvalidArgumentError("fromSeconds requires a numerical input");
    } else {
      return new DateTime({
        ts: seconds * 1000,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }

  /**
   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.year - a year, such as 1987
   * @param {number} obj.month - a month, 1-12
   * @param {number} obj.day - a day of the month, 1-31, depending on the month
   * @param {number} obj.ordinal - day of the year, 1-365 or 366
   * @param {number} obj.weekYear - an ISO week year
   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
   * @param {number} obj.hour - hour of the day, 0-23
   * @param {number} obj.minute - minute of the hour, 0-59
   * @param {number} obj.second - second of the minute, 0-59
   * @param {number} obj.millisecond - millisecond of the second, 0-999
   * @param {Object} opts - options for creating this DateTime
   * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
   * @return {DateTime}
   */
  static fromObject(obj, opts = {}) {
    obj = obj || {};
    const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }
    const tsNow = Settings.now(),
      offsetProvis = !isUndefined(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow),
      normalized = normalizeObject(obj, normalizeUnit),
      containsOrdinal = !isUndefined(normalized.ordinal),
      containsGregorYear = !isUndefined(normalized.year),
      containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day),
      containsGregor = containsGregorYear || containsGregorMD,
      definiteWeekDef = normalized.weekYear || normalized.weekNumber,
      loc = Locale.fromObject(opts);

    // cases:
    // just a weekday -> this week's instance of that weekday, no worries
    // (gregorian data or ordinal) + (weekYear or weekNumber) -> error
    // (gregorian month or day) + ordinal -> error
    // otherwise just use weeks or ordinals or gregorian, depending on what's specified

    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;

    // configure ourselves to deal with gregorian dates or week stuff
    let units,
      defaultValues,
      objNow = tsToObj(tsNow, offsetProvis);
    if (useWeekData) {
      units = orderedWeekUnits;
      defaultValues = defaultWeekUnitValues;
      objNow = gregorianToWeek(objNow);
    } else if (containsOrdinal) {
      units = orderedOrdinalUnits;
      defaultValues = defaultOrdinalUnitValues;
      objNow = gregorianToOrdinal(objNow);
    } else {
      units = orderedUnits;
      defaultValues = defaultUnitValues;
    }

    // set default values for missing stuff
    let foundFirst = false;
    for (const u of units) {
      const v = normalized[u];
      if (!isUndefined(v)) {
        foundFirst = true;
      } else if (foundFirst) {
        normalized[u] = defaultValues[u];
      } else {
        normalized[u] = objNow[u];
      }
    }

    // make sure the values we have are in range
    const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized),
      invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
    if (invalid) {
      return DateTime.invalid(invalid);
    }

    // compute the actual time
    const gregorian = useWeekData ? weekToGregorian(normalized) : containsOrdinal ? ordinalToGregorian(normalized) : normalized,
      [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse),
      inst = new DateTime({
        ts: tsFinal,
        zone: zoneToUse,
        o: offsetFinal,
        loc
      });

    // gregorian data + weekday serves only to validate
    if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
      return DateTime.invalid("mismatched weekday", `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`);
    }
    return inst;
  }

  /**
   * Create a DateTime from an ISO 8601 string
   * @param {string} text - the ISO string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromISO('2016-05-25T09:08:34.123')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
   * @example DateTime.fromISO('2016-W05-4')
   * @return {DateTime}
   */
  static fromISO(text, opts = {}) {
    const [vals, parsedZone] = parseISODate(text);
    return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
  }

  /**
   * Create a DateTime from an RFC 2822 string
   * @param {string} text - the RFC 2822 string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
   * @return {DateTime}
   */
  static fromRFC2822(text, opts = {}) {
    const [vals, parsedZone] = parseRFC2822Date(text);
    return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
  }

  /**
   * Create a DateTime from an HTTP header date
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @param {string} text - the HTTP header date
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
   * @return {DateTime}
   */
  static fromHTTP(text, opts = {}) {
    const [vals, parsedZone] = parseHTTPDate(text);
    return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
  }

  /**
   * Create a DateTime from an input string and format string.
   * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromFormat(text, fmt, opts = {}) {
    if (isUndefined(text) || isUndefined(fmt)) {
      throw new InvalidArgumentError("fromFormat requires an input string and a format");
    }
    const {
        locale = null,
        numberingSystem = null
      } = opts,
      localeToUse = Locale.fromOpts({
        locale,
        numberingSystem,
        defaultToEN: true
      }),
      [vals, parsedZone, specificOffset, invalid] = parseFromTokens(localeToUse, text, fmt);
    if (invalid) {
      return DateTime.invalid(invalid);
    } else {
      return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text, specificOffset);
    }
  }

  /**
   * @deprecated use fromFormat instead
   */
  static fromString(text, fmt, opts = {}) {
    return DateTime.fromFormat(text, fmt, opts);
  }

  /**
   * Create a DateTime from a SQL date, time, or datetime
   * Defaults to en-US if no locale has been specified, regardless of the system's locale
   * @param {string} text - the string to parse
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @example DateTime.fromSQL('2017-05-15')
   * @example DateTime.fromSQL('2017-05-15 09:12:34')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
   * @example DateTime.fromSQL('09:12:34.342')
   * @return {DateTime}
   */
  static fromSQL(text, opts = {}) {
    const [vals, parsedZone] = parseSQL(text);
    return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
  }

  /**
   * Create an invalid DateTime.
   * @param {DateTime} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {DateTime}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDateTimeError(invalid);
    } else {
      return new DateTime({
        invalid
      });
    }
  }

  /**
   * Check if an object is an instance of DateTime. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDateTime(o) {
    return o && o.isLuxonDateTime || false;
  }

  /**
   * Produce the format string for a set of options
   * @param formatOpts
   * @param localeOpts
   * @returns {string}
   */
  static parseFormatForOpts(formatOpts, localeOpts = {}) {
    const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
    return !tokenList ? null : tokenList.map(t => t ? t.val : null).join("");
  }

  /**
   * Produce the the fully expanded format token for the locale
   * Does NOT quote characters, so quoted tokens will not round trip correctly
   * @param fmt
   * @param localeOpts
   * @returns {string}
   */
  static expandFormat(fmt, localeOpts = {}) {
    const expanded = expandMacroTokens(Formatter.parseFormat(fmt), Locale.fromObject(localeOpts));
    return expanded.map(t => t.val).join("");
  }

  // INFO

  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
   * @return {number}
   */
  get(unit) {
    return this[unit];
  }

  /**
   * Returns whether the DateTime is valid. Invalid DateTimes occur when:
   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
   * * The DateTime was created by an operation on another invalid date
   * @type {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }

  /**
   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }

  /**
   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }

  /**
   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
   *
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }

  /**
   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }

  /**
   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
   *
   * @type {string}
   */
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }

  /**
   * Get the time zone associated with this DateTime.
   * @type {Zone}
   */
  get zone() {
    return this._zone;
  }

  /**
   * Get the name of the time zone.
   * @type {string}
   */
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }

  /**
   * Get the year
   * @example DateTime.local(2017, 5, 25).year //=> 2017
   * @type {number}
   */
  get year() {
    return this.isValid ? this.c.year : NaN;
  }

  /**
   * Get the quarter
   * @example DateTime.local(2017, 5, 25).quarter //=> 2
   * @type {number}
   */
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }

  /**
   * Get the month (1-12).
   * @example DateTime.local(2017, 5, 25).month //=> 5
   * @type {number}
   */
  get month() {
    return this.isValid ? this.c.month : NaN;
  }

  /**
   * Get the day of the month (1-30ish).
   * @example DateTime.local(2017, 5, 25).day //=> 25
   * @type {number}
   */
  get day() {
    return this.isValid ? this.c.day : NaN;
  }

  /**
   * Get the hour of the day (0-23).
   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
   * @type {number}
   */
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }

  /**
   * Get the minute of the hour (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
   * @type {number}
   */
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }

  /**
   * Get the second of the minute (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
   * @type {number}
   */
  get second() {
    return this.isValid ? this.c.second : NaN;
  }

  /**
   * Get the millisecond of the second (0-999).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
   * @type {number}
   */
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }

  /**
   * Get the week year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
   * @type {number}
   */
  get weekYear() {
    return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
  }

  /**
   * Get the week number of the week year (1-52ish).
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
   * @type {number}
   */
  get weekNumber() {
    return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
  }

  /**
   * Get the day of the week.
   * 1 is Monday and 7 is Sunday
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 11, 31).weekday //=> 4
   * @type {number}
   */
  get weekday() {
    return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
  }

  /**
   * Get the ordinal (meaning the day of the year)
   * @example DateTime.local(2017, 5, 25).ordinal //=> 145
   * @type {number|DateTime}
   */
  get ordinal() {
    return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
  }

  /**
   * Get the human readable short month name, such as 'Oct'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
   * @type {string}
   */
  get monthShort() {
    return this.isValid ? Info.months("short", {
      locObj: this.loc
    })[this.month - 1] : null;
  }

  /**
   * Get the human readable long month name, such as 'October'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthLong //=> October
   * @type {string}
   */
  get monthLong() {
    return this.isValid ? Info.months("long", {
      locObj: this.loc
    })[this.month - 1] : null;
  }

  /**
   * Get the human readable short weekday, such as 'Mon'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
   * @type {string}
   */
  get weekdayShort() {
    return this.isValid ? Info.weekdays("short", {
      locObj: this.loc
    })[this.weekday - 1] : null;
  }

  /**
   * Get the human readable long weekday, such as 'Monday'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
   * @type {string}
   */
  get weekdayLong() {
    return this.isValid ? Info.weekdays("long", {
      locObj: this.loc
    })[this.weekday - 1] : null;
  }

  /**
   * Get the UTC offset of this DateTime in minutes
   * @example DateTime.now().offset //=> -240
   * @example DateTime.utc().offset //=> 0
   * @type {number}
   */
  get offset() {
    return this.isValid ? +this.o : NaN;
  }

  /**
   * Get the short human name for the zone's current offset, for example "EST" or "EDT".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameShort() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "short",
        locale: this.locale
      });
    } else {
      return null;
    }
  }

  /**
   * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameLong() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "long",
        locale: this.locale
      });
    } else {
      return null;
    }
  }

  /**
   * Get whether this zone's offset ever changes, as in a DST.
   * @type {boolean}
   */
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }

  /**
   * Get whether the DateTime is in a DST.
   * @type {boolean}
   */
  get isInDST() {
    if (this.isOffsetFixed) {
      return false;
    } else {
      return this.offset > this.set({
        month: 1,
        day: 1
      }).offset || this.offset > this.set({
        month: 5
      }).offset;
    }
  }

  /**
   * Returns true if this DateTime is in a leap year, false otherwise
   * @example DateTime.local(2016).isInLeapYear //=> true
   * @example DateTime.local(2013).isInLeapYear //=> false
   * @type {boolean}
   */
  get isInLeapYear() {
    return isLeapYear(this.year);
  }

  /**
   * Returns the number of days in this DateTime's month
   * @example DateTime.local(2016, 2).daysInMonth //=> 29
   * @example DateTime.local(2016, 3).daysInMonth //=> 31
   * @type {number}
   */
  get daysInMonth() {
    return daysInMonth(this.year, this.month);
  }

  /**
   * Returns the number of days in this DateTime's year
   * @example DateTime.local(2016).daysInYear //=> 366
   * @example DateTime.local(2013).daysInYear //=> 365
   * @type {number}
   */
  get daysInYear() {
    return this.isValid ? daysInYear(this.year) : NaN;
  }

  /**
   * Returns the number of weeks in this DateTime's year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2004).weeksInWeekYear //=> 53
   * @example DateTime.local(2013).weeksInWeekYear //=> 52
   * @type {number}
   */
  get weeksInWeekYear() {
    return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
  }

  /**
   * Returns the resolved Intl options for this DateTime.
   * This is useful in understanding the behavior of formatting methods
   * @param {Object} opts - the same options as toLocaleString
   * @return {Object}
   */
  resolvedLocaleOptions(opts = {}) {
    const {
      locale,
      numberingSystem,
      calendar
    } = Formatter.create(this.loc.clone(opts), opts).resolvedOptions(this);
    return {
      locale,
      numberingSystem,
      outputCalendar: calendar
    };
  }

  // TRANSFORM

  /**
   * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
   *
   * Equivalent to {@link DateTime#setZone}('utc')
   * @param {number} [offset=0] - optionally, an offset from UTC in minutes
   * @param {Object} [opts={}] - options to pass to `setZone()`
   * @return {DateTime}
   */
  toUTC(offset = 0, opts = {}) {
    return this.setZone(FixedOffsetZone.instance(offset), opts);
  }

  /**
   * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
   *
   * Equivalent to `setZone('local')`
   * @return {DateTime}
   */
  toLocal() {
    return this.setZone(Settings.defaultZone);
  }

  /**
   * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
   *
   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
   * @param {Object} opts - options
   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
   * @return {DateTime}
   */
  setZone(zone, {
    keepLocalTime = false,
    keepCalendarTime = false
  } = {}) {
    zone = normalizeZone(zone, Settings.defaultZone);
    if (zone.equals(this.zone)) {
      return this;
    } else if (!zone.isValid) {
      return DateTime.invalid(unsupportedZone(zone));
    } else {
      let newTS = this.ts;
      if (keepLocalTime || keepCalendarTime) {
        const offsetGuess = zone.offset(this.ts);
        const asObj = this.toObject();
        [newTS] = objToTS(asObj, offsetGuess, zone);
      }
      return clone(this, {
        ts: newTS,
        zone
      });
    }
  }

  /**
   * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
   * @param {Object} properties - the properties to set
   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
   * @return {DateTime}
   */
  reconfigure({
    locale,
    numberingSystem,
    outputCalendar
  } = {}) {
    const loc = this.loc.clone({
      locale,
      numberingSystem,
      outputCalendar
    });
    return clone(this, {
      loc
    });
  }

  /**
   * "Set" the locale. Returns a newly-constructed DateTime.
   * Just a convenient alias for reconfigure({ locale })
   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
   * @return {DateTime}
   */
  setLocale(locale) {
    return this.reconfigure({
      locale
    });
  }

  /**
   * "Set" the values of specified units. Returns a newly-constructed DateTime.
   * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
   * @param {Object} values - a mapping of units to numbers
   * @example dt.set({ year: 2017 })
   * @example dt.set({ hour: 8, minute: 30 })
   * @example dt.set({ weekday: 5 })
   * @example dt.set({ year: 2005, ordinal: 234 })
   * @return {DateTime}
   */
  set(values) {
    if (!this.isValid) return this;
    const normalized = normalizeObject(values, normalizeUnit),
      settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday),
      containsOrdinal = !isUndefined(normalized.ordinal),
      containsGregorYear = !isUndefined(normalized.year),
      containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day),
      containsGregor = containsGregorYear || containsGregorMD,
      definiteWeekDef = normalized.weekYear || normalized.weekNumber;
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    let mixed;
    if (settingWeekStuff) {
      mixed = weekToGregorian({
        ...gregorianToWeek(this.c),
        ...normalized
      });
    } else if (!isUndefined(normalized.ordinal)) {
      mixed = ordinalToGregorian({
        ...gregorianToOrdinal(this.c),
        ...normalized
      });
    } else {
      mixed = {
        ...this.toObject(),
        ...normalized
      };

      // if we didn't set the day but we ended up on an overflow date,
      // use the last day of the right month
      if (isUndefined(normalized.day)) {
        mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
      }
    }
    const [ts, o] = objToTS(mixed, this.o, this.zone);
    return clone(this, {
      ts,
      o
    });
  }

  /**
   * Add a period of time to this DateTime and return the resulting DateTime
   *
   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @example DateTime.now().plus(123) //~> in 123 milliseconds
   * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
   * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
   * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
   * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
   * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
   * @return {DateTime}
   */
  plus(duration) {
    if (!this.isValid) return this;
    const dur = Duration.fromDurationLike(duration);
    return clone(this, adjustTime(this, dur));
  }

  /**
   * Subtract a period of time to this DateTime and return the resulting DateTime
   * See {@link DateTime#plus}
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   @return {DateTime}
   */
  minus(duration) {
    if (!this.isValid) return this;
    const dur = Duration.fromDurationLike(duration).negate();
    return clone(this, adjustTime(this, dur));
  }

  /**
   * "Set" this DateTime to the beginning of a unit of time.
   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
   * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
   * @return {DateTime}
   */
  startOf(unit) {
    if (!this.isValid) return this;
    const o = {},
      normalizedUnit = Duration.normalizeUnit(unit);
    switch (normalizedUnit) {
      case "years":
        o.month = 1;
      // falls through
      case "quarters":
      case "months":
        o.day = 1;
      // falls through
      case "weeks":
      case "days":
        o.hour = 0;
      // falls through
      case "hours":
        o.minute = 0;
      // falls through
      case "minutes":
        o.second = 0;
      // falls through
      case "seconds":
        o.millisecond = 0;
        break;
      // no default, invalid units throw in normalizeUnit()
    }

    if (normalizedUnit === "weeks") {
      o.weekday = 1;
    }
    if (normalizedUnit === "quarters") {
      const q = Math.ceil(this.month / 3);
      o.month = (q - 1) * 3 + 1;
    }
    return this.set(o);
  }

  /**
   * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
   * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
   * @return {DateTime}
   */
  endOf(unit) {
    return this.isValid ? this.plus({
      [unit]: 1
    }).startOf(unit).minus(1) : this;
  }

  // OUTPUT

  /**
   * Returns a string representation of this DateTime formatted according to the specified format string.
   * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @param {string} fmt - the format string
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
   * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
   * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
   * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
   * @return {string}
   */
  toFormat(fmt, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID;
  }

  /**
   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
   * of the DateTime in the assigned locale.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toLocaleString(); //=> 4/20/2017
   * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 août 2022'
   * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
   * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
   * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
   * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
   * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
   * @return {string}
   */
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID;
  }

  /**
   * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
   * @example DateTime.now().toLocaleParts(); //=> [
   *                                   //=>   { type: 'day', value: '25' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'month', value: '05' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'year', value: '1982' }
   *                                   //=> ]
   */
  toLocaleParts(opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
  }

  /**
   * Returns an ISO 8601-compliant string representation of this DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
   * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
   * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
   * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
   * @return {string}
   */
  toISO({
    format = "extended",
    suppressSeconds = false,
    suppressMilliseconds = false,
    includeOffset = true,
    extendedZone = false
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    const ext = format === "extended";
    let c = toISODate(this, ext);
    c += "T";
    c += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
    return c;
  }

  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's date component
   * @param {Object} opts - options
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
   * @return {string}
   */
  toISODate({
    format = "extended"
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, format === "extended");
  }

  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's week date
   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
   * @return {string}
   */
  toISOWeekDate() {
    return toTechFormat(this, "kkkk-'W'WW-c");
  }

  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's time component
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
   * @return {string}
   */
  toISOTime({
    suppressMilliseconds = false,
    suppressSeconds = false,
    includeOffset = true,
    includePrefix = false,
    extendedZone = false,
    format = "extended"
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    let c = includePrefix ? "T" : "";
    return c + toISOTime(this, format === "extended", suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
  }

  /**
   * Returns an RFC 2822-compatible string representation of this DateTime
   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
   * @return {string}
   */
  toRFC2822() {
    return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
  }

  /**
   * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
   * Specifically, the string conforms to RFC 1123.
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
   * @return {string}
   */
  toHTTP() {
    return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }

  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Date
   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
   * @return {string}
   */
  toSQLDate() {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, true);
  }

  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Time
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc().toSQL() //=> '05:15:16.345'
   * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
   * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
   * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
   * @return {string}
   */
  toSQLTime({
    includeOffset = true,
    includeZone = false,
    includeOffsetSpace = true
  } = {}) {
    let fmt = "HH:mm:ss.SSS";
    if (includeZone || includeOffset) {
      if (includeOffsetSpace) {
        fmt += " ";
      }
      if (includeZone) {
        fmt += "z";
      } else if (includeOffset) {
        fmt += "ZZ";
      }
    }
    return toTechFormat(this, fmt, true);
  }

  /**
   * Returns a string representation of this DateTime appropriate for use in SQL DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
   * @return {string}
   */
  toSQL(opts = {}) {
    if (!this.isValid) {
      return null;
    }
    return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
  }

  /**
   * Returns a string representation of this DateTime appropriate for debugging
   * @return {string}
   */
  toString() {
    return this.isValid ? this.toISO() : INVALID;
  }

  /**
   * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }

  /**
   * Returns the epoch milliseconds of this DateTime.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }

  /**
   * Returns the epoch seconds of this DateTime.
   * @return {number}
   */
  toSeconds() {
    return this.isValid ? this.ts / 1000 : NaN;
  }

  /**
   * Returns the epoch seconds (as a whole number) of this DateTime.
   * @return {number}
   */
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1000) : NaN;
  }

  /**
   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }

  /**
   * Returns a BSON serializable equivalent to this DateTime.
   * @return {Date}
   */
  toBSON() {
    return this.toJSDate();
  }

  /**
   * Returns a JavaScript object with this DateTime's year, month, day, and so on.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
   * @return {Object}
   */
  toObject(opts = {}) {
    if (!this.isValid) return {};
    const base = {
      ...this.c
    };
    if (opts.includeConfig) {
      base.outputCalendar = this.outputCalendar;
      base.numberingSystem = this.loc.numberingSystem;
      base.locale = this.loc.locale;
    }
    return base;
  }

  /**
   * Returns a JavaScript Date equivalent to this DateTime.
   * @return {Date}
   */
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }

  // COMPARE

  /**
   * Return the difference between two DateTimes as a Duration.
   * @param {DateTime} otherDateTime - the DateTime to compare this one to
   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example
   * var i1 = DateTime.fromISO('1982-05-25T09:45'),
   *     i2 = DateTime.fromISO('1983-10-14T10:30');
   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
   * @return {Duration}
   */
  diff(otherDateTime, unit = "milliseconds", opts = {}) {
    if (!this.isValid || !otherDateTime.isValid) {
      return Duration.invalid("created by diffing an invalid DateTime");
    }
    const durOpts = {
      locale: this.locale,
      numberingSystem: this.numberingSystem,
      ...opts
    };
    const units = maybeArray(unit).map(Duration.normalizeUnit),
      otherIsLater = otherDateTime.valueOf() > this.valueOf(),
      earlier = otherIsLater ? this : otherDateTime,
      later = otherIsLater ? otherDateTime : this,
      diffed = diff(earlier, later, units, durOpts);
    return otherIsLater ? diffed.negate() : diffed;
  }

  /**
   * Return the difference between this DateTime and right now.
   * See {@link DateTime#diff}
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  diffNow(unit = "milliseconds", opts = {}) {
    return this.diff(DateTime.now(), unit, opts);
  }

  /**
   * Return an Interval spanning between this DateTime and another DateTime
   * @param {DateTime} otherDateTime - the other end point of the Interval
   * @return {Interval}
   */
  until(otherDateTime) {
    return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
  }

  /**
   * Return whether this DateTime is in the same unit of time as another DateTime.
   * Higher-order units must also be identical for this function to return `true`.
   * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
   * @param {DateTime} otherDateTime - the other DateTime
   * @param {string} unit - the unit of time to check sameness on
   * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
   * @return {boolean}
   */
  hasSame(otherDateTime, unit) {
    if (!this.isValid) return false;
    const inputMs = otherDateTime.valueOf();
    const adjustedToZone = this.setZone(otherDateTime.zone, {
      keepLocalTime: true
    });
    return adjustedToZone.startOf(unit) <= inputMs && inputMs <= adjustedToZone.endOf(unit);
  }

  /**
   * Equality check
   * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
   * To compare just the millisecond values, use `+dt1 === +dt2`.
   * @param {DateTime} other - the other DateTime
   * @return {boolean}
   */
  equals(other) {
    return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
  }

  /**
   * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
   * platform supports Intl.RelativeTimeFormat. Rounds down by default.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
   * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
   * @param {boolean} [options.round=true] - whether to round the numbers in the output.
   * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
   * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 día"
   * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
   * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
   * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
   * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
   */
  toRelative(options = {}) {
    if (!this.isValid) return null;
    const base = options.base || DateTime.fromObject({}, {
        zone: this.zone
      }),
      padding = options.padding ? this < base ? -options.padding : options.padding : 0;
    let units = ["years", "months", "days", "hours", "minutes", "seconds"];
    let unit = options.unit;
    if (Array.isArray(options.unit)) {
      units = options.unit;
      unit = undefined;
    }
    return diffRelative(base, this.plus(padding), {
      ...options,
      numeric: "always",
      units,
      unit
    });
  }

  /**
   * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
   * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""mañana"
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
   * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
   */
  toRelativeCalendar(options = {}) {
    if (!this.isValid) return null;
    return diffRelative(options.base || DateTime.fromObject({}, {
      zone: this.zone
    }), this, {
      ...options,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: true
    });
  }

  /**
   * Return the min of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
   * @return {DateTime} the min DateTime, or undefined if called with no argument
   */
  static min(...dateTimes) {
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("min requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, i => i.valueOf(), Math.min);
  }

  /**
   * Return the max of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
   * @return {DateTime} the max DateTime, or undefined if called with no argument
   */
  static max(...dateTimes) {
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("max requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, i => i.valueOf(), Math.max);
  }

  // MISC

  /**
   * Explain how a string would be parsed by fromFormat()
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see description)
   * @param {Object} options - options taken by fromFormat()
   * @return {Object}
   */
  static fromFormatExplain(text, fmt, options = {}) {
    const {
        locale = null,
        numberingSystem = null
      } = options,
      localeToUse = Locale.fromOpts({
        locale,
        numberingSystem,
        defaultToEN: true
      });
    return explainFromTokens(localeToUse, text, fmt);
  }

  /**
   * @deprecated use fromFormatExplain instead
   */
  static fromStringExplain(text, fmt, options = {}) {
    return DateTime.fromFormatExplain(text, fmt, options);
  }

  // FORMAT PRESETS

  /**
   * {@link DateTime#toLocaleString} format like 10/14/1983
   * @type {Object}
   */
  static get DATE_SHORT() {
    return DATE_SHORT;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED() {
    return DATE_MED;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED_WITH_WEEKDAY() {
    return DATE_MED_WITH_WEEKDAY;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983'
   * @type {Object}
   */
  static get DATE_FULL() {
    return DATE_FULL;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
   * @type {Object}
   */
  static get DATE_HUGE() {
    return DATE_HUGE;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_SIMPLE() {
    return TIME_SIMPLE;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SECONDS() {
    return TIME_WITH_SECONDS;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SHORT_OFFSET() {
    return TIME_WITH_SHORT_OFFSET;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_LONG_OFFSET() {
    return TIME_WITH_LONG_OFFSET;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_SIMPLE() {
    return TIME_24_SIMPLE;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SECONDS() {
    return TIME_24_WITH_SECONDS;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SHORT_OFFSET() {
    return TIME_24_WITH_SHORT_OFFSET;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_LONG_OFFSET() {
    return TIME_24_WITH_LONG_OFFSET;
  }

  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT() {
    return DATETIME_SHORT;
  }

  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT_WITH_SECONDS() {
    return DATETIME_SHORT_WITH_SECONDS;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED() {
    return DATETIME_MED;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_SECONDS() {
    return DATETIME_MED_WITH_SECONDS;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_WEEKDAY() {
    return DATETIME_MED_WITH_WEEKDAY;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL() {
    return DATETIME_FULL;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL_WITH_SECONDS() {
    return DATETIME_FULL_WITH_SECONDS;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE() {
    return DATETIME_HUGE;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE_WITH_SECONDS() {
    return DATETIME_HUGE_WITH_SECONDS;
  }
}

/**
 * @private
 */
function friendlyDateTime(dateTimeish) {
  if (DateTime.isDateTime(dateTimeish)) {
    return dateTimeish;
  } else if (dateTimeish && dateTimeish.valueOf && isNumber(dateTimeish.valueOf())) {
    return DateTime.fromJSDate(dateTimeish);
  } else if (dateTimeish && typeof dateTimeish === "object") {
    return DateTime.fromObject(dateTimeish);
  } else {
    throw new InvalidArgumentError(`Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`);
  }
}
const VERSION = "3.2.1";
exports.DateTime = DateTime;
exports.Duration = Duration;
exports.FixedOffsetZone = FixedOffsetZone;
exports.IANAZone = IANAZone;
exports.Info = Info;
exports.Interval = Interval;
exports.InvalidZone = InvalidZone;
exports.Settings = Settings;
exports.SystemZone = SystemZone;
exports.VERSION = VERSION;
exports.Zone = Zone;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJMdXhvbkVycm9yIiwiRXJyb3IiLCJJbnZhbGlkRGF0ZVRpbWVFcnJvciIsImNvbnN0cnVjdG9yIiwicmVhc29uIiwidG9NZXNzYWdlIiwiSW52YWxpZEludGVydmFsRXJyb3IiLCJJbnZhbGlkRHVyYXRpb25FcnJvciIsIkNvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yIiwiSW52YWxpZFVuaXRFcnJvciIsInVuaXQiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsIlpvbmVJc0Fic3RyYWN0RXJyb3IiLCJuIiwicyIsImwiLCJEQVRFX1NIT1JUIiwieWVhciIsIm1vbnRoIiwiZGF5IiwiREFURV9NRUQiLCJEQVRFX01FRF9XSVRIX1dFRUtEQVkiLCJ3ZWVrZGF5IiwiREFURV9GVUxMIiwiREFURV9IVUdFIiwiVElNRV9TSU1QTEUiLCJob3VyIiwibWludXRlIiwiVElNRV9XSVRIX1NFQ09ORFMiLCJzZWNvbmQiLCJUSU1FX1dJVEhfU0hPUlRfT0ZGU0VUIiwidGltZVpvbmVOYW1lIiwiVElNRV9XSVRIX0xPTkdfT0ZGU0VUIiwiVElNRV8yNF9TSU1QTEUiLCJob3VyQ3ljbGUiLCJUSU1FXzI0X1dJVEhfU0VDT05EUyIsIlRJTUVfMjRfV0lUSF9TSE9SVF9PRkZTRVQiLCJUSU1FXzI0X1dJVEhfTE9OR19PRkZTRVQiLCJEQVRFVElNRV9TSE9SVCIsIkRBVEVUSU1FX1NIT1JUX1dJVEhfU0VDT05EUyIsIkRBVEVUSU1FX01FRCIsIkRBVEVUSU1FX01FRF9XSVRIX1NFQ09ORFMiLCJEQVRFVElNRV9NRURfV0lUSF9XRUVLREFZIiwiREFURVRJTUVfRlVMTCIsIkRBVEVUSU1FX0ZVTExfV0lUSF9TRUNPTkRTIiwiREFURVRJTUVfSFVHRSIsIkRBVEVUSU1FX0hVR0VfV0lUSF9TRUNPTkRTIiwiWm9uZSIsInR5cGUiLCJuYW1lIiwiaWFuYU5hbWUiLCJpc1VuaXZlcnNhbCIsIm9mZnNldE5hbWUiLCJ0cyIsIm9wdHMiLCJmb3JtYXRPZmZzZXQiLCJmb3JtYXQiLCJvZmZzZXQiLCJlcXVhbHMiLCJvdGhlclpvbmUiLCJpc1ZhbGlkIiwic2luZ2xldG9uJDEiLCJTeXN0ZW1ab25lIiwiaW5zdGFuY2UiLCJJbnRsIiwiRGF0ZVRpbWVGb3JtYXQiLCJyZXNvbHZlZE9wdGlvbnMiLCJ0aW1lWm9uZSIsImxvY2FsZSIsInBhcnNlWm9uZUluZm8iLCJEYXRlIiwiZ2V0VGltZXpvbmVPZmZzZXQiLCJkdGZDYWNoZSIsIm1ha2VEVEYiLCJ6b25lIiwiaG91cjEyIiwiZXJhIiwidHlwZVRvUG9zIiwiaGFja3lPZmZzZXQiLCJkdGYiLCJkYXRlIiwiZm9ybWF0dGVkIiwicmVwbGFjZSIsInBhcnNlZCIsImV4ZWMiLCJmTW9udGgiLCJmRGF5IiwiZlllYXIiLCJmYWRPckJjIiwiZkhvdXIiLCJmTWludXRlIiwiZlNlY29uZCIsInBhcnRzT2Zmc2V0IiwiZm9ybWF0VG9QYXJ0cyIsImZpbGxlZCIsImkiLCJsZW5ndGgiLCJ2YWx1ZSIsInBvcyIsImlzVW5kZWZpbmVkIiwicGFyc2VJbnQiLCJpYW5hWm9uZUNhY2hlIiwiSUFOQVpvbmUiLCJjcmVhdGUiLCJyZXNldENhY2hlIiwiaXNWYWxpZFNwZWNpZmllciIsImlzVmFsaWRab25lIiwiZSIsInpvbmVOYW1lIiwidmFsaWQiLCJpc05hTiIsIk5hTiIsImFkT3JCYyIsIk1hdGgiLCJhYnMiLCJhZGp1c3RlZEhvdXIiLCJhc1VUQyIsIm9ialRvTG9jYWxUUyIsIm1pbGxpc2Vjb25kIiwiYXNUUyIsIm92ZXIiLCJpbnRsTEZDYWNoZSIsImdldENhY2hlZExGIiwibG9jU3RyaW5nIiwia2V5IiwiSlNPTiIsInN0cmluZ2lmeSIsIkxpc3RGb3JtYXQiLCJpbnRsRFRDYWNoZSIsImdldENhY2hlZERURiIsImludGxOdW1DYWNoZSIsImdldENhY2hlZElORiIsImluZiIsIk51bWJlckZvcm1hdCIsImludGxSZWxDYWNoZSIsImdldENhY2hlZFJURiIsImJhc2UiLCJjYWNoZUtleU9wdHMiLCJSZWxhdGl2ZVRpbWVGb3JtYXQiLCJzeXNMb2NhbGVDYWNoZSIsInN5c3RlbUxvY2FsZSIsInBhcnNlTG9jYWxlU3RyaW5nIiwibG9jYWxlU3RyIiwieEluZGV4IiwiaW5kZXhPZiIsInN1YnN0cmluZyIsInVJbmRleCIsIm9wdGlvbnMiLCJzZWxlY3RlZFN0ciIsInNtYWxsZXIiLCJudW1iZXJpbmdTeXN0ZW0iLCJjYWxlbmRhciIsImludGxDb25maWdTdHJpbmciLCJvdXRwdXRDYWxlbmRhciIsImluY2x1ZGVzIiwibWFwTW9udGhzIiwiZiIsIm1zIiwiZHQiLCJEYXRlVGltZSIsInV0YyIsInB1c2giLCJtYXBXZWVrZGF5cyIsImxpc3RTdHVmZiIsImxvYyIsImRlZmF1bHRPSyIsImVuZ2xpc2hGbiIsImludGxGbiIsIm1vZGUiLCJsaXN0aW5nTW9kZSIsInN1cHBvcnRzRmFzdE51bWJlcnMiLCJzdGFydHNXaXRoIiwiaW50bCIsIlBvbHlOdW1iZXJGb3JtYXR0ZXIiLCJmb3JjZVNpbXBsZSIsInBhZFRvIiwiZmxvb3IiLCJvdGhlck9wdHMiLCJPYmplY3QiLCJrZXlzIiwiaW50bE9wdHMiLCJ1c2VHcm91cGluZyIsIm1pbmltdW1JbnRlZ2VyRGlnaXRzIiwiZml4ZWQiLCJyb3VuZFRvIiwicGFkU3RhcnQiLCJQb2x5RGF0ZUZvcm1hdHRlciIsInoiLCJ1bmRlZmluZWQiLCJnbXRPZmZzZXQiLCJvZmZzZXRaIiwiZnJvbU1pbGxpcyIsInRvSlNEYXRlIiwiUG9seVJlbEZvcm1hdHRlciIsImlzRW5nbGlzaCIsInN0eWxlIiwiaGFzUmVsYXRpdmUiLCJydGYiLCJjb3VudCIsImZvcm1hdFJlbGF0aXZlVGltZSIsIm51bWVyaWMiLCJMb2NhbGUiLCJmcm9tT3B0cyIsImRlZmF1bHRUb0VOIiwic3BlY2lmaWVkTG9jYWxlIiwiU2V0dGluZ3MiLCJkZWZhdWx0TG9jYWxlIiwibG9jYWxlUiIsIm51bWJlcmluZ1N5c3RlbVIiLCJkZWZhdWx0TnVtYmVyaW5nU3lzdGVtIiwib3V0cHV0Q2FsZW5kYXJSIiwiZGVmYXVsdE91dHB1dENhbGVuZGFyIiwiZnJvbU9iamVjdCIsIm51bWJlcmluZyIsInBhcnNlZExvY2FsZSIsInBhcnNlZE51bWJlcmluZ1N5c3RlbSIsInBhcnNlZE91dHB1dENhbGVuZGFyIiwid2Vla2RheXNDYWNoZSIsInN0YW5kYWxvbmUiLCJtb250aHNDYWNoZSIsIm1lcmlkaWVtQ2FjaGUiLCJlcmFDYWNoZSIsImZhc3ROdW1iZXJzQ2FjaGVkIiwiZmFzdE51bWJlcnMiLCJpc0FjdHVhbGx5RW4iLCJoYXNOb1dlaXJkbmVzcyIsImNsb25lIiwiYWx0cyIsImdldE93blByb3BlcnR5TmFtZXMiLCJyZWRlZmF1bHRUb0VOIiwicmVkZWZhdWx0VG9TeXN0ZW0iLCJtb250aHMiLCJmb3JtYXRTdHIiLCJleHRyYWN0Iiwid2Vla2RheXMiLCJtZXJpZGllbXMiLCJtYXAiLCJlcmFzIiwiZmllbGQiLCJkZiIsImR0Rm9ybWF0dGVyIiwicmVzdWx0cyIsIm1hdGNoaW5nIiwiZmluZCIsIm0iLCJ0b0xvd2VyQ2FzZSIsIm51bWJlckZvcm1hdHRlciIsInJlbEZvcm1hdHRlciIsImxpc3RGb3JtYXR0ZXIiLCJvdGhlciIsInNpbmdsZXRvbiIsIkZpeGVkT2Zmc2V0Wm9uZSIsInV0Y0luc3RhbmNlIiwicGFyc2VTcGVjaWZpZXIiLCJyIiwibWF0Y2giLCJzaWduZWRPZmZzZXQiLCJJbnZhbGlkWm9uZSIsIm5vcm1hbGl6ZVpvbmUiLCJpbnB1dCIsImRlZmF1bHRab25lIiwiaXNTdHJpbmciLCJsb3dlcmVkIiwiaXNOdW1iZXIiLCJub3ciLCJ0d29EaWdpdEN1dG9mZlllYXIiLCJ0aHJvd09uSW52YWxpZCIsImN1dG9mZlllYXIiLCJ0IiwicmVzZXRDYWNoZXMiLCJvIiwiaXNJbnRlZ2VyIiwiaXNEYXRlIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwibWF5YmVBcnJheSIsInRoaW5nIiwiQXJyYXkiLCJpc0FycmF5IiwiYmVzdEJ5IiwiYXJyIiwiYnkiLCJjb21wYXJlIiwicmVkdWNlIiwiYmVzdCIsIm5leHQiLCJwYWlyIiwicGljayIsIm9iaiIsImEiLCJrIiwiaGFzT3duUHJvcGVydHkiLCJwcm9wIiwiaW50ZWdlckJldHdlZW4iLCJib3R0b20iLCJ0b3AiLCJmbG9vck1vZCIsIngiLCJpc05lZyIsInBhZGRlZCIsInBhcnNlSW50ZWdlciIsInN0cmluZyIsInBhcnNlRmxvYXRpbmciLCJwYXJzZUZsb2F0IiwicGFyc2VNaWxsaXMiLCJmcmFjdGlvbiIsIm51bWJlciIsImRpZ2l0cyIsInRvd2FyZFplcm8iLCJmYWN0b3IiLCJyb3VuZGVyIiwidHJ1bmMiLCJyb3VuZCIsImlzTGVhcFllYXIiLCJkYXlzSW5ZZWFyIiwiZGF5c0luTW9udGgiLCJtb2RNb250aCIsIm1vZFllYXIiLCJkIiwiVVRDIiwic2V0VVRDRnVsbFllYXIiLCJnZXRVVENGdWxsWWVhciIsIndlZWtzSW5XZWVrWWVhciIsIndlZWtZZWFyIiwicDEiLCJsYXN0IiwicDIiLCJ1bnRydW5jYXRlWWVhciIsIm9mZnNldEZvcm1hdCIsIm1vZGlmaWVkIiwib2ZmSG91clN0ciIsIm9mZk1pbnV0ZVN0ciIsIm9mZkhvdXIiLCJOdW1iZXIiLCJvZmZNaW4iLCJvZmZNaW5TaWduZWQiLCJpcyIsImFzTnVtYmVyIiwibnVtZXJpY1ZhbHVlIiwibm9ybWFsaXplT2JqZWN0Iiwibm9ybWFsaXplciIsIm5vcm1hbGl6ZWQiLCJ1IiwidiIsImhvdXJzIiwibWludXRlcyIsInNpZ24iLCJSYW5nZUVycm9yIiwidGltZU9iamVjdCIsIm1vbnRoc0xvbmciLCJtb250aHNTaG9ydCIsIm1vbnRoc05hcnJvdyIsIndlZWtkYXlzTG9uZyIsIndlZWtkYXlzU2hvcnQiLCJ3ZWVrZGF5c05hcnJvdyIsImVyYXNMb25nIiwiZXJhc1Nob3J0IiwiZXJhc05hcnJvdyIsIm1lcmlkaWVtRm9yRGF0ZVRpbWUiLCJ3ZWVrZGF5Rm9yRGF0ZVRpbWUiLCJtb250aEZvckRhdGVUaW1lIiwiZXJhRm9yRGF0ZVRpbWUiLCJuYXJyb3ciLCJ1bml0cyIsInllYXJzIiwicXVhcnRlcnMiLCJ3ZWVrcyIsImRheXMiLCJzZWNvbmRzIiwibGFzdGFibGUiLCJpc0RheSIsImlzSW5QYXN0IiwiZm10VmFsdWUiLCJzaW5ndWxhciIsImxpbFVuaXRzIiwiZm10VW5pdCIsInN0cmluZ2lmeVRva2VucyIsInNwbGl0cyIsInRva2VuVG9TdHJpbmciLCJ0b2tlbiIsImxpdGVyYWwiLCJ2YWwiLCJtYWNyb1Rva2VuVG9Gb3JtYXRPcHRzIiwiRCIsIkREIiwiREREIiwiRERERCIsInR0IiwidHR0IiwidHR0dCIsIlQiLCJUVCIsIlRUVCIsIlRUVFQiLCJmZiIsImZmZiIsImZmZmYiLCJGIiwiRkYiLCJGRkYiLCJGRkZGIiwiRm9ybWF0dGVyIiwicGFyc2VGb3JtYXQiLCJmbXQiLCJjdXJyZW50IiwiY3VycmVudEZ1bGwiLCJicmFja2V0ZWQiLCJjIiwiY2hhckF0IiwiZm9ybWF0T3B0cyIsInN5c3RlbUxvYyIsImZvcm1hdFdpdGhTeXN0ZW1EZWZhdWx0IiwiZm9ybWF0RGF0ZVRpbWUiLCJmb3JtYXREYXRlVGltZVBhcnRzIiwiZm9ybWF0SW50ZXJ2YWwiLCJpbnRlcnZhbCIsInN0YXJ0IiwiZm9ybWF0UmFuZ2UiLCJlbmQiLCJudW0iLCJwIiwiZm9ybWF0RGF0ZVRpbWVGcm9tU3RyaW5nIiwia25vd25FbmdsaXNoIiwidXNlRGF0ZVRpbWVGb3JtYXR0ZXIiLCJpc09mZnNldEZpeGVkIiwiYWxsb3daIiwibWVyaWRpZW0iLCJtYXliZU1hY3JvIiwic2xpY2UiLCJ3ZWVrTnVtYmVyIiwib3JkaW5hbCIsInF1YXJ0ZXIiLCJmb3JtYXREdXJhdGlvbkZyb21TdHJpbmciLCJkdXIiLCJ0b2tlblRvRmllbGQiLCJsaWxkdXIiLCJtYXBwZWQiLCJnZXQiLCJ0b2tlbnMiLCJyZWFsVG9rZW5zIiwiZm91bmQiLCJjb25jYXQiLCJjb2xsYXBzZWQiLCJzaGlmdFRvIiwiZmlsdGVyIiwiSW52YWxpZCIsImV4cGxhbmF0aW9uIiwiaWFuYVJlZ2V4IiwiY29tYmluZVJlZ2V4ZXMiLCJyZWdleGVzIiwiZnVsbCIsInNvdXJjZSIsIlJlZ0V4cCIsImNvbWJpbmVFeHRyYWN0b3JzIiwiZXh0cmFjdG9ycyIsIm1lcmdlZFZhbHMiLCJtZXJnZWRab25lIiwiY3Vyc29yIiwiZXgiLCJwYXJzZSIsInBhdHRlcm5zIiwicmVnZXgiLCJleHRyYWN0b3IiLCJzaW1wbGVQYXJzZSIsInJldCIsIm9mZnNldFJlZ2V4IiwiaXNvRXh0ZW5kZWRab25lIiwiaXNvVGltZUJhc2VSZWdleCIsImlzb1RpbWVSZWdleCIsImlzb1RpbWVFeHRlbnNpb25SZWdleCIsImlzb1ltZFJlZ2V4IiwiaXNvV2Vla1JlZ2V4IiwiaXNvT3JkaW5hbFJlZ2V4IiwiZXh0cmFjdElTT1dlZWtEYXRhIiwiZXh0cmFjdElTT09yZGluYWxEYXRhIiwic3FsWW1kUmVnZXgiLCJzcWxUaW1lUmVnZXgiLCJzcWxUaW1lRXh0ZW5zaW9uUmVnZXgiLCJpbnQiLCJmYWxsYmFjayIsImV4dHJhY3RJU09ZbWQiLCJpdGVtIiwiZXh0cmFjdElTT1RpbWUiLCJtaWxsaXNlY29uZHMiLCJleHRyYWN0SVNPT2Zmc2V0IiwibG9jYWwiLCJmdWxsT2Zmc2V0IiwiZXh0cmFjdElBTkFab25lIiwiaXNvVGltZU9ubHkiLCJpc29EdXJhdGlvbiIsImV4dHJhY3RJU09EdXJhdGlvbiIsInllYXJTdHIiLCJtb250aFN0ciIsIndlZWtTdHIiLCJkYXlTdHIiLCJob3VyU3RyIiwibWludXRlU3RyIiwic2Vjb25kU3RyIiwibWlsbGlzZWNvbmRzU3RyIiwiaGFzTmVnYXRpdmVQcmVmaXgiLCJuZWdhdGl2ZVNlY29uZHMiLCJtYXliZU5lZ2F0ZSIsImZvcmNlIiwib2JzT2Zmc2V0cyIsIkdNVCIsIkVEVCIsIkVTVCIsIkNEVCIsIkNTVCIsIk1EVCIsIk1TVCIsIlBEVCIsIlBTVCIsImZyb21TdHJpbmdzIiwid2Vla2RheVN0ciIsInJlc3VsdCIsInJmYzI4MjIiLCJleHRyYWN0UkZDMjgyMiIsIm9ic09mZnNldCIsIm1pbE9mZnNldCIsInByZXByb2Nlc3NSRkMyODIyIiwidHJpbSIsInJmYzExMjMiLCJyZmM4NTAiLCJhc2NpaSIsImV4dHJhY3RSRkMxMTIzT3I4NTAiLCJleHRyYWN0QVNDSUkiLCJpc29ZbWRXaXRoVGltZUV4dGVuc2lvblJlZ2V4IiwiaXNvV2Vla1dpdGhUaW1lRXh0ZW5zaW9uUmVnZXgiLCJpc29PcmRpbmFsV2l0aFRpbWVFeHRlbnNpb25SZWdleCIsImlzb1RpbWVDb21iaW5lZFJlZ2V4IiwiZXh0cmFjdElTT1ltZFRpbWVBbmRPZmZzZXQiLCJleHRyYWN0SVNPV2Vla1RpbWVBbmRPZmZzZXQiLCJleHRyYWN0SVNPT3JkaW5hbERhdGVBbmRUaW1lIiwiZXh0cmFjdElTT1RpbWVBbmRPZmZzZXQiLCJwYXJzZUlTT0RhdGUiLCJwYXJzZVJGQzI4MjJEYXRlIiwicGFyc2VIVFRQRGF0ZSIsInBhcnNlSVNPRHVyYXRpb24iLCJleHRyYWN0SVNPVGltZU9ubHkiLCJwYXJzZUlTT1RpbWVPbmx5Iiwic3FsWW1kV2l0aFRpbWVFeHRlbnNpb25SZWdleCIsInNxbFRpbWVDb21iaW5lZFJlZ2V4IiwiZXh0cmFjdElTT1RpbWVPZmZzZXRBbmRJQU5BWm9uZSIsInBhcnNlU1FMIiwiSU5WQUxJRCQyIiwibG93T3JkZXJNYXRyaXgiLCJjYXN1YWxNYXRyaXgiLCJkYXlzSW5ZZWFyQWNjdXJhdGUiLCJkYXlzSW5Nb250aEFjY3VyYXRlIiwiYWNjdXJhdGVNYXRyaXgiLCJvcmRlcmVkVW5pdHMkMSIsInJldmVyc2VVbml0cyIsInJldmVyc2UiLCJjbG9uZSQxIiwiY2xlYXIiLCJjb25mIiwidmFsdWVzIiwiY29udmVyc2lvbkFjY3VyYWN5IiwibWF0cml4IiwiRHVyYXRpb24iLCJhbnRpVHJ1bmMiLCJjZWlsIiwiY29udmVydCIsImZyb21NYXAiLCJmcm9tVW5pdCIsInRvTWFwIiwidG9Vbml0IiwiY29udiIsInJhdyIsInNhbWVTaWduIiwiYWRkZWQiLCJub3JtYWxpemVWYWx1ZXMiLCJ2YWxzIiwicHJldmlvdXMiLCJyZW1vdmVaZXJvZXMiLCJuZXdWYWxzIiwiZW50cmllcyIsImNvbmZpZyIsImFjY3VyYXRlIiwiaW52YWxpZCIsImlzTHV4b25EdXJhdGlvbiIsIm5vcm1hbGl6ZVVuaXQiLCJmcm9tRHVyYXRpb25MaWtlIiwiZHVyYXRpb25MaWtlIiwiaXNEdXJhdGlvbiIsImZyb21JU08iLCJ0ZXh0IiwiZnJvbUlTT1RpbWUiLCJ3ZWVrIiwidG9Gb3JtYXQiLCJmbXRPcHRzIiwidG9IdW1hbiIsInVuaXREaXNwbGF5IiwibGlzdFN0eWxlIiwidG9PYmplY3QiLCJ0b0lTTyIsInRvSVNPVGltZSIsIm1pbGxpcyIsInRvTWlsbGlzIiwic3VwcHJlc3NNaWxsaXNlY29uZHMiLCJzdXBwcmVzc1NlY29uZHMiLCJpbmNsdWRlUHJlZml4Iiwic3RyIiwidG9KU09OIiwiYXMiLCJ2YWx1ZU9mIiwicGx1cyIsImR1cmF0aW9uIiwibWludXMiLCJuZWdhdGUiLCJtYXBVbml0cyIsImZuIiwic2V0IiwibWl4ZWQiLCJyZWNvbmZpZ3VyZSIsIm5vcm1hbGl6ZSIsInJlc2NhbGUiLCJzaGlmdFRvQWxsIiwiYnVpbHQiLCJhY2N1bXVsYXRlZCIsImxhc3RVbml0Iiwib3duIiwiYWsiLCJkb3duIiwibmVnYXRlZCIsImludmFsaWRSZWFzb24iLCJpbnZhbGlkRXhwbGFuYXRpb24iLCJlcSIsInYxIiwidjIiLCJJTlZBTElEJDEiLCJ2YWxpZGF0ZVN0YXJ0RW5kIiwiSW50ZXJ2YWwiLCJpc0x1eG9uSW50ZXJ2YWwiLCJmcm9tRGF0ZVRpbWVzIiwiYnVpbHRTdGFydCIsImZyaWVuZGx5RGF0ZVRpbWUiLCJidWlsdEVuZCIsInZhbGlkYXRlRXJyb3IiLCJhZnRlciIsImJlZm9yZSIsInNwbGl0Iiwic3RhcnRJc1ZhbGlkIiwiZW5kSXNWYWxpZCIsImlzSW50ZXJ2YWwiLCJ0b0R1cmF0aW9uIiwic3RhcnRPZiIsImRpZmYiLCJoYXNTYW1lIiwiaXNFbXB0eSIsImlzQWZ0ZXIiLCJkYXRlVGltZSIsImlzQmVmb3JlIiwiY29udGFpbnMiLCJzcGxpdEF0IiwiZGF0ZVRpbWVzIiwic29ydGVkIiwic29ydCIsInNwbGl0QnkiLCJpZHgiLCJkaXZpZGVFcXVhbGx5IiwibnVtYmVyT2ZQYXJ0cyIsIm92ZXJsYXBzIiwiYWJ1dHNTdGFydCIsImFidXRzRW5kIiwiZW5ndWxmcyIsImludGVyc2VjdGlvbiIsInVuaW9uIiwibWVyZ2UiLCJpbnRlcnZhbHMiLCJmaW5hbCIsImIiLCJzb2ZhciIsInhvciIsImN1cnJlbnRDb3VudCIsImVuZHMiLCJ0aW1lIiwiZmxhdHRlbmVkIiwiZGlmZmVyZW5jZSIsInRvTG9jYWxlU3RyaW5nIiwidG9JU09EYXRlIiwiZGF0ZUZvcm1hdCIsInNlcGFyYXRvciIsIm1hcEVuZHBvaW50cyIsIm1hcEZuIiwiSW5mbyIsImhhc0RTVCIsInByb3RvIiwic2V0Wm9uZSIsImlzVmFsaWRJQU5BWm9uZSIsImxvY09iaiIsIm1vbnRoc0Zvcm1hdCIsIndlZWtkYXlzRm9ybWF0IiwiZmVhdHVyZXMiLCJyZWxhdGl2ZSIsImRheURpZmYiLCJlYXJsaWVyIiwibGF0ZXIiLCJ1dGNEYXlTdGFydCIsInRvVVRDIiwia2VlcExvY2FsVGltZSIsImhpZ2hPcmRlckRpZmZzIiwiZGlmZmVycyIsImxvd2VzdE9yZGVyIiwiaGlnaFdhdGVyIiwiZGlmZmVyIiwicmVtYWluaW5nTWlsbGlzIiwibG93ZXJPcmRlclVuaXRzIiwibnVtYmVyaW5nU3lzdGVtcyIsImFyYWIiLCJhcmFiZXh0IiwiYmFsaSIsImJlbmciLCJkZXZhIiwiZnVsbHdpZGUiLCJndWpyIiwiaGFuaWRlYyIsImtobXIiLCJrbmRhIiwibGFvbyIsImxpbWIiLCJtbHltIiwibW9uZyIsIm15bXIiLCJvcnlhIiwidGFtbGRlYyIsInRlbHUiLCJ0aGFpIiwidGlidCIsImxhdG4iLCJudW1iZXJpbmdTeXN0ZW1zVVRGMTYiLCJoYW5pZGVjQ2hhcnMiLCJwYXJzZURpZ2l0cyIsImNvZGUiLCJjaGFyQ29kZUF0Iiwic2VhcmNoIiwibWluIiwibWF4IiwiZGlnaXRSZWdleCIsImFwcGVuZCIsIk1JU1NJTkdfRlRQIiwiaW50VW5pdCIsInBvc3QiLCJkZXNlciIsIk5CU1AiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJzcGFjZU9yTkJTUCIsInNwYWNlT3JOQlNQUmVnRXhwIiwiZml4TGlzdFJlZ2V4Iiwic3RyaXBJbnNlbnNpdGl2aXRpZXMiLCJvbmVPZiIsInN0cmluZ3MiLCJzdGFydEluZGV4Iiwiam9pbiIsImZpbmRJbmRleCIsImdyb3VwcyIsImgiLCJzaW1wbGUiLCJlc2NhcGVUb2tlbiIsInVuaXRGb3JUb2tlbiIsIm9uZSIsInR3byIsInRocmVlIiwiZm91ciIsInNpeCIsIm9uZU9yVHdvIiwib25lVG9UaHJlZSIsIm9uZVRvU2l4Iiwib25lVG9OaW5lIiwidHdvVG9Gb3VyIiwiZm91clRvU2l4IiwidW5pdGF0ZSIsInBhcnRUeXBlU3R5bGVUb1Rva2VuVmFsIiwic2hvcnQiLCJsb25nIiwiZGF5cGVyaW9kIiwiZGF5UGVyaW9kIiwidG9rZW5Gb3JQYXJ0IiwicGFydCIsImJ1aWxkUmVnZXgiLCJyZSIsImhhbmRsZXJzIiwibWF0Y2hlcyIsImFsbCIsIm1hdGNoSW5kZXgiLCJkYXRlVGltZUZyb21NYXRjaGVzIiwidG9GaWVsZCIsInNwZWNpZmljT2Zmc2V0IiwiWiIsInEiLCJNIiwiRyIsInkiLCJTIiwiZHVtbXlEYXRlVGltZUNhY2hlIiwiZ2V0RHVtbXlEYXRlVGltZSIsIm1heWJlRXhwYW5kTWFjcm9Ub2tlbiIsImZvcm1hdE9wdHNUb1Rva2VucyIsImV4cGFuZE1hY3JvVG9rZW5zIiwiZXhwbGFpbkZyb21Ub2tlbnMiLCJkaXNxdWFsaWZ5aW5nVW5pdCIsInJlZ2V4U3RyaW5nIiwicmF3TWF0Y2hlcyIsInBhcnNlRnJvbVRva2VucyIsImZvcm1hdHRlciIsInBhcnRzIiwibm9uTGVhcExhZGRlciIsImxlYXBMYWRkZXIiLCJ1bml0T3V0T2ZSYW5nZSIsImRheU9mV2VlayIsImpzIiwiZ2V0VVRDRGF5IiwiY29tcHV0ZU9yZGluYWwiLCJ1bmNvbXB1dGVPcmRpbmFsIiwidGFibGUiLCJtb250aDAiLCJncmVnb3JpYW5Ub1dlZWsiLCJncmVnT2JqIiwid2Vla1RvR3JlZ29yaWFuIiwid2Vla0RhdGEiLCJ3ZWVrZGF5T2ZKYW40IiwieWVhckluRGF5cyIsImdyZWdvcmlhblRvT3JkaW5hbCIsImdyZWdEYXRhIiwib3JkaW5hbFRvR3JlZ29yaWFuIiwib3JkaW5hbERhdGEiLCJoYXNJbnZhbGlkV2Vla0RhdGEiLCJ2YWxpZFllYXIiLCJ2YWxpZFdlZWsiLCJ2YWxpZFdlZWtkYXkiLCJoYXNJbnZhbGlkT3JkaW5hbERhdGEiLCJ2YWxpZE9yZGluYWwiLCJoYXNJbnZhbGlkR3JlZ29yaWFuRGF0YSIsInZhbGlkTW9udGgiLCJ2YWxpZERheSIsImhhc0ludmFsaWRUaW1lRGF0YSIsInZhbGlkSG91ciIsInZhbGlkTWludXRlIiwidmFsaWRTZWNvbmQiLCJ2YWxpZE1pbGxpc2Vjb25kIiwiSU5WQUxJRCIsIk1BWF9EQVRFIiwidW5zdXBwb3J0ZWRab25lIiwicG9zc2libHlDYWNoZWRXZWVrRGF0YSIsImluc3QiLCJvbGQiLCJmaXhPZmZzZXQiLCJsb2NhbFRTIiwidHoiLCJ1dGNHdWVzcyIsIm8yIiwibzMiLCJ0c1RvT2JqIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENEYXRlIiwiZ2V0VVRDSG91cnMiLCJnZXRVVENNaW51dGVzIiwiZ2V0VVRDU2Vjb25kcyIsImdldFVUQ01pbGxpc2Vjb25kcyIsIm9ialRvVFMiLCJhZGp1c3RUaW1lIiwib1ByZSIsIm1pbGxpc1RvQWRkIiwicGFyc2VEYXRhVG9EYXRlVGltZSIsInBhcnNlZFpvbmUiLCJpbnRlcnByZXRhdGlvblpvbmUiLCJ0b1RlY2hGb3JtYXQiLCJleHRlbmRlZCIsImxvbmdGb3JtYXQiLCJpbmNsdWRlT2Zmc2V0IiwiZXh0ZW5kZWRab25lIiwiZGVmYXVsdFVuaXRWYWx1ZXMiLCJkZWZhdWx0V2Vla1VuaXRWYWx1ZXMiLCJkZWZhdWx0T3JkaW5hbFVuaXRWYWx1ZXMiLCJvcmRlcmVkVW5pdHMiLCJvcmRlcmVkV2Vla1VuaXRzIiwib3JkZXJlZE9yZGluYWxVbml0cyIsIndlZWtudW1iZXIiLCJ3ZWVrc251bWJlciIsIndlZWtudW1iZXJzIiwid2Vla3llYXIiLCJ3ZWVreWVhcnMiLCJxdWlja0RUIiwidHNOb3ciLCJvZmZzZXRQcm92aXMiLCJkaWZmUmVsYXRpdmUiLCJjYWxlbmRhcnkiLCJsYXN0T3B0cyIsImFyZ0xpc3QiLCJhcmdzIiwiZnJvbSIsInVuY2hhbmdlZCIsIm90IiwiX3pvbmUiLCJpc0x1eG9uRGF0ZVRpbWUiLCJhcmd1bWVudHMiLCJmcm9tSlNEYXRlIiwiem9uZVRvVXNlIiwiZnJvbVNlY29uZHMiLCJjb250YWluc09yZGluYWwiLCJjb250YWluc0dyZWdvclllYXIiLCJjb250YWluc0dyZWdvck1EIiwiY29udGFpbnNHcmVnb3IiLCJkZWZpbml0ZVdlZWtEZWYiLCJ1c2VXZWVrRGF0YSIsImRlZmF1bHRWYWx1ZXMiLCJvYmpOb3ciLCJmb3VuZEZpcnN0IiwiaGlnaGVyT3JkZXJJbnZhbGlkIiwiZ3JlZ29yaWFuIiwidHNGaW5hbCIsIm9mZnNldEZpbmFsIiwiZnJvbVJGQzI4MjIiLCJmcm9tSFRUUCIsImZyb21Gb3JtYXQiLCJsb2NhbGVUb1VzZSIsImZyb21TdHJpbmciLCJmcm9tU1FMIiwiaXNEYXRlVGltZSIsInBhcnNlRm9ybWF0Rm9yT3B0cyIsImxvY2FsZU9wdHMiLCJ0b2tlbkxpc3QiLCJleHBhbmRGb3JtYXQiLCJleHBhbmRlZCIsIm1vbnRoU2hvcnQiLCJtb250aExvbmciLCJ3ZWVrZGF5U2hvcnQiLCJ3ZWVrZGF5TG9uZyIsIm9mZnNldE5hbWVTaG9ydCIsIm9mZnNldE5hbWVMb25nIiwiaXNJbkRTVCIsImlzSW5MZWFwWWVhciIsInJlc29sdmVkTG9jYWxlT3B0aW9ucyIsInRvTG9jYWwiLCJrZWVwQ2FsZW5kYXJUaW1lIiwibmV3VFMiLCJvZmZzZXRHdWVzcyIsImFzT2JqIiwic2V0TG9jYWxlIiwic2V0dGluZ1dlZWtTdHVmZiIsIm5vcm1hbGl6ZWRVbml0IiwiZW5kT2YiLCJ0b0xvY2FsZVBhcnRzIiwiZXh0IiwidG9JU09XZWVrRGF0ZSIsInRvUkZDMjgyMiIsInRvSFRUUCIsInRvU1FMRGF0ZSIsInRvU1FMVGltZSIsImluY2x1ZGVab25lIiwiaW5jbHVkZU9mZnNldFNwYWNlIiwidG9TUUwiLCJ0b1NlY29uZHMiLCJ0b1VuaXhJbnRlZ2VyIiwidG9CU09OIiwiaW5jbHVkZUNvbmZpZyIsIm90aGVyRGF0ZVRpbWUiLCJkdXJPcHRzIiwib3RoZXJJc0xhdGVyIiwiZGlmZmVkIiwiZGlmZk5vdyIsInVudGlsIiwiaW5wdXRNcyIsImFkanVzdGVkVG9ab25lIiwidG9SZWxhdGl2ZSIsInBhZGRpbmciLCJ0b1JlbGF0aXZlQ2FsZW5kYXIiLCJldmVyeSIsImZyb21Gb3JtYXRFeHBsYWluIiwiZnJvbVN0cmluZ0V4cGxhaW4iLCJkYXRlVGltZWlzaCIsIlZFUlNJT04iXSwic291cmNlcyI6WyIuLi8uLi9zcmMvZXJyb3JzLmpzIiwiLi4vLi4vc3JjL2ltcGwvZm9ybWF0cy5qcyIsIi4uLy4uL3NyYy96b25lLmpzIiwiLi4vLi4vc3JjL3pvbmVzL3N5c3RlbVpvbmUuanMiLCIuLi8uLi9zcmMvem9uZXMvSUFOQVpvbmUuanMiLCIuLi8uLi9zcmMvaW1wbC9sb2NhbGUuanMiLCIuLi8uLi9zcmMvem9uZXMvZml4ZWRPZmZzZXRab25lLmpzIiwiLi4vLi4vc3JjL3pvbmVzL2ludmFsaWRab25lLmpzIiwiLi4vLi4vc3JjL2ltcGwvem9uZVV0aWwuanMiLCIuLi8uLi9zcmMvc2V0dGluZ3MuanMiLCIuLi8uLi9zcmMvaW1wbC91dGlsLmpzIiwiLi4vLi4vc3JjL2ltcGwvZW5nbGlzaC5qcyIsIi4uLy4uL3NyYy9pbXBsL2Zvcm1hdHRlci5qcyIsIi4uLy4uL3NyYy9pbXBsL2ludmFsaWQuanMiLCIuLi8uLi9zcmMvaW1wbC9yZWdleFBhcnNlci5qcyIsIi4uLy4uL3NyYy9kdXJhdGlvbi5qcyIsIi4uLy4uL3NyYy9pbnRlcnZhbC5qcyIsIi4uLy4uL3NyYy9pbmZvLmpzIiwiLi4vLi4vc3JjL2ltcGwvZGlmZi5qcyIsIi4uLy4uL3NyYy9pbXBsL2RpZ2l0cy5qcyIsIi4uLy4uL3NyYy9pbXBsL3Rva2VuUGFyc2VyLmpzIiwiLi4vLi4vc3JjL2ltcGwvY29udmVyc2lvbnMuanMiLCIuLi8uLi9zcmMvZGF0ZXRpbWUuanMiLCIuLi8uLi9zcmMvbHV4b24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdGhlc2UgYXJlbid0IHJlYWxseSBwcml2YXRlLCBidXQgbm9yIGFyZSB0aGV5IHJlYWxseSB1c2VmdWwgdG8gZG9jdW1lbnRcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBMdXhvbkVycm9yIGV4dGVuZHMgRXJyb3Ige31cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZERhdGVUaW1lRXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHtcbiAgY29uc3RydWN0b3IocmVhc29uKSB7XG4gICAgc3VwZXIoYEludmFsaWQgRGF0ZVRpbWU6ICR7cmVhc29uLnRvTWVzc2FnZSgpfWApO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRJbnRlcnZhbEVycm9yIGV4dGVuZHMgTHV4b25FcnJvciB7XG4gIGNvbnN0cnVjdG9yKHJlYXNvbikge1xuICAgIHN1cGVyKGBJbnZhbGlkIEludGVydmFsOiAke3JlYXNvbi50b01lc3NhZ2UoKX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkRHVyYXRpb25FcnJvciBleHRlbmRzIEx1eG9uRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihyZWFzb24pIHtcbiAgICBzdXBlcihgSW52YWxpZCBEdXJhdGlvbjogJHtyZWFzb24udG9NZXNzYWdlKCl9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHt9XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRVbml0RXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHtcbiAgY29uc3RydWN0b3IodW5pdCkge1xuICAgIHN1cGVyKGBJbnZhbGlkIHVuaXQgJHt1bml0fWApO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRBcmd1bWVudEVycm9yIGV4dGVuZHMgTHV4b25FcnJvciB7fVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBab25lSXNBYnN0cmFjdEVycm9yIGV4dGVuZHMgTHV4b25FcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiWm9uZSBpcyBhbiBhYnN0cmFjdCBjbGFzc1wiKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmNvbnN0IG4gPSBcIm51bWVyaWNcIixcbiAgcyA9IFwic2hvcnRcIixcbiAgbCA9IFwibG9uZ1wiO1xuXG5leHBvcnQgY29uc3QgREFURV9TSE9SVCA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IG4sXG4gIGRheTogbixcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFX01FRCA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IHMsXG4gIGRheTogbixcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFX01FRF9XSVRIX1dFRUtEQVkgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBzLFxuICBkYXk6IG4sXG4gIHdlZWtkYXk6IHMsXG59O1xuXG5leHBvcnQgY29uc3QgREFURV9GVUxMID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbCxcbiAgZGF5OiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVfSFVHRSA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IGwsXG4gIGRheTogbixcbiAgd2Vla2RheTogbCxcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FX1NJTVBMRSA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfV0lUSF9TRUNPTkRTID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FX1dJVEhfU0hPUlRfT0ZGU0VUID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgdGltZVpvbmVOYW1lOiBzLFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfV0lUSF9MT05HX09GRlNFVCA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG4gIHRpbWVab25lTmFtZTogbCxcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FXzI0X1NJTVBMRSA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBob3VyQ3ljbGU6IFwiaDIzXCIsXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV8yNF9XSVRIX1NFQ09ORFMgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICBob3VyQ3ljbGU6IFwiaDIzXCIsXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV8yNF9XSVRIX1NIT1JUX09GRlNFVCA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG4gIGhvdXJDeWNsZTogXCJoMjNcIixcbiAgdGltZVpvbmVOYW1lOiBzLFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfMjRfV0lUSF9MT05HX09GRlNFVCA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG4gIGhvdXJDeWNsZTogXCJoMjNcIixcbiAgdGltZVpvbmVOYW1lOiBsLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX1NIT1JUID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbixcbiAgZGF5OiBuLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfU0hPUlRfV0lUSF9TRUNPTkRTID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbixcbiAgZGF5OiBuLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9NRUQgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBzLFxuICBkYXk6IG4sXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9NRURfV0lUSF9TRUNPTkRTID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogcyxcbiAgZGF5OiBuLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9NRURfV0lUSF9XRUVLREFZID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogcyxcbiAgZGF5OiBuLFxuICB3ZWVrZGF5OiBzLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfRlVMTCA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IGwsXG4gIGRheTogbixcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICB0aW1lWm9uZU5hbWU6IHMsXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFMgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBsLFxuICBkYXk6IG4sXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICB0aW1lWm9uZU5hbWU6IHMsXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfSFVHRSA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IGwsXG4gIGRheTogbixcbiAgd2Vla2RheTogbCxcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICB0aW1lWm9uZU5hbWU6IGwsXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfSFVHRV9XSVRIX1NFQ09ORFMgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBsLFxuICBkYXk6IG4sXG4gIHdlZWtkYXk6IGwsXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICB0aW1lWm9uZU5hbWU6IGwsXG59O1xuIiwiaW1wb3J0IHsgWm9uZUlzQWJzdHJhY3RFcnJvciB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuXG4vKipcbiAqIEBpbnRlcmZhY2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgWm9uZSB7XG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB6b25lXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IHR5cGUoKSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGlzIHpvbmUuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuXG4gIGdldCBpYW5hTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgb2Zmc2V0IGlzIGtub3duIHRvIGJlIGZpeGVkIGZvciB0aGUgd2hvbGUgeWVhci5cbiAgICogQGFic3RyYWN0XG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzVW5pdmVyc2FsKCkge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0J3MgY29tbW9uIG5hbWUgKHN1Y2ggYXMgRVNUKSBhdCB0aGUgc3BlY2lmaWVkIHRpbWVzdGFtcFxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRzIC0gRXBvY2ggbWlsbGlzZWNvbmRzIGZvciB3aGljaCB0byBnZXQgdGhlIG5hbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBPcHRpb25zIHRvIGFmZmVjdCB0aGUgZm9ybWF0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLmZvcm1hdCAtIFdoYXQgc3R5bGUgb2Ygb2Zmc2V0IHRvIHJldHVybi4gQWNjZXB0cyAnbG9uZycgb3IgJ3Nob3J0Jy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubG9jYWxlIC0gV2hhdCBsb2NhbGUgdG8gcmV0dXJuIHRoZSBvZmZzZXQgbmFtZSBpbi5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgb2Zmc2V0TmFtZSh0cywgb3B0cykge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0J3MgdmFsdWUgYXMgYSBzdHJpbmdcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0cyAtIEVwb2NoIG1pbGxpc2Vjb25kcyBmb3Igd2hpY2ggdG8gZ2V0IHRoZSBvZmZzZXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdCAtIFdoYXQgc3R5bGUgb2Ygb2Zmc2V0IHRvIHJldHVybi5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIEFjY2VwdHMgJ25hcnJvdycsICdzaG9ydCcsIG9yICd0ZWNoaWUnLiBSZXR1cm5pbmcgJys2JywgJyswNjowMCcsIG9yICcrMDYwMCcgcmVzcGVjdGl2ZWx5XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGZvcm1hdE9mZnNldCh0cywgZm9ybWF0KSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG9mZnNldCBpbiBtaW51dGVzIGZvciB0aGlzIHpvbmUgYXQgdGhlIHNwZWNpZmllZCB0aW1lc3RhbXAuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0gdHMgLSBFcG9jaCBtaWxsaXNlY29uZHMgZm9yIHdoaWNoIHRvIGNvbXB1dGUgdGhlIG9mZnNldFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBvZmZzZXQodHMpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgWm9uZSBpcyBlcXVhbCB0byBhbm90aGVyIHpvbmVcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7Wm9uZX0gb3RoZXJab25lIC0gdGhlIHpvbmUgdG8gY29tcGFyZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZXF1YWxzKG90aGVyWm9uZSkge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBab25lIGlzIHZhbGlkLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBmb3JtYXRPZmZzZXQsIHBhcnNlWm9uZUluZm8gfSBmcm9tIFwiLi4vaW1wbC91dGlsLmpzXCI7XG5pbXBvcnQgWm9uZSBmcm9tIFwiLi4vem9uZS5qc1wiO1xuXG5sZXQgc2luZ2xldG9uID0gbnVsbDtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBsb2NhbCB6b25lIGZvciB0aGlzIEphdmFTY3JpcHQgZW52aXJvbm1lbnQuXG4gKiBAaW1wbGVtZW50cyB7Wm9uZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3lzdGVtWm9uZSBleHRlbmRzIFpvbmUge1xuICAvKipcbiAgICogR2V0IGEgc2luZ2xldG9uIGluc3RhbmNlIG9mIHRoZSBsb2NhbCB6b25lXG4gICAqIEByZXR1cm4ge1N5c3RlbVpvbmV9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGluc3RhbmNlKCkge1xuICAgIGlmIChzaW5nbGV0b24gPT09IG51bGwpIHtcbiAgICAgIHNpbmdsZXRvbiA9IG5ldyBTeXN0ZW1ab25lKCk7XG4gICAgfVxuICAgIHJldHVybiBzaW5nbGV0b247XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gXCJzeXN0ZW1cIjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCgpLnJlc29sdmVkT3B0aW9ucygpLnRpbWVab25lO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IGlzVW5pdmVyc2FsKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIG9mZnNldE5hbWUodHMsIHsgZm9ybWF0LCBsb2NhbGUgfSkge1xuICAgIHJldHVybiBwYXJzZVpvbmVJbmZvKHRzLCBmb3JtYXQsIGxvY2FsZSk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBmb3JtYXRPZmZzZXQodHMsIGZvcm1hdCkge1xuICAgIHJldHVybiBmb3JtYXRPZmZzZXQodGhpcy5vZmZzZXQodHMpLCBmb3JtYXQpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgb2Zmc2V0KHRzKSB7XG4gICAgcmV0dXJuIC1uZXcgRGF0ZSh0cykuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGVxdWFscyhvdGhlclpvbmUpIHtcbiAgICByZXR1cm4gb3RoZXJab25lLnR5cGUgPT09IFwic3lzdGVtXCI7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgZm9ybWF0T2Zmc2V0LCBwYXJzZVpvbmVJbmZvLCBpc1VuZGVmaW5lZCwgb2JqVG9Mb2NhbFRTIH0gZnJvbSBcIi4uL2ltcGwvdXRpbC5qc1wiO1xuaW1wb3J0IFpvbmUgZnJvbSBcIi4uL3pvbmUuanNcIjtcblxubGV0IGR0ZkNhY2hlID0ge307XG5mdW5jdGlvbiBtYWtlRFRGKHpvbmUpIHtcbiAgaWYgKCFkdGZDYWNoZVt6b25lXSkge1xuICAgIGR0ZkNhY2hlW3pvbmVdID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoXCJlbi1VU1wiLCB7XG4gICAgICBob3VyMTI6IGZhbHNlLFxuICAgICAgdGltZVpvbmU6IHpvbmUsXG4gICAgICB5ZWFyOiBcIm51bWVyaWNcIixcbiAgICAgIG1vbnRoOiBcIjItZGlnaXRcIixcbiAgICAgIGRheTogXCIyLWRpZ2l0XCIsXG4gICAgICBob3VyOiBcIjItZGlnaXRcIixcbiAgICAgIG1pbnV0ZTogXCIyLWRpZ2l0XCIsXG4gICAgICBzZWNvbmQ6IFwiMi1kaWdpdFwiLFxuICAgICAgZXJhOiBcInNob3J0XCIsXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGR0ZkNhY2hlW3pvbmVdO1xufVxuXG5jb25zdCB0eXBlVG9Qb3MgPSB7XG4gIHllYXI6IDAsXG4gIG1vbnRoOiAxLFxuICBkYXk6IDIsXG4gIGVyYTogMyxcbiAgaG91cjogNCxcbiAgbWludXRlOiA1LFxuICBzZWNvbmQ6IDYsXG59O1xuXG5mdW5jdGlvbiBoYWNreU9mZnNldChkdGYsIGRhdGUpIHtcbiAgY29uc3QgZm9ybWF0dGVkID0gZHRmLmZvcm1hdChkYXRlKS5yZXBsYWNlKC9cXHUyMDBFL2csIFwiXCIpLFxuICAgIHBhcnNlZCA9IC8oXFxkKylcXC8oXFxkKylcXC8oXFxkKykgKEFEfEJDKSw/IChcXGQrKTooXFxkKyk6KFxcZCspLy5leGVjKGZvcm1hdHRlZCksXG4gICAgWywgZk1vbnRoLCBmRGF5LCBmWWVhciwgZmFkT3JCYywgZkhvdXIsIGZNaW51dGUsIGZTZWNvbmRdID0gcGFyc2VkO1xuICByZXR1cm4gW2ZZZWFyLCBmTW9udGgsIGZEYXksIGZhZE9yQmMsIGZIb3VyLCBmTWludXRlLCBmU2Vjb25kXTtcbn1cblxuZnVuY3Rpb24gcGFydHNPZmZzZXQoZHRmLCBkYXRlKSB7XG4gIGNvbnN0IGZvcm1hdHRlZCA9IGR0Zi5mb3JtYXRUb1BhcnRzKGRhdGUpO1xuICBjb25zdCBmaWxsZWQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb3JtYXR0ZWQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB7IHR5cGUsIHZhbHVlIH0gPSBmb3JtYXR0ZWRbaV07XG4gICAgY29uc3QgcG9zID0gdHlwZVRvUG9zW3R5cGVdO1xuXG4gICAgaWYgKHR5cGUgPT09IFwiZXJhXCIpIHtcbiAgICAgIGZpbGxlZFtwb3NdID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmICghaXNVbmRlZmluZWQocG9zKSkge1xuICAgICAgZmlsbGVkW3Bvc10gPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmlsbGVkO1xufVxuXG5sZXQgaWFuYVpvbmVDYWNoZSA9IHt9O1xuLyoqXG4gKiBBIHpvbmUgaWRlbnRpZmllZCBieSBhbiBJQU5BIGlkZW50aWZpZXIsIGxpa2UgQW1lcmljYS9OZXdfWW9ya1xuICogQGltcGxlbWVudHMge1pvbmV9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElBTkFab25lIGV4dGVuZHMgWm9uZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFpvbmUgbmFtZVxuICAgKiBAcmV0dXJuIHtJQU5BWm9uZX1cbiAgICovXG4gIHN0YXRpYyBjcmVhdGUobmFtZSkge1xuICAgIGlmICghaWFuYVpvbmVDYWNoZVtuYW1lXSkge1xuICAgICAgaWFuYVpvbmVDYWNoZVtuYW1lXSA9IG5ldyBJQU5BWm9uZShuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIGlhbmFab25lQ2FjaGVbbmFtZV07XG4gIH1cblxuICAvKipcbiAgICogUmVzZXQgbG9jYWwgY2FjaGVzLiBTaG91bGQgb25seSBiZSBuZWNlc3NhcnkgaW4gdGVzdGluZyBzY2VuYXJpb3MuXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBzdGF0aWMgcmVzZXRDYWNoZSgpIHtcbiAgICBpYW5hWm9uZUNhY2hlID0ge307XG4gICAgZHRmQ2FjaGUgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHN0cmluZyBpcyBhIHZhbGlkIHNwZWNpZmllci4gVGhpcyBvbmx5IGNoZWNrcyB0aGUgc3RyaW5nJ3MgZm9ybWF0LCBub3QgdGhhdCB0aGUgc3BlY2lmaWVyIGlkZW50aWZpZXMgYSBrbm93biB6b25lOyBzZWUgaXNWYWxpZFpvbmUgZm9yIHRoYXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzIC0gVGhlIHN0cmluZyB0byBjaGVjayB2YWxpZGl0eSBvblxuICAgKiBAZXhhbXBsZSBJQU5BWm9uZS5pc1ZhbGlkU3BlY2lmaWVyKFwiQW1lcmljYS9OZXdfWW9ya1wiKSAvLz0+IHRydWVcbiAgICogQGV4YW1wbGUgSUFOQVpvbmUuaXNWYWxpZFNwZWNpZmllcihcIlNwb3J0fn5ibG9ycFwiKSAvLz0+IGZhbHNlXG4gICAqIEBkZXByZWNhdGVkIFRoaXMgbWV0aG9kIHJldHVybnMgZmFsc2UgZm9yIHNvbWUgdmFsaWQgSUFOQSBuYW1lcy4gVXNlIGlzVmFsaWRab25lIGluc3RlYWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNWYWxpZFNwZWNpZmllcihzKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZFpvbmUocyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCBzdHJpbmcgaWRlbnRpZmllcyBhIHJlYWwgem9uZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gem9uZSAtIFRoZSBzdHJpbmcgdG8gY2hlY2tcbiAgICogQGV4YW1wbGUgSUFOQVpvbmUuaXNWYWxpZFpvbmUoXCJBbWVyaWNhL05ld19Zb3JrXCIpIC8vPT4gdHJ1ZVxuICAgKiBAZXhhbXBsZSBJQU5BWm9uZS5pc1ZhbGlkWm9uZShcIkZhbnRhc2lhL0Nhc3RsZVwiKSAvLz0+IGZhbHNlXG4gICAqIEBleGFtcGxlIElBTkFab25lLmlzVmFsaWRab25lKFwiU3BvcnR+fmJsb3JwXCIpIC8vPT4gZmFsc2VcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc1ZhbGlkWm9uZSh6b25lKSB7XG4gICAgaWYgKCF6b25lKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChcImVuLVVTXCIsIHsgdGltZVpvbmU6IHpvbmUgfSkuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgY29uc3RydWN0b3IobmFtZSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqIEBwcml2YXRlICoqL1xuICAgIHRoaXMuem9uZU5hbWUgPSBuYW1lO1xuICAgIC8qKiBAcHJpdmF0ZSAqKi9cbiAgICB0aGlzLnZhbGlkID0gSUFOQVpvbmUuaXNWYWxpZFpvbmUobmFtZSk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gXCJpYW5hXCI7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy56b25lTmFtZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBpc1VuaXZlcnNhbCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBvZmZzZXROYW1lKHRzLCB7IGZvcm1hdCwgbG9jYWxlIH0pIHtcbiAgICByZXR1cm4gcGFyc2Vab25lSW5mbyh0cywgZm9ybWF0LCBsb2NhbGUsIHRoaXMubmFtZSk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBmb3JtYXRPZmZzZXQodHMsIGZvcm1hdCkge1xuICAgIHJldHVybiBmb3JtYXRPZmZzZXQodGhpcy5vZmZzZXQodHMpLCBmb3JtYXQpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgb2Zmc2V0KHRzKSB7XG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHRzKTtcblxuICAgIGlmIChpc05hTihkYXRlKSkgcmV0dXJuIE5hTjtcblxuICAgIGNvbnN0IGR0ZiA9IG1ha2VEVEYodGhpcy5uYW1lKTtcbiAgICBsZXQgW3llYXIsIG1vbnRoLCBkYXksIGFkT3JCYywgaG91ciwgbWludXRlLCBzZWNvbmRdID0gZHRmLmZvcm1hdFRvUGFydHNcbiAgICAgID8gcGFydHNPZmZzZXQoZHRmLCBkYXRlKVxuICAgICAgOiBoYWNreU9mZnNldChkdGYsIGRhdGUpO1xuXG4gICAgaWYgKGFkT3JCYyA9PT0gXCJCQ1wiKSB7XG4gICAgICB5ZWFyID0gLU1hdGguYWJzKHllYXIpICsgMTtcbiAgICB9XG5cbiAgICAvLyBiZWNhdXNlIHdlJ3JlIHVzaW5nIGhvdXIxMiBhbmQgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTAyNTU2NCZjYW49MiZxPSUyMjI0JTNBMDAlMjIlMjBkYXRldGltZWZvcm1hdFxuICAgIGNvbnN0IGFkanVzdGVkSG91ciA9IGhvdXIgPT09IDI0ID8gMCA6IGhvdXI7XG5cbiAgICBjb25zdCBhc1VUQyA9IG9ialRvTG9jYWxUUyh7XG4gICAgICB5ZWFyLFxuICAgICAgbW9udGgsXG4gICAgICBkYXksXG4gICAgICBob3VyOiBhZGp1c3RlZEhvdXIsXG4gICAgICBtaW51dGUsXG4gICAgICBzZWNvbmQsXG4gICAgICBtaWxsaXNlY29uZDogMCxcbiAgICB9KTtcblxuICAgIGxldCBhc1RTID0gK2RhdGU7XG4gICAgY29uc3Qgb3ZlciA9IGFzVFMgJSAxMDAwO1xuICAgIGFzVFMgLT0gb3ZlciA+PSAwID8gb3ZlciA6IDEwMDAgKyBvdmVyO1xuICAgIHJldHVybiAoYXNVVEMgLSBhc1RTKSAvICg2MCAqIDEwMDApO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZXF1YWxzKG90aGVyWm9uZSkge1xuICAgIHJldHVybiBvdGhlclpvbmUudHlwZSA9PT0gXCJpYW5hXCIgJiYgb3RoZXJab25lLm5hbWUgPT09IHRoaXMubmFtZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLnZhbGlkO1xuICB9XG59XG4iLCJpbXBvcnQgeyBwYWRTdGFydCwgcm91bmRUbywgaGFzUmVsYXRpdmUgfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5pbXBvcnQgKiBhcyBFbmdsaXNoIGZyb20gXCIuL2VuZ2xpc2guanNcIjtcbmltcG9ydCBTZXR0aW5ncyBmcm9tIFwiLi4vc2V0dGluZ3MuanNcIjtcbmltcG9ydCBEYXRlVGltZSBmcm9tIFwiLi4vZGF0ZXRpbWUuanNcIjtcbmltcG9ydCBJQU5BWm9uZSBmcm9tIFwiLi4vem9uZXMvSUFOQVpvbmUuanNcIjtcblxuLy8gdG9kbyAtIHJlbWFwIGNhY2hpbmdcblxubGV0IGludGxMRkNhY2hlID0ge307XG5mdW5jdGlvbiBnZXRDYWNoZWRMRihsb2NTdHJpbmcsIG9wdHMgPSB7fSkge1xuICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeShbbG9jU3RyaW5nLCBvcHRzXSk7XG4gIGxldCBkdGYgPSBpbnRsTEZDYWNoZVtrZXldO1xuICBpZiAoIWR0Zikge1xuICAgIGR0ZiA9IG5ldyBJbnRsLkxpc3RGb3JtYXQobG9jU3RyaW5nLCBvcHRzKTtcbiAgICBpbnRsTEZDYWNoZVtrZXldID0gZHRmO1xuICB9XG4gIHJldHVybiBkdGY7XG59XG5cbmxldCBpbnRsRFRDYWNoZSA9IHt9O1xuZnVuY3Rpb24gZ2V0Q2FjaGVkRFRGKGxvY1N0cmluZywgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KFtsb2NTdHJpbmcsIG9wdHNdKTtcbiAgbGV0IGR0ZiA9IGludGxEVENhY2hlW2tleV07XG4gIGlmICghZHRmKSB7XG4gICAgZHRmID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jU3RyaW5nLCBvcHRzKTtcbiAgICBpbnRsRFRDYWNoZVtrZXldID0gZHRmO1xuICB9XG4gIHJldHVybiBkdGY7XG59XG5cbmxldCBpbnRsTnVtQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGdldENhY2hlZElORihsb2NTdHJpbmcsIG9wdHMgPSB7fSkge1xuICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeShbbG9jU3RyaW5nLCBvcHRzXSk7XG4gIGxldCBpbmYgPSBpbnRsTnVtQ2FjaGVba2V5XTtcbiAgaWYgKCFpbmYpIHtcbiAgICBpbmYgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jU3RyaW5nLCBvcHRzKTtcbiAgICBpbnRsTnVtQ2FjaGVba2V5XSA9IGluZjtcbiAgfVxuICByZXR1cm4gaW5mO1xufVxuXG5sZXQgaW50bFJlbENhY2hlID0ge307XG5mdW5jdGlvbiBnZXRDYWNoZWRSVEYobG9jU3RyaW5nLCBvcHRzID0ge30pIHtcbiAgY29uc3QgeyBiYXNlLCAuLi5jYWNoZUtleU9wdHMgfSA9IG9wdHM7IC8vIGV4Y2x1ZGUgYGJhc2VgIGZyb20gdGhlIG9wdGlvbnNcbiAgY29uc3Qga2V5ID0gSlNPTi5zdHJpbmdpZnkoW2xvY1N0cmluZywgY2FjaGVLZXlPcHRzXSk7XG4gIGxldCBpbmYgPSBpbnRsUmVsQ2FjaGVba2V5XTtcbiAgaWYgKCFpbmYpIHtcbiAgICBpbmYgPSBuZXcgSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXQobG9jU3RyaW5nLCBvcHRzKTtcbiAgICBpbnRsUmVsQ2FjaGVba2V5XSA9IGluZjtcbiAgfVxuICByZXR1cm4gaW5mO1xufVxuXG5sZXQgc3lzTG9jYWxlQ2FjaGUgPSBudWxsO1xuZnVuY3Rpb24gc3lzdGVtTG9jYWxlKCkge1xuICBpZiAoc3lzTG9jYWxlQ2FjaGUpIHtcbiAgICByZXR1cm4gc3lzTG9jYWxlQ2FjaGU7XG4gIH0gZWxzZSB7XG4gICAgc3lzTG9jYWxlQ2FjaGUgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCgpLnJlc29sdmVkT3B0aW9ucygpLmxvY2FsZTtcbiAgICByZXR1cm4gc3lzTG9jYWxlQ2FjaGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VMb2NhbGVTdHJpbmcobG9jYWxlU3RyKSB7XG4gIC8vIEkgcmVhbGx5IHdhbnQgdG8gYXZvaWQgd3JpdGluZyBhIEJDUCA0NyBwYXJzZXJcbiAgLy8gc2VlLCBlLmcuIGh0dHBzOi8vZ2l0aHViLmNvbS93b29vcm0vYmNwLTQ3XG4gIC8vIEluc3RlYWQsIHdlJ2xsIGRvIHRoaXM6XG5cbiAgLy8gYSkgaWYgdGhlIHN0cmluZyBoYXMgbm8gLXUgZXh0ZW5zaW9ucywganVzdCBsZWF2ZSBpdCBhbG9uZVxuICAvLyBiKSBpZiBpdCBkb2VzLCB1c2UgSW50bCB0byByZXNvbHZlIGV2ZXJ5dGhpbmdcbiAgLy8gYykgaWYgSW50bCBmYWlscywgdHJ5IGFnYWluIHdpdGhvdXQgdGhlIC11XG5cbiAgLy8gcHJpdmF0ZSBzdWJ0YWdzIGFuZCB1bmljb2RlIHN1YnRhZ3MgaGF2ZSBvcmRlcmluZyByZXF1aXJlbWVudHMsXG4gIC8vIGFuZCB3ZSdyZSBub3QgcHJvcGVybHkgcGFyc2luZyB0aGlzLCBzbyBqdXN0IHN0cmlwIG91dCB0aGVcbiAgLy8gcHJpdmF0ZSBvbmVzIGlmIHRoZXkgZXhpc3QuXG4gIGNvbnN0IHhJbmRleCA9IGxvY2FsZVN0ci5pbmRleE9mKFwiLXgtXCIpO1xuICBpZiAoeEluZGV4ICE9PSAtMSkge1xuICAgIGxvY2FsZVN0ciA9IGxvY2FsZVN0ci5zdWJzdHJpbmcoMCwgeEluZGV4KTtcbiAgfVxuXG4gIGNvbnN0IHVJbmRleCA9IGxvY2FsZVN0ci5pbmRleE9mKFwiLXUtXCIpO1xuICBpZiAodUluZGV4ID09PSAtMSkge1xuICAgIHJldHVybiBbbG9jYWxlU3RyXTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgb3B0aW9ucztcbiAgICBsZXQgc2VsZWN0ZWRTdHI7XG4gICAgdHJ5IHtcbiAgICAgIG9wdGlvbnMgPSBnZXRDYWNoZWREVEYobG9jYWxlU3RyKS5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgICAgIHNlbGVjdGVkU3RyID0gbG9jYWxlU3RyO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnN0IHNtYWxsZXIgPSBsb2NhbGVTdHIuc3Vic3RyaW5nKDAsIHVJbmRleCk7XG4gICAgICBvcHRpb25zID0gZ2V0Q2FjaGVkRFRGKHNtYWxsZXIpLnJlc29sdmVkT3B0aW9ucygpO1xuICAgICAgc2VsZWN0ZWRTdHIgPSBzbWFsbGVyO1xuICAgIH1cblxuICAgIGNvbnN0IHsgbnVtYmVyaW5nU3lzdGVtLCBjYWxlbmRhciB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gW3NlbGVjdGVkU3RyLCBudW1iZXJpbmdTeXN0ZW0sIGNhbGVuZGFyXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnRsQ29uZmlnU3RyaW5nKGxvY2FsZVN0ciwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhcikge1xuICBpZiAob3V0cHV0Q2FsZW5kYXIgfHwgbnVtYmVyaW5nU3lzdGVtKSB7XG4gICAgaWYgKCFsb2NhbGVTdHIuaW5jbHVkZXMoXCItdS1cIikpIHtcbiAgICAgIGxvY2FsZVN0ciArPSBcIi11XCI7XG4gICAgfVxuXG4gICAgaWYgKG91dHB1dENhbGVuZGFyKSB7XG4gICAgICBsb2NhbGVTdHIgKz0gYC1jYS0ke291dHB1dENhbGVuZGFyfWA7XG4gICAgfVxuXG4gICAgaWYgKG51bWJlcmluZ1N5c3RlbSkge1xuICAgICAgbG9jYWxlU3RyICs9IGAtbnUtJHtudW1iZXJpbmdTeXN0ZW19YDtcbiAgICB9XG4gICAgcmV0dXJuIGxvY2FsZVN0cjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbG9jYWxlU3RyO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcE1vbnRocyhmKSB7XG4gIGNvbnN0IG1zID0gW107XG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IDEyOyBpKyspIHtcbiAgICBjb25zdCBkdCA9IERhdGVUaW1lLnV0YygyMDE2LCBpLCAxKTtcbiAgICBtcy5wdXNoKGYoZHQpKTtcbiAgfVxuICByZXR1cm4gbXM7XG59XG5cbmZ1bmN0aW9uIG1hcFdlZWtkYXlzKGYpIHtcbiAgY29uc3QgbXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gNzsgaSsrKSB7XG4gICAgY29uc3QgZHQgPSBEYXRlVGltZS51dGMoMjAxNiwgMTEsIDEzICsgaSk7XG4gICAgbXMucHVzaChmKGR0KSk7XG4gIH1cbiAgcmV0dXJuIG1zO1xufVxuXG5mdW5jdGlvbiBsaXN0U3R1ZmYobG9jLCBsZW5ndGgsIGRlZmF1bHRPSywgZW5nbGlzaEZuLCBpbnRsRm4pIHtcbiAgY29uc3QgbW9kZSA9IGxvYy5saXN0aW5nTW9kZShkZWZhdWx0T0spO1xuXG4gIGlmIChtb2RlID09PSBcImVycm9yXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmIChtb2RlID09PSBcImVuXCIpIHtcbiAgICByZXR1cm4gZW5nbGlzaEZuKGxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGludGxGbihsZW5ndGgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN1cHBvcnRzRmFzdE51bWJlcnMobG9jKSB7XG4gIGlmIChsb2MubnVtYmVyaW5nU3lzdGVtICYmIGxvYy5udW1iZXJpbmdTeXN0ZW0gIT09IFwibGF0blwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXG4gICAgICBsb2MubnVtYmVyaW5nU3lzdGVtID09PSBcImxhdG5cIiB8fFxuICAgICAgIWxvYy5sb2NhbGUgfHxcbiAgICAgIGxvYy5sb2NhbGUuc3RhcnRzV2l0aChcImVuXCIpIHx8XG4gICAgICBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2MuaW50bCkucmVzb2x2ZWRPcHRpb25zKCkubnVtYmVyaW5nU3lzdGVtID09PSBcImxhdG5cIlxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmNsYXNzIFBvbHlOdW1iZXJGb3JtYXR0ZXIge1xuICBjb25zdHJ1Y3RvcihpbnRsLCBmb3JjZVNpbXBsZSwgb3B0cykge1xuICAgIHRoaXMucGFkVG8gPSBvcHRzLnBhZFRvIHx8IDA7XG4gICAgdGhpcy5mbG9vciA9IG9wdHMuZmxvb3IgfHwgZmFsc2U7XG5cbiAgICBjb25zdCB7IHBhZFRvLCBmbG9vciwgLi4ub3RoZXJPcHRzIH0gPSBvcHRzO1xuXG4gICAgaWYgKCFmb3JjZVNpbXBsZSB8fCBPYmplY3Qua2V5cyhvdGhlck9wdHMpLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGludGxPcHRzID0geyB1c2VHcm91cGluZzogZmFsc2UsIC4uLm9wdHMgfTtcbiAgICAgIGlmIChvcHRzLnBhZFRvID4gMCkgaW50bE9wdHMubWluaW11bUludGVnZXJEaWdpdHMgPSBvcHRzLnBhZFRvO1xuICAgICAgdGhpcy5pbmYgPSBnZXRDYWNoZWRJTkYoaW50bCwgaW50bE9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIGZvcm1hdChpKSB7XG4gICAgaWYgKHRoaXMuaW5mKSB7XG4gICAgICBjb25zdCBmaXhlZCA9IHRoaXMuZmxvb3IgPyBNYXRoLmZsb29yKGkpIDogaTtcbiAgICAgIHJldHVybiB0aGlzLmluZi5mb3JtYXQoZml4ZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0byBtYXRjaCB0aGUgYnJvd3NlcidzIG51bWJlcmZvcm1hdHRlciBkZWZhdWx0c1xuICAgICAgY29uc3QgZml4ZWQgPSB0aGlzLmZsb29yID8gTWF0aC5mbG9vcihpKSA6IHJvdW5kVG8oaSwgMyk7XG4gICAgICByZXR1cm4gcGFkU3RhcnQoZml4ZWQsIHRoaXMucGFkVG8pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuY2xhc3MgUG9seURhdGVGb3JtYXR0ZXIge1xuICBjb25zdHJ1Y3RvcihkdCwgaW50bCwgb3B0cykge1xuICAgIHRoaXMub3B0cyA9IG9wdHM7XG5cbiAgICBsZXQgeiA9IHVuZGVmaW5lZDtcbiAgICBpZiAoZHQuem9uZS5pc1VuaXZlcnNhbCkge1xuICAgICAgLy8gVVRDLTggb3IgRXRjL1VUQy04IGFyZSBub3QgcGFydCBvZiB0emRhdGEsIG9ubHkgRXRjL0dNVCs4IGFuZCB0aGUgbGlrZS5cbiAgICAgIC8vIFRoYXQgaXMgd2h5IGZpeGVkLW9mZnNldCBUWiBpcyBzZXQgdG8gdGhhdCB1bmxlc3MgaXQgaXM6XG4gICAgICAvLyAxLiBSZXByZXNlbnRpbmcgb2Zmc2V0IDAgd2hlbiBVVEMgaXMgdXNlZCB0byBtYWludGFpbiBwcmV2aW91cyBiZWhhdmlvciBhbmQgZG9lcyBub3QgYmVjb21lIEdNVC5cbiAgICAgIC8vIDIuIFVuc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyOlxuICAgICAgLy8gICAgLSBzb21lIGRvIG5vdCBzdXBwb3J0IEV0Yy9cbiAgICAgIC8vICAgIC0gPCBFdGMvR01ULTE0LCA+IEV0Yy9HTVQrMTIsIGFuZCAzMC1taW51dGUgb3IgNDUtbWludXRlIG9mZnNldHMgYXJlIG5vdCBwYXJ0IG9mIHR6ZGF0YVxuICAgICAgY29uc3QgZ210T2Zmc2V0ID0gLTEgKiAoZHQub2Zmc2V0IC8gNjApO1xuICAgICAgY29uc3Qgb2Zmc2V0WiA9IGdtdE9mZnNldCA+PSAwID8gYEV0Yy9HTVQrJHtnbXRPZmZzZXR9YCA6IGBFdGMvR01UJHtnbXRPZmZzZXR9YDtcbiAgICAgIGlmIChkdC5vZmZzZXQgIT09IDAgJiYgSUFOQVpvbmUuY3JlYXRlKG9mZnNldFopLnZhbGlkKSB7XG4gICAgICAgIHogPSBvZmZzZXRaO1xuICAgICAgICB0aGlzLmR0ID0gZHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb3QgYWxsIGZpeGVkLW9mZnNldCB6b25lcyBsaWtlIEV0Yy8rNDozMCBhcmUgcHJlc2VudCBpbiB0emRhdGEuXG4gICAgICAgIC8vIFNvIHdlIGhhdmUgdG8gbWFrZSBkby4gVHdvIGNhc2VzOlxuICAgICAgICAvLyAxLiBUaGUgZm9ybWF0IG9wdGlvbnMgdGVsbCB1cyB0byBzaG93IHRoZSB6b25lLiBXZSBjYW4ndCBkbyB0aGF0LCBzbyB0aGUgYmVzdFxuICAgICAgICAvLyB3ZSBjYW4gZG8gaXMgZm9ybWF0IHRoZSBkYXRlIGluIFVUQy5cbiAgICAgICAgLy8gMi4gVGhlIGZvcm1hdCBvcHRpb25zIGRvbid0IHRlbGwgdXMgdG8gc2hvdyB0aGUgem9uZS4gVGhlbiB3ZSBjYW4gYWRqdXN0IHRoZW1cbiAgICAgICAgLy8gdGhlIHRpbWUgYW5kIHRlbGwgdGhlIGZvcm1hdHRlciB0byBzaG93IGl0IHRvIHVzIGluIFVUQywgc28gdGhhdCB0aGUgdGltZSBpcyByaWdodFxuICAgICAgICAvLyBhbmQgdGhlIGJhZCB6b25lIGRvZXNuJ3Qgc2hvdyB1cC5cbiAgICAgICAgeiA9IFwiVVRDXCI7XG4gICAgICAgIGlmIChvcHRzLnRpbWVab25lTmFtZSkge1xuICAgICAgICAgIHRoaXMuZHQgPSBkdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmR0ID0gZHQub2Zmc2V0ID09PSAwID8gZHQgOiBEYXRlVGltZS5mcm9tTWlsbGlzKGR0LnRzICsgZHQub2Zmc2V0ICogNjAgKiAxMDAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZHQuem9uZS50eXBlID09PSBcInN5c3RlbVwiKSB7XG4gICAgICB0aGlzLmR0ID0gZHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZHQgPSBkdDtcbiAgICAgIHogPSBkdC56b25lLm5hbWU7XG4gICAgfVxuXG4gICAgY29uc3QgaW50bE9wdHMgPSB7IC4uLnRoaXMub3B0cyB9O1xuICAgIGludGxPcHRzLnRpbWVab25lID0gaW50bE9wdHMudGltZVpvbmUgfHwgejtcbiAgICB0aGlzLmR0ZiA9IGdldENhY2hlZERURihpbnRsLCBpbnRsT3B0cyk7XG4gIH1cblxuICBmb3JtYXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHRmLmZvcm1hdCh0aGlzLmR0LnRvSlNEYXRlKCkpO1xuICB9XG5cbiAgZm9ybWF0VG9QYXJ0cygpIHtcbiAgICByZXR1cm4gdGhpcy5kdGYuZm9ybWF0VG9QYXJ0cyh0aGlzLmR0LnRvSlNEYXRlKCkpO1xuICB9XG5cbiAgcmVzb2x2ZWRPcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmR0Zi5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFBvbHlSZWxGb3JtYXR0ZXIge1xuICBjb25zdHJ1Y3RvcihpbnRsLCBpc0VuZ2xpc2gsIG9wdHMpIHtcbiAgICB0aGlzLm9wdHMgPSB7IHN0eWxlOiBcImxvbmdcIiwgLi4ub3B0cyB9O1xuICAgIGlmICghaXNFbmdsaXNoICYmIGhhc1JlbGF0aXZlKCkpIHtcbiAgICAgIHRoaXMucnRmID0gZ2V0Q2FjaGVkUlRGKGludGwsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIGZvcm1hdChjb3VudCwgdW5pdCkge1xuICAgIGlmICh0aGlzLnJ0Zikge1xuICAgICAgcmV0dXJuIHRoaXMucnRmLmZvcm1hdChjb3VudCwgdW5pdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBFbmdsaXNoLmZvcm1hdFJlbGF0aXZlVGltZSh1bml0LCBjb3VudCwgdGhpcy5vcHRzLm51bWVyaWMsIHRoaXMub3B0cy5zdHlsZSAhPT0gXCJsb25nXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZvcm1hdFRvUGFydHMoY291bnQsIHVuaXQpIHtcbiAgICBpZiAodGhpcy5ydGYpIHtcbiAgICAgIHJldHVybiB0aGlzLnJ0Zi5mb3JtYXRUb1BhcnRzKGNvdW50LCB1bml0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9jYWxlIHtcbiAgc3RhdGljIGZyb21PcHRzKG9wdHMpIHtcbiAgICByZXR1cm4gTG9jYWxlLmNyZWF0ZShvcHRzLmxvY2FsZSwgb3B0cy5udW1iZXJpbmdTeXN0ZW0sIG9wdHMub3V0cHV0Q2FsZW5kYXIsIG9wdHMuZGVmYXVsdFRvRU4pO1xuICB9XG5cbiAgc3RhdGljIGNyZWF0ZShsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXIsIGRlZmF1bHRUb0VOID0gZmFsc2UpIHtcbiAgICBjb25zdCBzcGVjaWZpZWRMb2NhbGUgPSBsb2NhbGUgfHwgU2V0dGluZ3MuZGVmYXVsdExvY2FsZTtcbiAgICAvLyB0aGUgc3lzdGVtIGxvY2FsZSBpcyB1c2VmdWwgZm9yIGh1bWFuIHJlYWRhYmxlIHN0cmluZ3MgYnV0IGFubm95aW5nIGZvciBwYXJzaW5nL2Zvcm1hdHRpbmcga25vd24gZm9ybWF0c1xuICAgIGNvbnN0IGxvY2FsZVIgPSBzcGVjaWZpZWRMb2NhbGUgfHwgKGRlZmF1bHRUb0VOID8gXCJlbi1VU1wiIDogc3lzdGVtTG9jYWxlKCkpO1xuICAgIGNvbnN0IG51bWJlcmluZ1N5c3RlbVIgPSBudW1iZXJpbmdTeXN0ZW0gfHwgU2V0dGluZ3MuZGVmYXVsdE51bWJlcmluZ1N5c3RlbTtcbiAgICBjb25zdCBvdXRwdXRDYWxlbmRhclIgPSBvdXRwdXRDYWxlbmRhciB8fCBTZXR0aW5ncy5kZWZhdWx0T3V0cHV0Q2FsZW5kYXI7XG4gICAgcmV0dXJuIG5ldyBMb2NhbGUobG9jYWxlUiwgbnVtYmVyaW5nU3lzdGVtUiwgb3V0cHV0Q2FsZW5kYXJSLCBzcGVjaWZpZWRMb2NhbGUpO1xuICB9XG5cbiAgc3RhdGljIHJlc2V0Q2FjaGUoKSB7XG4gICAgc3lzTG9jYWxlQ2FjaGUgPSBudWxsO1xuICAgIGludGxEVENhY2hlID0ge307XG4gICAgaW50bE51bUNhY2hlID0ge307XG4gICAgaW50bFJlbENhY2hlID0ge307XG4gIH1cblxuICBzdGF0aWMgZnJvbU9iamVjdCh7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhciB9ID0ge30pIHtcbiAgICByZXR1cm4gTG9jYWxlLmNyZWF0ZShsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXIpO1xuICB9XG5cbiAgY29uc3RydWN0b3IobG9jYWxlLCBudW1iZXJpbmcsIG91dHB1dENhbGVuZGFyLCBzcGVjaWZpZWRMb2NhbGUpIHtcbiAgICBjb25zdCBbcGFyc2VkTG9jYWxlLCBwYXJzZWROdW1iZXJpbmdTeXN0ZW0sIHBhcnNlZE91dHB1dENhbGVuZGFyXSA9IHBhcnNlTG9jYWxlU3RyaW5nKGxvY2FsZSk7XG5cbiAgICB0aGlzLmxvY2FsZSA9IHBhcnNlZExvY2FsZTtcbiAgICB0aGlzLm51bWJlcmluZ1N5c3RlbSA9IG51bWJlcmluZyB8fCBwYXJzZWROdW1iZXJpbmdTeXN0ZW0gfHwgbnVsbDtcbiAgICB0aGlzLm91dHB1dENhbGVuZGFyID0gb3V0cHV0Q2FsZW5kYXIgfHwgcGFyc2VkT3V0cHV0Q2FsZW5kYXIgfHwgbnVsbDtcbiAgICB0aGlzLmludGwgPSBpbnRsQ29uZmlnU3RyaW5nKHRoaXMubG9jYWxlLCB0aGlzLm51bWJlcmluZ1N5c3RlbSwgdGhpcy5vdXRwdXRDYWxlbmRhcik7XG5cbiAgICB0aGlzLndlZWtkYXlzQ2FjaGUgPSB7IGZvcm1hdDoge30sIHN0YW5kYWxvbmU6IHt9IH07XG4gICAgdGhpcy5tb250aHNDYWNoZSA9IHsgZm9ybWF0OiB7fSwgc3RhbmRhbG9uZToge30gfTtcbiAgICB0aGlzLm1lcmlkaWVtQ2FjaGUgPSBudWxsO1xuICAgIHRoaXMuZXJhQ2FjaGUgPSB7fTtcblxuICAgIHRoaXMuc3BlY2lmaWVkTG9jYWxlID0gc3BlY2lmaWVkTG9jYWxlO1xuICAgIHRoaXMuZmFzdE51bWJlcnNDYWNoZWQgPSBudWxsO1xuICB9XG5cbiAgZ2V0IGZhc3ROdW1iZXJzKCkge1xuICAgIGlmICh0aGlzLmZhc3ROdW1iZXJzQ2FjaGVkID09IG51bGwpIHtcbiAgICAgIHRoaXMuZmFzdE51bWJlcnNDYWNoZWQgPSBzdXBwb3J0c0Zhc3ROdW1iZXJzKHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZhc3ROdW1iZXJzQ2FjaGVkO1xuICB9XG5cbiAgbGlzdGluZ01vZGUoKSB7XG4gICAgY29uc3QgaXNBY3R1YWxseUVuID0gdGhpcy5pc0VuZ2xpc2goKTtcbiAgICBjb25zdCBoYXNOb1dlaXJkbmVzcyA9XG4gICAgICAodGhpcy5udW1iZXJpbmdTeXN0ZW0gPT09IG51bGwgfHwgdGhpcy5udW1iZXJpbmdTeXN0ZW0gPT09IFwibGF0blwiKSAmJlxuICAgICAgKHRoaXMub3V0cHV0Q2FsZW5kYXIgPT09IG51bGwgfHwgdGhpcy5vdXRwdXRDYWxlbmRhciA9PT0gXCJncmVnb3J5XCIpO1xuICAgIHJldHVybiBpc0FjdHVhbGx5RW4gJiYgaGFzTm9XZWlyZG5lc3MgPyBcImVuXCIgOiBcImludGxcIjtcbiAgfVxuXG4gIGNsb25lKGFsdHMpIHtcbiAgICBpZiAoIWFsdHMgfHwgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYWx0cykubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIExvY2FsZS5jcmVhdGUoXG4gICAgICAgIGFsdHMubG9jYWxlIHx8IHRoaXMuc3BlY2lmaWVkTG9jYWxlLFxuICAgICAgICBhbHRzLm51bWJlcmluZ1N5c3RlbSB8fCB0aGlzLm51bWJlcmluZ1N5c3RlbSxcbiAgICAgICAgYWx0cy5vdXRwdXRDYWxlbmRhciB8fCB0aGlzLm91dHB1dENhbGVuZGFyLFxuICAgICAgICBhbHRzLmRlZmF1bHRUb0VOIHx8IGZhbHNlXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJlZGVmYXVsdFRvRU4oYWx0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoeyAuLi5hbHRzLCBkZWZhdWx0VG9FTjogdHJ1ZSB9KTtcbiAgfVxuXG4gIHJlZGVmYXVsdFRvU3lzdGVtKGFsdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKHsgLi4uYWx0cywgZGVmYXVsdFRvRU46IGZhbHNlIH0pO1xuICB9XG5cbiAgbW9udGhzKGxlbmd0aCwgZm9ybWF0ID0gZmFsc2UsIGRlZmF1bHRPSyA9IHRydWUpIHtcbiAgICByZXR1cm4gbGlzdFN0dWZmKHRoaXMsIGxlbmd0aCwgZGVmYXVsdE9LLCBFbmdsaXNoLm1vbnRocywgKCkgPT4ge1xuICAgICAgY29uc3QgaW50bCA9IGZvcm1hdCA/IHsgbW9udGg6IGxlbmd0aCwgZGF5OiBcIm51bWVyaWNcIiB9IDogeyBtb250aDogbGVuZ3RoIH0sXG4gICAgICAgIGZvcm1hdFN0ciA9IGZvcm1hdCA/IFwiZm9ybWF0XCIgOiBcInN0YW5kYWxvbmVcIjtcbiAgICAgIGlmICghdGhpcy5tb250aHNDYWNoZVtmb3JtYXRTdHJdW2xlbmd0aF0pIHtcbiAgICAgICAgdGhpcy5tb250aHNDYWNoZVtmb3JtYXRTdHJdW2xlbmd0aF0gPSBtYXBNb250aHMoKGR0KSA9PiB0aGlzLmV4dHJhY3QoZHQsIGludGwsIFwibW9udGhcIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubW9udGhzQ2FjaGVbZm9ybWF0U3RyXVtsZW5ndGhdO1xuICAgIH0pO1xuICB9XG5cbiAgd2Vla2RheXMobGVuZ3RoLCBmb3JtYXQgPSBmYWxzZSwgZGVmYXVsdE9LID0gdHJ1ZSkge1xuICAgIHJldHVybiBsaXN0U3R1ZmYodGhpcywgbGVuZ3RoLCBkZWZhdWx0T0ssIEVuZ2xpc2gud2Vla2RheXMsICgpID0+IHtcbiAgICAgIGNvbnN0IGludGwgPSBmb3JtYXRcbiAgICAgICAgICA/IHsgd2Vla2RheTogbGVuZ3RoLCB5ZWFyOiBcIm51bWVyaWNcIiwgbW9udGg6IFwibG9uZ1wiLCBkYXk6IFwibnVtZXJpY1wiIH1cbiAgICAgICAgICA6IHsgd2Vla2RheTogbGVuZ3RoIH0sXG4gICAgICAgIGZvcm1hdFN0ciA9IGZvcm1hdCA/IFwiZm9ybWF0XCIgOiBcInN0YW5kYWxvbmVcIjtcbiAgICAgIGlmICghdGhpcy53ZWVrZGF5c0NhY2hlW2Zvcm1hdFN0cl1bbGVuZ3RoXSkge1xuICAgICAgICB0aGlzLndlZWtkYXlzQ2FjaGVbZm9ybWF0U3RyXVtsZW5ndGhdID0gbWFwV2Vla2RheXMoKGR0KSA9PlxuICAgICAgICAgIHRoaXMuZXh0cmFjdChkdCwgaW50bCwgXCJ3ZWVrZGF5XCIpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53ZWVrZGF5c0NhY2hlW2Zvcm1hdFN0cl1bbGVuZ3RoXTtcbiAgICB9KTtcbiAgfVxuXG4gIG1lcmlkaWVtcyhkZWZhdWx0T0sgPSB0cnVlKSB7XG4gICAgcmV0dXJuIGxpc3RTdHVmZihcbiAgICAgIHRoaXMsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICBkZWZhdWx0T0ssXG4gICAgICAoKSA9PiBFbmdsaXNoLm1lcmlkaWVtcyxcbiAgICAgICgpID0+IHtcbiAgICAgICAgLy8gSW4gdGhlb3J5IHRoZXJlIGNvdWxkIGJlIGFyaWJpdHJhcnkgZGF5IHBlcmlvZHMuIFdlJ3JlIGdvbm5hIGFzc3VtZSB0aGVyZSBhcmUgZXhhY3RseSB0d29cbiAgICAgICAgLy8gZm9yIEFNIGFuZCBQTS4gVGhpcyBpcyBwcm9iYWJseSB3cm9uZywgYnV0IGl0J3MgbWFrZXMgcGFyc2luZyB3YXkgZWFzaWVyLlxuICAgICAgICBpZiAoIXRoaXMubWVyaWRpZW1DYWNoZSkge1xuICAgICAgICAgIGNvbnN0IGludGwgPSB7IGhvdXI6IFwibnVtZXJpY1wiLCBob3VyQ3ljbGU6IFwiaDEyXCIgfTtcbiAgICAgICAgICB0aGlzLm1lcmlkaWVtQ2FjaGUgPSBbRGF0ZVRpbWUudXRjKDIwMTYsIDExLCAxMywgOSksIERhdGVUaW1lLnV0YygyMDE2LCAxMSwgMTMsIDE5KV0ubWFwKFxuICAgICAgICAgICAgKGR0KSA9PiB0aGlzLmV4dHJhY3QoZHQsIGludGwsIFwiZGF5cGVyaW9kXCIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLm1lcmlkaWVtQ2FjaGU7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIGVyYXMobGVuZ3RoLCBkZWZhdWx0T0sgPSB0cnVlKSB7XG4gICAgcmV0dXJuIGxpc3RTdHVmZih0aGlzLCBsZW5ndGgsIGRlZmF1bHRPSywgRW5nbGlzaC5lcmFzLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbnRsID0geyBlcmE6IGxlbmd0aCB9O1xuXG4gICAgICAvLyBUaGlzIGlzIHByb2JsZW1hdGljLiBEaWZmZXJlbnQgY2FsZW5kYXJzIGFyZSBnb2luZyB0byBkZWZpbmUgZXJhcyB0b3RhbGx5IGRpZmZlcmVudGx5LiBXaGF0IEkgbmVlZCBpcyB0aGUgbWluaW11bSBzZXQgb2YgZGF0ZXNcbiAgICAgIC8vIHRvIGRlZmluaXRlbHkgZW51bWVyYXRlIHRoZW0uXG4gICAgICBpZiAoIXRoaXMuZXJhQ2FjaGVbbGVuZ3RoXSkge1xuICAgICAgICB0aGlzLmVyYUNhY2hlW2xlbmd0aF0gPSBbRGF0ZVRpbWUudXRjKC00MCwgMSwgMSksIERhdGVUaW1lLnV0YygyMDE3LCAxLCAxKV0ubWFwKChkdCkgPT5cbiAgICAgICAgICB0aGlzLmV4dHJhY3QoZHQsIGludGwsIFwiZXJhXCIpXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmVyYUNhY2hlW2xlbmd0aF07XG4gICAgfSk7XG4gIH1cblxuICBleHRyYWN0KGR0LCBpbnRsT3B0cywgZmllbGQpIHtcbiAgICBjb25zdCBkZiA9IHRoaXMuZHRGb3JtYXR0ZXIoZHQsIGludGxPcHRzKSxcbiAgICAgIHJlc3VsdHMgPSBkZi5mb3JtYXRUb1BhcnRzKCksXG4gICAgICBtYXRjaGluZyA9IHJlc3VsdHMuZmluZCgobSkgPT4gbS50eXBlLnRvTG93ZXJDYXNlKCkgPT09IGZpZWxkKTtcbiAgICByZXR1cm4gbWF0Y2hpbmcgPyBtYXRjaGluZy52YWx1ZSA6IG51bGw7XG4gIH1cblxuICBudW1iZXJGb3JtYXR0ZXIob3B0cyA9IHt9KSB7XG4gICAgLy8gdGhpcyBmb3JjZXNpbXBsZSBvcHRpb24gaXMgbmV2ZXIgdXNlZCAodGhlIG9ubHkgY2FsbGVyIHNob3J0LWNpcmN1aXRzIG9uIGl0LCBidXQgaXQgc2VlbXMgc2FmZXIgdG8gbGVhdmUpXG4gICAgLy8gKGluIGNvbnRyYXN0LCB0aGUgcmVzdCBvZiB0aGUgY29uZGl0aW9uIGlzIHVzZWQgaGVhdmlseSlcbiAgICByZXR1cm4gbmV3IFBvbHlOdW1iZXJGb3JtYXR0ZXIodGhpcy5pbnRsLCBvcHRzLmZvcmNlU2ltcGxlIHx8IHRoaXMuZmFzdE51bWJlcnMsIG9wdHMpO1xuICB9XG5cbiAgZHRGb3JtYXR0ZXIoZHQsIGludGxPcHRzID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFBvbHlEYXRlRm9ybWF0dGVyKGR0LCB0aGlzLmludGwsIGludGxPcHRzKTtcbiAgfVxuXG4gIHJlbEZvcm1hdHRlcihvcHRzID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFBvbHlSZWxGb3JtYXR0ZXIodGhpcy5pbnRsLCB0aGlzLmlzRW5nbGlzaCgpLCBvcHRzKTtcbiAgfVxuXG4gIGxpc3RGb3JtYXR0ZXIob3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIGdldENhY2hlZExGKHRoaXMuaW50bCwgb3B0cyk7XG4gIH1cblxuICBpc0VuZ2xpc2goKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMubG9jYWxlID09PSBcImVuXCIgfHxcbiAgICAgIHRoaXMubG9jYWxlLnRvTG93ZXJDYXNlKCkgPT09IFwiZW4tdXNcIiB8fFxuICAgICAgbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQodGhpcy5pbnRsKS5yZXNvbHZlZE9wdGlvbnMoKS5sb2NhbGUuc3RhcnRzV2l0aChcImVuLXVzXCIpXG4gICAgKTtcbiAgfVxuXG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmxvY2FsZSA9PT0gb3RoZXIubG9jYWxlICYmXG4gICAgICB0aGlzLm51bWJlcmluZ1N5c3RlbSA9PT0gb3RoZXIubnVtYmVyaW5nU3lzdGVtICYmXG4gICAgICB0aGlzLm91dHB1dENhbGVuZGFyID09PSBvdGhlci5vdXRwdXRDYWxlbmRhclxuICAgICk7XG4gIH1cbn1cbiIsImltcG9ydCB7IGZvcm1hdE9mZnNldCwgc2lnbmVkT2Zmc2V0IH0gZnJvbSBcIi4uL2ltcGwvdXRpbC5qc1wiO1xuaW1wb3J0IFpvbmUgZnJvbSBcIi4uL3pvbmUuanNcIjtcblxubGV0IHNpbmdsZXRvbiA9IG51bGw7XG5cbi8qKlxuICogQSB6b25lIHdpdGggYSBmaXhlZCBvZmZzZXQgKG1lYW5pbmcgbm8gRFNUKVxuICogQGltcGxlbWVudHMge1pvbmV9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpeGVkT2Zmc2V0Wm9uZSBleHRlbmRzIFpvbmUge1xuICAvKipcbiAgICogR2V0IGEgc2luZ2xldG9uIGluc3RhbmNlIG9mIFVUQ1xuICAgKiBAcmV0dXJuIHtGaXhlZE9mZnNldFpvbmV9XG4gICAqL1xuICBzdGF0aWMgZ2V0IHV0Y0luc3RhbmNlKCkge1xuICAgIGlmIChzaW5nbGV0b24gPT09IG51bGwpIHtcbiAgICAgIHNpbmdsZXRvbiA9IG5ldyBGaXhlZE9mZnNldFpvbmUoMCk7XG4gICAgfVxuICAgIHJldHVybiBzaW5nbGV0b247XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIGluc3RhbmNlIHdpdGggYSBzcGVjaWZpZWQgb2Zmc2V0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBUaGUgb2Zmc2V0IGluIG1pbnV0ZXNcbiAgICogQHJldHVybiB7Rml4ZWRPZmZzZXRab25lfVxuICAgKi9cbiAgc3RhdGljIGluc3RhbmNlKG9mZnNldCkge1xuICAgIHJldHVybiBvZmZzZXQgPT09IDAgPyBGaXhlZE9mZnNldFpvbmUudXRjSW5zdGFuY2UgOiBuZXcgRml4ZWRPZmZzZXRab25lKG9mZnNldCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIGluc3RhbmNlIG9mIEZpeGVkT2Zmc2V0Wm9uZSBmcm9tIGEgVVRDIG9mZnNldCBzdHJpbmcsIGxpa2UgXCJVVEMrNlwiXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzIC0gVGhlIG9mZnNldCBzdHJpbmcgdG8gcGFyc2VcbiAgICogQGV4YW1wbGUgRml4ZWRPZmZzZXRab25lLnBhcnNlU3BlY2lmaWVyKFwiVVRDKzZcIilcbiAgICogQGV4YW1wbGUgRml4ZWRPZmZzZXRab25lLnBhcnNlU3BlY2lmaWVyKFwiVVRDKzA2XCIpXG4gICAqIEBleGFtcGxlIEZpeGVkT2Zmc2V0Wm9uZS5wYXJzZVNwZWNpZmllcihcIlVUQy02OjAwXCIpXG4gICAqIEByZXR1cm4ge0ZpeGVkT2Zmc2V0Wm9uZX1cbiAgICovXG4gIHN0YXRpYyBwYXJzZVNwZWNpZmllcihzKSB7XG4gICAgaWYgKHMpIHtcbiAgICAgIGNvbnN0IHIgPSBzLm1hdGNoKC9edXRjKD86KFsrLV1cXGR7MSwyfSkoPzo6KFxcZHsyfSkpPyk/JC9pKTtcbiAgICAgIGlmIChyKSB7XG4gICAgICAgIHJldHVybiBuZXcgRml4ZWRPZmZzZXRab25lKHNpZ25lZE9mZnNldChyWzFdLCByWzJdKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3RydWN0b3Iob2Zmc2V0KSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKiogQHByaXZhdGUgKiovXG4gICAgdGhpcy5maXhlZCA9IG9mZnNldDtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiBcImZpeGVkXCI7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5maXhlZCA9PT0gMCA/IFwiVVRDXCIgOiBgVVRDJHtmb3JtYXRPZmZzZXQodGhpcy5maXhlZCwgXCJuYXJyb3dcIil9YDtcbiAgfVxuXG4gIGdldCBpYW5hTmFtZSgpIHtcbiAgICBpZiAodGhpcy5maXhlZCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFwiRXRjL1VUQ1wiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYEV0Yy9HTVQke2Zvcm1hdE9mZnNldCgtdGhpcy5maXhlZCwgXCJuYXJyb3dcIil9YDtcbiAgICB9XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBvZmZzZXROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBmb3JtYXRPZmZzZXQodHMsIGZvcm1hdCkge1xuICAgIHJldHVybiBmb3JtYXRPZmZzZXQodGhpcy5maXhlZCwgZm9ybWF0KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBpc1VuaXZlcnNhbCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIG9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5maXhlZDtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGVxdWFscyhvdGhlclpvbmUpIHtcbiAgICByZXR1cm4gb3RoZXJab25lLnR5cGUgPT09IFwiZml4ZWRcIiAmJiBvdGhlclpvbmUuZml4ZWQgPT09IHRoaXMuZml4ZWQ7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuIiwiaW1wb3J0IFpvbmUgZnJvbSBcIi4uL3pvbmUuanNcIjtcblxuLyoqXG4gKiBBIHpvbmUgdGhhdCBmYWlsZWQgdG8gcGFyc2UuIFlvdSBzaG91bGQgbmV2ZXIgbmVlZCB0byBpbnN0YW50aWF0ZSB0aGlzLlxuICogQGltcGxlbWVudHMge1pvbmV9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEludmFsaWRab25lIGV4dGVuZHMgWm9uZSB7XG4gIGNvbnN0cnVjdG9yKHpvbmVOYW1lKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKiogIEBwcml2YXRlICovXG4gICAgdGhpcy56b25lTmFtZSA9IHpvbmVOYW1lO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIFwiaW52YWxpZFwiO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuem9uZU5hbWU7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgaXNVbml2ZXJzYWwoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgb2Zmc2V0TmFtZSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGZvcm1hdE9mZnNldCgpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIG9mZnNldCgpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZXF1YWxzKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmltcG9ydCBab25lIGZyb20gXCIuLi96b25lLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4uL3pvbmVzL0lBTkFab25lLmpzXCI7XG5pbXBvcnQgRml4ZWRPZmZzZXRab25lIGZyb20gXCIuLi96b25lcy9maXhlZE9mZnNldFpvbmUuanNcIjtcbmltcG9ydCBJbnZhbGlkWm9uZSBmcm9tIFwiLi4vem9uZXMvaW52YWxpZFpvbmUuanNcIjtcblxuaW1wb3J0IHsgaXNVbmRlZmluZWQsIGlzU3RyaW5nLCBpc051bWJlciB9IGZyb20gXCIuL3V0aWwuanNcIjtcbmltcG9ydCBTeXN0ZW1ab25lIGZyb20gXCIuLi96b25lcy9zeXN0ZW1ab25lLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVab25lKGlucHV0LCBkZWZhdWx0Wm9uZSkge1xuICBsZXQgb2Zmc2V0O1xuICBpZiAoaXNVbmRlZmluZWQoaW5wdXQpIHx8IGlucHV0ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRab25lO1xuICB9IGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgWm9uZSkge1xuICAgIHJldHVybiBpbnB1dDtcbiAgfSBlbHNlIGlmIChpc1N0cmluZyhpbnB1dCkpIHtcbiAgICBjb25zdCBsb3dlcmVkID0gaW5wdXQudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobG93ZXJlZCA9PT0gXCJkZWZhdWx0XCIpIHJldHVybiBkZWZhdWx0Wm9uZTtcbiAgICBlbHNlIGlmIChsb3dlcmVkID09PSBcImxvY2FsXCIgfHwgbG93ZXJlZCA9PT0gXCJzeXN0ZW1cIikgcmV0dXJuIFN5c3RlbVpvbmUuaW5zdGFuY2U7XG4gICAgZWxzZSBpZiAobG93ZXJlZCA9PT0gXCJ1dGNcIiB8fCBsb3dlcmVkID09PSBcImdtdFwiKSByZXR1cm4gRml4ZWRPZmZzZXRab25lLnV0Y0luc3RhbmNlO1xuICAgIGVsc2UgcmV0dXJuIEZpeGVkT2Zmc2V0Wm9uZS5wYXJzZVNwZWNpZmllcihsb3dlcmVkKSB8fCBJQU5BWm9uZS5jcmVhdGUoaW5wdXQpO1xuICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlucHV0KSkge1xuICAgIHJldHVybiBGaXhlZE9mZnNldFpvbmUuaW5zdGFuY2UoaW5wdXQpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJvYmplY3RcIiAmJiBpbnB1dC5vZmZzZXQgJiYgdHlwZW9mIGlucHV0Lm9mZnNldCA9PT0gXCJudW1iZXJcIikge1xuICAgIC8vIFRoaXMgaXMgZHVtYiwgYnV0IHRoZSBpbnN0YW5jZW9mIGNoZWNrIGFib3ZlIGRvZXNuJ3Qgc2VlbSB0byByZWFsbHkgd29ya1xuICAgIC8vIHNvIHdlJ3JlIGR1Y2sgY2hlY2tpbmcgaXRcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBJbnZhbGlkWm9uZShpbnB1dCk7XG4gIH1cbn1cbiIsImltcG9ydCBTeXN0ZW1ab25lIGZyb20gXCIuL3pvbmVzL3N5c3RlbVpvbmUuanNcIjtcbmltcG9ydCBJQU5BWm9uZSBmcm9tIFwiLi96b25lcy9JQU5BWm9uZS5qc1wiO1xuaW1wb3J0IExvY2FsZSBmcm9tIFwiLi9pbXBsL2xvY2FsZS5qc1wiO1xuXG5pbXBvcnQgeyBub3JtYWxpemVab25lIH0gZnJvbSBcIi4vaW1wbC96b25lVXRpbC5qc1wiO1xuXG5sZXQgbm93ID0gKCkgPT4gRGF0ZS5ub3coKSxcbiAgZGVmYXVsdFpvbmUgPSBcInN5c3RlbVwiLFxuICBkZWZhdWx0TG9jYWxlID0gbnVsbCxcbiAgZGVmYXVsdE51bWJlcmluZ1N5c3RlbSA9IG51bGwsXG4gIGRlZmF1bHRPdXRwdXRDYWxlbmRhciA9IG51bGwsXG4gIHR3b0RpZ2l0Q3V0b2ZmWWVhciA9IDYwLFxuICB0aHJvd09uSW52YWxpZDtcblxuLyoqXG4gKiBTZXR0aW5ncyBjb250YWlucyBzdGF0aWMgZ2V0dGVycyBhbmQgc2V0dGVycyB0aGF0IGNvbnRyb2wgTHV4b24ncyBvdmVyYWxsIGJlaGF2aW9yLiBMdXhvbiBpcyBhIHNpbXBsZSBsaWJyYXJ5IHdpdGggZmV3IG9wdGlvbnMsIGJ1dCB0aGUgb25lcyBpdCBkb2VzIGhhdmUgbGl2ZSBoZXJlLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZXR0aW5ncyB7XG4gIC8qKlxuICAgKiBHZXQgdGhlIGNhbGxiYWNrIGZvciByZXR1cm5pbmcgdGhlIGN1cnJlbnQgdGltZXN0YW1wLlxuICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAqL1xuICBzdGF0aWMgZ2V0IG5vdygpIHtcbiAgICByZXR1cm4gbm93O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY2FsbGJhY2sgZm9yIHJldHVybmluZyB0aGUgY3VycmVudCB0aW1lc3RhbXAuXG4gICAqIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgbnVtYmVyLCB3aGljaCB3aWxsIGJlIGludGVycHJldGVkIGFzIGFuIEVwb2NoIG1pbGxpc2Vjb25kIGNvdW50XG4gICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICogQGV4YW1wbGUgU2V0dGluZ3Mubm93ID0gKCkgPT4gRGF0ZS5ub3coKSArIDMwMDAgLy8gcHJldGVuZCBpdCBpcyAzIHNlY29uZHMgaW4gdGhlIGZ1dHVyZVxuICAgKiBAZXhhbXBsZSBTZXR0aW5ncy5ub3cgPSAoKSA9PiAwIC8vIGFsd2F5cyBwcmV0ZW5kIGl0J3MgSmFuIDEsIDE5NzAgYXQgbWlkbmlnaHQgaW4gVVRDIHRpbWVcbiAgICovXG4gIHN0YXRpYyBzZXQgbm93KG4pIHtcbiAgICBub3cgPSBuO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZGVmYXVsdCB0aW1lIHpvbmUgdG8gY3JlYXRlIERhdGVUaW1lcyBpbi4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogVXNlIHRoZSB2YWx1ZSBcInN5c3RlbVwiIHRvIHJlc2V0IHRoaXMgdmFsdWUgdG8gdGhlIHN5c3RlbSdzIHRpbWUgem9uZS5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBzZXQgZGVmYXVsdFpvbmUoem9uZSkge1xuICAgIGRlZmF1bHRab25lID0gem9uZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRlZmF1bHQgdGltZSB6b25lIG9iamVjdCBjdXJyZW50bHkgdXNlZCB0byBjcmVhdGUgRGF0ZVRpbWVzLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0aGUgc3lzdGVtJ3MgdGltZSB6b25lICh0aGUgb25lIHNldCBvbiB0aGUgbWFjaGluZSB0aGF0IHJ1bnMgdGhpcyBjb2RlKS5cbiAgICogQHR5cGUge1pvbmV9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRab25lKCkge1xuICAgIHJldHVybiBub3JtYWxpemVab25lKGRlZmF1bHRab25lLCBTeXN0ZW1ab25lLmluc3RhbmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRlZmF1bHQgbG9jYWxlIHRvIGNyZWF0ZSBEYXRlVGltZXMgd2l0aC4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdExvY2FsZSgpIHtcbiAgICByZXR1cm4gZGVmYXVsdExvY2FsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGRlZmF1bHQgbG9jYWxlIHRvIGNyZWF0ZSBEYXRlVGltZXMgd2l0aC4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBzZXQgZGVmYXVsdExvY2FsZShsb2NhbGUpIHtcbiAgICBkZWZhdWx0TG9jYWxlID0gbG9jYWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGVmYXVsdCBudW1iZXJpbmcgc3lzdGVtIHRvIGNyZWF0ZSBEYXRlVGltZXMgd2l0aC4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdE51bWJlcmluZ1N5c3RlbSgpIHtcbiAgICByZXR1cm4gZGVmYXVsdE51bWJlcmluZ1N5c3RlbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGRlZmF1bHQgbnVtYmVyaW5nIHN5c3RlbSB0byBjcmVhdGUgRGF0ZVRpbWVzIHdpdGguIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgc2V0IGRlZmF1bHROdW1iZXJpbmdTeXN0ZW0obnVtYmVyaW5nU3lzdGVtKSB7XG4gICAgZGVmYXVsdE51bWJlcmluZ1N5c3RlbSA9IG51bWJlcmluZ1N5c3RlbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRlZmF1bHQgb3V0cHV0IGNhbGVuZGFyIHRvIGNyZWF0ZSBEYXRlVGltZXMgd2l0aC4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdE91dHB1dENhbGVuZGFyKCkge1xuICAgIHJldHVybiBkZWZhdWx0T3V0cHV0Q2FsZW5kYXI7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBkZWZhdWx0IG91dHB1dCBjYWxlbmRhciB0byBjcmVhdGUgRGF0ZVRpbWVzIHdpdGguIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgc2V0IGRlZmF1bHRPdXRwdXRDYWxlbmRhcihvdXRwdXRDYWxlbmRhcikge1xuICAgIGRlZmF1bHRPdXRwdXRDYWxlbmRhciA9IG91dHB1dENhbGVuZGFyO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3V0b2ZmIHllYXIgYWZ0ZXIgd2hpY2ggYSBzdHJpbmcgZW5jb2RpbmcgYSB5ZWFyIGFzIHR3byBkaWdpdHMgaXMgaW50ZXJwcmV0ZWQgdG8gb2NjdXIgaW4gdGhlIGN1cnJlbnQgY2VudHVyeS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgdHdvRGlnaXRDdXRvZmZZZWFyKCkge1xuICAgIHJldHVybiB0d29EaWdpdEN1dG9mZlllYXI7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBjdXRvZmYgeWVhciBhZnRlciB3aGljaCBhIHN0cmluZyBlbmNvZGluZyBhIHllYXIgYXMgdHdvIGRpZ2l0cyBpcyBpbnRlcnByZXRlZCB0byBvY2N1ciBpbiB0aGUgY3VycmVudCBjZW50dXJ5LlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZXhhbXBsZSBTZXR0aW5ncy50d29EaWdpdEN1dG9mZlllYXIgPSAwIC8vIGN1dC1vZmYgeWVhciBpcyAwLCBzbyBhbGwgJ3l5JyBhcmUgaW50ZXJwcmV0dGVkIGFzIGN1cnJlbnQgY2VudHVyeVxuICAgKiBAZXhhbXBsZSBTZXR0aW5ncy50d29EaWdpdEN1dG9mZlllYXIgPSA1MCAvLyAnNDknIC0+IDE5NDk7ICc1MCcgLT4gMjA1MFxuICAgKiBAZXhhbXBsZSBTZXR0aW5ncy50d29EaWdpdEN1dG9mZlllYXIgPSAxOTUwIC8vIGludGVycHJldHRlZCBhcyA1MFxuICAgKiBAZXhhbXBsZSBTZXR0aW5ncy50d29EaWdpdEN1dG9mZlllYXIgPSAyMDUwIC8vIEFMU08gaW50ZXJwcmV0dGVkIGFzIDUwXG4gICAqL1xuICBzdGF0aWMgc2V0IHR3b0RpZ2l0Q3V0b2ZmWWVhcihjdXRvZmZZZWFyKSB7XG4gICAgdHdvRGlnaXRDdXRvZmZZZWFyID0gY3V0b2ZmWWVhciAlIDEwMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgd2hldGhlciBMdXhvbiB3aWxsIHRocm93IHdoZW4gaXQgZW5jb3VudGVycyBpbnZhbGlkIERhdGVUaW1lcywgRHVyYXRpb25zLCBvciBJbnRlcnZhbHNcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgZ2V0IHRocm93T25JbnZhbGlkKCkge1xuICAgIHJldHVybiB0aHJvd09uSW52YWxpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgd2hldGhlciBMdXhvbiB3aWxsIHRocm93IHdoZW4gaXQgZW5jb3VudGVycyBpbnZhbGlkIERhdGVUaW1lcywgRHVyYXRpb25zLCBvciBJbnRlcnZhbHNcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgc2V0IHRocm93T25JbnZhbGlkKHQpIHtcbiAgICB0aHJvd09uSW52YWxpZCA9IHQ7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXQgTHV4b24ncyBnbG9iYWwgY2FjaGVzLiBTaG91bGQgb25seSBiZSBuZWNlc3NhcnkgaW4gdGVzdGluZyBzY2VuYXJpb3MuXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBzdGF0aWMgcmVzZXRDYWNoZXMoKSB7XG4gICAgTG9jYWxlLnJlc2V0Q2FjaGUoKTtcbiAgICBJQU5BWm9uZS5yZXNldENhY2hlKCk7XG4gIH1cbn1cbiIsIi8qXG4gIFRoaXMgaXMganVzdCBhIGp1bmsgZHJhd2VyLCBjb250YWluaW5nIGFueXRoaW5nIHVzZWQgYWNyb3NzIG11bHRpcGxlIGNsYXNzZXMuXG4gIEJlY2F1c2UgTHV4b24gaXMgc21hbGwoaXNoKSwgdGhpcyBzaG91bGQgc3RheSBzbWFsbCBhbmQgd2Ugd29uJ3Qgd29ycnkgYWJvdXQgc3BsaXR0aW5nXG4gIGl0IHVwIGludG8sIHNheSwgcGFyc2luZ1V0aWwuanMgYW5kIGJhc2ljVXRpbC5qcyBhbmQgc28gb24uIEJ1dCB0aGV5IGFyZSBkaXZpZGVkIHVwIGJ5IGZlYXR1cmUgYXJlYS5cbiovXG5cbmltcG9ydCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gZnJvbSBcIi4uL2Vycm9ycy5qc1wiO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gXCIuLi9zZXR0aW5ncy5qc1wiO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuLy8gVFlQRVNcblxuZXhwb3J0IGZ1bmN0aW9uIGlzVW5kZWZpbmVkKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSBcInVuZGVmaW5lZFwiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09IFwibnVtYmVyXCI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0ludGVnZXIobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09IFwibnVtYmVyXCIgJiYgbyAlIDEgPT09IDA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyhvKSB7XG4gIHJldHVybiB0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRGF0ZShvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09IFwiW29iamVjdCBEYXRlXVwiO1xufVxuXG4vLyBDQVBBQklMSVRJRVNcblxuZXhwb3J0IGZ1bmN0aW9uIGhhc1JlbGF0aXZlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB0eXBlb2YgSW50bCAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhIUludGwuUmVsYXRpdmVUaW1lRm9ybWF0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIE9CSkVDVFMgQU5EIEFSUkFZU1xuXG5leHBvcnQgZnVuY3Rpb24gbWF5YmVBcnJheSh0aGluZykge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh0aGluZykgPyB0aGluZyA6IFt0aGluZ107XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiZXN0QnkoYXJyLCBieSwgY29tcGFyZSkge1xuICBpZiAoYXJyLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIGFyci5yZWR1Y2UoKGJlc3QsIG5leHQpID0+IHtcbiAgICBjb25zdCBwYWlyID0gW2J5KG5leHQpLCBuZXh0XTtcbiAgICBpZiAoIWJlc3QpIHtcbiAgICAgIHJldHVybiBwYWlyO1xuICAgIH0gZWxzZSBpZiAoY29tcGFyZShiZXN0WzBdLCBwYWlyWzBdKSA9PT0gYmVzdFswXSkge1xuICAgICAgcmV0dXJuIGJlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwYWlyO1xuICAgIH1cbiAgfSwgbnVsbClbMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwaWNrKG9iaiwga2V5cykge1xuICByZXR1cm4ga2V5cy5yZWR1Y2UoKGEsIGspID0+IHtcbiAgICBhW2tdID0gb2JqW2tdO1xuICAgIHJldHVybiBhO1xuICB9LCB7fSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG4vLyBOVU1CRVJTIEFORCBTVFJJTkdTXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnRlZ2VyQmV0d2Vlbih0aGluZywgYm90dG9tLCB0b3ApIHtcbiAgcmV0dXJuIGlzSW50ZWdlcih0aGluZykgJiYgdGhpbmcgPj0gYm90dG9tICYmIHRoaW5nIDw9IHRvcDtcbn1cblxuLy8geCAlIG4gYnV0IHRha2VzIHRoZSBzaWduIG9mIG4gaW5zdGVhZCBvZiB4XG5leHBvcnQgZnVuY3Rpb24gZmxvb3JNb2QoeCwgbikge1xuICByZXR1cm4geCAtIG4gKiBNYXRoLmZsb29yKHggLyBuKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhZFN0YXJ0KGlucHV0LCBuID0gMikge1xuICBjb25zdCBpc05lZyA9IGlucHV0IDwgMDtcbiAgbGV0IHBhZGRlZDtcbiAgaWYgKGlzTmVnKSB7XG4gICAgcGFkZGVkID0gXCItXCIgKyAoXCJcIiArIC1pbnB1dCkucGFkU3RhcnQobiwgXCIwXCIpO1xuICB9IGVsc2Uge1xuICAgIHBhZGRlZCA9IChcIlwiICsgaW5wdXQpLnBhZFN0YXJ0KG4sIFwiMFwiKTtcbiAgfVxuICByZXR1cm4gcGFkZGVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VJbnRlZ2VyKHN0cmluZykge1xuICBpZiAoaXNVbmRlZmluZWQoc3RyaW5nKSB8fCBzdHJpbmcgPT09IG51bGwgfHwgc3RyaW5nID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGFyc2VJbnQoc3RyaW5nLCAxMCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRmxvYXRpbmcoc3RyaW5nKSB7XG4gIGlmIChpc1VuZGVmaW5lZChzdHJpbmcpIHx8IHN0cmluZyA9PT0gbnVsbCB8fCBzdHJpbmcgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHN0cmluZyk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlTWlsbGlzKGZyYWN0aW9uKSB7XG4gIC8vIFJldHVybiB1bmRlZmluZWQgKGluc3RlYWQgb2YgMCkgaW4gdGhlc2UgY2FzZXMsIHdoZXJlIGZyYWN0aW9uIGlzIG5vdCBzZXRcbiAgaWYgKGlzVW5kZWZpbmVkKGZyYWN0aW9uKSB8fCBmcmFjdGlvbiA9PT0gbnVsbCB8fCBmcmFjdGlvbiA9PT0gXCJcIikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZiA9IHBhcnNlRmxvYXQoXCIwLlwiICsgZnJhY3Rpb24pICogMTAwMDtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihmKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcm91bmRUbyhudW1iZXIsIGRpZ2l0cywgdG93YXJkWmVybyA9IGZhbHNlKSB7XG4gIGNvbnN0IGZhY3RvciA9IDEwICoqIGRpZ2l0cyxcbiAgICByb3VuZGVyID0gdG93YXJkWmVybyA/IE1hdGgudHJ1bmMgOiBNYXRoLnJvdW5kO1xuICByZXR1cm4gcm91bmRlcihudW1iZXIgKiBmYWN0b3IpIC8gZmFjdG9yO1xufVxuXG4vLyBEQVRFIEJBU0lDU1xuXG5leHBvcnQgZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gIHJldHVybiB5ZWFyICUgNCA9PT0gMCAmJiAoeWVhciAlIDEwMCAhPT0gMCB8fCB5ZWFyICUgNDAwID09PSAwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRheXNJblllYXIoeWVhcikge1xuICByZXR1cm4gaXNMZWFwWWVhcih5ZWFyKSA/IDM2NiA6IDM2NTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gIGNvbnN0IG1vZE1vbnRoID0gZmxvb3JNb2QobW9udGggLSAxLCAxMikgKyAxLFxuICAgIG1vZFllYXIgPSB5ZWFyICsgKG1vbnRoIC0gbW9kTW9udGgpIC8gMTI7XG5cbiAgaWYgKG1vZE1vbnRoID09PSAyKSB7XG4gICAgcmV0dXJuIGlzTGVhcFllYXIobW9kWWVhcikgPyAyOSA6IDI4O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbMzEsIG51bGwsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXVttb2RNb250aCAtIDFdO1xuICB9XG59XG5cbi8vIGNvdmVydCBhIGNhbGVuZGFyIG9iamVjdCB0byBhIGxvY2FsIHRpbWVzdGFtcCAoZXBvY2gsIGJ1dCB3aXRoIHRoZSBvZmZzZXQgYmFrZWQgaW4pXG5leHBvcnQgZnVuY3Rpb24gb2JqVG9Mb2NhbFRTKG9iaikge1xuICBsZXQgZCA9IERhdGUuVVRDKFxuICAgIG9iai55ZWFyLFxuICAgIG9iai5tb250aCAtIDEsXG4gICAgb2JqLmRheSxcbiAgICBvYmouaG91cixcbiAgICBvYmoubWludXRlLFxuICAgIG9iai5zZWNvbmQsXG4gICAgb2JqLm1pbGxpc2Vjb25kXG4gICk7XG5cbiAgLy8gZm9yIGxlZ2FjeSByZWFzb25zLCB5ZWFycyBiZXR3ZWVuIDAgYW5kIDk5IGFyZSBpbnRlcnByZXRlZCBhcyAxOVhYOyByZXZlcnQgdGhhdFxuICBpZiAob2JqLnllYXIgPCAxMDAgJiYgb2JqLnllYXIgPj0gMCkge1xuICAgIGQgPSBuZXcgRGF0ZShkKTtcbiAgICBkLnNldFVUQ0Z1bGxZZWFyKGQuZ2V0VVRDRnVsbFllYXIoKSAtIDE5MDApO1xuICB9XG4gIHJldHVybiArZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdlZWtzSW5XZWVrWWVhcih3ZWVrWWVhcikge1xuICBjb25zdCBwMSA9XG4gICAgICAod2Vla1llYXIgK1xuICAgICAgICBNYXRoLmZsb29yKHdlZWtZZWFyIC8gNCkgLVxuICAgICAgICBNYXRoLmZsb29yKHdlZWtZZWFyIC8gMTAwKSArXG4gICAgICAgIE1hdGguZmxvb3Iod2Vla1llYXIgLyA0MDApKSAlXG4gICAgICA3LFxuICAgIGxhc3QgPSB3ZWVrWWVhciAtIDEsXG4gICAgcDIgPSAobGFzdCArIE1hdGguZmxvb3IobGFzdCAvIDQpIC0gTWF0aC5mbG9vcihsYXN0IC8gMTAwKSArIE1hdGguZmxvb3IobGFzdCAvIDQwMCkpICUgNztcbiAgcmV0dXJuIHAxID09PSA0IHx8IHAyID09PSAzID8gNTMgOiA1Mjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVudHJ1bmNhdGVZZWFyKHllYXIpIHtcbiAgaWYgKHllYXIgPiA5OSkge1xuICAgIHJldHVybiB5ZWFyO1xuICB9IGVsc2UgcmV0dXJuIHllYXIgPiBTZXR0aW5ncy50d29EaWdpdEN1dG9mZlllYXIgPyAxOTAwICsgeWVhciA6IDIwMDAgKyB5ZWFyO1xufVxuXG4vLyBQQVJTSU5HXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVpvbmVJbmZvKHRzLCBvZmZzZXRGb3JtYXQsIGxvY2FsZSwgdGltZVpvbmUgPSBudWxsKSB7XG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh0cyksXG4gICAgaW50bE9wdHMgPSB7XG4gICAgICBob3VyQ3ljbGU6IFwiaDIzXCIsXG4gICAgICB5ZWFyOiBcIm51bWVyaWNcIixcbiAgICAgIG1vbnRoOiBcIjItZGlnaXRcIixcbiAgICAgIGRheTogXCIyLWRpZ2l0XCIsXG4gICAgICBob3VyOiBcIjItZGlnaXRcIixcbiAgICAgIG1pbnV0ZTogXCIyLWRpZ2l0XCIsXG4gICAgfTtcblxuICBpZiAodGltZVpvbmUpIHtcbiAgICBpbnRsT3B0cy50aW1lWm9uZSA9IHRpbWVab25lO1xuICB9XG5cbiAgY29uc3QgbW9kaWZpZWQgPSB7IHRpbWVab25lTmFtZTogb2Zmc2V0Rm9ybWF0LCAuLi5pbnRsT3B0cyB9O1xuXG4gIGNvbnN0IHBhcnNlZCA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwgbW9kaWZpZWQpXG4gICAgLmZvcm1hdFRvUGFydHMoZGF0ZSlcbiAgICAuZmluZCgobSkgPT4gbS50eXBlLnRvTG93ZXJDYXNlKCkgPT09IFwidGltZXpvbmVuYW1lXCIpO1xuICByZXR1cm4gcGFyc2VkID8gcGFyc2VkLnZhbHVlIDogbnVsbDtcbn1cblxuLy8gc2lnbmVkT2Zmc2V0KCctNScsICczMCcpIC0+IC0zMzBcbmV4cG9ydCBmdW5jdGlvbiBzaWduZWRPZmZzZXQob2ZmSG91clN0ciwgb2ZmTWludXRlU3RyKSB7XG4gIGxldCBvZmZIb3VyID0gcGFyc2VJbnQob2ZmSG91clN0ciwgMTApO1xuXG4gIC8vIGRvbid0IHx8IHRoaXMgYmVjYXVzZSB3ZSB3YW50IHRvIHByZXNlcnZlIC0wXG4gIGlmIChOdW1iZXIuaXNOYU4ob2ZmSG91cikpIHtcbiAgICBvZmZIb3VyID0gMDtcbiAgfVxuXG4gIGNvbnN0IG9mZk1pbiA9IHBhcnNlSW50KG9mZk1pbnV0ZVN0ciwgMTApIHx8IDAsXG4gICAgb2ZmTWluU2lnbmVkID0gb2ZmSG91ciA8IDAgfHwgT2JqZWN0LmlzKG9mZkhvdXIsIC0wKSA/IC1vZmZNaW4gOiBvZmZNaW47XG4gIHJldHVybiBvZmZIb3VyICogNjAgKyBvZmZNaW5TaWduZWQ7XG59XG5cbi8vIENPRVJDSU9OXG5cbmV4cG9ydCBmdW5jdGlvbiBhc051bWJlcih2YWx1ZSkge1xuICBjb25zdCBudW1lcmljVmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIiB8fCB2YWx1ZSA9PT0gXCJcIiB8fCBOdW1iZXIuaXNOYU4obnVtZXJpY1ZhbHVlKSlcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoYEludmFsaWQgdW5pdCB2YWx1ZSAke3ZhbHVlfWApO1xuICByZXR1cm4gbnVtZXJpY1ZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplT2JqZWN0KG9iaiwgbm9ybWFsaXplcikge1xuICBjb25zdCBub3JtYWxpemVkID0ge307XG4gIGZvciAoY29uc3QgdSBpbiBvYmopIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkob2JqLCB1KSkge1xuICAgICAgY29uc3QgdiA9IG9ialt1XTtcbiAgICAgIGlmICh2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbCkgY29udGludWU7XG4gICAgICBub3JtYWxpemVkW25vcm1hbGl6ZXIodSldID0gYXNOdW1iZXIodik7XG4gICAgfVxuICB9XG4gIHJldHVybiBub3JtYWxpemVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0T2Zmc2V0KG9mZnNldCwgZm9ybWF0KSB7XG4gIGNvbnN0IGhvdXJzID0gTWF0aC50cnVuYyhNYXRoLmFicyhvZmZzZXQgLyA2MCkpLFxuICAgIG1pbnV0ZXMgPSBNYXRoLnRydW5jKE1hdGguYWJzKG9mZnNldCAlIDYwKSksXG4gICAgc2lnbiA9IG9mZnNldCA+PSAwID8gXCIrXCIgOiBcIi1cIjtcblxuICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgIGNhc2UgXCJzaG9ydFwiOlxuICAgICAgcmV0dXJuIGAke3NpZ259JHtwYWRTdGFydChob3VycywgMil9OiR7cGFkU3RhcnQobWludXRlcywgMil9YDtcbiAgICBjYXNlIFwibmFycm93XCI6XG4gICAgICByZXR1cm4gYCR7c2lnbn0ke2hvdXJzfSR7bWludXRlcyA+IDAgPyBgOiR7bWludXRlc31gIDogXCJcIn1gO1xuICAgIGNhc2UgXCJ0ZWNoaWVcIjpcbiAgICAgIHJldHVybiBgJHtzaWdufSR7cGFkU3RhcnQoaG91cnMsIDIpfSR7cGFkU3RhcnQobWludXRlcywgMil9YDtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFZhbHVlIGZvcm1hdCAke2Zvcm1hdH0gaXMgb3V0IG9mIHJhbmdlIGZvciBwcm9wZXJ0eSBmb3JtYXRgKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdGltZU9iamVjdChvYmopIHtcbiAgcmV0dXJuIHBpY2sob2JqLCBbXCJob3VyXCIsIFwibWludXRlXCIsIFwic2Vjb25kXCIsIFwibWlsbGlzZWNvbmRcIl0pO1xufVxuIiwiaW1wb3J0ICogYXMgRm9ybWF0cyBmcm9tIFwiLi9mb3JtYXRzLmpzXCI7XG5pbXBvcnQgeyBwaWNrIH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuXG5mdW5jdGlvbiBzdHJpbmdpZnkob2JqKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmosIE9iamVjdC5rZXlzKG9iaikuc29ydCgpKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydCBjb25zdCBtb250aHNMb25nID0gW1xuICBcIkphbnVhcnlcIixcbiAgXCJGZWJydWFyeVwiLFxuICBcIk1hcmNoXCIsXG4gIFwiQXByaWxcIixcbiAgXCJNYXlcIixcbiAgXCJKdW5lXCIsXG4gIFwiSnVseVwiLFxuICBcIkF1Z3VzdFwiLFxuICBcIlNlcHRlbWJlclwiLFxuICBcIk9jdG9iZXJcIixcbiAgXCJOb3ZlbWJlclwiLFxuICBcIkRlY2VtYmVyXCIsXG5dO1xuXG5leHBvcnQgY29uc3QgbW9udGhzU2hvcnQgPSBbXG4gIFwiSmFuXCIsXG4gIFwiRmViXCIsXG4gIFwiTWFyXCIsXG4gIFwiQXByXCIsXG4gIFwiTWF5XCIsXG4gIFwiSnVuXCIsXG4gIFwiSnVsXCIsXG4gIFwiQXVnXCIsXG4gIFwiU2VwXCIsXG4gIFwiT2N0XCIsXG4gIFwiTm92XCIsXG4gIFwiRGVjXCIsXG5dO1xuXG5leHBvcnQgY29uc3QgbW9udGhzTmFycm93ID0gW1wiSlwiLCBcIkZcIiwgXCJNXCIsIFwiQVwiLCBcIk1cIiwgXCJKXCIsIFwiSlwiLCBcIkFcIiwgXCJTXCIsIFwiT1wiLCBcIk5cIiwgXCJEXCJdO1xuXG5leHBvcnQgZnVuY3Rpb24gbW9udGhzKGxlbmd0aCkge1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgXCJuYXJyb3dcIjpcbiAgICAgIHJldHVybiBbLi4ubW9udGhzTmFycm93XTtcbiAgICBjYXNlIFwic2hvcnRcIjpcbiAgICAgIHJldHVybiBbLi4ubW9udGhzU2hvcnRdO1xuICAgIGNhc2UgXCJsb25nXCI6XG4gICAgICByZXR1cm4gWy4uLm1vbnRoc0xvbmddO1xuICAgIGNhc2UgXCJudW1lcmljXCI6XG4gICAgICByZXR1cm4gW1wiMVwiLCBcIjJcIiwgXCIzXCIsIFwiNFwiLCBcIjVcIiwgXCI2XCIsIFwiN1wiLCBcIjhcIiwgXCI5XCIsIFwiMTBcIiwgXCIxMVwiLCBcIjEyXCJdO1xuICAgIGNhc2UgXCIyLWRpZ2l0XCI6XG4gICAgICByZXR1cm4gW1wiMDFcIiwgXCIwMlwiLCBcIjAzXCIsIFwiMDRcIiwgXCIwNVwiLCBcIjA2XCIsIFwiMDdcIiwgXCIwOFwiLCBcIjA5XCIsIFwiMTBcIiwgXCIxMVwiLCBcIjEyXCJdO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgd2Vla2RheXNMb25nID0gW1xuICBcIk1vbmRheVwiLFxuICBcIlR1ZXNkYXlcIixcbiAgXCJXZWRuZXNkYXlcIixcbiAgXCJUaHVyc2RheVwiLFxuICBcIkZyaWRheVwiLFxuICBcIlNhdHVyZGF5XCIsXG4gIFwiU3VuZGF5XCIsXG5dO1xuXG5leHBvcnQgY29uc3Qgd2Vla2RheXNTaG9ydCA9IFtcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiLCBcIlN1blwiXTtcblxuZXhwb3J0IGNvbnN0IHdlZWtkYXlzTmFycm93ID0gW1wiTVwiLCBcIlRcIiwgXCJXXCIsIFwiVFwiLCBcIkZcIiwgXCJTXCIsIFwiU1wiXTtcblxuZXhwb3J0IGZ1bmN0aW9uIHdlZWtkYXlzKGxlbmd0aCkge1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgXCJuYXJyb3dcIjpcbiAgICAgIHJldHVybiBbLi4ud2Vla2RheXNOYXJyb3ddO1xuICAgIGNhc2UgXCJzaG9ydFwiOlxuICAgICAgcmV0dXJuIFsuLi53ZWVrZGF5c1Nob3J0XTtcbiAgICBjYXNlIFwibG9uZ1wiOlxuICAgICAgcmV0dXJuIFsuLi53ZWVrZGF5c0xvbmddO1xuICAgIGNhc2UgXCJudW1lcmljXCI6XG4gICAgICByZXR1cm4gW1wiMVwiLCBcIjJcIiwgXCIzXCIsIFwiNFwiLCBcIjVcIiwgXCI2XCIsIFwiN1wiXTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IG1lcmlkaWVtcyA9IFtcIkFNXCIsIFwiUE1cIl07XG5cbmV4cG9ydCBjb25zdCBlcmFzTG9uZyA9IFtcIkJlZm9yZSBDaHJpc3RcIiwgXCJBbm5vIERvbWluaVwiXTtcblxuZXhwb3J0IGNvbnN0IGVyYXNTaG9ydCA9IFtcIkJDXCIsIFwiQURcIl07XG5cbmV4cG9ydCBjb25zdCBlcmFzTmFycm93ID0gW1wiQlwiLCBcIkFcIl07XG5cbmV4cG9ydCBmdW5jdGlvbiBlcmFzKGxlbmd0aCkge1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgXCJuYXJyb3dcIjpcbiAgICAgIHJldHVybiBbLi4uZXJhc05hcnJvd107XG4gICAgY2FzZSBcInNob3J0XCI6XG4gICAgICByZXR1cm4gWy4uLmVyYXNTaG9ydF07XG4gICAgY2FzZSBcImxvbmdcIjpcbiAgICAgIHJldHVybiBbLi4uZXJhc0xvbmddO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVyaWRpZW1Gb3JEYXRlVGltZShkdCkge1xuICByZXR1cm4gbWVyaWRpZW1zW2R0LmhvdXIgPCAxMiA/IDAgOiAxXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdlZWtkYXlGb3JEYXRlVGltZShkdCwgbGVuZ3RoKSB7XG4gIHJldHVybiB3ZWVrZGF5cyhsZW5ndGgpW2R0LndlZWtkYXkgLSAxXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1vbnRoRm9yRGF0ZVRpbWUoZHQsIGxlbmd0aCkge1xuICByZXR1cm4gbW9udGhzKGxlbmd0aClbZHQubW9udGggLSAxXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVyYUZvckRhdGVUaW1lKGR0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGVyYXMobGVuZ3RoKVtkdC55ZWFyIDwgMCA/IDAgOiAxXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFJlbGF0aXZlVGltZSh1bml0LCBjb3VudCwgbnVtZXJpYyA9IFwiYWx3YXlzXCIsIG5hcnJvdyA9IGZhbHNlKSB7XG4gIGNvbnN0IHVuaXRzID0ge1xuICAgIHllYXJzOiBbXCJ5ZWFyXCIsIFwieXIuXCJdLFxuICAgIHF1YXJ0ZXJzOiBbXCJxdWFydGVyXCIsIFwicXRyLlwiXSxcbiAgICBtb250aHM6IFtcIm1vbnRoXCIsIFwibW8uXCJdLFxuICAgIHdlZWtzOiBbXCJ3ZWVrXCIsIFwid2suXCJdLFxuICAgIGRheXM6IFtcImRheVwiLCBcImRheVwiLCBcImRheXNcIl0sXG4gICAgaG91cnM6IFtcImhvdXJcIiwgXCJoci5cIl0sXG4gICAgbWludXRlczogW1wibWludXRlXCIsIFwibWluLlwiXSxcbiAgICBzZWNvbmRzOiBbXCJzZWNvbmRcIiwgXCJzZWMuXCJdLFxuICB9O1xuXG4gIGNvbnN0IGxhc3RhYmxlID0gW1wiaG91cnNcIiwgXCJtaW51dGVzXCIsIFwic2Vjb25kc1wiXS5pbmRleE9mKHVuaXQpID09PSAtMTtcblxuICBpZiAobnVtZXJpYyA9PT0gXCJhdXRvXCIgJiYgbGFzdGFibGUpIHtcbiAgICBjb25zdCBpc0RheSA9IHVuaXQgPT09IFwiZGF5c1wiO1xuICAgIHN3aXRjaCAoY291bnQpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIGlzRGF5ID8gXCJ0b21vcnJvd1wiIDogYG5leHQgJHt1bml0c1t1bml0XVswXX1gO1xuICAgICAgY2FzZSAtMTpcbiAgICAgICAgcmV0dXJuIGlzRGF5ID8gXCJ5ZXN0ZXJkYXlcIiA6IGBsYXN0ICR7dW5pdHNbdW5pdF1bMF19YDtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIGlzRGF5ID8gXCJ0b2RheVwiIDogYHRoaXMgJHt1bml0c1t1bml0XVswXX1gO1xuICAgICAgZGVmYXVsdDogLy8gZmFsbCB0aHJvdWdoXG4gICAgfVxuICB9XG5cbiAgY29uc3QgaXNJblBhc3QgPSBPYmplY3QuaXMoY291bnQsIC0wKSB8fCBjb3VudCA8IDAsXG4gICAgZm10VmFsdWUgPSBNYXRoLmFicyhjb3VudCksXG4gICAgc2luZ3VsYXIgPSBmbXRWYWx1ZSA9PT0gMSxcbiAgICBsaWxVbml0cyA9IHVuaXRzW3VuaXRdLFxuICAgIGZtdFVuaXQgPSBuYXJyb3dcbiAgICAgID8gc2luZ3VsYXJcbiAgICAgICAgPyBsaWxVbml0c1sxXVxuICAgICAgICA6IGxpbFVuaXRzWzJdIHx8IGxpbFVuaXRzWzFdXG4gICAgICA6IHNpbmd1bGFyXG4gICAgICA/IHVuaXRzW3VuaXRdWzBdXG4gICAgICA6IHVuaXQ7XG4gIHJldHVybiBpc0luUGFzdCA/IGAke2ZtdFZhbHVlfSAke2ZtdFVuaXR9IGFnb2AgOiBgaW4gJHtmbXRWYWx1ZX0gJHtmbXRVbml0fWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRTdHJpbmcoa25vd25Gb3JtYXQpIHtcbiAgLy8gdGhlc2UgYWxsIGhhdmUgdGhlIG9mZnNldHMgcmVtb3ZlZCBiZWNhdXNlIHdlIGRvbid0IGhhdmUgYWNjZXNzIHRvIHRoZW1cbiAgLy8gd2l0aG91dCBhbGwgdGhlIGludGwgc3R1ZmYgdGhpcyBpcyBiYWNrZmlsbGluZ1xuICBjb25zdCBmaWx0ZXJlZCA9IHBpY2soa25vd25Gb3JtYXQsIFtcbiAgICAgIFwid2Vla2RheVwiLFxuICAgICAgXCJlcmFcIixcbiAgICAgIFwieWVhclwiLFxuICAgICAgXCJtb250aFwiLFxuICAgICAgXCJkYXlcIixcbiAgICAgIFwiaG91clwiLFxuICAgICAgXCJtaW51dGVcIixcbiAgICAgIFwic2Vjb25kXCIsXG4gICAgICBcInRpbWVab25lTmFtZVwiLFxuICAgICAgXCJob3VyQ3ljbGVcIixcbiAgICBdKSxcbiAgICBrZXkgPSBzdHJpbmdpZnkoZmlsdGVyZWQpLFxuICAgIGRhdGVUaW1lSHVnZSA9IFwiRUVFRSwgTExMTCBkLCB5eXl5LCBoOm1tIGFcIjtcbiAgc3dpdGNoIChrZXkpIHtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVfU0hPUlQpOlxuICAgICAgcmV0dXJuIFwiTS9kL3l5eXlcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVfTUVEKTpcbiAgICAgIHJldHVybiBcIkxMTCBkLCB5eXl5XCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFX01FRF9XSVRIX1dFRUtEQVkpOlxuICAgICAgcmV0dXJuIFwiRUVFLCBMTEwgZCwgeXl5eVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURV9GVUxMKTpcbiAgICAgIHJldHVybiBcIkxMTEwgZCwgeXl5eVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURV9IVUdFKTpcbiAgICAgIHJldHVybiBcIkVFRUUsIExMTEwgZCwgeXl5eVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV9TSU1QTEUpOlxuICAgICAgcmV0dXJuIFwiaDptbSBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FX1dJVEhfU0VDT05EUyk6XG4gICAgICByZXR1cm4gXCJoOm1tOnNzIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfV0lUSF9TSE9SVF9PRkZTRVQpOlxuICAgICAgcmV0dXJuIFwiaDptbSBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FX1dJVEhfTE9OR19PRkZTRVQpOlxuICAgICAgcmV0dXJuIFwiaDptbSBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FXzI0X1NJTVBMRSk6XG4gICAgICByZXR1cm4gXCJISDptbVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV8yNF9XSVRIX1NFQ09ORFMpOlxuICAgICAgcmV0dXJuIFwiSEg6bW06c3NcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfMjRfV0lUSF9TSE9SVF9PRkZTRVQpOlxuICAgICAgcmV0dXJuIFwiSEg6bW1cIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfMjRfV0lUSF9MT05HX09GRlNFVCk6XG4gICAgICByZXR1cm4gXCJISDptbVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfU0hPUlQpOlxuICAgICAgcmV0dXJuIFwiTS9kL3l5eXksIGg6bW0gYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfTUVEKTpcbiAgICAgIHJldHVybiBcIkxMTCBkLCB5eXl5LCBoOm1tIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX0ZVTEwpOlxuICAgICAgcmV0dXJuIFwiTExMTCBkLCB5eXl5LCBoOm1tIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX0hVR0UpOlxuICAgICAgcmV0dXJuIGRhdGVUaW1lSHVnZTtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX1NIT1JUX1dJVEhfU0VDT05EUyk6XG4gICAgICByZXR1cm4gXCJNL2QveXl5eSwgaDptbTpzcyBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9NRURfV0lUSF9TRUNPTkRTKTpcbiAgICAgIHJldHVybiBcIkxMTCBkLCB5eXl5LCBoOm1tOnNzIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX01FRF9XSVRIX1dFRUtEQVkpOlxuICAgICAgcmV0dXJuIFwiRUVFLCBkIExMTCB5eXl5LCBoOm1tIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX0ZVTExfV0lUSF9TRUNPTkRTKTpcbiAgICAgIHJldHVybiBcIkxMTEwgZCwgeXl5eSwgaDptbTpzcyBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9IVUdFX1dJVEhfU0VDT05EUyk6XG4gICAgICByZXR1cm4gXCJFRUVFLCBMTExMIGQsIHl5eXksIGg6bW06c3MgYVwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZGF0ZVRpbWVIdWdlO1xuICB9XG59XG4iLCJpbXBvcnQgKiBhcyBFbmdsaXNoIGZyb20gXCIuL2VuZ2xpc2guanNcIjtcbmltcG9ydCAqIGFzIEZvcm1hdHMgZnJvbSBcIi4vZm9ybWF0cy5qc1wiO1xuaW1wb3J0IHsgcGFkU3RhcnQgfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVRva2VucyhzcGxpdHMsIHRva2VuVG9TdHJpbmcpIHtcbiAgbGV0IHMgPSBcIlwiO1xuICBmb3IgKGNvbnN0IHRva2VuIG9mIHNwbGl0cykge1xuICAgIGlmICh0b2tlbi5saXRlcmFsKSB7XG4gICAgICBzICs9IHRva2VuLnZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcyArPSB0b2tlblRvU3RyaW5nKHRva2VuLnZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzO1xufVxuXG5jb25zdCBtYWNyb1Rva2VuVG9Gb3JtYXRPcHRzID0ge1xuICBEOiBGb3JtYXRzLkRBVEVfU0hPUlQsXG4gIEREOiBGb3JtYXRzLkRBVEVfTUVELFxuICBEREQ6IEZvcm1hdHMuREFURV9GVUxMLFxuICBEREREOiBGb3JtYXRzLkRBVEVfSFVHRSxcbiAgdDogRm9ybWF0cy5USU1FX1NJTVBMRSxcbiAgdHQ6IEZvcm1hdHMuVElNRV9XSVRIX1NFQ09ORFMsXG4gIHR0dDogRm9ybWF0cy5USU1FX1dJVEhfU0hPUlRfT0ZGU0VULFxuICB0dHR0OiBGb3JtYXRzLlRJTUVfV0lUSF9MT05HX09GRlNFVCxcbiAgVDogRm9ybWF0cy5USU1FXzI0X1NJTVBMRSxcbiAgVFQ6IEZvcm1hdHMuVElNRV8yNF9XSVRIX1NFQ09ORFMsXG4gIFRUVDogRm9ybWF0cy5USU1FXzI0X1dJVEhfU0hPUlRfT0ZGU0VULFxuICBUVFRUOiBGb3JtYXRzLlRJTUVfMjRfV0lUSF9MT05HX09GRlNFVCxcbiAgZjogRm9ybWF0cy5EQVRFVElNRV9TSE9SVCxcbiAgZmY6IEZvcm1hdHMuREFURVRJTUVfTUVELFxuICBmZmY6IEZvcm1hdHMuREFURVRJTUVfRlVMTCxcbiAgZmZmZjogRm9ybWF0cy5EQVRFVElNRV9IVUdFLFxuICBGOiBGb3JtYXRzLkRBVEVUSU1FX1NIT1JUX1dJVEhfU0VDT05EUyxcbiAgRkY6IEZvcm1hdHMuREFURVRJTUVfTUVEX1dJVEhfU0VDT05EUyxcbiAgRkZGOiBGb3JtYXRzLkRBVEVUSU1FX0ZVTExfV0lUSF9TRUNPTkRTLFxuICBGRkZGOiBGb3JtYXRzLkRBVEVUSU1FX0hVR0VfV0lUSF9TRUNPTkRTLFxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZvcm1hdHRlciB7XG4gIHN0YXRpYyBjcmVhdGUobG9jYWxlLCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gbmV3IEZvcm1hdHRlcihsb2NhbGUsIG9wdHMpO1xuICB9XG5cbiAgc3RhdGljIHBhcnNlRm9ybWF0KGZtdCkge1xuICAgIGxldCBjdXJyZW50ID0gbnVsbCxcbiAgICAgIGN1cnJlbnRGdWxsID0gXCJcIixcbiAgICAgIGJyYWNrZXRlZCA9IGZhbHNlO1xuICAgIGNvbnN0IHNwbGl0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZm10Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjID0gZm10LmNoYXJBdChpKTtcbiAgICAgIGlmIChjID09PSBcIidcIikge1xuICAgICAgICBpZiAoY3VycmVudEZ1bGwubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHNwbGl0cy5wdXNoKHsgbGl0ZXJhbDogYnJhY2tldGVkLCB2YWw6IGN1cnJlbnRGdWxsIH0pO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBudWxsO1xuICAgICAgICBjdXJyZW50RnVsbCA9IFwiXCI7XG4gICAgICAgIGJyYWNrZXRlZCA9ICFicmFja2V0ZWQ7XG4gICAgICB9IGVsc2UgaWYgKGJyYWNrZXRlZCkge1xuICAgICAgICBjdXJyZW50RnVsbCArPSBjO1xuICAgICAgfSBlbHNlIGlmIChjID09PSBjdXJyZW50KSB7XG4gICAgICAgIGN1cnJlbnRGdWxsICs9IGM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY3VycmVudEZ1bGwubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHNwbGl0cy5wdXNoKHsgbGl0ZXJhbDogZmFsc2UsIHZhbDogY3VycmVudEZ1bGwgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEZ1bGwgPSBjO1xuICAgICAgICBjdXJyZW50ID0gYztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY3VycmVudEZ1bGwubGVuZ3RoID4gMCkge1xuICAgICAgc3BsaXRzLnB1c2goeyBsaXRlcmFsOiBicmFja2V0ZWQsIHZhbDogY3VycmVudEZ1bGwgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNwbGl0cztcbiAgfVxuXG4gIHN0YXRpYyBtYWNyb1Rva2VuVG9Gb3JtYXRPcHRzKHRva2VuKSB7XG4gICAgcmV0dXJuIG1hY3JvVG9rZW5Ub0Zvcm1hdE9wdHNbdG9rZW5dO1xuICB9XG5cbiAgY29uc3RydWN0b3IobG9jYWxlLCBmb3JtYXRPcHRzKSB7XG4gICAgdGhpcy5vcHRzID0gZm9ybWF0T3B0cztcbiAgICB0aGlzLmxvYyA9IGxvY2FsZTtcbiAgICB0aGlzLnN5c3RlbUxvYyA9IG51bGw7XG4gIH1cblxuICBmb3JtYXRXaXRoU3lzdGVtRGVmYXVsdChkdCwgb3B0cykge1xuICAgIGlmICh0aGlzLnN5c3RlbUxvYyA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5zeXN0ZW1Mb2MgPSB0aGlzLmxvYy5yZWRlZmF1bHRUb1N5c3RlbSgpO1xuICAgIH1cbiAgICBjb25zdCBkZiA9IHRoaXMuc3lzdGVtTG9jLmR0Rm9ybWF0dGVyKGR0LCB7IC4uLnRoaXMub3B0cywgLi4ub3B0cyB9KTtcbiAgICByZXR1cm4gZGYuZm9ybWF0KCk7XG4gIH1cblxuICBmb3JtYXREYXRlVGltZShkdCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgZGYgPSB0aGlzLmxvYy5kdEZvcm1hdHRlcihkdCwgeyAuLi50aGlzLm9wdHMsIC4uLm9wdHMgfSk7XG4gICAgcmV0dXJuIGRmLmZvcm1hdCgpO1xuICB9XG5cbiAgZm9ybWF0RGF0ZVRpbWVQYXJ0cyhkdCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgZGYgPSB0aGlzLmxvYy5kdEZvcm1hdHRlcihkdCwgeyAuLi50aGlzLm9wdHMsIC4uLm9wdHMgfSk7XG4gICAgcmV0dXJuIGRmLmZvcm1hdFRvUGFydHMoKTtcbiAgfVxuXG4gIGZvcm1hdEludGVydmFsKGludGVydmFsLCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBkZiA9IHRoaXMubG9jLmR0Rm9ybWF0dGVyKGludGVydmFsLnN0YXJ0LCB7IC4uLnRoaXMub3B0cywgLi4ub3B0cyB9KTtcbiAgICByZXR1cm4gZGYuZHRmLmZvcm1hdFJhbmdlKGludGVydmFsLnN0YXJ0LnRvSlNEYXRlKCksIGludGVydmFsLmVuZC50b0pTRGF0ZSgpKTtcbiAgfVxuXG4gIHJlc29sdmVkT3B0aW9ucyhkdCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgZGYgPSB0aGlzLmxvYy5kdEZvcm1hdHRlcihkdCwgeyAuLi50aGlzLm9wdHMsIC4uLm9wdHMgfSk7XG4gICAgcmV0dXJuIGRmLnJlc29sdmVkT3B0aW9ucygpO1xuICB9XG5cbiAgbnVtKG4sIHAgPSAwKSB7XG4gICAgLy8gd2UgZ2V0IHNvbWUgcGVyZiBvdXQgb2YgZG9pbmcgdGhpcyBoZXJlLCBhbm5veWluZ2x5XG4gICAgaWYgKHRoaXMub3B0cy5mb3JjZVNpbXBsZSkge1xuICAgICAgcmV0dXJuIHBhZFN0YXJ0KG4sIHApO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdHMgPSB7IC4uLnRoaXMub3B0cyB9O1xuXG4gICAgaWYgKHAgPiAwKSB7XG4gICAgICBvcHRzLnBhZFRvID0gcDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5sb2MubnVtYmVyRm9ybWF0dGVyKG9wdHMpLmZvcm1hdChuKTtcbiAgfVxuXG4gIGZvcm1hdERhdGVUaW1lRnJvbVN0cmluZyhkdCwgZm10KSB7XG4gICAgY29uc3Qga25vd25FbmdsaXNoID0gdGhpcy5sb2MubGlzdGluZ01vZGUoKSA9PT0gXCJlblwiLFxuICAgICAgdXNlRGF0ZVRpbWVGb3JtYXR0ZXIgPSB0aGlzLmxvYy5vdXRwdXRDYWxlbmRhciAmJiB0aGlzLmxvYy5vdXRwdXRDYWxlbmRhciAhPT0gXCJncmVnb3J5XCIsXG4gICAgICBzdHJpbmcgPSAob3B0cywgZXh0cmFjdCkgPT4gdGhpcy5sb2MuZXh0cmFjdChkdCwgb3B0cywgZXh0cmFjdCksXG4gICAgICBmb3JtYXRPZmZzZXQgPSAob3B0cykgPT4ge1xuICAgICAgICBpZiAoZHQuaXNPZmZzZXRGaXhlZCAmJiBkdC5vZmZzZXQgPT09IDAgJiYgb3B0cy5hbGxvd1opIHtcbiAgICAgICAgICByZXR1cm4gXCJaXCI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZHQuaXNWYWxpZCA/IGR0LnpvbmUuZm9ybWF0T2Zmc2V0KGR0LnRzLCBvcHRzLmZvcm1hdCkgOiBcIlwiO1xuICAgICAgfSxcbiAgICAgIG1lcmlkaWVtID0gKCkgPT5cbiAgICAgICAga25vd25FbmdsaXNoXG4gICAgICAgICAgPyBFbmdsaXNoLm1lcmlkaWVtRm9yRGF0ZVRpbWUoZHQpXG4gICAgICAgICAgOiBzdHJpbmcoeyBob3VyOiBcIm51bWVyaWNcIiwgaG91ckN5Y2xlOiBcImgxMlwiIH0sIFwiZGF5cGVyaW9kXCIpLFxuICAgICAgbW9udGggPSAobGVuZ3RoLCBzdGFuZGFsb25lKSA9PlxuICAgICAgICBrbm93bkVuZ2xpc2hcbiAgICAgICAgICA/IEVuZ2xpc2gubW9udGhGb3JEYXRlVGltZShkdCwgbGVuZ3RoKVxuICAgICAgICAgIDogc3RyaW5nKHN0YW5kYWxvbmUgPyB7IG1vbnRoOiBsZW5ndGggfSA6IHsgbW9udGg6IGxlbmd0aCwgZGF5OiBcIm51bWVyaWNcIiB9LCBcIm1vbnRoXCIpLFxuICAgICAgd2Vla2RheSA9IChsZW5ndGgsIHN0YW5kYWxvbmUpID0+XG4gICAgICAgIGtub3duRW5nbGlzaFxuICAgICAgICAgID8gRW5nbGlzaC53ZWVrZGF5Rm9yRGF0ZVRpbWUoZHQsIGxlbmd0aClcbiAgICAgICAgICA6IHN0cmluZyhcbiAgICAgICAgICAgICAgc3RhbmRhbG9uZSA/IHsgd2Vla2RheTogbGVuZ3RoIH0gOiB7IHdlZWtkYXk6IGxlbmd0aCwgbW9udGg6IFwibG9uZ1wiLCBkYXk6IFwibnVtZXJpY1wiIH0sXG4gICAgICAgICAgICAgIFwid2Vla2RheVwiXG4gICAgICAgICAgICApLFxuICAgICAgbWF5YmVNYWNybyA9ICh0b2tlbikgPT4ge1xuICAgICAgICBjb25zdCBmb3JtYXRPcHRzID0gRm9ybWF0dGVyLm1hY3JvVG9rZW5Ub0Zvcm1hdE9wdHModG9rZW4pO1xuICAgICAgICBpZiAoZm9ybWF0T3B0cykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdFdpdGhTeXN0ZW1EZWZhdWx0KGR0LCBmb3JtYXRPcHRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBlcmEgPSAobGVuZ3RoKSA9PlxuICAgICAgICBrbm93bkVuZ2xpc2ggPyBFbmdsaXNoLmVyYUZvckRhdGVUaW1lKGR0LCBsZW5ndGgpIDogc3RyaW5nKHsgZXJhOiBsZW5ndGggfSwgXCJlcmFcIiksXG4gICAgICB0b2tlblRvU3RyaW5nID0gKHRva2VuKSA9PiB7XG4gICAgICAgIC8vIFdoZXJlIHBvc3NpYmxlOiBodHRwOi8vY2xkci51bmljb2RlLm9yZy90cmFuc2xhdGlvbi9kYXRlLXRpbWUtMS9kYXRlLXRpbWUjVE9DLVN0YW5kYWxvbmUtdnMuLUZvcm1hdC1TdHlsZXNcbiAgICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAgIC8vIG1zXG4gICAgICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5taWxsaXNlY29uZCk7XG4gICAgICAgICAgY2FzZSBcInVcIjpcbiAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgICAgY2FzZSBcIlNTU1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0Lm1pbGxpc2Vjb25kLCAzKTtcbiAgICAgICAgICAvLyBzZWNvbmRzXG4gICAgICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5zZWNvbmQpO1xuICAgICAgICAgIGNhc2UgXCJzc1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LnNlY29uZCwgMik7XG4gICAgICAgICAgLy8gZnJhY3Rpb25hbCBzZWNvbmRzXG4gICAgICAgICAgY2FzZSBcInV1XCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oTWF0aC5mbG9vcihkdC5taWxsaXNlY29uZCAvIDEwKSwgMik7XG4gICAgICAgICAgY2FzZSBcInV1dVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKE1hdGguZmxvb3IoZHQubWlsbGlzZWNvbmQgLyAxMDApKTtcbiAgICAgICAgICAvLyBtaW51dGVzXG4gICAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5taW51dGUpO1xuICAgICAgICAgIGNhc2UgXCJtbVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0Lm1pbnV0ZSwgMik7XG4gICAgICAgICAgLy8gaG91cnNcbiAgICAgICAgICBjYXNlIFwiaFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LmhvdXIgJSAxMiA9PT0gMCA/IDEyIDogZHQuaG91ciAlIDEyKTtcbiAgICAgICAgICBjYXNlIFwiaGhcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5ob3VyICUgMTIgPT09IDAgPyAxMiA6IGR0LmhvdXIgJSAxMiwgMik7XG4gICAgICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5ob3VyKTtcbiAgICAgICAgICBjYXNlIFwiSEhcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5ob3VyLCAyKTtcbiAgICAgICAgICAvLyBvZmZzZXRcbiAgICAgICAgICBjYXNlIFwiWlwiOlxuICAgICAgICAgICAgLy8gbGlrZSArNlxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE9mZnNldCh7IGZvcm1hdDogXCJuYXJyb3dcIiwgYWxsb3daOiB0aGlzLm9wdHMuYWxsb3daIH0pO1xuICAgICAgICAgIGNhc2UgXCJaWlwiOlxuICAgICAgICAgICAgLy8gbGlrZSArMDY6MDBcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRPZmZzZXQoeyBmb3JtYXQ6IFwic2hvcnRcIiwgYWxsb3daOiB0aGlzLm9wdHMuYWxsb3daIH0pO1xuICAgICAgICAgIGNhc2UgXCJaWlpcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgKzA2MDBcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRPZmZzZXQoeyBmb3JtYXQ6IFwidGVjaGllXCIsIGFsbG93WjogdGhpcy5vcHRzLmFsbG93WiB9KTtcbiAgICAgICAgICBjYXNlIFwiWlpaWlwiOlxuICAgICAgICAgICAgLy8gbGlrZSBFU1RcbiAgICAgICAgICAgIHJldHVybiBkdC56b25lLm9mZnNldE5hbWUoZHQudHMsIHsgZm9ybWF0OiBcInNob3J0XCIsIGxvY2FsZTogdGhpcy5sb2MubG9jYWxlIH0pO1xuICAgICAgICAgIGNhc2UgXCJaWlpaWlwiOlxuICAgICAgICAgICAgLy8gbGlrZSBFYXN0ZXJuIFN0YW5kYXJkIFRpbWVcbiAgICAgICAgICAgIHJldHVybiBkdC56b25lLm9mZnNldE5hbWUoZHQudHMsIHsgZm9ybWF0OiBcImxvbmdcIiwgbG9jYWxlOiB0aGlzLmxvYy5sb2NhbGUgfSk7XG4gICAgICAgICAgLy8gem9uZVxuICAgICAgICAgIGNhc2UgXCJ6XCI6XG4gICAgICAgICAgICAvLyBsaWtlIEFtZXJpY2EvTmV3X1lvcmtcbiAgICAgICAgICAgIHJldHVybiBkdC56b25lTmFtZTtcbiAgICAgICAgICAvLyBtZXJpZGllbXNcbiAgICAgICAgICBjYXNlIFwiYVwiOlxuICAgICAgICAgICAgcmV0dXJuIG1lcmlkaWVtKCk7XG4gICAgICAgICAgLy8gZGF0ZXNcbiAgICAgICAgICBjYXNlIFwiZFwiOlxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyID8gc3RyaW5nKHsgZGF5OiBcIm51bWVyaWNcIiB9LCBcImRheVwiKSA6IHRoaXMubnVtKGR0LmRheSk7XG4gICAgICAgICAgY2FzZSBcImRkXCI6XG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXIgPyBzdHJpbmcoeyBkYXk6IFwiMi1kaWdpdFwiIH0sIFwiZGF5XCIpIDogdGhpcy5udW0oZHQuZGF5LCAyKTtcbiAgICAgICAgICAvLyB3ZWVrZGF5cyAtIHN0YW5kYWxvbmVcbiAgICAgICAgICBjYXNlIFwiY1wiOlxuICAgICAgICAgICAgLy8gbGlrZSAxXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQud2Vla2RheSk7XG4gICAgICAgICAgY2FzZSBcImNjY1wiOlxuICAgICAgICAgICAgLy8gbGlrZSAnVHVlcydcbiAgICAgICAgICAgIHJldHVybiB3ZWVrZGF5KFwic2hvcnRcIiwgdHJ1ZSk7XG4gICAgICAgICAgY2FzZSBcImNjY2NcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgJ1R1ZXNkYXknXG4gICAgICAgICAgICByZXR1cm4gd2Vla2RheShcImxvbmdcIiwgdHJ1ZSk7XG4gICAgICAgICAgY2FzZSBcImNjY2NjXCI6XG4gICAgICAgICAgICAvLyBsaWtlICdUJ1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtkYXkoXCJuYXJyb3dcIiwgdHJ1ZSk7XG4gICAgICAgICAgLy8gd2Vla2RheXMgLSBmb3JtYXRcbiAgICAgICAgICBjYXNlIFwiRVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAxXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQud2Vla2RheSk7XG4gICAgICAgICAgY2FzZSBcIkVFRVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAnVHVlcydcbiAgICAgICAgICAgIHJldHVybiB3ZWVrZGF5KFwic2hvcnRcIiwgZmFsc2UpO1xuICAgICAgICAgIGNhc2UgXCJFRUVFXCI6XG4gICAgICAgICAgICAvLyBsaWtlICdUdWVzZGF5J1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtkYXkoXCJsb25nXCIsIGZhbHNlKTtcbiAgICAgICAgICBjYXNlIFwiRUVFRUVcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgJ1QnXG4gICAgICAgICAgICByZXR1cm4gd2Vla2RheShcIm5hcnJvd1wiLCBmYWxzZSk7XG4gICAgICAgICAgLy8gbW9udGhzIC0gc3RhbmRhbG9uZVxuICAgICAgICAgIGNhc2UgXCJMXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDFcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlclxuICAgICAgICAgICAgICA/IHN0cmluZyh7IG1vbnRoOiBcIm51bWVyaWNcIiwgZGF5OiBcIm51bWVyaWNcIiB9LCBcIm1vbnRoXCIpXG4gICAgICAgICAgICAgIDogdGhpcy5udW0oZHQubW9udGgpO1xuICAgICAgICAgIGNhc2UgXCJMTFwiOlxuICAgICAgICAgICAgLy8gbGlrZSAwMSwgZG9lc24ndCBzZWVtIHRvIHdvcmtcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlclxuICAgICAgICAgICAgICA/IHN0cmluZyh7IG1vbnRoOiBcIjItZGlnaXRcIiwgZGF5OiBcIm51bWVyaWNcIiB9LCBcIm1vbnRoXCIpXG4gICAgICAgICAgICAgIDogdGhpcy5udW0oZHQubW9udGgsIDIpO1xuICAgICAgICAgIGNhc2UgXCJMTExcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgSmFuXG4gICAgICAgICAgICByZXR1cm4gbW9udGgoXCJzaG9ydFwiLCB0cnVlKTtcbiAgICAgICAgICBjYXNlIFwiTExMTFwiOlxuICAgICAgICAgICAgLy8gbGlrZSBKYW51YXJ5XG4gICAgICAgICAgICByZXR1cm4gbW9udGgoXCJsb25nXCIsIHRydWUpO1xuICAgICAgICAgIGNhc2UgXCJMTExMTFwiOlxuICAgICAgICAgICAgLy8gbGlrZSBKXG4gICAgICAgICAgICByZXR1cm4gbW9udGgoXCJuYXJyb3dcIiwgdHJ1ZSk7XG4gICAgICAgICAgLy8gbW9udGhzIC0gZm9ybWF0XG4gICAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMVxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyXG4gICAgICAgICAgICAgID8gc3RyaW5nKHsgbW9udGg6IFwibnVtZXJpY1wiIH0sIFwibW9udGhcIilcbiAgICAgICAgICAgICAgOiB0aGlzLm51bShkdC5tb250aCk7XG4gICAgICAgICAgY2FzZSBcIk1NXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDAxXG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXJcbiAgICAgICAgICAgICAgPyBzdHJpbmcoeyBtb250aDogXCIyLWRpZ2l0XCIgfSwgXCJtb250aFwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0Lm1vbnRoLCAyKTtcbiAgICAgICAgICBjYXNlIFwiTU1NXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEphblxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoKFwic2hvcnRcIiwgZmFsc2UpO1xuICAgICAgICAgIGNhc2UgXCJNTU1NXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEphbnVhcnlcbiAgICAgICAgICAgIHJldHVybiBtb250aChcImxvbmdcIiwgZmFsc2UpO1xuICAgICAgICAgIGNhc2UgXCJNTU1NTVwiOlxuICAgICAgICAgICAgLy8gbGlrZSBKXG4gICAgICAgICAgICByZXR1cm4gbW9udGgoXCJuYXJyb3dcIiwgZmFsc2UpO1xuICAgICAgICAgIC8vIHllYXJzXG4gICAgICAgICAgY2FzZSBcInlcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMjAxNFxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyID8gc3RyaW5nKHsgeWVhcjogXCJudW1lcmljXCIgfSwgXCJ5ZWFyXCIpIDogdGhpcy5udW0oZHQueWVhcik7XG4gICAgICAgICAgY2FzZSBcInl5XCI6XG4gICAgICAgICAgICAvLyBsaWtlIDE0XG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXJcbiAgICAgICAgICAgICAgPyBzdHJpbmcoeyB5ZWFyOiBcIjItZGlnaXRcIiB9LCBcInllYXJcIilcbiAgICAgICAgICAgICAgOiB0aGlzLm51bShkdC55ZWFyLnRvU3RyaW5nKCkuc2xpY2UoLTIpLCAyKTtcbiAgICAgICAgICBjYXNlIFwieXl5eVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAwMDEyXG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXJcbiAgICAgICAgICAgICAgPyBzdHJpbmcoeyB5ZWFyOiBcIm51bWVyaWNcIiB9LCBcInllYXJcIilcbiAgICAgICAgICAgICAgOiB0aGlzLm51bShkdC55ZWFyLCA0KTtcbiAgICAgICAgICBjYXNlIFwieXl5eXl5XCI6XG4gICAgICAgICAgICAvLyBsaWtlIDAwMDAxMlxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyXG4gICAgICAgICAgICAgID8gc3RyaW5nKHsgeWVhcjogXCJudW1lcmljXCIgfSwgXCJ5ZWFyXCIpXG4gICAgICAgICAgICAgIDogdGhpcy5udW0oZHQueWVhciwgNik7XG4gICAgICAgICAgLy8gZXJhc1xuICAgICAgICAgIGNhc2UgXCJHXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEFEXG4gICAgICAgICAgICByZXR1cm4gZXJhKFwic2hvcnRcIik7XG4gICAgICAgICAgY2FzZSBcIkdHXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEFubm8gRG9taW5pXG4gICAgICAgICAgICByZXR1cm4gZXJhKFwibG9uZ1wiKTtcbiAgICAgICAgICBjYXNlIFwiR0dHR0dcIjpcbiAgICAgICAgICAgIHJldHVybiBlcmEoXCJuYXJyb3dcIik7XG4gICAgICAgICAgY2FzZSBcImtrXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQud2Vla1llYXIudG9TdHJpbmcoKS5zbGljZSgtMiksIDIpO1xuICAgICAgICAgIGNhc2UgXCJra2trXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQud2Vla1llYXIsIDQpO1xuICAgICAgICAgIGNhc2UgXCJXXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQud2Vla051bWJlcik7XG4gICAgICAgICAgY2FzZSBcIldXXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQud2Vla051bWJlciwgMik7XG4gICAgICAgICAgY2FzZSBcIm9cIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5vcmRpbmFsKTtcbiAgICAgICAgICBjYXNlIFwib29vXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQub3JkaW5hbCwgMyk7XG4gICAgICAgICAgY2FzZSBcInFcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LnF1YXJ0ZXIpO1xuICAgICAgICAgIGNhc2UgXCJxcVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAwMVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LnF1YXJ0ZXIsIDIpO1xuICAgICAgICAgIGNhc2UgXCJYXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oTWF0aC5mbG9vcihkdC50cyAvIDEwMDApKTtcbiAgICAgICAgICBjYXNlIFwieFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LnRzKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG1heWJlTWFjcm8odG9rZW4pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgcmV0dXJuIHN0cmluZ2lmeVRva2VucyhGb3JtYXR0ZXIucGFyc2VGb3JtYXQoZm10KSwgdG9rZW5Ub1N0cmluZyk7XG4gIH1cblxuICBmb3JtYXREdXJhdGlvbkZyb21TdHJpbmcoZHVyLCBmbXQpIHtcbiAgICBjb25zdCB0b2tlblRvRmllbGQgPSAodG9rZW4pID0+IHtcbiAgICAgICAgc3dpdGNoICh0b2tlblswXSkge1xuICAgICAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJtaWxsaXNlY29uZFwiO1xuICAgICAgICAgIGNhc2UgXCJzXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJzZWNvbmRcIjtcbiAgICAgICAgICBjYXNlIFwibVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwibWludXRlXCI7XG4gICAgICAgICAgY2FzZSBcImhcIjpcbiAgICAgICAgICAgIHJldHVybiBcImhvdXJcIjtcbiAgICAgICAgICBjYXNlIFwiZFwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZGF5XCI7XG4gICAgICAgICAgY2FzZSBcIndcIjpcbiAgICAgICAgICAgIHJldHVybiBcIndlZWtcIjtcbiAgICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwibW9udGhcIjtcbiAgICAgICAgICBjYXNlIFwieVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwieWVhclwiO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRva2VuVG9TdHJpbmcgPSAobGlsZHVyKSA9PiAodG9rZW4pID0+IHtcbiAgICAgICAgY29uc3QgbWFwcGVkID0gdG9rZW5Ub0ZpZWxkKHRva2VuKTtcbiAgICAgICAgaWYgKG1hcHBlZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm51bShsaWxkdXIuZ2V0KG1hcHBlZCksIHRva2VuLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdG9rZW5zID0gRm9ybWF0dGVyLnBhcnNlRm9ybWF0KGZtdCksXG4gICAgICByZWFsVG9rZW5zID0gdG9rZW5zLnJlZHVjZShcbiAgICAgICAgKGZvdW5kLCB7IGxpdGVyYWwsIHZhbCB9KSA9PiAobGl0ZXJhbCA/IGZvdW5kIDogZm91bmQuY29uY2F0KHZhbCkpLFxuICAgICAgICBbXVxuICAgICAgKSxcbiAgICAgIGNvbGxhcHNlZCA9IGR1ci5zaGlmdFRvKC4uLnJlYWxUb2tlbnMubWFwKHRva2VuVG9GaWVsZCkuZmlsdGVyKCh0KSA9PiB0KSk7XG4gICAgcmV0dXJuIHN0cmluZ2lmeVRva2Vucyh0b2tlbnMsIHRva2VuVG9TdHJpbmcoY29sbGFwc2VkKSk7XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIEludmFsaWQge1xuICBjb25zdHJ1Y3RvcihyZWFzb24sIGV4cGxhbmF0aW9uKSB7XG4gICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gICAgdGhpcy5leHBsYW5hdGlvbiA9IGV4cGxhbmF0aW9uO1xuICB9XG5cbiAgdG9NZXNzYWdlKCkge1xuICAgIGlmICh0aGlzLmV4cGxhbmF0aW9uKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5yZWFzb259OiAke3RoaXMuZXhwbGFuYXRpb259YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucmVhc29uO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgdW50cnVuY2F0ZVllYXIsXG4gIHNpZ25lZE9mZnNldCxcbiAgcGFyc2VJbnRlZ2VyLFxuICBwYXJzZU1pbGxpcyxcbiAgaXNVbmRlZmluZWQsXG4gIHBhcnNlRmxvYXRpbmcsXG59IGZyb20gXCIuL3V0aWwuanNcIjtcbmltcG9ydCAqIGFzIEVuZ2xpc2ggZnJvbSBcIi4vZW5nbGlzaC5qc1wiO1xuaW1wb3J0IEZpeGVkT2Zmc2V0Wm9uZSBmcm9tIFwiLi4vem9uZXMvZml4ZWRPZmZzZXRab25lLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4uL3pvbmVzL0lBTkFab25lLmpzXCI7XG5cbi8qXG4gKiBUaGlzIGZpbGUgaGFuZGxlcyBwYXJzaW5nIGZvciB3ZWxsLXNwZWNpZmllZCBmb3JtYXRzLiBIZXJlJ3MgaG93IGl0IHdvcmtzOlxuICogVHdvIHRoaW5ncyBnbyBpbnRvIHBhcnNpbmc6IGEgcmVnZXggdG8gbWF0Y2ggd2l0aCBhbmQgYW4gZXh0cmFjdG9yIHRvIHRha2UgYXBhcnQgdGhlIGdyb3VwcyBpbiB0aGUgbWF0Y2guXG4gKiBBbiBleHRyYWN0b3IgaXMganVzdCBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSByZWdleCBtYXRjaCBhcnJheSBhbmQgcmV0dXJucyBhIHsgeWVhcjogLi4uLCBtb250aDogLi4uIH0gb2JqZWN0XG4gKiBwYXJzZSgpIGRvZXMgdGhlIHdvcmsgb2YgZXhlY3V0aW5nIHRoZSByZWdleCBhbmQgYXBwbHlpbmcgdGhlIGV4dHJhY3Rvci4gSXQgdGFrZXMgbXVsdGlwbGUgcmVnZXgvZXh0cmFjdG9yIHBhaXJzIHRvIHRyeSBpbiBzZXF1ZW5jZS5cbiAqIEV4dHJhY3RvcnMgY2FuIHRha2UgYSBcImN1cnNvclwiIHJlcHJlc2VudGluZyB0aGUgb2Zmc2V0IGluIHRoZSBtYXRjaCB0byBsb29rIGF0LiBUaGlzIG1ha2VzIGl0IGVhc3kgdG8gY29tYmluZSBleHRyYWN0b3JzLlxuICogY29tYmluZUV4dHJhY3RvcnMoKSBkb2VzIHRoZSB3b3JrIG9mIGNvbWJpbmluZyB0aGVtLCBrZWVwaW5nIHRyYWNrIG9mIHRoZSBjdXJzb3IgdGhyb3VnaCBtdWx0aXBsZSBleHRyYWN0aW9ucy5cbiAqIFNvbWUgZXh0cmFjdGlvbnMgYXJlIHN1cGVyIGR1bWIgYW5kIHNpbXBsZVBhcnNlIGFuZCBmcm9tU3RyaW5ncyBoZWxwIERSWSB0aGVtLlxuICovXG5cbmNvbnN0IGlhbmFSZWdleCA9IC9bQS1aYS16XystXXsxLDI1Nn0oPzo6P1xcL1tBLVphLXowLTlfKy1dezEsMjU2fSg/OlxcL1tBLVphLXowLTlfKy1dezEsMjU2fSk/KT8vO1xuXG5mdW5jdGlvbiBjb21iaW5lUmVnZXhlcyguLi5yZWdleGVzKSB7XG4gIGNvbnN0IGZ1bGwgPSByZWdleGVzLnJlZHVjZSgoZiwgcikgPT4gZiArIHIuc291cmNlLCBcIlwiKTtcbiAgcmV0dXJuIFJlZ0V4cChgXiR7ZnVsbH0kYCk7XG59XG5cbmZ1bmN0aW9uIGNvbWJpbmVFeHRyYWN0b3JzKC4uLmV4dHJhY3RvcnMpIHtcbiAgcmV0dXJuIChtKSA9PlxuICAgIGV4dHJhY3RvcnNcbiAgICAgIC5yZWR1Y2UoXG4gICAgICAgIChbbWVyZ2VkVmFscywgbWVyZ2VkWm9uZSwgY3Vyc29yXSwgZXgpID0+IHtcbiAgICAgICAgICBjb25zdCBbdmFsLCB6b25lLCBuZXh0XSA9IGV4KG0sIGN1cnNvcik7XG4gICAgICAgICAgcmV0dXJuIFt7IC4uLm1lcmdlZFZhbHMsIC4uLnZhbCB9LCB6b25lIHx8IG1lcmdlZFpvbmUsIG5leHRdO1xuICAgICAgICB9LFxuICAgICAgICBbe30sIG51bGwsIDFdXG4gICAgICApXG4gICAgICAuc2xpY2UoMCwgMik7XG59XG5cbmZ1bmN0aW9uIHBhcnNlKHMsIC4uLnBhdHRlcm5zKSB7XG4gIGlmIChzID09IG51bGwpIHtcbiAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICB9XG5cbiAgZm9yIChjb25zdCBbcmVnZXgsIGV4dHJhY3Rvcl0gb2YgcGF0dGVybnMpIHtcbiAgICBjb25zdCBtID0gcmVnZXguZXhlYyhzKTtcbiAgICBpZiAobSkge1xuICAgICAgcmV0dXJuIGV4dHJhY3RvcihtKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtudWxsLCBudWxsXTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlUGFyc2UoLi4ua2V5cykge1xuICByZXR1cm4gKG1hdGNoLCBjdXJzb3IpID0+IHtcbiAgICBjb25zdCByZXQgPSB7fTtcbiAgICBsZXQgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXRba2V5c1tpXV0gPSBwYXJzZUludGVnZXIobWF0Y2hbY3Vyc29yICsgaV0pO1xuICAgIH1cbiAgICByZXR1cm4gW3JldCwgbnVsbCwgY3Vyc29yICsgaV07XG4gIH07XG59XG5cbi8vIElTTyBhbmQgU1FMIHBhcnNpbmdcbmNvbnN0IG9mZnNldFJlZ2V4ID0gLyg/OihaKXwoWystXVxcZFxcZCkoPzo6PyhcXGRcXGQpKT8pLztcbmNvbnN0IGlzb0V4dGVuZGVkWm9uZSA9IGAoPzoke29mZnNldFJlZ2V4LnNvdXJjZX0/KD86XFxcXFsoJHtpYW5hUmVnZXguc291cmNlfSlcXFxcXSk/KT9gO1xuY29uc3QgaXNvVGltZUJhc2VSZWdleCA9IC8oXFxkXFxkKSg/Ojo/KFxcZFxcZCkoPzo6PyhcXGRcXGQpKD86Wy4sXShcXGR7MSwzMH0pKT8pPyk/LztcbmNvbnN0IGlzb1RpbWVSZWdleCA9IFJlZ0V4cChgJHtpc29UaW1lQmFzZVJlZ2V4LnNvdXJjZX0ke2lzb0V4dGVuZGVkWm9uZX1gKTtcbmNvbnN0IGlzb1RpbWVFeHRlbnNpb25SZWdleCA9IFJlZ0V4cChgKD86VCR7aXNvVGltZVJlZ2V4LnNvdXJjZX0pP2ApO1xuY29uc3QgaXNvWW1kUmVnZXggPSAvKFsrLV1cXGR7Nn18XFxkezR9KSg/Oi0/KFxcZFxcZCkoPzotPyhcXGRcXGQpKT8pPy87XG5jb25zdCBpc29XZWVrUmVnZXggPSAvKFxcZHs0fSktP1coXFxkXFxkKSg/Oi0/KFxcZCkpPy87XG5jb25zdCBpc29PcmRpbmFsUmVnZXggPSAvKFxcZHs0fSktPyhcXGR7M30pLztcbmNvbnN0IGV4dHJhY3RJU09XZWVrRGF0YSA9IHNpbXBsZVBhcnNlKFwid2Vla1llYXJcIiwgXCJ3ZWVrTnVtYmVyXCIsIFwid2Vla0RheVwiKTtcbmNvbnN0IGV4dHJhY3RJU09PcmRpbmFsRGF0YSA9IHNpbXBsZVBhcnNlKFwieWVhclwiLCBcIm9yZGluYWxcIik7XG5jb25zdCBzcWxZbWRSZWdleCA9IC8oXFxkezR9KS0oXFxkXFxkKS0oXFxkXFxkKS87IC8vIGR1bWJlZC1kb3duIHZlcnNpb24gb2YgdGhlIElTTyBvbmVcbmNvbnN0IHNxbFRpbWVSZWdleCA9IFJlZ0V4cChcbiAgYCR7aXNvVGltZUJhc2VSZWdleC5zb3VyY2V9ID8oPzoke29mZnNldFJlZ2V4LnNvdXJjZX18KCR7aWFuYVJlZ2V4LnNvdXJjZX0pKT9gXG4pO1xuY29uc3Qgc3FsVGltZUV4dGVuc2lvblJlZ2V4ID0gUmVnRXhwKGAoPzogJHtzcWxUaW1lUmVnZXguc291cmNlfSk/YCk7XG5cbmZ1bmN0aW9uIGludChtYXRjaCwgcG9zLCBmYWxsYmFjaykge1xuICBjb25zdCBtID0gbWF0Y2hbcG9zXTtcbiAgcmV0dXJuIGlzVW5kZWZpbmVkKG0pID8gZmFsbGJhY2sgOiBwYXJzZUludGVnZXIobSk7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RJU09ZbWQobWF0Y2gsIGN1cnNvcikge1xuICBjb25zdCBpdGVtID0ge1xuICAgIHllYXI6IGludChtYXRjaCwgY3Vyc29yKSxcbiAgICBtb250aDogaW50KG1hdGNoLCBjdXJzb3IgKyAxLCAxKSxcbiAgICBkYXk6IGludChtYXRjaCwgY3Vyc29yICsgMiwgMSksXG4gIH07XG5cbiAgcmV0dXJuIFtpdGVtLCBudWxsLCBjdXJzb3IgKyAzXTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdElTT1RpbWUobWF0Y2gsIGN1cnNvcikge1xuICBjb25zdCBpdGVtID0ge1xuICAgIGhvdXJzOiBpbnQobWF0Y2gsIGN1cnNvciwgMCksXG4gICAgbWludXRlczogaW50KG1hdGNoLCBjdXJzb3IgKyAxLCAwKSxcbiAgICBzZWNvbmRzOiBpbnQobWF0Y2gsIGN1cnNvciArIDIsIDApLFxuICAgIG1pbGxpc2Vjb25kczogcGFyc2VNaWxsaXMobWF0Y2hbY3Vyc29yICsgM10pLFxuICB9O1xuXG4gIHJldHVybiBbaXRlbSwgbnVsbCwgY3Vyc29yICsgNF07XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RJU09PZmZzZXQobWF0Y2gsIGN1cnNvcikge1xuICBjb25zdCBsb2NhbCA9ICFtYXRjaFtjdXJzb3JdICYmICFtYXRjaFtjdXJzb3IgKyAxXSxcbiAgICBmdWxsT2Zmc2V0ID0gc2lnbmVkT2Zmc2V0KG1hdGNoW2N1cnNvciArIDFdLCBtYXRjaFtjdXJzb3IgKyAyXSksXG4gICAgem9uZSA9IGxvY2FsID8gbnVsbCA6IEZpeGVkT2Zmc2V0Wm9uZS5pbnN0YW5jZShmdWxsT2Zmc2V0KTtcbiAgcmV0dXJuIFt7fSwgem9uZSwgY3Vyc29yICsgM107XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RJQU5BWm9uZShtYXRjaCwgY3Vyc29yKSB7XG4gIGNvbnN0IHpvbmUgPSBtYXRjaFtjdXJzb3JdID8gSUFOQVpvbmUuY3JlYXRlKG1hdGNoW2N1cnNvcl0pIDogbnVsbDtcbiAgcmV0dXJuIFt7fSwgem9uZSwgY3Vyc29yICsgMV07XG59XG5cbi8vIElTTyB0aW1lIHBhcnNpbmdcblxuY29uc3QgaXNvVGltZU9ubHkgPSBSZWdFeHAoYF5UPyR7aXNvVGltZUJhc2VSZWdleC5zb3VyY2V9JGApO1xuXG4vLyBJU08gZHVyYXRpb24gcGFyc2luZ1xuXG5jb25zdCBpc29EdXJhdGlvbiA9XG4gIC9eLT9QKD86KD86KC0/XFxkezEsMjB9KD86XFwuXFxkezEsMjB9KT8pWSk/KD86KC0/XFxkezEsMjB9KD86XFwuXFxkezEsMjB9KT8pTSk/KD86KC0/XFxkezEsMjB9KD86XFwuXFxkezEsMjB9KT8pVyk/KD86KC0/XFxkezEsMjB9KD86XFwuXFxkezEsMjB9KT8pRCk/KD86VCg/OigtP1xcZHsxLDIwfSg/OlxcLlxcZHsxLDIwfSk/KUgpPyg/OigtP1xcZHsxLDIwfSg/OlxcLlxcZHsxLDIwfSk/KU0pPyg/OigtP1xcZHsxLDIwfSkoPzpbLixdKC0/XFxkezEsMjB9KSk/Uyk/KT8pJC87XG5cbmZ1bmN0aW9uIGV4dHJhY3RJU09EdXJhdGlvbihtYXRjaCkge1xuICBjb25zdCBbcywgeWVhclN0ciwgbW9udGhTdHIsIHdlZWtTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIsIG1pbGxpc2Vjb25kc1N0cl0gPVxuICAgIG1hdGNoO1xuXG4gIGNvbnN0IGhhc05lZ2F0aXZlUHJlZml4ID0gc1swXSA9PT0gXCItXCI7XG4gIGNvbnN0IG5lZ2F0aXZlU2Vjb25kcyA9IHNlY29uZFN0ciAmJiBzZWNvbmRTdHJbMF0gPT09IFwiLVwiO1xuXG4gIGNvbnN0IG1heWJlTmVnYXRlID0gKG51bSwgZm9yY2UgPSBmYWxzZSkgPT5cbiAgICBudW0gIT09IHVuZGVmaW5lZCAmJiAoZm9yY2UgfHwgKG51bSAmJiBoYXNOZWdhdGl2ZVByZWZpeCkpID8gLW51bSA6IG51bTtcblxuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIHllYXJzOiBtYXliZU5lZ2F0ZShwYXJzZUZsb2F0aW5nKHllYXJTdHIpKSxcbiAgICAgIG1vbnRoczogbWF5YmVOZWdhdGUocGFyc2VGbG9hdGluZyhtb250aFN0cikpLFxuICAgICAgd2Vla3M6IG1heWJlTmVnYXRlKHBhcnNlRmxvYXRpbmcod2Vla1N0cikpLFxuICAgICAgZGF5czogbWF5YmVOZWdhdGUocGFyc2VGbG9hdGluZyhkYXlTdHIpKSxcbiAgICAgIGhvdXJzOiBtYXliZU5lZ2F0ZShwYXJzZUZsb2F0aW5nKGhvdXJTdHIpKSxcbiAgICAgIG1pbnV0ZXM6IG1heWJlTmVnYXRlKHBhcnNlRmxvYXRpbmcobWludXRlU3RyKSksXG4gICAgICBzZWNvbmRzOiBtYXliZU5lZ2F0ZShwYXJzZUZsb2F0aW5nKHNlY29uZFN0ciksIHNlY29uZFN0ciA9PT0gXCItMFwiKSxcbiAgICAgIG1pbGxpc2Vjb25kczogbWF5YmVOZWdhdGUocGFyc2VNaWxsaXMobWlsbGlzZWNvbmRzU3RyKSwgbmVnYXRpdmVTZWNvbmRzKSxcbiAgICB9LFxuICBdO1xufVxuXG4vLyBUaGVzZSBhcmUgYSBsaXR0bGUgYnJhaW5kZWFkLiBFRFQgKnNob3VsZCogdGVsbCB1cyB0aGF0IHdlJ3JlIGluLCBzYXksIEFtZXJpY2EvTmV3X1lvcmtcbi8vIGFuZCBub3QganVzdCB0aGF0IHdlJ3JlIGluIC0yNDAgKnJpZ2h0IG5vdyouIEJ1dCBzaW5jZSBJIGRvbid0IHRoaW5rIHRoZXNlIGFyZSB1c2VkIHRoYXQgb2Z0ZW5cbi8vIEknbSBqdXN0IGdvaW5nIHRvIGlnbm9yZSB0aGF0XG5jb25zdCBvYnNPZmZzZXRzID0ge1xuICBHTVQ6IDAsXG4gIEVEVDogLTQgKiA2MCxcbiAgRVNUOiAtNSAqIDYwLFxuICBDRFQ6IC01ICogNjAsXG4gIENTVDogLTYgKiA2MCxcbiAgTURUOiAtNiAqIDYwLFxuICBNU1Q6IC03ICogNjAsXG4gIFBEVDogLTcgKiA2MCxcbiAgUFNUOiAtOCAqIDYwLFxufTtcblxuZnVuY3Rpb24gZnJvbVN0cmluZ3Mod2Vla2RheVN0ciwgeWVhclN0ciwgbW9udGhTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIpIHtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHllYXI6IHllYXJTdHIubGVuZ3RoID09PSAyID8gdW50cnVuY2F0ZVllYXIocGFyc2VJbnRlZ2VyKHllYXJTdHIpKSA6IHBhcnNlSW50ZWdlcih5ZWFyU3RyKSxcbiAgICBtb250aDogRW5nbGlzaC5tb250aHNTaG9ydC5pbmRleE9mKG1vbnRoU3RyKSArIDEsXG4gICAgZGF5OiBwYXJzZUludGVnZXIoZGF5U3RyKSxcbiAgICBob3VyOiBwYXJzZUludGVnZXIoaG91clN0ciksXG4gICAgbWludXRlOiBwYXJzZUludGVnZXIobWludXRlU3RyKSxcbiAgfTtcblxuICBpZiAoc2Vjb25kU3RyKSByZXN1bHQuc2Vjb25kID0gcGFyc2VJbnRlZ2VyKHNlY29uZFN0cik7XG4gIGlmICh3ZWVrZGF5U3RyKSB7XG4gICAgcmVzdWx0LndlZWtkYXkgPVxuICAgICAgd2Vla2RheVN0ci5sZW5ndGggPiAzXG4gICAgICAgID8gRW5nbGlzaC53ZWVrZGF5c0xvbmcuaW5kZXhPZih3ZWVrZGF5U3RyKSArIDFcbiAgICAgICAgOiBFbmdsaXNoLndlZWtkYXlzU2hvcnQuaW5kZXhPZih3ZWVrZGF5U3RyKSArIDE7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBSRkMgMjgyMi81MzIyXG5jb25zdCByZmMyODIyID1cbiAgL14oPzooTW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXR8U3VuKSxcXHMpPyhcXGR7MSwyfSlcXHMoSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpXFxzKFxcZHsyLDR9KVxccyhcXGRcXGQpOihcXGRcXGQpKD86OihcXGRcXGQpKT9cXHMoPzooVVR8R01UfFtFQ01QXVtTRF1UKXwoW1p6XSl8KD86KFsrLV1cXGRcXGQpKFxcZFxcZCkpKSQvO1xuXG5mdW5jdGlvbiBleHRyYWN0UkZDMjgyMihtYXRjaCkge1xuICBjb25zdCBbXG4gICAgICAsXG4gICAgICB3ZWVrZGF5U3RyLFxuICAgICAgZGF5U3RyLFxuICAgICAgbW9udGhTdHIsXG4gICAgICB5ZWFyU3RyLFxuICAgICAgaG91clN0cixcbiAgICAgIG1pbnV0ZVN0cixcbiAgICAgIHNlY29uZFN0cixcbiAgICAgIG9ic09mZnNldCxcbiAgICAgIG1pbE9mZnNldCxcbiAgICAgIG9mZkhvdXJTdHIsXG4gICAgICBvZmZNaW51dGVTdHIsXG4gICAgXSA9IG1hdGNoLFxuICAgIHJlc3VsdCA9IGZyb21TdHJpbmdzKHdlZWtkYXlTdHIsIHllYXJTdHIsIG1vbnRoU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyKTtcblxuICBsZXQgb2Zmc2V0O1xuICBpZiAob2JzT2Zmc2V0KSB7XG4gICAgb2Zmc2V0ID0gb2JzT2Zmc2V0c1tvYnNPZmZzZXRdO1xuICB9IGVsc2UgaWYgKG1pbE9mZnNldCkge1xuICAgIG9mZnNldCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgb2Zmc2V0ID0gc2lnbmVkT2Zmc2V0KG9mZkhvdXJTdHIsIG9mZk1pbnV0ZVN0cik7XG4gIH1cblxuICByZXR1cm4gW3Jlc3VsdCwgbmV3IEZpeGVkT2Zmc2V0Wm9uZShvZmZzZXQpXTtcbn1cblxuZnVuY3Rpb24gcHJlcHJvY2Vzc1JGQzI4MjIocykge1xuICAvLyBSZW1vdmUgY29tbWVudHMgYW5kIGZvbGRpbmcgd2hpdGVzcGFjZSBhbmQgcmVwbGFjZSBtdWx0aXBsZS1zcGFjZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuICByZXR1cm4gc1xuICAgIC5yZXBsYWNlKC9cXChbXigpXSpcXCl8W1xcblxcdF0vZywgXCIgXCIpXG4gICAgLnJlcGxhY2UoLyhcXHNcXHMrKS9nLCBcIiBcIilcbiAgICAudHJpbSgpO1xufVxuXG4vLyBodHRwIGRhdGVcblxuY29uc3QgcmZjMTEyMyA9XG4gICAgL14oTW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXR8U3VuKSwgKFxcZFxcZCkgKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKSAoXFxkezR9KSAoXFxkXFxkKTooXFxkXFxkKTooXFxkXFxkKSBHTVQkLyxcbiAgcmZjODUwID1cbiAgICAvXihNb25kYXl8VHVlc2RheXxXZWRuZXNkYXl8VGh1cnNkYXl8RnJpZGF5fFNhdHVyZGF5fFN1bmRheSksIChcXGRcXGQpLShKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYyktKFxcZFxcZCkgKFxcZFxcZCk6KFxcZFxcZCk6KFxcZFxcZCkgR01UJC8sXG4gIGFzY2lpID1cbiAgICAvXihNb258VHVlfFdlZHxUaHV8RnJpfFNhdHxTdW4pIChKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYykgKCBcXGR8XFxkXFxkKSAoXFxkXFxkKTooXFxkXFxkKTooXFxkXFxkKSAoXFxkezR9KSQvO1xuXG5mdW5jdGlvbiBleHRyYWN0UkZDMTEyM09yODUwKG1hdGNoKSB7XG4gIGNvbnN0IFssIHdlZWtkYXlTdHIsIGRheVN0ciwgbW9udGhTdHIsIHllYXJTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyXSA9IG1hdGNoLFxuICAgIHJlc3VsdCA9IGZyb21TdHJpbmdzKHdlZWtkYXlTdHIsIHllYXJTdHIsIG1vbnRoU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyKTtcbiAgcmV0dXJuIFtyZXN1bHQsIEZpeGVkT2Zmc2V0Wm9uZS51dGNJbnN0YW5jZV07XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RBU0NJSShtYXRjaCkge1xuICBjb25zdCBbLCB3ZWVrZGF5U3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0ciwgeWVhclN0cl0gPSBtYXRjaCxcbiAgICByZXN1bHQgPSBmcm9tU3RyaW5ncyh3ZWVrZGF5U3RyLCB5ZWFyU3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cik7XG4gIHJldHVybiBbcmVzdWx0LCBGaXhlZE9mZnNldFpvbmUudXRjSW5zdGFuY2VdO1xufVxuXG5jb25zdCBpc29ZbWRXaXRoVGltZUV4dGVuc2lvblJlZ2V4ID0gY29tYmluZVJlZ2V4ZXMoaXNvWW1kUmVnZXgsIGlzb1RpbWVFeHRlbnNpb25SZWdleCk7XG5jb25zdCBpc29XZWVrV2l0aFRpbWVFeHRlbnNpb25SZWdleCA9IGNvbWJpbmVSZWdleGVzKGlzb1dlZWtSZWdleCwgaXNvVGltZUV4dGVuc2lvblJlZ2V4KTtcbmNvbnN0IGlzb09yZGluYWxXaXRoVGltZUV4dGVuc2lvblJlZ2V4ID0gY29tYmluZVJlZ2V4ZXMoaXNvT3JkaW5hbFJlZ2V4LCBpc29UaW1lRXh0ZW5zaW9uUmVnZXgpO1xuY29uc3QgaXNvVGltZUNvbWJpbmVkUmVnZXggPSBjb21iaW5lUmVnZXhlcyhpc29UaW1lUmVnZXgpO1xuXG5jb25zdCBleHRyYWN0SVNPWW1kVGltZUFuZE9mZnNldCA9IGNvbWJpbmVFeHRyYWN0b3JzKFxuICBleHRyYWN0SVNPWW1kLFxuICBleHRyYWN0SVNPVGltZSxcbiAgZXh0cmFjdElTT09mZnNldCxcbiAgZXh0cmFjdElBTkFab25lXG4pO1xuY29uc3QgZXh0cmFjdElTT1dlZWtUaW1lQW5kT2Zmc2V0ID0gY29tYmluZUV4dHJhY3RvcnMoXG4gIGV4dHJhY3RJU09XZWVrRGF0YSxcbiAgZXh0cmFjdElTT1RpbWUsXG4gIGV4dHJhY3RJU09PZmZzZXQsXG4gIGV4dHJhY3RJQU5BWm9uZVxuKTtcbmNvbnN0IGV4dHJhY3RJU09PcmRpbmFsRGF0ZUFuZFRpbWUgPSBjb21iaW5lRXh0cmFjdG9ycyhcbiAgZXh0cmFjdElTT09yZGluYWxEYXRhLFxuICBleHRyYWN0SVNPVGltZSxcbiAgZXh0cmFjdElTT09mZnNldCxcbiAgZXh0cmFjdElBTkFab25lXG4pO1xuY29uc3QgZXh0cmFjdElTT1RpbWVBbmRPZmZzZXQgPSBjb21iaW5lRXh0cmFjdG9ycyhcbiAgZXh0cmFjdElTT1RpbWUsXG4gIGV4dHJhY3RJU09PZmZzZXQsXG4gIGV4dHJhY3RJQU5BWm9uZVxuKTtcblxuLypcbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSVNPRGF0ZShzKSB7XG4gIHJldHVybiBwYXJzZShcbiAgICBzLFxuICAgIFtpc29ZbWRXaXRoVGltZUV4dGVuc2lvblJlZ2V4LCBleHRyYWN0SVNPWW1kVGltZUFuZE9mZnNldF0sXG4gICAgW2lzb1dlZWtXaXRoVGltZUV4dGVuc2lvblJlZ2V4LCBleHRyYWN0SVNPV2Vla1RpbWVBbmRPZmZzZXRdLFxuICAgIFtpc29PcmRpbmFsV2l0aFRpbWVFeHRlbnNpb25SZWdleCwgZXh0cmFjdElTT09yZGluYWxEYXRlQW5kVGltZV0sXG4gICAgW2lzb1RpbWVDb21iaW5lZFJlZ2V4LCBleHRyYWN0SVNPVGltZUFuZE9mZnNldF1cbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUkZDMjgyMkRhdGUocykge1xuICByZXR1cm4gcGFyc2UocHJlcHJvY2Vzc1JGQzI4MjIocyksIFtyZmMyODIyLCBleHRyYWN0UkZDMjgyMl0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VIVFRQRGF0ZShzKSB7XG4gIHJldHVybiBwYXJzZShcbiAgICBzLFxuICAgIFtyZmMxMTIzLCBleHRyYWN0UkZDMTEyM09yODUwXSxcbiAgICBbcmZjODUwLCBleHRyYWN0UkZDMTEyM09yODUwXSxcbiAgICBbYXNjaWksIGV4dHJhY3RBU0NJSV1cbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSVNPRHVyYXRpb24ocykge1xuICByZXR1cm4gcGFyc2UocywgW2lzb0R1cmF0aW9uLCBleHRyYWN0SVNPRHVyYXRpb25dKTtcbn1cblxuY29uc3QgZXh0cmFjdElTT1RpbWVPbmx5ID0gY29tYmluZUV4dHJhY3RvcnMoZXh0cmFjdElTT1RpbWUpO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VJU09UaW1lT25seShzKSB7XG4gIHJldHVybiBwYXJzZShzLCBbaXNvVGltZU9ubHksIGV4dHJhY3RJU09UaW1lT25seV0pO1xufVxuXG5jb25zdCBzcWxZbWRXaXRoVGltZUV4dGVuc2lvblJlZ2V4ID0gY29tYmluZVJlZ2V4ZXMoc3FsWW1kUmVnZXgsIHNxbFRpbWVFeHRlbnNpb25SZWdleCk7XG5jb25zdCBzcWxUaW1lQ29tYmluZWRSZWdleCA9IGNvbWJpbmVSZWdleGVzKHNxbFRpbWVSZWdleCk7XG5cbmNvbnN0IGV4dHJhY3RJU09UaW1lT2Zmc2V0QW5kSUFOQVpvbmUgPSBjb21iaW5lRXh0cmFjdG9ycyhcbiAgZXh0cmFjdElTT1RpbWUsXG4gIGV4dHJhY3RJU09PZmZzZXQsXG4gIGV4dHJhY3RJQU5BWm9uZVxuKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU1FMKHMpIHtcbiAgcmV0dXJuIHBhcnNlKFxuICAgIHMsXG4gICAgW3NxbFltZFdpdGhUaW1lRXh0ZW5zaW9uUmVnZXgsIGV4dHJhY3RJU09ZbWRUaW1lQW5kT2Zmc2V0XSxcbiAgICBbc3FsVGltZUNvbWJpbmVkUmVnZXgsIGV4dHJhY3RJU09UaW1lT2Zmc2V0QW5kSUFOQVpvbmVdXG4gICk7XG59XG4iLCJpbXBvcnQgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgSW52YWxpZER1cmF0aW9uRXJyb3IsIEludmFsaWRVbml0RXJyb3IgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmltcG9ydCBGb3JtYXR0ZXIgZnJvbSBcIi4vaW1wbC9mb3JtYXR0ZXIuanNcIjtcbmltcG9ydCBJbnZhbGlkIGZyb20gXCIuL2ltcGwvaW52YWxpZC5qc1wiO1xuaW1wb3J0IExvY2FsZSBmcm9tIFwiLi9pbXBsL2xvY2FsZS5qc1wiO1xuaW1wb3J0IHsgcGFyc2VJU09EdXJhdGlvbiwgcGFyc2VJU09UaW1lT25seSB9IGZyb20gXCIuL2ltcGwvcmVnZXhQYXJzZXIuanNcIjtcbmltcG9ydCB7XG4gIGFzTnVtYmVyLFxuICBoYXNPd25Qcm9wZXJ0eSxcbiAgaXNOdW1iZXIsXG4gIGlzVW5kZWZpbmVkLFxuICBub3JtYWxpemVPYmplY3QsXG4gIHJvdW5kVG8sXG59IGZyb20gXCIuL2ltcGwvdXRpbC5qc1wiO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gXCIuL3NldHRpbmdzLmpzXCI7XG5cbmNvbnN0IElOVkFMSUQgPSBcIkludmFsaWQgRHVyYXRpb25cIjtcblxuLy8gdW5pdCBjb252ZXJzaW9uIGNvbnN0YW50c1xuZXhwb3J0IGNvbnN0IGxvd09yZGVyTWF0cml4ID0ge1xuICAgIHdlZWtzOiB7XG4gICAgICBkYXlzOiA3LFxuICAgICAgaG91cnM6IDcgKiAyNCxcbiAgICAgIG1pbnV0ZXM6IDcgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogNyAqIDI0ICogNjAgKiA2MCxcbiAgICAgIG1pbGxpc2Vjb25kczogNyAqIDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gICAgfSxcbiAgICBkYXlzOiB7XG4gICAgICBob3VyczogMjQsXG4gICAgICBtaW51dGVzOiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogMjQgKiA2MCAqIDYwLFxuICAgICAgbWlsbGlzZWNvbmRzOiAyNCAqIDYwICogNjAgKiAxMDAwLFxuICAgIH0sXG4gICAgaG91cnM6IHsgbWludXRlczogNjAsIHNlY29uZHM6IDYwICogNjAsIG1pbGxpc2Vjb25kczogNjAgKiA2MCAqIDEwMDAgfSxcbiAgICBtaW51dGVzOiB7IHNlY29uZHM6IDYwLCBtaWxsaXNlY29uZHM6IDYwICogMTAwMCB9LFxuICAgIHNlY29uZHM6IHsgbWlsbGlzZWNvbmRzOiAxMDAwIH0sXG4gIH0sXG4gIGNhc3VhbE1hdHJpeCA9IHtcbiAgICB5ZWFyczoge1xuICAgICAgcXVhcnRlcnM6IDQsXG4gICAgICBtb250aHM6IDEyLFxuICAgICAgd2Vla3M6IDUyLFxuICAgICAgZGF5czogMzY1LFxuICAgICAgaG91cnM6IDM2NSAqIDI0LFxuICAgICAgbWludXRlczogMzY1ICogMjQgKiA2MCxcbiAgICAgIHNlY29uZHM6IDM2NSAqIDI0ICogNjAgKiA2MCxcbiAgICAgIG1pbGxpc2Vjb25kczogMzY1ICogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuICAgIHF1YXJ0ZXJzOiB7XG4gICAgICBtb250aHM6IDMsXG4gICAgICB3ZWVrczogMTMsXG4gICAgICBkYXlzOiA5MSxcbiAgICAgIGhvdXJzOiA5MSAqIDI0LFxuICAgICAgbWludXRlczogOTEgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogOTEgKiAyNCAqIDYwICogNjAsXG4gICAgICBtaWxsaXNlY29uZHM6IDkxICogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuICAgIG1vbnRoczoge1xuICAgICAgd2Vla3M6IDQsXG4gICAgICBkYXlzOiAzMCxcbiAgICAgIGhvdXJzOiAzMCAqIDI0LFxuICAgICAgbWludXRlczogMzAgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogMzAgKiAyNCAqIDYwICogNjAsXG4gICAgICBtaWxsaXNlY29uZHM6IDMwICogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuXG4gICAgLi4ubG93T3JkZXJNYXRyaXgsXG4gIH0sXG4gIGRheXNJblllYXJBY2N1cmF0ZSA9IDE0NjA5Ny4wIC8gNDAwLFxuICBkYXlzSW5Nb250aEFjY3VyYXRlID0gMTQ2MDk3LjAgLyA0ODAwLFxuICBhY2N1cmF0ZU1hdHJpeCA9IHtcbiAgICB5ZWFyczoge1xuICAgICAgcXVhcnRlcnM6IDQsXG4gICAgICBtb250aHM6IDEyLFxuICAgICAgd2Vla3M6IGRheXNJblllYXJBY2N1cmF0ZSAvIDcsXG4gICAgICBkYXlzOiBkYXlzSW5ZZWFyQWNjdXJhdGUsXG4gICAgICBob3VyczogZGF5c0luWWVhckFjY3VyYXRlICogMjQsXG4gICAgICBtaW51dGVzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogZGF5c0luWWVhckFjY3VyYXRlICogMjQgKiA2MCAqIDYwLFxuICAgICAgbWlsbGlzZWNvbmRzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCAqIDYwICogNjAgKiAxMDAwLFxuICAgIH0sXG4gICAgcXVhcnRlcnM6IHtcbiAgICAgIG1vbnRoczogMyxcbiAgICAgIHdlZWtzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgLyAyOCxcbiAgICAgIGRheXM6IGRheXNJblllYXJBY2N1cmF0ZSAvIDQsXG4gICAgICBob3VyczogKGRheXNJblllYXJBY2N1cmF0ZSAqIDI0KSAvIDQsXG4gICAgICBtaW51dGVzOiAoZGF5c0luWWVhckFjY3VyYXRlICogMjQgKiA2MCkgLyA0LFxuICAgICAgc2Vjb25kczogKGRheXNJblllYXJBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCkgLyA0LFxuICAgICAgbWlsbGlzZWNvbmRzOiAoZGF5c0luWWVhckFjY3VyYXRlICogMjQgKiA2MCAqIDYwICogMTAwMCkgLyA0LFxuICAgIH0sXG4gICAgbW9udGhzOiB7XG4gICAgICB3ZWVrczogZGF5c0luTW9udGhBY2N1cmF0ZSAvIDcsXG4gICAgICBkYXlzOiBkYXlzSW5Nb250aEFjY3VyYXRlLFxuICAgICAgaG91cnM6IGRheXNJbk1vbnRoQWNjdXJhdGUgKiAyNCxcbiAgICAgIG1pbnV0ZXM6IGRheXNJbk1vbnRoQWNjdXJhdGUgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogZGF5c0luTW9udGhBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCxcbiAgICAgIG1pbGxpc2Vjb25kczogZGF5c0luTW9udGhBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gICAgfSxcbiAgICAuLi5sb3dPcmRlck1hdHJpeCxcbiAgfTtcblxuLy8gdW5pdHMgb3JkZXJlZCBieSBzaXplXG5jb25zdCBvcmRlcmVkVW5pdHMgPSBbXG4gIFwieWVhcnNcIixcbiAgXCJxdWFydGVyc1wiLFxuICBcIm1vbnRoc1wiLFxuICBcIndlZWtzXCIsXG4gIFwiZGF5c1wiLFxuICBcImhvdXJzXCIsXG4gIFwibWludXRlc1wiLFxuICBcInNlY29uZHNcIixcbiAgXCJtaWxsaXNlY29uZHNcIixcbl07XG5cbmNvbnN0IHJldmVyc2VVbml0cyA9IG9yZGVyZWRVbml0cy5zbGljZSgwKS5yZXZlcnNlKCk7XG5cbi8vIGNsb25lIHJlYWxseSBtZWFucyBcImNyZWF0ZSBhbm90aGVyIGluc3RhbmNlIGp1c3QgbGlrZSB0aGlzIG9uZSwgYnV0IHdpdGggdGhlc2UgY2hhbmdlc1wiXG5mdW5jdGlvbiBjbG9uZShkdXIsIGFsdHMsIGNsZWFyID0gZmFsc2UpIHtcbiAgLy8gZGVlcCBtZXJnZSBmb3IgdmFsc1xuICBjb25zdCBjb25mID0ge1xuICAgIHZhbHVlczogY2xlYXIgPyBhbHRzLnZhbHVlcyA6IHsgLi4uZHVyLnZhbHVlcywgLi4uKGFsdHMudmFsdWVzIHx8IHt9KSB9LFxuICAgIGxvYzogZHVyLmxvYy5jbG9uZShhbHRzLmxvYyksXG4gICAgY29udmVyc2lvbkFjY3VyYWN5OiBhbHRzLmNvbnZlcnNpb25BY2N1cmFjeSB8fCBkdXIuY29udmVyc2lvbkFjY3VyYWN5LFxuICAgIG1hdHJpeDogYWx0cy5tYXRyaXggfHwgZHVyLm1hdHJpeCxcbiAgfTtcbiAgcmV0dXJuIG5ldyBEdXJhdGlvbihjb25mKTtcbn1cblxuZnVuY3Rpb24gYW50aVRydW5jKG4pIHtcbiAgcmV0dXJuIG4gPCAwID8gTWF0aC5mbG9vcihuKSA6IE1hdGguY2VpbChuKTtcbn1cblxuLy8gTkI6IG11dGF0ZXMgcGFyYW1ldGVyc1xuZnVuY3Rpb24gY29udmVydChtYXRyaXgsIGZyb21NYXAsIGZyb21Vbml0LCB0b01hcCwgdG9Vbml0KSB7XG4gIGNvbnN0IGNvbnYgPSBtYXRyaXhbdG9Vbml0XVtmcm9tVW5pdF0sXG4gICAgcmF3ID0gZnJvbU1hcFtmcm9tVW5pdF0gLyBjb252LFxuICAgIHNhbWVTaWduID0gTWF0aC5zaWduKHJhdykgPT09IE1hdGguc2lnbih0b01hcFt0b1VuaXRdKSxcbiAgICAvLyBvaywgc28gdGhpcyBpcyB3aWxkLCBidXQgc2VlIHRoZSBtYXRyaXggaW4gdGhlIHRlc3RzXG4gICAgYWRkZWQgPVxuICAgICAgIXNhbWVTaWduICYmIHRvTWFwW3RvVW5pdF0gIT09IDAgJiYgTWF0aC5hYnMocmF3KSA8PSAxID8gYW50aVRydW5jKHJhdykgOiBNYXRoLnRydW5jKHJhdyk7XG4gIHRvTWFwW3RvVW5pdF0gKz0gYWRkZWQ7XG4gIGZyb21NYXBbZnJvbVVuaXRdIC09IGFkZGVkICogY29udjtcbn1cblxuLy8gTkI6IG11dGF0ZXMgcGFyYW1ldGVyc1xuZnVuY3Rpb24gbm9ybWFsaXplVmFsdWVzKG1hdHJpeCwgdmFscykge1xuICByZXZlcnNlVW5pdHMucmVkdWNlKChwcmV2aW91cywgY3VycmVudCkgPT4ge1xuICAgIGlmICghaXNVbmRlZmluZWQodmFsc1tjdXJyZW50XSkpIHtcbiAgICAgIGlmIChwcmV2aW91cykge1xuICAgICAgICBjb252ZXJ0KG1hdHJpeCwgdmFscywgcHJldmlvdXMsIHZhbHMsIGN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwcmV2aW91cztcbiAgICB9XG4gIH0sIG51bGwpO1xufVxuXG4vLyBSZW1vdmUgYWxsIHByb3BlcnRpZXMgd2l0aCBhIHZhbHVlIG9mIDAgZnJvbSBhbiBvYmplY3RcbmZ1bmN0aW9uIHJlbW92ZVplcm9lcyh2YWxzKSB7XG4gIGNvbnN0IG5ld1ZhbHMgPSB7fTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFscykpIHtcbiAgICBpZiAodmFsdWUgIT09IDApIHtcbiAgICAgIG5ld1ZhbHNba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3VmFscztcbn1cblxuLyoqXG4gKiBBIER1cmF0aW9uIG9iamVjdCByZXByZXNlbnRzIGEgcGVyaW9kIG9mIHRpbWUsIGxpa2UgXCIyIG1vbnRoc1wiIG9yIFwiMSBkYXksIDEgaG91clwiLiBDb25jZXB0dWFsbHksIGl0J3MganVzdCBhIG1hcCBvZiB1bml0cyB0byB0aGVpciBxdWFudGl0aWVzLCBhY2NvbXBhbmllZCBieSBzb21lIGFkZGl0aW9uYWwgY29uZmlndXJhdGlvbiBhbmQgbWV0aG9kcyBmb3IgY3JlYXRpbmcsIHBhcnNpbmcsIGludGVycm9nYXRpbmcsIHRyYW5zZm9ybWluZywgYW5kIGZvcm1hdHRpbmcgdGhlbS4gVGhleSBjYW4gYmUgdXNlZCBvbiB0aGVpciBvd24gb3IgaW4gY29uanVuY3Rpb24gd2l0aCBvdGhlciBMdXhvbiB0eXBlczsgZm9yIGV4YW1wbGUsIHlvdSBjYW4gdXNlIHtAbGluayBEYXRlVGltZSNwbHVzfSB0byBhZGQgYSBEdXJhdGlvbiBvYmplY3QgdG8gYSBEYXRlVGltZSwgcHJvZHVjaW5nIGFub3RoZXIgRGF0ZVRpbWUuXG4gKlxuICogSGVyZSBpcyBhIGJyaWVmIG92ZXJ2aWV3IG9mIGNvbW1vbmx5IHVzZWQgbWV0aG9kcyBhbmQgZ2V0dGVycyBpbiBEdXJhdGlvbjpcbiAqXG4gKiAqICoqQ3JlYXRpb24qKiBUbyBjcmVhdGUgYSBEdXJhdGlvbiwgdXNlIHtAbGluayBEdXJhdGlvbi5mcm9tTWlsbGlzfSwge0BsaW5rIER1cmF0aW9uLmZyb21PYmplY3R9LCBvciB7QGxpbmsgRHVyYXRpb24uZnJvbUlTT30uXG4gKiAqICoqVW5pdCB2YWx1ZXMqKiBTZWUgdGhlIHtAbGluayBEdXJhdGlvbiN5ZWFyc30sIHtAbGluayBEdXJhdGlvbiNtb250aHN9LCB7QGxpbmsgRHVyYXRpb24jd2Vla3N9LCB7QGxpbmsgRHVyYXRpb24jZGF5c30sIHtAbGluayBEdXJhdGlvbiNob3Vyc30sIHtAbGluayBEdXJhdGlvbiNtaW51dGVzfSwge0BsaW5rIER1cmF0aW9uI3NlY29uZHN9LCB7QGxpbmsgRHVyYXRpb24jbWlsbGlzZWNvbmRzfSBhY2Nlc3NvcnMuXG4gKiAqICoqQ29uZmlndXJhdGlvbioqIFNlZSAge0BsaW5rIER1cmF0aW9uI2xvY2FsZX0gYW5kIHtAbGluayBEdXJhdGlvbiNudW1iZXJpbmdTeXN0ZW19IGFjY2Vzc29ycy5cbiAqICogKipUcmFuc2Zvcm1hdGlvbioqIFRvIGNyZWF0ZSBuZXcgRHVyYXRpb25zIG91dCBvZiBvbGQgb25lcyB1c2Uge0BsaW5rIER1cmF0aW9uI3BsdXN9LCB7QGxpbmsgRHVyYXRpb24jbWludXN9LCB7QGxpbmsgRHVyYXRpb24jbm9ybWFsaXplfSwge0BsaW5rIER1cmF0aW9uI3NldH0sIHtAbGluayBEdXJhdGlvbiNyZWNvbmZpZ3VyZX0sIHtAbGluayBEdXJhdGlvbiNzaGlmdFRvfSwgYW5kIHtAbGluayBEdXJhdGlvbiNuZWdhdGV9LlxuICogKiAqKk91dHB1dCoqIFRvIGNvbnZlcnQgdGhlIER1cmF0aW9uIGludG8gb3RoZXIgcmVwcmVzZW50YXRpb25zLCBzZWUge0BsaW5rIER1cmF0aW9uI2FzfSwge0BsaW5rIER1cmF0aW9uI3RvSVNPfSwge0BsaW5rIER1cmF0aW9uI3RvRm9ybWF0fSwgYW5kIHtAbGluayBEdXJhdGlvbiN0b0pTT059XG4gKlxuICogVGhlcmUncyBhcmUgbW9yZSBtZXRob2RzIGRvY3VtZW50ZWQgYmVsb3cuIEluIGFkZGl0aW9uLCBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBzdWJ0bGVyIHRvcGljcyBsaWtlIGludGVybmF0aW9uYWxpemF0aW9uIGFuZCB2YWxpZGl0eSwgc2VlIHRoZSBleHRlcm5hbCBkb2N1bWVudGF0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEdXJhdGlvbiB7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgY29uc3QgYWNjdXJhdGUgPSBjb25maWcuY29udmVyc2lvbkFjY3VyYWN5ID09PSBcImxvbmd0ZXJtXCIgfHwgZmFsc2U7XG4gICAgbGV0IG1hdHJpeCA9IGFjY3VyYXRlID8gYWNjdXJhdGVNYXRyaXggOiBjYXN1YWxNYXRyaXg7XG5cbiAgICBpZiAoY29uZmlnLm1hdHJpeCkge1xuICAgICAgbWF0cml4ID0gY29uZmlnLm1hdHJpeDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnZhbHVlcyA9IGNvbmZpZy52YWx1ZXM7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5sb2MgPSBjb25maWcubG9jIHx8IExvY2FsZS5jcmVhdGUoKTtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmNvbnZlcnNpb25BY2N1cmFjeSA9IGFjY3VyYXRlID8gXCJsb25ndGVybVwiIDogXCJjYXN1YWxcIjtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmludmFsaWQgPSBjb25maWcuaW52YWxpZCB8fCBudWxsO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubWF0cml4ID0gbWF0cml4O1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaXNMdXhvbkR1cmF0aW9uID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgRHVyYXRpb24gZnJvbSBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCBvZiBtaWxsaXNlY29uZHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIGZvciBwYXJzaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J2VuLVVTJ10gLSB0aGUgbG9jYWxlIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc3RhdGljIGZyb21NaWxsaXMoY291bnQsIG9wdHMpIHtcbiAgICByZXR1cm4gRHVyYXRpb24uZnJvbU9iamVjdCh7IG1pbGxpc2Vjb25kczogY291bnQgfSwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRHVyYXRpb24gZnJvbSBhIEphdmFTY3JpcHQgb2JqZWN0IHdpdGgga2V5cyBsaWtlICd5ZWFycycgYW5kICdob3VycycuXG4gICAqIElmIHRoaXMgb2JqZWN0IGlzIGVtcHR5IHRoZW4gYSB6ZXJvIG1pbGxpc2Vjb25kcyBkdXJhdGlvbiBpcyByZXR1cm5lZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIHRoZSBvYmplY3QgdG8gY3JlYXRlIHRoZSBEYXRlVGltZSBmcm9tXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoueWVhcnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5xdWFydGVyc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm1vbnRoc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLndlZWtzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouZGF5c1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLmhvdXJzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubWludXRlc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLnNlY29uZHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5taWxsaXNlY29uZHNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzPVtdXSAtIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoaXMgRHVyYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nZW4tVVMnXSAtIHRoZSBsb2NhbGUgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBwcmVzZXQgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5tYXRyaXg9T2JqZWN0XSAtIHRoZSBjdXN0b20gY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc3RhdGljIGZyb21PYmplY3Qob2JqLCBvcHRzID0ge30pIHtcbiAgICBpZiAob2JqID09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFxuICAgICAgICBgRHVyYXRpb24uZnJvbU9iamVjdDogYXJndW1lbnQgZXhwZWN0ZWQgdG8gYmUgYW4gb2JqZWN0LCBnb3QgJHtcbiAgICAgICAgICBvYmogPT09IG51bGwgPyBcIm51bGxcIiA6IHR5cGVvZiBvYmpcbiAgICAgICAgfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBEdXJhdGlvbih7XG4gICAgICB2YWx1ZXM6IG5vcm1hbGl6ZU9iamVjdChvYmosIER1cmF0aW9uLm5vcm1hbGl6ZVVuaXQpLFxuICAgICAgbG9jOiBMb2NhbGUuZnJvbU9iamVjdChvcHRzKSxcbiAgICAgIGNvbnZlcnNpb25BY2N1cmFjeTogb3B0cy5jb252ZXJzaW9uQWNjdXJhY3ksXG4gICAgICBtYXRyaXg6IG9wdHMubWF0cml4LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIER1cmF0aW9uIGZyb20gRHVyYXRpb25MaWtlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdCB8IG51bWJlciB8IER1cmF0aW9ufSBkdXJhdGlvbkxpa2VcbiAgICogT25lIG9mOlxuICAgKiAtIG9iamVjdCB3aXRoIGtleXMgbGlrZSAneWVhcnMnIGFuZCAnaG91cnMnLlxuICAgKiAtIG51bWJlciByZXByZXNlbnRpbmcgbWlsbGlzZWNvbmRzXG4gICAqIC0gRHVyYXRpb24gaW5zdGFuY2VcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzdGF0aWMgZnJvbUR1cmF0aW9uTGlrZShkdXJhdGlvbkxpa2UpIHtcbiAgICBpZiAoaXNOdW1iZXIoZHVyYXRpb25MaWtlKSkge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmZyb21NaWxsaXMoZHVyYXRpb25MaWtlKTtcbiAgICB9IGVsc2UgaWYgKER1cmF0aW9uLmlzRHVyYXRpb24oZHVyYXRpb25MaWtlKSkge1xuICAgICAgcmV0dXJuIGR1cmF0aW9uTGlrZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkdXJhdGlvbkxpa2UgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5mcm9tT2JqZWN0KGR1cmF0aW9uTGlrZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcbiAgICAgICAgYFVua25vd24gZHVyYXRpb24gYXJndW1lbnQgJHtkdXJhdGlvbkxpa2V9IG9mIHR5cGUgJHt0eXBlb2YgZHVyYXRpb25MaWtlfWBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIER1cmF0aW9uIGZyb20gYW4gSVNPIDg2MDEgZHVyYXRpb24gc3RyaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRleHQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIGZvciBwYXJzaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J2VuLVVTJ10gLSB0aGUgbG9jYWxlIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgcHJlc2V0IGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubWF0cml4PU9iamVjdF0gLSB0aGUgcHJlc2V0IGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI0R1cmF0aW9uc1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPKCdQM1k2TTFXNERUMTJIMzBNNVMnKS50b09iamVjdCgpIC8vPT4geyB5ZWFyczogMywgbW9udGhzOiA2LCB3ZWVrczogMSwgZGF5czogNCwgaG91cnM6IDEyLCBtaW51dGVzOiAzMCwgc2Vjb25kczogNSB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU08oJ1BUMjNIJykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDIzIH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTTygnUDVZM00nKS50b09iamVjdCgpIC8vPT4geyB5ZWFyczogNSwgbW9udGhzOiAzIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzdGF0aWMgZnJvbUlTTyh0ZXh0LCBvcHRzKSB7XG4gICAgY29uc3QgW3BhcnNlZF0gPSBwYXJzZUlTT0R1cmF0aW9uKHRleHQpO1xuICAgIGlmIChwYXJzZWQpIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5mcm9tT2JqZWN0KHBhcnNlZCwgb3B0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5pbnZhbGlkKFwidW5wYXJzYWJsZVwiLCBgdGhlIGlucHV0IFwiJHt0ZXh0fVwiIGNhbid0IGJlIHBhcnNlZCBhcyBJU08gODYwMWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEdXJhdGlvbiBmcm9tIGFuIElTTyA4NjAxIHRpbWUgc3RyaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRleHQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIGZvciBwYXJzaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J2VuLVVTJ10gLSB0aGUgbG9jYWxlIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgcHJlc2V0IGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubWF0cml4PU9iamVjdF0gLSB0aGUgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjVGltZXNcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTT1RpbWUoJzExOjIyOjMzLjQ0NCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMjIsIHNlY29uZHM6IDMzLCBtaWxsaXNlY29uZHM6IDQ0NCB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU09UaW1lKCcxMTowMCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMCwgc2Vjb25kczogMCB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU09UaW1lKCdUMTE6MDAnKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMTEsIG1pbnV0ZXM6IDAsIHNlY29uZHM6IDAgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPVGltZSgnMTEwMCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMCwgc2Vjb25kczogMCB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU09UaW1lKCdUMTEwMCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMCwgc2Vjb25kczogMCB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc3RhdGljIGZyb21JU09UaW1lKHRleHQsIG9wdHMpIHtcbiAgICBjb25zdCBbcGFyc2VkXSA9IHBhcnNlSVNPVGltZU9ubHkodGV4dCk7XG4gICAgaWYgKHBhcnNlZCkge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmZyb21PYmplY3QocGFyc2VkLCBvcHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmludmFsaWQoXCJ1bnBhcnNhYmxlXCIsIGB0aGUgaW5wdXQgXCIke3RleHR9XCIgY2FuJ3QgYmUgcGFyc2VkIGFzIElTTyA4NjAxYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnZhbGlkIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uIC0gc2ltcGxlIHN0cmluZyBvZiB3aHkgdGhpcyBkYXRldGltZSBpcyBpbnZhbGlkLiBTaG91bGQgbm90IGNvbnRhaW4gcGFyYW1ldGVycyBvciBhbnl0aGluZyBlbHNlIGRhdGEtZGVwZW5kZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZXhwbGFuYXRpb249bnVsbF0gLSBsb25nZXIgZXhwbGFuYXRpb24sIG1heSBpbmNsdWRlIHBhcmFtZXRlcnMgYW5kIG90aGVyIHVzZWZ1bCBkZWJ1Z2dpbmcgaW5mb3JtYXRpb25cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzdGF0aWMgaW52YWxpZChyZWFzb24sIGV4cGxhbmF0aW9uID0gbnVsbCkge1xuICAgIGlmICghcmVhc29uKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJuZWVkIHRvIHNwZWNpZnkgYSByZWFzb24gdGhlIER1cmF0aW9uIGlzIGludmFsaWRcIik7XG4gICAgfVxuXG4gICAgY29uc3QgaW52YWxpZCA9IHJlYXNvbiBpbnN0YW5jZW9mIEludmFsaWQgPyByZWFzb24gOiBuZXcgSW52YWxpZChyZWFzb24sIGV4cGxhbmF0aW9uKTtcblxuICAgIGlmIChTZXR0aW5ncy50aHJvd09uSW52YWxpZCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWREdXJhdGlvbkVycm9yKGludmFsaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IER1cmF0aW9uKHsgaW52YWxpZCB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBub3JtYWxpemVVbml0KHVuaXQpIHtcbiAgICBjb25zdCBub3JtYWxpemVkID0ge1xuICAgICAgeWVhcjogXCJ5ZWFyc1wiLFxuICAgICAgeWVhcnM6IFwieWVhcnNcIixcbiAgICAgIHF1YXJ0ZXI6IFwicXVhcnRlcnNcIixcbiAgICAgIHF1YXJ0ZXJzOiBcInF1YXJ0ZXJzXCIsXG4gICAgICBtb250aDogXCJtb250aHNcIixcbiAgICAgIG1vbnRoczogXCJtb250aHNcIixcbiAgICAgIHdlZWs6IFwid2Vla3NcIixcbiAgICAgIHdlZWtzOiBcIndlZWtzXCIsXG4gICAgICBkYXk6IFwiZGF5c1wiLFxuICAgICAgZGF5czogXCJkYXlzXCIsXG4gICAgICBob3VyOiBcImhvdXJzXCIsXG4gICAgICBob3VyczogXCJob3Vyc1wiLFxuICAgICAgbWludXRlOiBcIm1pbnV0ZXNcIixcbiAgICAgIG1pbnV0ZXM6IFwibWludXRlc1wiLFxuICAgICAgc2Vjb25kOiBcInNlY29uZHNcIixcbiAgICAgIHNlY29uZHM6IFwic2Vjb25kc1wiLFxuICAgICAgbWlsbGlzZWNvbmQ6IFwibWlsbGlzZWNvbmRzXCIsXG4gICAgICBtaWxsaXNlY29uZHM6IFwibWlsbGlzZWNvbmRzXCIsXG4gICAgfVt1bml0ID8gdW5pdC50b0xvd2VyQ2FzZSgpIDogdW5pdF07XG5cbiAgICBpZiAoIW5vcm1hbGl6ZWQpIHRocm93IG5ldyBJbnZhbGlkVW5pdEVycm9yKHVuaXQpO1xuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gb2JqZWN0IGlzIGEgRHVyYXRpb24uIFdvcmtzIGFjcm9zcyBjb250ZXh0IGJvdW5kYXJpZXNcbiAgICogQHBhcmFtIHtvYmplY3R9IG9cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc0R1cmF0aW9uKG8pIHtcbiAgICByZXR1cm4gKG8gJiYgby5pc0x1eG9uRHVyYXRpb24pIHx8IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCAgdGhlIGxvY2FsZSBvZiBhIER1cmF0aW9uLCBzdWNoICdlbi1HQidcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBsb2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMubG9jLmxvY2FsZSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBudW1iZXJpbmcgc3lzdGVtIG9mIGEgRHVyYXRpb24sIHN1Y2ggJ2JlbmcnLiBUaGUgbnVtYmVyaW5nIHN5c3RlbSBpcyB1c2VkIHdoZW4gZm9ybWF0dGluZyB0aGUgRHVyYXRpb25cbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBudW1iZXJpbmdTeXN0ZW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMubG9jLm51bWJlcmluZ1N5c3RlbSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIER1cmF0aW9uIGZvcm1hdHRlZCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBmb3JtYXQgc3RyaW5nLiBZb3UgbWF5IHVzZSB0aGVzZSB0b2tlbnM6XG4gICAqICogYFNgIGZvciBtaWxsaXNlY29uZHNcbiAgICogKiBgc2AgZm9yIHNlY29uZHNcbiAgICogKiBgbWAgZm9yIG1pbnV0ZXNcbiAgICogKiBgaGAgZm9yIGhvdXJzXG4gICAqICogYGRgIGZvciBkYXlzXG4gICAqICogYHdgIGZvciB3ZWVrc1xuICAgKiAqIGBNYCBmb3IgbW9udGhzXG4gICAqICogYHlgIGZvciB5ZWFyc1xuICAgKiBOb3RlczpcbiAgICogKiBBZGQgcGFkZGluZyBieSByZXBlYXRpbmcgdGhlIHRva2VuLCBlLmcuIFwieXlcIiBwYWRzIHRoZSB5ZWFycyB0byB0d28gZGlnaXRzLCBcImhoaGhcIiBwYWRzIHRoZSBob3VycyBvdXQgdG8gZm91ciBkaWdpdHNcbiAgICogKiBUb2tlbnMgY2FuIGJlIGVzY2FwZWQgYnkgd3JhcHBpbmcgd2l0aCBzaW5nbGUgcXVvdGVzLlxuICAgKiAqIFRoZSBkdXJhdGlvbiB3aWxsIGJlIGNvbnZlcnRlZCB0byB0aGUgc2V0IG9mIHVuaXRzIGluIHRoZSBmb3JtYXQgc3RyaW5nIHVzaW5nIHtAbGluayBEdXJhdGlvbiNzaGlmdFRvfSBhbmQgdGhlIER1cmF0aW9ucydzIGNvbnZlcnNpb24gYWNjdXJhY3kgc2V0dGluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGZtdCAtIHRoZSBmb3JtYXQgc3RyaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmZsb29yPXRydWVdIC0gZmxvb3IgbnVtZXJpY2FsIHZhbHVlc1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDEsIGRheXM6IDYsIHNlY29uZHM6IDIgfSkudG9Gb3JtYXQoXCJ5IGQgc1wiKSAvLz0+IFwiMSA2IDJcIlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDEsIGRheXM6IDYsIHNlY29uZHM6IDIgfSkudG9Gb3JtYXQoXCJ5eSBkZCBzc3NcIikgLy89PiBcIjAxIDA2IDAwMlwiXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMSwgZGF5czogNiwgc2Vjb25kczogMiB9KS50b0Zvcm1hdChcIk0gU1wiKSAvLz0+IFwiMTIgNTE4NDAyMDAwXCJcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9Gb3JtYXQoZm10LCBvcHRzID0ge30pIHtcbiAgICAvLyByZXZlcnNlLWNvbXBhdCBzaW5jZSAxLjI7IHdlIGFsd2F5cyByb3VuZCBkb3duIG5vdywgbmV2ZXIgdXAsIGFuZCB3ZSBkbyBpdCBieSBkZWZhdWx0XG4gICAgY29uc3QgZm10T3B0cyA9IHtcbiAgICAgIC4uLm9wdHMsXG4gICAgICBmbG9vcjogb3B0cy5yb3VuZCAhPT0gZmFsc2UgJiYgb3B0cy5mbG9vciAhPT0gZmFsc2UsXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkXG4gICAgICA/IEZvcm1hdHRlci5jcmVhdGUodGhpcy5sb2MsIGZtdE9wdHMpLmZvcm1hdER1cmF0aW9uRnJvbVN0cmluZyh0aGlzLCBmbXQpXG4gICAgICA6IElOVkFMSUQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIER1cmF0aW9uIHdpdGggYWxsIHVuaXRzIGluY2x1ZGVkLlxuICAgKiBUbyBtb2RpZnkgaXRzIGJlaGF2aW9yIHVzZSB0aGUgYGxpc3RTdHlsZWAgYW5kIGFueSBJbnRsLk51bWJlckZvcm1hdCBvcHRpb24sIHRob3VnaCBgdW5pdERpc3BsYXlgIGlzIGVzcGVjaWFsbHkgcmVsZXZhbnQuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvSW50bC9OdW1iZXJGb3JtYXRcbiAgICogQHBhcmFtIG9wdHMgLSBPbiBvcHRpb24gb2JqZWN0IHRvIG92ZXJyaWRlIHRoZSBmb3JtYXR0aW5nLiBBY2NlcHRzIHRoZSBzYW1lIGtleXMgYXMgdGhlIG9wdGlvbnMgcGFyYW1ldGVyIG9mIHRoZSBuYXRpdmUgYEludC5OdW1iZXJGb3JtYXRgIGNvbnN0cnVjdG9yLCBhcyB3ZWxsIGFzIGBsaXN0U3R5bGVgLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiB2YXIgZHVyID0gRHVyYXRpb24uZnJvbU9iamVjdCh7IGRheXM6IDEsIGhvdXJzOiA1LCBtaW51dGVzOiA2IH0pXG4gICAqIGR1ci50b0h1bWFuKCkgLy89PiAnMSBkYXksIDUgaG91cnMsIDYgbWludXRlcydcbiAgICogZHVyLnRvSHVtYW4oeyBsaXN0U3R5bGU6IFwibG9uZ1wiIH0pIC8vPT4gJzEgZGF5LCA1IGhvdXJzLCBhbmQgNiBtaW51dGVzJ1xuICAgKiBkdXIudG9IdW1hbih7IHVuaXREaXNwbGF5OiBcInNob3J0XCIgfSkgLy89PiAnMSBkYXksIDUgaHIsIDYgbWluJ1xuICAgKiBgYGBcbiAgICovXG4gIHRvSHVtYW4ob3B0cyA9IHt9KSB7XG4gICAgY29uc3QgbCA9IG9yZGVyZWRVbml0c1xuICAgICAgLm1hcCgodW5pdCkgPT4ge1xuICAgICAgICBjb25zdCB2YWwgPSB0aGlzLnZhbHVlc1t1bml0XTtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbCkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sb2NcbiAgICAgICAgICAubnVtYmVyRm9ybWF0dGVyKHsgc3R5bGU6IFwidW5pdFwiLCB1bml0RGlzcGxheTogXCJsb25nXCIsIC4uLm9wdHMsIHVuaXQ6IHVuaXQuc2xpY2UoMCwgLTEpIH0pXG4gICAgICAgICAgLmZvcm1hdCh2YWwpO1xuICAgICAgfSlcbiAgICAgIC5maWx0ZXIoKG4pID0+IG4pO1xuXG4gICAgcmV0dXJuIHRoaXMubG9jXG4gICAgICAubGlzdEZvcm1hdHRlcih7IHR5cGU6IFwiY29uanVuY3Rpb25cIiwgc3R5bGU6IG9wdHMubGlzdFN0eWxlIHx8IFwibmFycm93XCIsIC4uLm9wdHMgfSlcbiAgICAgIC5mb3JtYXQobCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIEphdmFTY3JpcHQgb2JqZWN0IHdpdGggdGhpcyBEdXJhdGlvbidzIHZhbHVlcy5cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAxLCBkYXlzOiA2LCBzZWNvbmRzOiAyIH0pLnRvT2JqZWN0KCkgLy89PiB7IHllYXJzOiAxLCBkYXlzOiA2LCBzZWNvbmRzOiAyIH1cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgdG9PYmplY3QoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB7fTtcbiAgICByZXR1cm4geyAuLi50aGlzLnZhbHVlcyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIER1cmF0aW9uLlxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI0R1cmF0aW9uc1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDMsIHNlY29uZHM6IDQ1IH0pLnRvSVNPKCkgLy89PiAnUDNZVDQ1UydcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IG1vbnRoczogNCwgc2Vjb25kczogNDUgfSkudG9JU08oKSAvLz0+ICdQNE1UNDVTJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbW9udGhzOiA1IH0pLnRvSVNPKCkgLy89PiAnUDVNJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbWludXRlczogNSB9KS50b0lTTygpIC8vPT4gJ1BUNU0nXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBtaWxsaXNlY29uZHM6IDYgfSkudG9JU08oKSAvLz0+ICdQVDAuMDA2UydcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU08oKSB7XG4gICAgLy8gd2UgY291bGQgdXNlIHRoZSBmb3JtYXR0ZXIsIGJ1dCB0aGlzIGlzIGFuIGVhc2llciB3YXkgdG8gZ2V0IHRoZSBtaW5pbXVtIHN0cmluZ1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gbnVsbDtcblxuICAgIGxldCBzID0gXCJQXCI7XG4gICAgaWYgKHRoaXMueWVhcnMgIT09IDApIHMgKz0gdGhpcy55ZWFycyArIFwiWVwiO1xuICAgIGlmICh0aGlzLm1vbnRocyAhPT0gMCB8fCB0aGlzLnF1YXJ0ZXJzICE9PSAwKSBzICs9IHRoaXMubW9udGhzICsgdGhpcy5xdWFydGVycyAqIDMgKyBcIk1cIjtcbiAgICBpZiAodGhpcy53ZWVrcyAhPT0gMCkgcyArPSB0aGlzLndlZWtzICsgXCJXXCI7XG4gICAgaWYgKHRoaXMuZGF5cyAhPT0gMCkgcyArPSB0aGlzLmRheXMgKyBcIkRcIjtcbiAgICBpZiAodGhpcy5ob3VycyAhPT0gMCB8fCB0aGlzLm1pbnV0ZXMgIT09IDAgfHwgdGhpcy5zZWNvbmRzICE9PSAwIHx8IHRoaXMubWlsbGlzZWNvbmRzICE9PSAwKVxuICAgICAgcyArPSBcIlRcIjtcbiAgICBpZiAodGhpcy5ob3VycyAhPT0gMCkgcyArPSB0aGlzLmhvdXJzICsgXCJIXCI7XG4gICAgaWYgKHRoaXMubWludXRlcyAhPT0gMCkgcyArPSB0aGlzLm1pbnV0ZXMgKyBcIk1cIjtcbiAgICBpZiAodGhpcy5zZWNvbmRzICE9PSAwIHx8IHRoaXMubWlsbGlzZWNvbmRzICE9PSAwKVxuICAgICAgLy8gdGhpcyB3aWxsIGhhbmRsZSBcImZsb2F0aW5nIHBvaW50IG1hZG5lc3NcIiBieSByZW1vdmluZyBleHRyYSBkZWNpbWFsIHBsYWNlc1xuICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTg4MDA0L2lzLWZsb2F0aW5nLXBvaW50LW1hdGgtYnJva2VuXG4gICAgICBzICs9IHJvdW5kVG8odGhpcy5zZWNvbmRzICsgdGhpcy5taWxsaXNlY29uZHMgLyAxMDAwLCAzKSArIFwiU1wiO1xuICAgIGlmIChzID09PSBcIlBcIikgcyArPSBcIlQwU1wiO1xuICAgIHJldHVybiBzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIER1cmF0aW9uLCBmb3JtYXR0ZWQgYXMgYSB0aW1lIG9mIGRheS5cbiAgICogTm90ZSB0aGF0IHRoaXMgd2lsbCByZXR1cm4gbnVsbCBpZiB0aGUgZHVyYXRpb24gaXMgaW52YWxpZCwgbmVnYXRpdmUsIG9yIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiAyNCBob3Vycy5cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNUaW1lc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zdXBwcmVzc01pbGxpc2Vjb25kcz1mYWxzZV0gLSBleGNsdWRlIG1pbGxpc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3VwcHJlc3NTZWNvbmRzPWZhbHNlXSAtIGV4Y2x1ZGUgc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZVByZWZpeD1mYWxzZV0gLSBpbmNsdWRlIHRoZSBgVGAgcHJlZml4XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5mb3JtYXQ9J2V4dGVuZGVkJ10gLSBjaG9vc2UgYmV0d2VlbiB0aGUgYmFzaWMgYW5kIGV4dGVuZGVkIGZvcm1hdFxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDExIH0pLnRvSVNPVGltZSgpIC8vPT4gJzExOjAwOjAwLjAwMCdcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxMSB9KS50b0lTT1RpbWUoeyBzdXBwcmVzc01pbGxpc2Vjb25kczogdHJ1ZSB9KSAvLz0+ICcxMTowMDowMCdcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxMSB9KS50b0lTT1RpbWUoeyBzdXBwcmVzc1NlY29uZHM6IHRydWUgfSkgLy89PiAnMTE6MDAnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMTEgfSkudG9JU09UaW1lKHsgaW5jbHVkZVByZWZpeDogdHJ1ZSB9KSAvLz0+ICdUMTE6MDA6MDAuMDAwJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDExIH0pLnRvSVNPVGltZSh7IGZvcm1hdDogJ2Jhc2ljJyB9KSAvLz0+ICcxMTAwMDAuMDAwJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTT1RpbWUob3B0cyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBudWxsO1xuXG4gICAgY29uc3QgbWlsbGlzID0gdGhpcy50b01pbGxpcygpO1xuICAgIGlmIChtaWxsaXMgPCAwIHx8IG1pbGxpcyA+PSA4NjQwMDAwMCkgcmV0dXJuIG51bGw7XG5cbiAgICBvcHRzID0ge1xuICAgICAgc3VwcHJlc3NNaWxsaXNlY29uZHM6IGZhbHNlLFxuICAgICAgc3VwcHJlc3NTZWNvbmRzOiBmYWxzZSxcbiAgICAgIGluY2x1ZGVQcmVmaXg6IGZhbHNlLFxuICAgICAgZm9ybWF0OiBcImV4dGVuZGVkXCIsXG4gICAgICAuLi5vcHRzLFxuICAgIH07XG5cbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuc2hpZnRUbyhcImhvdXJzXCIsIFwibWludXRlc1wiLCBcInNlY29uZHNcIiwgXCJtaWxsaXNlY29uZHNcIik7XG5cbiAgICBsZXQgZm10ID0gb3B0cy5mb3JtYXQgPT09IFwiYmFzaWNcIiA/IFwiaGhtbVwiIDogXCJoaDptbVwiO1xuXG4gICAgaWYgKCFvcHRzLnN1cHByZXNzU2Vjb25kcyB8fCB2YWx1ZS5zZWNvbmRzICE9PSAwIHx8IHZhbHVlLm1pbGxpc2Vjb25kcyAhPT0gMCkge1xuICAgICAgZm10ICs9IG9wdHMuZm9ybWF0ID09PSBcImJhc2ljXCIgPyBcInNzXCIgOiBcIjpzc1wiO1xuICAgICAgaWYgKCFvcHRzLnN1cHByZXNzTWlsbGlzZWNvbmRzIHx8IHZhbHVlLm1pbGxpc2Vjb25kcyAhPT0gMCkge1xuICAgICAgICBmbXQgKz0gXCIuU1NTXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHN0ciA9IHZhbHVlLnRvRm9ybWF0KGZtdCk7XG5cbiAgICBpZiAob3B0cy5pbmNsdWRlUHJlZml4KSB7XG4gICAgICBzdHIgPSBcIlRcIiArIHN0cjtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEdXJhdGlvbiBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIEpTT04uXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b0lTTygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEdXJhdGlvbiBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIGRlYnVnZ2luZy5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9JU08oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG1pbGxpc2Vjb25kcyB2YWx1ZSBvZiB0aGlzIER1cmF0aW9uLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICB0b01pbGxpcygpIHtcbiAgICByZXR1cm4gdGhpcy5hcyhcIm1pbGxpc2Vjb25kc1wiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG1pbGxpc2Vjb25kcyB2YWx1ZSBvZiB0aGlzIER1cmF0aW9uLiBBbGlhcyBvZiB7QGxpbmsgdG9NaWxsaXN9XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHZhbHVlT2YoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9NaWxsaXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIHRoaXMgRHVyYXRpb24gbG9uZ2VyIGJ5IHRoZSBzcGVjaWZpZWQgYW1vdW50LiBSZXR1cm4gYSBuZXdseS1jb25zdHJ1Y3RlZCBEdXJhdGlvbi5cbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBhbW91bnQgdG8gYWRkLiBFaXRoZXIgYSBMdXhvbiBEdXJhdGlvbiwgYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCB0aGUgb2JqZWN0IGFyZ3VtZW50IHRvIER1cmF0aW9uLmZyb21PYmplY3QoKVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHBsdXMoZHVyYXRpb24pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG5cbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKSxcbiAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgZm9yIChjb25zdCBrIG9mIG9yZGVyZWRVbml0cykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5KGR1ci52YWx1ZXMsIGspIHx8IGhhc093blByb3BlcnR5KHRoaXMudmFsdWVzLCBrKSkge1xuICAgICAgICByZXN1bHRba10gPSBkdXIuZ2V0KGspICsgdGhpcy5nZXQoayk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdmFsdWVzOiByZXN1bHQgfSwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSB0aGlzIER1cmF0aW9uIHNob3J0ZXIgYnkgdGhlIHNwZWNpZmllZCBhbW91bnQuIFJldHVybiBhIG5ld2x5LWNvbnN0cnVjdGVkIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufE9iamVjdHxudW1iZXJ9IGR1cmF0aW9uIC0gVGhlIGFtb3VudCB0byBzdWJ0cmFjdC4gRWl0aGVyIGEgTHV4b24gRHVyYXRpb24sIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgdGhlIG9iamVjdCBhcmd1bWVudCB0byBEdXJhdGlvbi5mcm9tT2JqZWN0KClcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBtaW51cyhkdXJhdGlvbikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcblxuICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb24pO1xuICAgIHJldHVybiB0aGlzLnBsdXMoZHVyLm5lZ2F0ZSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY2FsZSB0aGlzIER1cmF0aW9uIGJ5IHRoZSBzcGVjaWZpZWQgYW1vdW50LiBSZXR1cm4gYSBuZXdseS1jb25zdHJ1Y3RlZCBEdXJhdGlvbi5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCB1bml0LiBBcml0eSBpcyAxIG9yIDI6IHRoZSB2YWx1ZSBvZiB0aGUgdW5pdCBhbmQsIG9wdGlvbmFsbHksIHRoZSB1bml0IG5hbWUuIE11c3QgcmV0dXJuIGEgbnVtYmVyLlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDEsIG1pbnV0ZXM6IDMwIH0pLm1hcFVuaXRzKHggPT4geCAqIDIpIC8vPT4geyBob3VyczogMiwgbWludXRlczogNjAgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDEsIG1pbnV0ZXM6IDMwIH0pLm1hcFVuaXRzKCh4LCB1KSA9PiB1ID09PSBcImhvdXJzXCIgPyB4ICogMiA6IHgpIC8vPT4geyBob3VyczogMiwgbWludXRlczogMzAgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIG1hcFVuaXRzKGZuKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyh0aGlzLnZhbHVlcykpIHtcbiAgICAgIHJlc3VsdFtrXSA9IGFzTnVtYmVyKGZuKHRoaXMudmFsdWVzW2tdLCBrKSk7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogcmVzdWx0IH0sIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgb2YgdW5pdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSBhIHVuaXQgc3VjaCBhcyAnbWludXRlJyBvciAnZGF5J1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHt5ZWFyczogMiwgZGF5czogM30pLmdldCgneWVhcnMnKSAvLz0+IDJcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7eWVhcnM6IDIsIGRheXM6IDN9KS5nZXQoJ21vbnRocycpIC8vPT4gMFxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHt5ZWFyczogMiwgZGF5czogM30pLmdldCgnZGF5cycpIC8vPT4gM1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQodW5pdCkge1xuICAgIHJldHVybiB0aGlzW0R1cmF0aW9uLm5vcm1hbGl6ZVVuaXQodW5pdCldO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIHZhbHVlcyBvZiBzcGVjaWZpZWQgdW5pdHMuIFJldHVybiBhIG5ld2x5LWNvbnN0cnVjdGVkIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzIC0gYSBtYXBwaW5nIG9mIHVuaXRzIHRvIG51bWJlcnNcbiAgICogQGV4YW1wbGUgZHVyLnNldCh7IHllYXJzOiAyMDE3IH0pXG4gICAqIEBleGFtcGxlIGR1ci5zZXQoeyBob3VyczogOCwgbWludXRlczogMzAgfSlcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzZXQodmFsdWVzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuXG4gICAgY29uc3QgbWl4ZWQgPSB7IC4uLnRoaXMudmFsdWVzLCAuLi5ub3JtYWxpemVPYmplY3QodmFsdWVzLCBEdXJhdGlvbi5ub3JtYWxpemVVbml0KSB9O1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogbWl4ZWQgfSk7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgbG9jYWxlIGFuZC9vciBudW1iZXJpbmdTeXN0ZW0uICBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRHVyYXRpb24uXG4gICAqIEBleGFtcGxlIGR1ci5yZWNvbmZpZ3VyZSh7IGxvY2FsZTogJ2VuLUdCJyB9KVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHJlY29uZmlndXJlKHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIGNvbnZlcnNpb25BY2N1cmFjeSwgbWF0cml4IH0gPSB7fSkge1xuICAgIGNvbnN0IGxvYyA9IHRoaXMubG9jLmNsb25lKHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0gfSk7XG4gICAgY29uc3Qgb3B0cyA9IHsgbG9jLCBtYXRyaXgsIGNvbnZlcnNpb25BY2N1cmFjeSB9O1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgZHVyYXRpb24gaW4gdGhlIHNwZWNpZmllZCB1bml0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIGEgdW5pdCBzdWNoIGFzICdtaW51dGVzJyBvciAnZGF5cydcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7eWVhcnM6IDF9KS5hcygnZGF5cycpIC8vPT4gMzY1XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3Qoe3llYXJzOiAxfSkuYXMoJ21vbnRocycpIC8vPT4gMTJcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7aG91cnM6IDYwfSkuYXMoJ2RheXMnKSAvLz0+IDIuNVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBhcyh1bml0KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuc2hpZnRUbyh1bml0KS5nZXQodW5pdCkgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmVkdWNlIHRoaXMgRHVyYXRpb24gdG8gaXRzIGNhbm9uaWNhbCByZXByZXNlbnRhdGlvbiBpbiBpdHMgY3VycmVudCB1bml0cy5cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAyLCBkYXlzOiA1MDAwIH0pLm5vcm1hbGl6ZSgpLnRvT2JqZWN0KCkgLy89PiB7IHllYXJzOiAxNSwgZGF5czogMjU1IH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxMiwgbWludXRlczogLTQ1IH0pLm5vcm1hbGl6ZSgpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMTUgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIG5vcm1hbGl6ZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgdmFscyA9IHRoaXMudG9PYmplY3QoKTtcbiAgICBub3JtYWxpemVWYWx1ZXModGhpcy5tYXRyaXgsIHZhbHMpO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogdmFscyB9LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNjYWxlIHVuaXRzIHRvIGl0cyBsYXJnZXN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBtaWxsaXNlY29uZHM6IDkwMDAwIH0pLnJlc2NhbGUoKS50b09iamVjdCgpIC8vPT4geyBtaW51dGVzOiAxLCBzZWNvbmRzOiAzMCB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgcmVzY2FsZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgdmFscyA9IHJlbW92ZVplcm9lcyh0aGlzLm5vcm1hbGl6ZSgpLnNoaWZ0VG9BbGwoKS50b09iamVjdCgpKTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB2YWx1ZXM6IHZhbHMgfSwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCB0aGlzIER1cmF0aW9uIGludG8gaXRzIHJlcHJlc2VudGF0aW9uIGluIGEgZGlmZmVyZW50IHNldCBvZiB1bml0cy5cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxLCBzZWNvbmRzOiAzMCB9KS5zaGlmdFRvKCdtaW51dGVzJywgJ21pbGxpc2Vjb25kcycpLnRvT2JqZWN0KCkgLy89PiB7IG1pbnV0ZXM6IDYwLCBtaWxsaXNlY29uZHM6IDMwMDAwIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzaGlmdFRvKC4uLnVuaXRzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKHVuaXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdW5pdHMgPSB1bml0cy5tYXAoKHUpID0+IER1cmF0aW9uLm5vcm1hbGl6ZVVuaXQodSkpO1xuXG4gICAgY29uc3QgYnVpbHQgPSB7fSxcbiAgICAgIGFjY3VtdWxhdGVkID0ge30sXG4gICAgICB2YWxzID0gdGhpcy50b09iamVjdCgpO1xuICAgIGxldCBsYXN0VW5pdDtcblxuICAgIGZvciAoY29uc3QgayBvZiBvcmRlcmVkVW5pdHMpIHtcbiAgICAgIGlmICh1bml0cy5pbmRleE9mKGspID49IDApIHtcbiAgICAgICAgbGFzdFVuaXQgPSBrO1xuXG4gICAgICAgIGxldCBvd24gPSAwO1xuXG4gICAgICAgIC8vIGFueXRoaW5nIHdlIGhhdmVuJ3QgYm9pbGVkIGRvd24geWV0IHNob3VsZCBnZXQgYm9pbGVkIHRvIHRoaXMgdW5pdFxuICAgICAgICBmb3IgKGNvbnN0IGFrIGluIGFjY3VtdWxhdGVkKSB7XG4gICAgICAgICAgb3duICs9IHRoaXMubWF0cml4W2FrXVtrXSAqIGFjY3VtdWxhdGVkW2FrXTtcbiAgICAgICAgICBhY2N1bXVsYXRlZFtha10gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGx1cyBhbnl0aGluZyB0aGF0J3MgYWxyZWFkeSBpbiB0aGlzIHVuaXRcbiAgICAgICAgaWYgKGlzTnVtYmVyKHZhbHNba10pKSB7XG4gICAgICAgICAgb3duICs9IHZhbHNba107XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpID0gTWF0aC50cnVuYyhvd24pO1xuICAgICAgICBidWlsdFtrXSA9IGk7XG4gICAgICAgIGFjY3VtdWxhdGVkW2tdID0gKG93biAqIDEwMDAgLSBpICogMTAwMCkgLyAxMDAwO1xuXG4gICAgICAgIC8vIHBsdXMgYW55dGhpbmcgZnVydGhlciBkb3duIHRoZSBjaGFpbiB0aGF0IHNob3VsZCBiZSByb2xsZWQgdXAgaW4gdG8gdGhpc1xuICAgICAgICBmb3IgKGNvbnN0IGRvd24gaW4gdmFscykge1xuICAgICAgICAgIGlmIChvcmRlcmVkVW5pdHMuaW5kZXhPZihkb3duKSA+IG9yZGVyZWRVbml0cy5pbmRleE9mKGspKSB7XG4gICAgICAgICAgICBjb252ZXJ0KHRoaXMubWF0cml4LCB2YWxzLCBkb3duLCBidWlsdCwgayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIG90aGVyd2lzZSwga2VlcCBpdCBpbiB0aGUgd2luZ3MgdG8gYm9pbCBpdCBsYXRlclxuICAgICAgfSBlbHNlIGlmIChpc051bWJlcih2YWxzW2tdKSkge1xuICAgICAgICBhY2N1bXVsYXRlZFtrXSA9IHZhbHNba107XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYW55dGhpbmcgbGVmdG92ZXIgYmVjb21lcyB0aGUgZGVjaW1hbCBmb3IgdGhlIGxhc3QgdW5pdFxuICAgIC8vIGxhc3RVbml0IG11c3QgYmUgZGVmaW5lZCBzaW5jZSB1bml0cyBpcyBub3QgZW1wdHlcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhY2N1bXVsYXRlZCkge1xuICAgICAgaWYgKGFjY3VtdWxhdGVkW2tleV0gIT09IDApIHtcbiAgICAgICAgYnVpbHRbbGFzdFVuaXRdICs9XG4gICAgICAgICAga2V5ID09PSBsYXN0VW5pdCA/IGFjY3VtdWxhdGVkW2tleV0gOiBhY2N1bXVsYXRlZFtrZXldIC8gdGhpcy5tYXRyaXhbbGFzdFVuaXRdW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdmFsdWVzOiBidWlsdCB9LCB0cnVlKS5ub3JtYWxpemUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaGlmdCB0aGlzIER1cmF0aW9uIHRvIGFsbCBhdmFpbGFibGUgdW5pdHMuXG4gICAqIFNhbWUgYXMgc2hpZnRUbyhcInllYXJzXCIsIFwibW9udGhzXCIsIFwid2Vla3NcIiwgXCJkYXlzXCIsIFwiaG91cnNcIiwgXCJtaW51dGVzXCIsIFwic2Vjb25kc1wiLCBcIm1pbGxpc2Vjb25kc1wiKVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHNoaWZ0VG9BbGwoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIHJldHVybiB0aGlzLnNoaWZ0VG8oXG4gICAgICBcInllYXJzXCIsXG4gICAgICBcIm1vbnRoc1wiLFxuICAgICAgXCJ3ZWVrc1wiLFxuICAgICAgXCJkYXlzXCIsXG4gICAgICBcImhvdXJzXCIsXG4gICAgICBcIm1pbnV0ZXNcIixcbiAgICAgIFwic2Vjb25kc1wiLFxuICAgICAgXCJtaWxsaXNlY29uZHNcIlxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBuZWdhdGl2ZSBvZiB0aGlzIER1cmF0aW9uLlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDEsIHNlY29uZHM6IDMwIH0pLm5lZ2F0ZSgpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAtMSwgc2Vjb25kczogLTMwIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBuZWdhdGUoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IG5lZ2F0ZWQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXModGhpcy52YWx1ZXMpKSB7XG4gICAgICBuZWdhdGVkW2tdID0gdGhpcy52YWx1ZXNba10gPT09IDAgPyAwIDogLXRoaXMudmFsdWVzW2tdO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB2YWx1ZXM6IG5lZ2F0ZWQgfSwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB5ZWFycy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB5ZWFycygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMueWVhcnMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHF1YXJ0ZXJzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHF1YXJ0ZXJzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5xdWFydGVycyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbW9udGhzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1vbnRocygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMubW9udGhzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB3ZWVrc1xuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdlZWtzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy53ZWVrcyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGF5cy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBkYXlzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5kYXlzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBob3Vycy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBob3VycygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMuaG91cnMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pbnV0ZXMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbWludXRlcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMubWludXRlcyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2Vjb25kcy5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHNlY29uZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLnNlY29uZHMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pbGxpc2Vjb25kcy5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1pbGxpc2Vjb25kcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMubWlsbGlzZWNvbmRzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBEdXJhdGlvbiBpcyBpbnZhbGlkLiBJbnZhbGlkIGR1cmF0aW9ucyBhcmUgcmV0dXJuZWQgYnkgZGlmZiBvcGVyYXRpb25zXG4gICAqIG9uIGludmFsaWQgRGF0ZVRpbWVzIG9yIEludGVydmFscy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPT09IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBlcnJvciBjb2RlIGlmIHRoaXMgRHVyYXRpb24gYmVjYW1lIGludmFsaWQsIG9yIG51bGwgaWYgdGhlIER1cmF0aW9uIGlzIHZhbGlkXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldCBpbnZhbGlkUmVhc29uKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPyB0aGlzLmludmFsaWQucmVhc29uIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGV4cGxhbmF0aW9uIG9mIHdoeSB0aGlzIER1cmF0aW9uIGJlY2FtZSBpbnZhbGlkLCBvciBudWxsIGlmIHRoZSBEdXJhdGlvbiBpcyB2YWxpZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGludmFsaWRFeHBsYW5hdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID8gdGhpcy5pbnZhbGlkLmV4cGxhbmF0aW9uIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFcXVhbGl0eSBjaGVja1xuICAgKiBUd28gRHVyYXRpb25zIGFyZSBlcXVhbCBpZmYgdGhleSBoYXZlIHRoZSBzYW1lIHVuaXRzIGFuZCB0aGUgc2FtZSB2YWx1ZXMgZm9yIGVhY2ggdW5pdC5cbiAgICogQHBhcmFtIHtEdXJhdGlvbn0gb3RoZXJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGVxdWFscyhvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkIHx8ICFvdGhlci5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmxvYy5lcXVhbHMob3RoZXIubG9jKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVxKHYxLCB2Mikge1xuICAgICAgLy8gQ29uc2lkZXIgMCBhbmQgdW5kZWZpbmVkIGFzIGVxdWFsXG4gICAgICBpZiAodjEgPT09IHVuZGVmaW5lZCB8fCB2MSA9PT0gMCkgcmV0dXJuIHYyID09PSB1bmRlZmluZWQgfHwgdjIgPT09IDA7XG4gICAgICByZXR1cm4gdjEgPT09IHYyO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgdSBvZiBvcmRlcmVkVW5pdHMpIHtcbiAgICAgIGlmICghZXEodGhpcy52YWx1ZXNbdV0sIG90aGVyLnZhbHVlc1t1XSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuIiwiaW1wb3J0IERhdGVUaW1lLCB7IGZyaWVuZGx5RGF0ZVRpbWUgfSBmcm9tIFwiLi9kYXRldGltZS5qc1wiO1xuaW1wb3J0IER1cmF0aW9uIGZyb20gXCIuL2R1cmF0aW9uLmpzXCI7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSBcIi4vc2V0dGluZ3MuanNcIjtcbmltcG9ydCB7IEludmFsaWRBcmd1bWVudEVycm9yLCBJbnZhbGlkSW50ZXJ2YWxFcnJvciB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IEludmFsaWQgZnJvbSBcIi4vaW1wbC9pbnZhbGlkLmpzXCI7XG5pbXBvcnQgRm9ybWF0dGVyIGZyb20gXCIuL2ltcGwvZm9ybWF0dGVyLmpzXCI7XG5pbXBvcnQgKiBhcyBGb3JtYXRzIGZyb20gXCIuL2ltcGwvZm9ybWF0cy5qc1wiO1xuXG5jb25zdCBJTlZBTElEID0gXCJJbnZhbGlkIEludGVydmFsXCI7XG5cbi8vIGNoZWNrcyBpZiB0aGUgc3RhcnQgaXMgZXF1YWwgdG8gb3IgYmVmb3JlIHRoZSBlbmRcbmZ1bmN0aW9uIHZhbGlkYXRlU3RhcnRFbmQoc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0IHx8ICFzdGFydC5pc1ZhbGlkKSB7XG4gICAgcmV0dXJuIEludGVydmFsLmludmFsaWQoXCJtaXNzaW5nIG9yIGludmFsaWQgc3RhcnRcIik7XG4gIH0gZWxzZSBpZiAoIWVuZCB8fCAhZW5kLmlzVmFsaWQpIHtcbiAgICByZXR1cm4gSW50ZXJ2YWwuaW52YWxpZChcIm1pc3Npbmcgb3IgaW52YWxpZCBlbmRcIik7XG4gIH0gZWxzZSBpZiAoZW5kIDwgc3RhcnQpIHtcbiAgICByZXR1cm4gSW50ZXJ2YWwuaW52YWxpZChcbiAgICAgIFwiZW5kIGJlZm9yZSBzdGFydFwiLFxuICAgICAgYFRoZSBlbmQgb2YgYW4gaW50ZXJ2YWwgbXVzdCBiZSBhZnRlciBpdHMgc3RhcnQsIGJ1dCB5b3UgaGFkIHN0YXJ0PSR7c3RhcnQudG9JU08oKX0gYW5kIGVuZD0ke2VuZC50b0lTTygpfWBcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogQW4gSW50ZXJ2YWwgb2JqZWN0IHJlcHJlc2VudHMgYSBoYWxmLW9wZW4gaW50ZXJ2YWwgb2YgdGltZSwgd2hlcmUgZWFjaCBlbmRwb2ludCBpcyBhIHtAbGluayBEYXRlVGltZX0uIENvbmNlcHR1YWxseSwgaXQncyBhIGNvbnRhaW5lciBmb3IgdGhvc2UgdHdvIGVuZHBvaW50cywgYWNjb21wYW5pZWQgYnkgbWV0aG9kcyBmb3IgY3JlYXRpbmcsIHBhcnNpbmcsIGludGVycm9nYXRpbmcsIGNvbXBhcmluZywgdHJhbnNmb3JtaW5nLCBhbmQgZm9ybWF0dGluZyB0aGVtLlxuICpcbiAqIEhlcmUgaXMgYSBicmllZiBvdmVydmlldyBvZiB0aGUgbW9zdCBjb21tb25seSB1c2VkIG1ldGhvZHMgYW5kIGdldHRlcnMgaW4gSW50ZXJ2YWw6XG4gKlxuICogKiAqKkNyZWF0aW9uKiogVG8gY3JlYXRlIGFuIEludGVydmFsLCB1c2Uge0BsaW5rIEludGVydmFsLmZyb21EYXRlVGltZXN9LCB7QGxpbmsgSW50ZXJ2YWwuYWZ0ZXJ9LCB7QGxpbmsgSW50ZXJ2YWwuYmVmb3JlfSwgb3Ige0BsaW5rIEludGVydmFsLmZyb21JU099LlxuICogKiAqKkFjY2Vzc29ycyoqIFVzZSB7QGxpbmsgSW50ZXJ2YWwjc3RhcnR9IGFuZCB7QGxpbmsgSW50ZXJ2YWwjZW5kfSB0byBnZXQgdGhlIHN0YXJ0IGFuZCBlbmQuXG4gKiAqICoqSW50ZXJyb2dhdGlvbioqIFRvIGFuYWx5emUgdGhlIEludGVydmFsLCB1c2Uge0BsaW5rIEludGVydmFsI2NvdW50fSwge0BsaW5rIEludGVydmFsI2xlbmd0aH0sIHtAbGluayBJbnRlcnZhbCNoYXNTYW1lfSwge0BsaW5rIEludGVydmFsI2NvbnRhaW5zfSwge0BsaW5rIEludGVydmFsI2lzQWZ0ZXJ9LCBvciB7QGxpbmsgSW50ZXJ2YWwjaXNCZWZvcmV9LlxuICogKiAqKlRyYW5zZm9ybWF0aW9uKiogVG8gY3JlYXRlIG90aGVyIEludGVydmFscyBvdXQgb2YgdGhpcyBvbmUsIHVzZSB7QGxpbmsgSW50ZXJ2YWwjc2V0fSwge0BsaW5rIEludGVydmFsI3NwbGl0QXR9LCB7QGxpbmsgSW50ZXJ2YWwjc3BsaXRCeX0sIHtAbGluayBJbnRlcnZhbCNkaXZpZGVFcXVhbGx5fSwge0BsaW5rIEludGVydmFsLm1lcmdlfSwge0BsaW5rIEludGVydmFsLnhvcn0sIHtAbGluayBJbnRlcnZhbCN1bmlvbn0sIHtAbGluayBJbnRlcnZhbCNpbnRlcnNlY3Rpb259LCBvciB7QGxpbmsgSW50ZXJ2YWwjZGlmZmVyZW5jZX0uXG4gKiAqICoqQ29tcGFyaXNvbioqIFRvIGNvbXBhcmUgdGhpcyBJbnRlcnZhbCB0byBhbm90aGVyIG9uZSwgdXNlIHtAbGluayBJbnRlcnZhbCNlcXVhbHN9LCB7QGxpbmsgSW50ZXJ2YWwjb3ZlcmxhcHN9LCB7QGxpbmsgSW50ZXJ2YWwjYWJ1dHNTdGFydH0sIHtAbGluayBJbnRlcnZhbCNhYnV0c0VuZH0sIHtAbGluayBJbnRlcnZhbCNlbmd1bGZzfVxuICogKiAqKk91dHB1dCoqIFRvIGNvbnZlcnQgdGhlIEludGVydmFsIGludG8gb3RoZXIgcmVwcmVzZW50YXRpb25zLCBzZWUge0BsaW5rIEludGVydmFsI3RvU3RyaW5nfSwge0BsaW5rIEludGVydmFsI3RvTG9jYWxlU3RyaW5nfSwge0BsaW5rIEludGVydmFsI3RvSVNPfSwge0BsaW5rIEludGVydmFsI3RvSVNPRGF0ZX0sIHtAbGluayBJbnRlcnZhbCN0b0lTT1RpbWV9LCB7QGxpbmsgSW50ZXJ2YWwjdG9Gb3JtYXR9LCBhbmQge0BsaW5rIEludGVydmFsI3RvRHVyYXRpb259LlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnRlcnZhbCB7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5zID0gY29uZmlnLnN0YXJ0O1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZSA9IGNvbmZpZy5lbmQ7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pbnZhbGlkID0gY29uZmlnLmludmFsaWQgfHwgbnVsbDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmlzTHV4b25JbnRlcnZhbCA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGludmFsaWQgSW50ZXJ2YWwuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb24gLSBzaW1wbGUgc3RyaW5nIG9mIHdoeSB0aGlzIEludGVydmFsIGlzIGludmFsaWQuIFNob3VsZCBub3QgY29udGFpbiBwYXJhbWV0ZXJzIG9yIGFueXRoaW5nIGVsc2UgZGF0YS1kZXBlbmRlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtleHBsYW5hdGlvbj1udWxsXSAtIGxvbmdlciBleHBsYW5hdGlvbiwgbWF5IGluY2x1ZGUgcGFyYW1ldGVycyBhbmQgb3RoZXIgdXNlZnVsIGRlYnVnZ2luZyBpbmZvcm1hdGlvblxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIHN0YXRpYyBpbnZhbGlkKHJlYXNvbiwgZXhwbGFuYXRpb24gPSBudWxsKSB7XG4gICAgaWYgKCFyZWFzb24pIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIm5lZWQgdG8gc3BlY2lmeSBhIHJlYXNvbiB0aGUgSW50ZXJ2YWwgaXMgaW52YWxpZFwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnZhbGlkID0gcmVhc29uIGluc3RhbmNlb2YgSW52YWxpZCA/IHJlYXNvbiA6IG5ldyBJbnZhbGlkKHJlYXNvbiwgZXhwbGFuYXRpb24pO1xuXG4gICAgaWYgKFNldHRpbmdzLnRocm93T25JbnZhbGlkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEludGVydmFsRXJyb3IoaW52YWxpZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgSW50ZXJ2YWwoeyBpbnZhbGlkIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gSW50ZXJ2YWwgZnJvbSBhIHN0YXJ0IERhdGVUaW1lIGFuZCBhbiBlbmQgRGF0ZVRpbWUuIEluY2x1c2l2ZSBvZiB0aGUgc3RhcnQgYnV0IG5vdCB0aGUgZW5kLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfERhdGV8T2JqZWN0fSBzdGFydFxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfERhdGV8T2JqZWN0fSBlbmRcbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICBzdGF0aWMgZnJvbURhdGVUaW1lcyhzdGFydCwgZW5kKSB7XG4gICAgY29uc3QgYnVpbHRTdGFydCA9IGZyaWVuZGx5RGF0ZVRpbWUoc3RhcnQpLFxuICAgICAgYnVpbHRFbmQgPSBmcmllbmRseURhdGVUaW1lKGVuZCk7XG5cbiAgICBjb25zdCB2YWxpZGF0ZUVycm9yID0gdmFsaWRhdGVTdGFydEVuZChidWlsdFN0YXJ0LCBidWlsdEVuZCk7XG5cbiAgICBpZiAodmFsaWRhdGVFcnJvciA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbmV3IEludGVydmFsKHtcbiAgICAgICAgc3RhcnQ6IGJ1aWx0U3RhcnQsXG4gICAgICAgIGVuZDogYnVpbHRFbmQsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbGlkYXRlRXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBJbnRlcnZhbCBmcm9tIGEgc3RhcnQgRGF0ZVRpbWUgYW5kIGEgRHVyYXRpb24gdG8gZXh0ZW5kIHRvLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfERhdGV8T2JqZWN0fSBzdGFydFxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufE9iamVjdHxudW1iZXJ9IGR1cmF0aW9uIC0gdGhlIGxlbmd0aCBvZiB0aGUgSW50ZXJ2YWwuXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgc3RhdGljIGFmdGVyKHN0YXJ0LCBkdXJhdGlvbikge1xuICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb24pLFxuICAgICAgZHQgPSBmcmllbmRseURhdGVUaW1lKHN0YXJ0KTtcbiAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdCwgZHQucGx1cyhkdXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gSW50ZXJ2YWwgZnJvbSBhbiBlbmQgRGF0ZVRpbWUgYW5kIGEgRHVyYXRpb24gdG8gZXh0ZW5kIGJhY2t3YXJkcyB0by5cbiAgICogQHBhcmFtIHtEYXRlVGltZXxEYXRlfE9iamVjdH0gZW5kXG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSB0aGUgbGVuZ3RoIG9mIHRoZSBJbnRlcnZhbC5cbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICBzdGF0aWMgYmVmb3JlKGVuZCwgZHVyYXRpb24pIHtcbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKSxcbiAgICAgIGR0ID0gZnJpZW5kbHlEYXRlVGltZShlbmQpO1xuICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0Lm1pbnVzKGR1ciksIGR0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gSW50ZXJ2YWwgZnJvbSBhbiBJU08gODYwMSBzdHJpbmcuXG4gICAqIEFjY2VwdHMgYDxzdGFydD4vPGVuZD5gLCBgPHN0YXJ0Pi88ZHVyYXRpb24+YCwgYW5kIGA8ZHVyYXRpb24+LzxlbmQ+YCBmb3JtYXRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBJU08gc3RyaW5nIHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gLSBvcHRpb25zIHRvIHBhc3Mge0BsaW5rIERhdGVUaW1lI2Zyb21JU099IGFuZCBvcHRpb25hbGx5IHtAbGluayBEdXJhdGlvbiNmcm9tSVNPfVxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI1RpbWVfaW50ZXJ2YWxzXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgc3RhdGljIGZyb21JU08odGV4dCwgb3B0cykge1xuICAgIGNvbnN0IFtzLCBlXSA9ICh0ZXh0IHx8IFwiXCIpLnNwbGl0KFwiL1wiLCAyKTtcbiAgICBpZiAocyAmJiBlKSB7XG4gICAgICBsZXQgc3RhcnQsIHN0YXJ0SXNWYWxpZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0YXJ0ID0gRGF0ZVRpbWUuZnJvbUlTTyhzLCBvcHRzKTtcbiAgICAgICAgc3RhcnRJc1ZhbGlkID0gc3RhcnQuaXNWYWxpZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc3RhcnRJc1ZhbGlkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGxldCBlbmQsIGVuZElzVmFsaWQ7XG4gICAgICB0cnkge1xuICAgICAgICBlbmQgPSBEYXRlVGltZS5mcm9tSVNPKGUsIG9wdHMpO1xuICAgICAgICBlbmRJc1ZhbGlkID0gZW5kLmlzVmFsaWQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVuZElzVmFsaWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXJ0SXNWYWxpZCAmJiBlbmRJc1ZhbGlkKSB7XG4gICAgICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhcnRJc1ZhbGlkKSB7XG4gICAgICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21JU08oZSwgb3B0cyk7XG4gICAgICAgIGlmIChkdXIuaXNWYWxpZCkge1xuICAgICAgICAgIHJldHVybiBJbnRlcnZhbC5hZnRlcihzdGFydCwgZHVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlbmRJc1ZhbGlkKSB7XG4gICAgICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21JU08ocywgb3B0cyk7XG4gICAgICAgIGlmIChkdXIuaXNWYWxpZCkge1xuICAgICAgICAgIHJldHVybiBJbnRlcnZhbC5iZWZvcmUoZW5kLCBkdXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBJbnRlcnZhbC5pbnZhbGlkKFwidW5wYXJzYWJsZVwiLCBgdGhlIGlucHV0IFwiJHt0ZXh0fVwiIGNhbid0IGJlIHBhcnNlZCBhcyBJU08gODYwMWApO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIG9iamVjdCBpcyBhbiBJbnRlcnZhbC4gV29ya3MgYWNyb3NzIGNvbnRleHQgYm91bmRhcmllc1xuICAgKiBAcGFyYW0ge29iamVjdH0gb1xuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzSW50ZXJ2YWwobykge1xuICAgIHJldHVybiAobyAmJiBvLmlzTHV4b25JbnRlcnZhbCkgfHwgZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RhcnQgb2YgdGhlIEludGVydmFsXG4gICAqIEB0eXBlIHtEYXRlVGltZX1cbiAgICovXG4gIGdldCBzdGFydCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5zIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlbmQgb2YgdGhlIEludGVydmFsXG4gICAqIEB0eXBlIHtEYXRlVGltZX1cbiAgICovXG4gIGdldCBlbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuZSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwncyBlbmQgaXMgYXQgbGVhc3QgaXRzIHN0YXJ0LCBtZWFuaW5nIHRoYXQgdGhlIEludGVydmFsIGlzbid0ICdiYWNrd2FyZHMnLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWRSZWFzb24gPT09IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBlcnJvciBjb2RlIGlmIHRoaXMgSW50ZXJ2YWwgaXMgaW52YWxpZCwgb3IgbnVsbCBpZiB0aGUgSW50ZXJ2YWwgaXMgdmFsaWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBpbnZhbGlkUmVhc29uKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPyB0aGlzLmludmFsaWQucmVhc29uIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGV4cGxhbmF0aW9uIG9mIHdoeSB0aGlzIEludGVydmFsIGJlY2FtZSBpbnZhbGlkLCBvciBudWxsIGlmIHRoZSBJbnRlcnZhbCBpcyB2YWxpZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGludmFsaWRFeHBsYW5hdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID8gdGhpcy5pbnZhbGlkLmV4cGxhbmF0aW9uIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIEludGVydmFsIGluIHRoZSBzcGVjaWZpZWQgdW5pdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSB0aGUgdW5pdCAoc3VjaCBhcyAnaG91cnMnIG9yICdkYXlzJykgdG8gcmV0dXJuIHRoZSBsZW5ndGggaW4uXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGxlbmd0aCh1bml0ID0gXCJtaWxsaXNlY29uZHNcIikge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnRvRHVyYXRpb24oLi4uW3VuaXRdKS5nZXQodW5pdCkgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY291bnQgb2YgbWludXRlcywgaG91cnMsIGRheXMsIG1vbnRocywgb3IgeWVhcnMgaW5jbHVkZWQgaW4gdGhlIEludGVydmFsLCBldmVuIGluIHBhcnQuXG4gICAqIFVubGlrZSB7QGxpbmsgSW50ZXJ2YWwjbGVuZ3RofSB0aGlzIGNvdW50cyBzZWN0aW9ucyBvZiB0aGUgY2FsZW5kYXIsIG5vdCBwZXJpb2RzIG9mIHRpbWUsIGUuZy4gc3BlY2lmeWluZyAnZGF5J1xuICAgKiBhc2tzICd3aGF0IGRhdGVzIGFyZSBpbmNsdWRlZCBpbiB0aGlzIGludGVydmFsPycsIG5vdCAnaG93IG1hbnkgZGF5cyBsb25nIGlzIHRoaXMgaW50ZXJ2YWw/J1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW3VuaXQ9J21pbGxpc2Vjb25kcyddIC0gdGhlIHVuaXQgb2YgdGltZSB0byBjb3VudC5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgY291bnQodW5pdCA9IFwibWlsbGlzZWNvbmRzXCIpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIE5hTjtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuc3RhcnQuc3RhcnRPZih1bml0KSxcbiAgICAgIGVuZCA9IHRoaXMuZW5kLnN0YXJ0T2YodW5pdCk7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoZW5kLmRpZmYoc3RhcnQsIHVuaXQpLmdldCh1bml0KSkgKyAxO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGlzIEludGVydmFsJ3Mgc3RhcnQgYW5kIGVuZCBhcmUgYm90aCBpbiB0aGUgc2FtZSB1bml0IG9mIHRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSB0aGUgdW5pdCBvZiB0aW1lIHRvIGNoZWNrIHNhbWVuZXNzIG9uXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNTYW1lKHVuaXQpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5pc0VtcHR5KCkgfHwgdGhpcy5lLm1pbnVzKDEpLmhhc1NhbWUodGhpcy5zLCB1bml0KSA6IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgaGFzIHRoZSBzYW1lIHN0YXJ0IGFuZCBlbmQgRGF0ZVRpbWVzLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5zLnZhbHVlT2YoKSA9PT0gdGhpcy5lLnZhbHVlT2YoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsJ3Mgc3RhcnQgaXMgYWZ0ZXIgdGhlIHNwZWNpZmllZCBEYXRlVGltZS5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gZGF0ZVRpbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQWZ0ZXIoZGF0ZVRpbWUpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0aGlzLnMgPiBkYXRlVGltZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsJ3MgZW5kIGlzIGJlZm9yZSB0aGUgc3BlY2lmaWVkIERhdGVUaW1lLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBkYXRlVGltZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNCZWZvcmUoZGF0ZVRpbWUpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0aGlzLmUgPD0gZGF0ZVRpbWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCBjb250YWlucyB0aGUgc3BlY2lmaWVkIERhdGVUaW1lLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBkYXRlVGltZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgY29udGFpbnMoZGF0ZVRpbWUpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0aGlzLnMgPD0gZGF0ZVRpbWUgJiYgdGhpcy5lID4gZGF0ZVRpbWU7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRzXCIgdGhlIHN0YXJ0IGFuZC9vciBlbmQgZGF0ZXMuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBJbnRlcnZhbC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlcyAtIHRoZSB2YWx1ZXMgdG8gc2V0XG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IHZhbHVlcy5zdGFydCAtIHRoZSBzdGFydGluZyBEYXRlVGltZVxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSB2YWx1ZXMuZW5kIC0gdGhlIGVuZGluZyBEYXRlVGltZVxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIHNldCh7IHN0YXJ0LCBlbmQgfSA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHN0YXJ0IHx8IHRoaXMucywgZW5kIHx8IHRoaXMuZSk7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXQgdGhpcyBJbnRlcnZhbCBhdCBlYWNoIG9mIHRoZSBzcGVjaWZpZWQgRGF0ZVRpbWVzXG4gICAqIEBwYXJhbSB7Li4uRGF0ZVRpbWV9IGRhdGVUaW1lcyAtIHRoZSB1bml0IG9mIHRpbWUgdG8gY291bnQuXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3BsaXRBdCguLi5kYXRlVGltZXMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHNvcnRlZCA9IGRhdGVUaW1lc1xuICAgICAgICAubWFwKGZyaWVuZGx5RGF0ZVRpbWUpXG4gICAgICAgIC5maWx0ZXIoKGQpID0+IHRoaXMuY29udGFpbnMoZCkpXG4gICAgICAgIC5zb3J0KCksXG4gICAgICByZXN1bHRzID0gW107XG4gICAgbGV0IHsgcyB9ID0gdGhpcyxcbiAgICAgIGkgPSAwO1xuXG4gICAgd2hpbGUgKHMgPCB0aGlzLmUpIHtcbiAgICAgIGNvbnN0IGFkZGVkID0gc29ydGVkW2ldIHx8IHRoaXMuZSxcbiAgICAgICAgbmV4dCA9ICthZGRlZCA+ICt0aGlzLmUgPyB0aGlzLmUgOiBhZGRlZDtcbiAgICAgIHJlc3VsdHMucHVzaChJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHMsIG5leHQpKTtcbiAgICAgIHMgPSBuZXh0O1xuICAgICAgaSArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0IHRoaXMgSW50ZXJ2YWwgaW50byBzbWFsbGVyIEludGVydmFscywgZWFjaCBvZiB0aGUgc3BlY2lmaWVkIGxlbmd0aC5cbiAgICogTGVmdCBvdmVyIHRpbWUgaXMgZ3JvdXBlZCBpbnRvIGEgc21hbGxlciBpbnRlcnZhbFxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufE9iamVjdHxudW1iZXJ9IGR1cmF0aW9uIC0gVGhlIGxlbmd0aCBvZiBlYWNoIHJlc3VsdGluZyBpbnRlcnZhbC5cbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzcGxpdEJ5KGR1cmF0aW9uKSB7XG4gICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUR1cmF0aW9uTGlrZShkdXJhdGlvbik7XG5cbiAgICBpZiAoIXRoaXMuaXNWYWxpZCB8fCAhZHVyLmlzVmFsaWQgfHwgZHVyLmFzKFwibWlsbGlzZWNvbmRzXCIpID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgbGV0IHsgcyB9ID0gdGhpcyxcbiAgICAgIGlkeCA9IDEsXG4gICAgICBuZXh0O1xuXG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgIHdoaWxlIChzIDwgdGhpcy5lKSB7XG4gICAgICBjb25zdCBhZGRlZCA9IHRoaXMuc3RhcnQucGx1cyhkdXIubWFwVW5pdHMoKHgpID0+IHggKiBpZHgpKTtcbiAgICAgIG5leHQgPSArYWRkZWQgPiArdGhpcy5lID8gdGhpcy5lIDogYWRkZWQ7XG4gICAgICByZXN1bHRzLnB1c2goSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhzLCBuZXh0KSk7XG4gICAgICBzID0gbmV4dDtcbiAgICAgIGlkeCArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0IHRoaXMgSW50ZXJ2YWwgaW50byB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBzbWFsbGVyIGludGVydmFscy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlck9mUGFydHMgLSBUaGUgbnVtYmVyIG9mIEludGVydmFscyB0byBkaXZpZGUgdGhlIEludGVydmFsIGludG8uXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgZGl2aWRlRXF1YWxseShudW1iZXJPZlBhcnRzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gdGhpcy5zcGxpdEJ5KHRoaXMubGVuZ3RoKCkgLyBudW1iZXJPZlBhcnRzKS5zbGljZSgwLCBudW1iZXJPZlBhcnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsIG92ZXJsYXBzIHdpdGggdGhlIHNwZWNpZmllZCBJbnRlcnZhbFxuICAgKiBAcGFyYW0ge0ludGVydmFsfSBvdGhlclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgb3ZlcmxhcHMob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5lID4gb3RoZXIucyAmJiB0aGlzLnMgPCBvdGhlci5lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwncyBlbmQgaXMgYWRqYWNlbnQgdG8gdGhlIHNwZWNpZmllZCBJbnRlcnZhbCdzIHN0YXJ0LlxuICAgKiBAcGFyYW0ge0ludGVydmFsfSBvdGhlclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgYWJ1dHNTdGFydChvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuICt0aGlzLmUgPT09ICtvdGhlci5zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwncyBzdGFydCBpcyBhZGphY2VudCB0byB0aGUgc3BlY2lmaWVkIEludGVydmFsJ3MgZW5kLlxuICAgKiBAcGFyYW0ge0ludGVydmFsfSBvdGhlclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgYWJ1dHNFbmQob3RoZXIpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiArb3RoZXIuZSA9PT0gK3RoaXMucztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsIGVuZ3VsZnMgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgdGhlIHNwZWNpZmllZCBJbnRlcnZhbC5cbiAgICogQHBhcmFtIHtJbnRlcnZhbH0gb3RoZXJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGVuZ3VsZnMob3RoZXIpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0aGlzLnMgPD0gb3RoZXIucyAmJiB0aGlzLmUgPj0gb3RoZXIuZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsIGhhcyB0aGUgc2FtZSBzdGFydCBhbmQgZW5kIGFzIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWwuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBlcXVhbHMob3RoZXIpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCB8fCAhb3RoZXIuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnMuZXF1YWxzKG90aGVyLnMpICYmIHRoaXMuZS5lcXVhbHMob3RoZXIuZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIEludGVydmFsIHJlcHJlc2VudGluZyB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoaXMgSW50ZXJ2YWwgYW5kIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWwuXG4gICAqIFNwZWNpZmljYWxseSwgdGhlIHJlc3VsdGluZyBJbnRlcnZhbCBoYXMgdGhlIG1heGltdW0gc3RhcnQgdGltZSBhbmQgdGhlIG1pbmltdW0gZW5kIHRpbWUgb2YgdGhlIHR3byBJbnRlcnZhbHMuXG4gICAqIFJldHVybnMgbnVsbCBpZiB0aGUgaW50ZXJzZWN0aW9uIGlzIGVtcHR5LCBtZWFuaW5nLCB0aGUgaW50ZXJ2YWxzIGRvbid0IGludGVyc2VjdC5cbiAgICogQHBhcmFtIHtJbnRlcnZhbH0gb3RoZXJcbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICBpbnRlcnNlY3Rpb24ob3RoZXIpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgcyA9IHRoaXMucyA+IG90aGVyLnMgPyB0aGlzLnMgOiBvdGhlci5zLFxuICAgICAgZSA9IHRoaXMuZSA8IG90aGVyLmUgPyB0aGlzLmUgOiBvdGhlci5lO1xuXG4gICAgaWYgKHMgPj0gZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHMsIGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gSW50ZXJ2YWwgcmVwcmVzZW50aW5nIHRoZSB1bmlvbiBvZiB0aGlzIEludGVydmFsIGFuZCB0aGUgc3BlY2lmaWVkIEludGVydmFsLlxuICAgKiBTcGVjaWZpY2FsbHksIHRoZSByZXN1bHRpbmcgSW50ZXJ2YWwgaGFzIHRoZSBtaW5pbXVtIHN0YXJ0IHRpbWUgYW5kIHRoZSBtYXhpbXVtIGVuZCB0aW1lIG9mIHRoZSB0d28gSW50ZXJ2YWxzLlxuICAgKiBAcGFyYW0ge0ludGVydmFsfSBvdGhlclxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIHVuaW9uKG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IHMgPSB0aGlzLnMgPCBvdGhlci5zID8gdGhpcy5zIDogb3RoZXIucyxcbiAgICAgIGUgPSB0aGlzLmUgPiBvdGhlci5lID8gdGhpcy5lIDogb3RoZXIuZTtcbiAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhzLCBlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZSBhbiBhcnJheSBvZiBJbnRlcnZhbHMgaW50byBhIGVxdWl2YWxlbnQgbWluaW1hbCBzZXQgb2YgSW50ZXJ2YWxzLlxuICAgKiBDb21iaW5lcyBvdmVybGFwcGluZyBhbmQgYWRqYWNlbnQgSW50ZXJ2YWxzLlxuICAgKiBAcGFyYW0ge0FycmF5fSBpbnRlcnZhbHNcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgbWVyZ2UoaW50ZXJ2YWxzKSB7XG4gICAgY29uc3QgW2ZvdW5kLCBmaW5hbF0gPSBpbnRlcnZhbHNcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBhLnMgLSBiLnMpXG4gICAgICAucmVkdWNlKFxuICAgICAgICAoW3NvZmFyLCBjdXJyZW50XSwgaXRlbSkgPT4ge1xuICAgICAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIFtzb2ZhciwgaXRlbV07XG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50Lm92ZXJsYXBzKGl0ZW0pIHx8IGN1cnJlbnQuYWJ1dHNTdGFydChpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtzb2ZhciwgY3VycmVudC51bmlvbihpdGVtKV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbc29mYXIuY29uY2F0KFtjdXJyZW50XSksIGl0ZW1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgW1tdLCBudWxsXVxuICAgICAgKTtcbiAgICBpZiAoZmluYWwpIHtcbiAgICAgIGZvdW5kLnB1c2goZmluYWwpO1xuICAgIH1cbiAgICByZXR1cm4gZm91bmQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIEludGVydmFscyByZXByZXNlbnRpbmcgdGhlIHNwYW5zIG9mIHRpbWUgdGhhdCBvbmx5IGFwcGVhciBpbiBvbmUgb2YgdGhlIHNwZWNpZmllZCBJbnRlcnZhbHMuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGludGVydmFsc1xuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyB4b3IoaW50ZXJ2YWxzKSB7XG4gICAgbGV0IHN0YXJ0ID0gbnVsbCxcbiAgICAgIGN1cnJlbnRDb3VudCA9IDA7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdLFxuICAgICAgZW5kcyA9IGludGVydmFscy5tYXAoKGkpID0+IFtcbiAgICAgICAgeyB0aW1lOiBpLnMsIHR5cGU6IFwic1wiIH0sXG4gICAgICAgIHsgdGltZTogaS5lLCB0eXBlOiBcImVcIiB9LFxuICAgICAgXSksXG4gICAgICBmbGF0dGVuZWQgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0KC4uLmVuZHMpLFxuICAgICAgYXJyID0gZmxhdHRlbmVkLnNvcnQoKGEsIGIpID0+IGEudGltZSAtIGIudGltZSk7XG5cbiAgICBmb3IgKGNvbnN0IGkgb2YgYXJyKSB7XG4gICAgICBjdXJyZW50Q291bnQgKz0gaS50eXBlID09PSBcInNcIiA/IDEgOiAtMTtcblxuICAgICAgaWYgKGN1cnJlbnRDb3VudCA9PT0gMSkge1xuICAgICAgICBzdGFydCA9IGkudGltZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzdGFydCAmJiArc3RhcnQgIT09ICtpLnRpbWUpIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2goSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhzdGFydCwgaS50aW1lKSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIEludGVydmFsLm1lcmdlKHJlc3VsdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBJbnRlcnZhbCByZXByZXNlbnRpbmcgdGhlIHNwYW4gb2YgdGltZSBpbiB0aGlzIEludGVydmFsIHRoYXQgZG9lc24ndCBvdmVybGFwIHdpdGggYW55IG9mIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWxzLlxuICAgKiBAcGFyYW0gey4uLkludGVydmFsfSBpbnRlcnZhbHNcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBkaWZmZXJlbmNlKC4uLmludGVydmFscykge1xuICAgIHJldHVybiBJbnRlcnZhbC54b3IoW3RoaXNdLmNvbmNhdChpbnRlcnZhbHMpKVxuICAgICAgLm1hcCgoaSkgPT4gdGhpcy5pbnRlcnNlY3Rpb24oaSkpXG4gICAgICAuZmlsdGVyKChpKSA9PiBpICYmICFpLmlzRW1wdHkoKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIEludGVydmFsIGFwcHJvcHJpYXRlIGZvciBkZWJ1Z2dpbmcuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gSU5WQUxJRDtcbiAgICByZXR1cm4gYFske3RoaXMucy50b0lTTygpfSDigJMgJHt0aGlzLmUudG9JU08oKX0pYDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbG9jYWxpemVkIHN0cmluZyByZXByZXNlbnRpbmcgdGhpcyBJbnRlcnZhbC4gQWNjZXB0cyB0aGUgc2FtZSBvcHRpb25zIGFzIHRoZVxuICAgKiBJbnRsLkRhdGVUaW1lRm9ybWF0IGNvbnN0cnVjdG9yIGFuZCBhbnkgcHJlc2V0cyBkZWZpbmVkIGJ5IEx1eG9uLCBzdWNoIGFzXG4gICAqIHtAbGluayBEYXRlVGltZS5EQVRFX0ZVTEx9IG9yIHtAbGluayBEYXRlVGltZS5USU1FX1NJTVBMRX0uIFRoZSBleGFjdCBiZWhhdmlvciBvZiB0aGlzIG1ldGhvZFxuICAgKiBpcyBicm93c2VyLXNwZWNpZmljLCBidXQgaW4gZ2VuZXJhbCBpdCB3aWxsIHJldHVybiBhbiBhcHByb3ByaWF0ZSByZXByZXNlbnRhdGlvbiBvZiB0aGVcbiAgICogSW50ZXJ2YWwgaW4gdGhlIGFzc2lnbmVkIGxvY2FsZS4gRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW5cbiAgICogc3BlY2lmaWVkLlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGVUaW1lRm9ybWF0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZm9ybWF0T3B0cz1EYXRlVGltZS5EQVRFX1NIT1JUXSAtIEVpdGhlciBhIERhdGVUaW1lIHByZXNldCBvclxuICAgKiBJbnRsLkRhdGVUaW1lRm9ybWF0IGNvbnN0cnVjdG9yIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gT3B0aW9ucyB0byBvdmVycmlkZSB0aGUgY29uZmlndXJhdGlvbiBvZiB0aGUgc3RhcnQgRGF0ZVRpbWUuXG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21JU08oJzIwMjItMTEtMDdUMDk6MDBaLzIwMjItMTEtMDhUMDk6MDBaJykudG9Mb2NhbGVTdHJpbmcoKTsgLy89PiAxMS83LzIwMjIg4oCTIDExLzgvMjAyMlxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tSVNPKCcyMDIyLTExLTA3VDA5OjAwWi8yMDIyLTExLTA4VDA5OjAwWicpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLkRBVEVfRlVMTCk7IC8vPT4gTm92ZW1iZXIgNyDigJMgOCwgMjAyMlxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tSVNPKCcyMDIyLTExLTA3VDA5OjAwWi8yMDIyLTExLTA4VDA5OjAwWicpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLkRBVEVfRlVMTCwgeyBsb2NhbGU6ICdmci1GUicgfSk7IC8vPT4gN+KAkzggbm92ZW1icmUgMjAyMlxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tSVNPKCcyMDIyLTExLTA3VDE3OjAwWi8yMDIyLTExLTA3VDE5OjAwWicpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLlRJTUVfU0lNUExFKTsgLy89PiA2OjAwIOKAkyA4OjAwIFBNXG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21JU08oJzIwMjItMTEtMDdUMTc6MDBaLzIwMjItMTEtMDdUMTk6MDBaJykudG9Mb2NhbGVTdHJpbmcoeyB3ZWVrZGF5OiAnc2hvcnQnLCBtb250aDogJ3Nob3J0JywgZGF5OiAnMi1kaWdpdCcsIGhvdXI6ICcyLWRpZ2l0JywgbWludXRlOiAnMi1kaWdpdCcgfSk7IC8vPT4gTW9uLCBOb3YgMDcsIDY6MDAg4oCTIDg6MDAgcFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0xvY2FsZVN0cmluZyhmb3JtYXRPcHRzID0gRm9ybWF0cy5EQVRFX1NIT1JULCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkXG4gICAgICA/IEZvcm1hdHRlci5jcmVhdGUodGhpcy5zLmxvYy5jbG9uZShvcHRzKSwgZm9ybWF0T3B0cykuZm9ybWF0SW50ZXJ2YWwodGhpcylcbiAgICAgIDogSU5WQUxJRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBJbnRlcnZhbC5cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNUaW1lX2ludGVydmFsc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIFRoZSBzYW1lIG9wdGlvbnMgYXMge0BsaW5rIERhdGVUaW1lI3RvSVNPfVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTTyhvcHRzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBJTlZBTElEO1xuICAgIHJldHVybiBgJHt0aGlzLnMudG9JU08ob3B0cyl9LyR7dGhpcy5lLnRvSVNPKG9wdHMpfWA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGRhdGUgb2YgdGhpcyBJbnRlcnZhbC5cbiAgICogVGhlIHRpbWUgY29tcG9uZW50cyBhcmUgaWdub3JlZC5cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNUaW1lX2ludGVydmFsc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTT0RhdGUoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBJTlZBTElEO1xuICAgIHJldHVybiBgJHt0aGlzLnMudG9JU09EYXRlKCl9LyR7dGhpcy5lLnRvSVNPRGF0ZSgpfWA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRpbWUgb2YgdGhpcyBJbnRlcnZhbC5cbiAgICogVGhlIGRhdGUgY29tcG9uZW50cyBhcmUgaWdub3JlZC5cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNUaW1lX2ludGVydmFsc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIFRoZSBzYW1lIG9wdGlvbnMgYXMge0BsaW5rIERhdGVUaW1lI3RvSVNPfVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTT1RpbWUob3B0cykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gSU5WQUxJRDtcbiAgICByZXR1cm4gYCR7dGhpcy5zLnRvSVNPVGltZShvcHRzKX0vJHt0aGlzLmUudG9JU09UaW1lKG9wdHMpfWA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIEludGVydmFsIGZvcm1hdHRlZCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBmb3JtYXRcbiAgICogc3RyaW5nLiAqKllvdSBtYXkgbm90IHdhbnQgdGhpcy4qKiBTZWUge0BsaW5rIEludGVydmFsI3RvTG9jYWxlU3RyaW5nfSBmb3IgYSBtb3JlIGZsZXhpYmxlXG4gICAqIGZvcm1hdHRpbmcgdG9vbC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGVGb3JtYXQgLSBUaGUgZm9ybWF0IHN0cmluZy4gVGhpcyBzdHJpbmcgZm9ybWF0cyB0aGUgc3RhcnQgYW5kIGVuZCB0aW1lLlxuICAgKiBTZWUge0BsaW5rIERhdGVUaW1lI3RvRm9ybWF0fSBmb3IgZGV0YWlscy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBPcHRpb25zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuc2VwYXJhdG9yID0gICcg4oCTICddIC0gQSBzZXBhcmF0b3IgdG8gcGxhY2UgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZFxuICAgKiByZXByZXNlbnRhdGlvbnMuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvRm9ybWF0KGRhdGVGb3JtYXQsIHsgc2VwYXJhdG9yID0gXCIg4oCTIFwiIH0gPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gSU5WQUxJRDtcbiAgICByZXR1cm4gYCR7dGhpcy5zLnRvRm9ybWF0KGRhdGVGb3JtYXQpfSR7c2VwYXJhdG9yfSR7dGhpcy5lLnRvRm9ybWF0KGRhdGVGb3JtYXQpfWA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgRHVyYXRpb24gcmVwcmVzZW50aW5nIHRoZSB0aW1lIHNwYW5uZWQgYnkgdGhpcyBpbnRlcnZhbC5cbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IFt1bml0PVsnbWlsbGlzZWNvbmRzJ11dIC0gdGhlIHVuaXQgb3IgdW5pdHMgKHN1Y2ggYXMgJ2hvdXJzJyBvciAnZGF5cycpIHRvIGluY2x1ZGUgaW4gdGhlIGR1cmF0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdGhhdCBhZmZlY3QgdGhlIGNyZWF0aW9uIG9mIHRoZSBEdXJhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikudG9EdXJhdGlvbigpLnRvT2JqZWN0KCkgLy89PiB7IG1pbGxpc2Vjb25kczogODg0ODkyNTcgfVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS50b0R1cmF0aW9uKCdkYXlzJykudG9PYmplY3QoKSAvLz0+IHsgZGF5czogMS4wMjQxODEyMTUyNzc3Nzc4IH1cbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikudG9EdXJhdGlvbihbJ2hvdXJzJywgJ21pbnV0ZXMnXSkudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDI0LCBtaW51dGVzOiAzNC44MjA5NSB9XG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLnRvRHVyYXRpb24oWydob3VycycsICdtaW51dGVzJywgJ3NlY29uZHMnXSkudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDI0LCBtaW51dGVzOiAzNCwgc2Vjb25kczogNDkuMjU3IH1cbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikudG9EdXJhdGlvbignc2Vjb25kcycpLnRvT2JqZWN0KCkgLy89PiB7IHNlY29uZHM6IDg4NDg5LjI1NyB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgdG9EdXJhdGlvbih1bml0LCBvcHRzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5pbnZhbGlkKHRoaXMuaW52YWxpZFJlYXNvbik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmUuZGlmZih0aGlzLnMsIHVuaXQsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1biBtYXBGbiBvbiB0aGUgaW50ZXJ2YWwgc3RhcnQgYW5kIGVuZCwgcmV0dXJuaW5nIGEgbmV3IEludGVydmFsIGZyb20gdGhlIHJlc3VsdGluZyBEYXRlVGltZXNcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gbWFwRm5cbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLm1hcEVuZHBvaW50cyhlbmRwb2ludCA9PiBlbmRwb2ludC50b1VUQygpKVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS5tYXBFbmRwb2ludHMoZW5kcG9pbnQgPT4gZW5kcG9pbnQucGx1cyh7IGhvdXJzOiAyIH0pKVxuICAgKi9cbiAgbWFwRW5kcG9pbnRzKG1hcEZuKSB7XG4gICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMobWFwRm4odGhpcy5zKSwgbWFwRm4odGhpcy5lKSk7XG4gIH1cbn1cbiIsImltcG9ydCBEYXRlVGltZSBmcm9tIFwiLi9kYXRldGltZS5qc1wiO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gXCIuL3NldHRpbmdzLmpzXCI7XG5pbXBvcnQgTG9jYWxlIGZyb20gXCIuL2ltcGwvbG9jYWxlLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4vem9uZXMvSUFOQVpvbmUuanNcIjtcbmltcG9ydCB7IG5vcm1hbGl6ZVpvbmUgfSBmcm9tIFwiLi9pbXBsL3pvbmVVdGlsLmpzXCI7XG5cbmltcG9ydCB7IGhhc1JlbGF0aXZlIH0gZnJvbSBcIi4vaW1wbC91dGlsLmpzXCI7XG5cbi8qKlxuICogVGhlIEluZm8gY2xhc3MgY29udGFpbnMgc3RhdGljIG1ldGhvZHMgZm9yIHJldHJpZXZpbmcgZ2VuZXJhbCB0aW1lIGFuZCBkYXRlIHJlbGF0ZWQgZGF0YS4gRm9yIGV4YW1wbGUsIGl0IGhhcyBtZXRob2RzIGZvciBmaW5kaW5nIG91dCBpZiBhIHRpbWUgem9uZSBoYXMgYSBEU1QsIGZvciBsaXN0aW5nIHRoZSBtb250aHMgaW4gYW55IHN1cHBvcnRlZCBsb2NhbGUsIGFuZCBmb3IgZGlzY292ZXJpbmcgd2hpY2ggb2YgTHV4b24gZmVhdHVyZXMgYXJlIGF2YWlsYWJsZSBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5mbyB7XG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGUgc3BlY2lmaWVkIHpvbmUgY29udGFpbnMgYSBEU1QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFt6b25lPSdsb2NhbCddIC0gWm9uZSB0byBjaGVjay4gRGVmYXVsdHMgdG8gdGhlIGVudmlyb25tZW50J3MgbG9jYWwgem9uZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBoYXNEU1Qoem9uZSA9IFNldHRpbmdzLmRlZmF1bHRab25lKSB7XG4gICAgY29uc3QgcHJvdG8gPSBEYXRlVGltZS5ub3coKS5zZXRab25lKHpvbmUpLnNldCh7IG1vbnRoOiAxMiB9KTtcblxuICAgIHJldHVybiAhem9uZS5pc1VuaXZlcnNhbCAmJiBwcm90by5vZmZzZXQgIT09IHByb3RvLnNldCh7IG1vbnRoOiA2IH0pLm9mZnNldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGUgc3BlY2lmaWVkIHpvbmUgaXMgYSB2YWxpZCBJQU5BIHNwZWNpZmllci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHpvbmUgLSBab25lIHRvIGNoZWNrXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNWYWxpZElBTkFab25lKHpvbmUpIHtcbiAgICByZXR1cm4gSUFOQVpvbmUuaXNWYWxpZFpvbmUoem9uZSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhlIGlucHV0IGludG8gYSB7QGxpbmsgWm9uZX0gaW5zdGFuY2UuXG4gICAqXG4gICAqICogSWYgYGlucHV0YCBpcyBhbHJlYWR5IGEgWm9uZSBpbnN0YW5jZSwgaXQgaXMgcmV0dXJuZWQgdW5jaGFuZ2VkLlxuICAgKiAqIElmIGBpbnB1dGAgaXMgYSBzdHJpbmcgY29udGFpbmluZyBhIHZhbGlkIHRpbWUgem9uZSBuYW1lLCBhIFpvbmUgaW5zdGFuY2VcbiAgICogICB3aXRoIHRoYXQgbmFtZSBpcyByZXR1cm5lZC5cbiAgICogKiBJZiBgaW5wdXRgIGlzIGEgc3RyaW5nIHRoYXQgZG9lc24ndCByZWZlciB0byBhIGtub3duIHRpbWUgem9uZSwgYSBab25lXG4gICAqICAgaW5zdGFuY2Ugd2l0aCB7QGxpbmsgWm9uZSNpc1ZhbGlkfSA9PSBmYWxzZSBpcyByZXR1cm5lZC5cbiAgICogKiBJZiBgaW5wdXQgaXMgYSBudW1iZXIsIGEgWm9uZSBpbnN0YW5jZSB3aXRoIHRoZSBzcGVjaWZpZWQgZml4ZWQgb2Zmc2V0XG4gICAqICAgaW4gbWludXRlcyBpcyByZXR1cm5lZC5cbiAgICogKiBJZiBgaW5wdXRgIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYCwgdGhlIGRlZmF1bHQgem9uZSBpcyByZXR1cm5lZC5cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZXxudW1iZXJ9IFtpbnB1dF0gLSB0aGUgdmFsdWUgdG8gYmUgY29udmVydGVkXG4gICAqIEByZXR1cm4ge1pvbmV9XG4gICAqL1xuICBzdGF0aWMgbm9ybWFsaXplWm9uZShpbnB1dCkge1xuICAgIHJldHVybiBub3JtYWxpemVab25lKGlucHV0LCBTZXR0aW5ncy5kZWZhdWx0Wm9uZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIHN0YW5kYWxvbmUgbW9udGggbmFtZXMuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZVRpbWVGb3JtYXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsZW5ndGg9J2xvbmcnXSAtIHRoZSBsZW5ndGggb2YgdGhlIG1vbnRoIHJlcHJlc2VudGF0aW9uLCBzdWNoIGFzIFwibnVtZXJpY1wiLCBcIjItZGlnaXRcIiwgXCJuYXJyb3dcIiwgXCJzaG9ydFwiLCBcImxvbmdcIlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZV0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm51bWJlcmluZ1N5c3RlbT1udWxsXSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NPYmo9bnVsbF0gLSBhbiBleGlzdGluZyBsb2NhbGUgb2JqZWN0IHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMub3V0cHV0Q2FsZW5kYXI9J2dyZWdvcnknXSAtIHRoZSBjYWxlbmRhclxuICAgKiBAZXhhbXBsZSBJbmZvLm1vbnRocygpWzBdIC8vPT4gJ0phbnVhcnknXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKCdzaG9ydCcpWzBdIC8vPT4gJ0phbidcbiAgICogQGV4YW1wbGUgSW5mby5tb250aHMoJ251bWVyaWMnKVswXSAvLz0+ICcxJ1xuICAgKiBAZXhhbXBsZSBJbmZvLm1vbnRocygnc2hvcnQnLCB7IGxvY2FsZTogJ2ZyLUNBJyB9IClbMF0gLy89PiAnamFudi4nXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKCdudW1lcmljJywgeyBsb2NhbGU6ICdhcicgfSlbMF0gLy89PiAn2aEnXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKCdsb25nJywgeyBvdXRwdXRDYWxlbmRhcjogJ2lzbGFtaWMnIH0pWzBdIC8vPT4gJ1JhYmnKuyBJJ1xuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyBtb250aHMoXG4gICAgbGVuZ3RoID0gXCJsb25nXCIsXG4gICAgeyBsb2NhbGUgPSBudWxsLCBudW1iZXJpbmdTeXN0ZW0gPSBudWxsLCBsb2NPYmogPSBudWxsLCBvdXRwdXRDYWxlbmRhciA9IFwiZ3JlZ29yeVwiIH0gPSB7fVxuICApIHtcbiAgICByZXR1cm4gKGxvY09iaiB8fCBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhcikpLm1vbnRocyhsZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBmb3JtYXQgbW9udGggbmFtZXMuXG4gICAqIEZvcm1hdCBtb250aHMgZGlmZmVyIGZyb20gc3RhbmRhbG9uZSBtb250aHMgaW4gdGhhdCB0aGV5J3JlIG1lYW50IHRvIGFwcGVhciBuZXh0IHRvIHRoZSBkYXkgb2YgdGhlIG1vbnRoLiBJbiBzb21lIGxhbmd1YWdlcywgdGhhdFxuICAgKiBjaGFuZ2VzIHRoZSBzdHJpbmcuXG4gICAqIFNlZSB7QGxpbmsgSW5mbyNtb250aHN9XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGVuZ3RoPSdsb25nJ10gLSB0aGUgbGVuZ3RoIG9mIHRoZSBtb250aCByZXByZXNlbnRhdGlvbiwgc3VjaCBhcyBcIm51bWVyaWNcIiwgXCIyLWRpZ2l0XCIsIFwibmFycm93XCIsIFwic2hvcnRcIiwgXCJsb25nXCJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGVdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5udW1iZXJpbmdTeXN0ZW09bnVsbF0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jT2JqPW51bGxdIC0gYW4gZXhpc3RpbmcgbG9jYWxlIG9iamVjdCB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm91dHB1dENhbGVuZGFyPSdncmVnb3J5J10gLSB0aGUgY2FsZW5kYXJcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgbW9udGhzRm9ybWF0KFxuICAgIGxlbmd0aCA9IFwibG9uZ1wiLFxuICAgIHsgbG9jYWxlID0gbnVsbCwgbnVtYmVyaW5nU3lzdGVtID0gbnVsbCwgbG9jT2JqID0gbnVsbCwgb3V0cHV0Q2FsZW5kYXIgPSBcImdyZWdvcnlcIiB9ID0ge31cbiAgKSB7XG4gICAgcmV0dXJuIChsb2NPYmogfHwgTG9jYWxlLmNyZWF0ZShsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXIpKS5tb250aHMobGVuZ3RoLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2Ygc3RhbmRhbG9uZSB3ZWVrIG5hbWVzLlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGVUaW1lRm9ybWF0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGVuZ3RoPSdsb25nJ10gLSB0aGUgbGVuZ3RoIG9mIHRoZSB3ZWVrZGF5IHJlcHJlc2VudGF0aW9uLCBzdWNoIGFzIFwibmFycm93XCIsIFwic2hvcnRcIiwgXCJsb25nXCIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlXSAtIHRoZSBsb2NhbGUgY29kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubnVtYmVyaW5nU3lzdGVtPW51bGxdIC0gdGhlIG51bWJlcmluZyBzeXN0ZW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY09iaj1udWxsXSAtIGFuIGV4aXN0aW5nIGxvY2FsZSBvYmplY3QgdG8gdXNlXG4gICAqIEBleGFtcGxlIEluZm8ud2Vla2RheXMoKVswXSAvLz0+ICdNb25kYXknXG4gICAqIEBleGFtcGxlIEluZm8ud2Vla2RheXMoJ3Nob3J0JylbMF0gLy89PiAnTW9uJ1xuICAgKiBAZXhhbXBsZSBJbmZvLndlZWtkYXlzKCdzaG9ydCcsIHsgbG9jYWxlOiAnZnItQ0EnIH0pWzBdIC8vPT4gJ2x1bi4nXG4gICAqIEBleGFtcGxlIEluZm8ud2Vla2RheXMoJ3Nob3J0JywgeyBsb2NhbGU6ICdhcicgfSlbMF0gLy89PiAn2KfZhNin2KvZhtmK2YYnXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIHdlZWtkYXlzKGxlbmd0aCA9IFwibG9uZ1wiLCB7IGxvY2FsZSA9IG51bGwsIG51bWJlcmluZ1N5c3RlbSA9IG51bGwsIGxvY09iaiA9IG51bGwgfSA9IHt9KSB7XG4gICAgcmV0dXJuIChsb2NPYmogfHwgTG9jYWxlLmNyZWF0ZShsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgbnVsbCkpLndlZWtkYXlzKGxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIGZvcm1hdCB3ZWVrIG5hbWVzLlxuICAgKiBGb3JtYXQgd2Vla2RheXMgZGlmZmVyIGZyb20gc3RhbmRhbG9uZSB3ZWVrZGF5cyBpbiB0aGF0IHRoZXkncmUgbWVhbnQgdG8gYXBwZWFyIG5leHQgdG8gbW9yZSBkYXRlIGluZm9ybWF0aW9uLiBJbiBzb21lIGxhbmd1YWdlcywgdGhhdFxuICAgKiBjaGFuZ2VzIHRoZSBzdHJpbmcuXG4gICAqIFNlZSB7QGxpbmsgSW5mbyN3ZWVrZGF5c31cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsZW5ndGg9J2xvbmcnXSAtIHRoZSBsZW5ndGggb2YgdGhlIG1vbnRoIHJlcHJlc2VudGF0aW9uLCBzdWNoIGFzIFwibmFycm93XCIsIFwic2hvcnRcIiwgXCJsb25nXCIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPW51bGxdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5udW1iZXJpbmdTeXN0ZW09bnVsbF0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jT2JqPW51bGxdIC0gYW4gZXhpc3RpbmcgbG9jYWxlIG9iamVjdCB0byB1c2VcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgd2Vla2RheXNGb3JtYXQoXG4gICAgbGVuZ3RoID0gXCJsb25nXCIsXG4gICAgeyBsb2NhbGUgPSBudWxsLCBudW1iZXJpbmdTeXN0ZW0gPSBudWxsLCBsb2NPYmogPSBudWxsIH0gPSB7fVxuICApIHtcbiAgICByZXR1cm4gKGxvY09iaiB8fCBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBudWxsKSkud2Vla2RheXMobGVuZ3RoLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgbWVyaWRpZW1zLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZV0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQGV4YW1wbGUgSW5mby5tZXJpZGllbXMoKSAvLz0+IFsgJ0FNJywgJ1BNJyBdXG4gICAqIEBleGFtcGxlIEluZm8ubWVyaWRpZW1zKHsgbG9jYWxlOiAnbXknIH0pIC8vPT4gWyAn4YCU4YC24YCU4YCA4YC6JywgJ+GAiuGAlOGAsScgXVxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyBtZXJpZGllbXMoeyBsb2NhbGUgPSBudWxsIH0gPSB7fSkge1xuICAgIHJldHVybiBMb2NhbGUuY3JlYXRlKGxvY2FsZSkubWVyaWRpZW1zKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIGVyYXMsIHN1Y2ggYXMgWydCQycsICdBRCddLiBUaGUgbG9jYWxlIGNhbiBiZSBzcGVjaWZpZWQsIGJ1dCB0aGUgY2FsZW5kYXIgc3lzdGVtIGlzIGFsd2F5cyBHcmVnb3JpYW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGVuZ3RoPSdzaG9ydCddIC0gdGhlIGxlbmd0aCBvZiB0aGUgZXJhIHJlcHJlc2VudGF0aW9uLCBzdWNoIGFzIFwic2hvcnRcIiBvciBcImxvbmdcIi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGVdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBleGFtcGxlIEluZm8uZXJhcygpIC8vPT4gWyAnQkMnLCAnQUQnIF1cbiAgICogQGV4YW1wbGUgSW5mby5lcmFzKCdsb25nJykgLy89PiBbICdCZWZvcmUgQ2hyaXN0JywgJ0Fubm8gRG9taW5pJyBdXG4gICAqIEBleGFtcGxlIEluZm8uZXJhcygnbG9uZycsIHsgbG9jYWxlOiAnZnInIH0pIC8vPT4gWyAnYXZhbnQgSsOpc3VzLUNocmlzdCcsICdhcHLDqHMgSsOpc3VzLUNocmlzdCcgXVxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyBlcmFzKGxlbmd0aCA9IFwic2hvcnRcIiwgeyBsb2NhbGUgPSBudWxsIH0gPSB7fSkge1xuICAgIHJldHVybiBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVsbCwgXCJncmVnb3J5XCIpLmVyYXMobGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHNldCBvZiBhdmFpbGFibGUgZmVhdHVyZXMgaW4gdGhpcyBlbnZpcm9ubWVudC5cbiAgICogU29tZSBmZWF0dXJlcyBvZiBMdXhvbiBhcmUgbm90IGF2YWlsYWJsZSBpbiBhbGwgZW52aXJvbm1lbnRzLiBGb3IgZXhhbXBsZSwgb24gb2xkZXIgYnJvd3NlcnMsIHJlbGF0aXZlIHRpbWUgZm9ybWF0dGluZyBzdXBwb3J0IGlzIG5vdCBhdmFpbGFibGUuIFVzZSB0aGlzIGZ1bmN0aW9uIHRvIGZpZ3VyZSBvdXQgaWYgdGhhdCdzIHRoZSBjYXNlLlxuICAgKiBLZXlzOlxuICAgKiAqIGByZWxhdGl2ZWA6IHdoZXRoZXIgdGhpcyBlbnZpcm9ubWVudCBzdXBwb3J0cyByZWxhdGl2ZSB0aW1lIGZvcm1hdHRpbmdcbiAgICogQGV4YW1wbGUgSW5mby5mZWF0dXJlcygpIC8vPT4geyByZWxhdGl2ZTogZmFsc2UgfVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZmVhdHVyZXMoKSB7XG4gICAgcmV0dXJuIHsgcmVsYXRpdmU6IGhhc1JlbGF0aXZlKCkgfTtcbiAgfVxufVxuIiwiaW1wb3J0IER1cmF0aW9uIGZyb20gXCIuLi9kdXJhdGlvbi5qc1wiO1xuXG5mdW5jdGlvbiBkYXlEaWZmKGVhcmxpZXIsIGxhdGVyKSB7XG4gIGNvbnN0IHV0Y0RheVN0YXJ0ID0gKGR0KSA9PiBkdC50b1VUQygwLCB7IGtlZXBMb2NhbFRpbWU6IHRydWUgfSkuc3RhcnRPZihcImRheVwiKS52YWx1ZU9mKCksXG4gICAgbXMgPSB1dGNEYXlTdGFydChsYXRlcikgLSB1dGNEYXlTdGFydChlYXJsaWVyKTtcbiAgcmV0dXJuIE1hdGguZmxvb3IoRHVyYXRpb24uZnJvbU1pbGxpcyhtcykuYXMoXCJkYXlzXCIpKTtcbn1cblxuZnVuY3Rpb24gaGlnaE9yZGVyRGlmZnMoY3Vyc29yLCBsYXRlciwgdW5pdHMpIHtcbiAgY29uc3QgZGlmZmVycyA9IFtcbiAgICBbXCJ5ZWFyc1wiLCAoYSwgYikgPT4gYi55ZWFyIC0gYS55ZWFyXSxcbiAgICBbXCJxdWFydGVyc1wiLCAoYSwgYikgPT4gYi5xdWFydGVyIC0gYS5xdWFydGVyICsgKGIueWVhciAtIGEueWVhcikgKiA0XSxcbiAgICBbXCJtb250aHNcIiwgKGEsIGIpID0+IGIubW9udGggLSBhLm1vbnRoICsgKGIueWVhciAtIGEueWVhcikgKiAxMl0sXG4gICAgW1xuICAgICAgXCJ3ZWVrc1wiLFxuICAgICAgKGEsIGIpID0+IHtcbiAgICAgICAgY29uc3QgZGF5cyA9IGRheURpZmYoYSwgYik7XG4gICAgICAgIHJldHVybiAoZGF5cyAtIChkYXlzICUgNykpIC8gNztcbiAgICAgIH0sXG4gICAgXSxcbiAgICBbXCJkYXlzXCIsIGRheURpZmZdLFxuICBdO1xuXG4gIGNvbnN0IHJlc3VsdHMgPSB7fTtcbiAgY29uc3QgZWFybGllciA9IGN1cnNvcjtcbiAgbGV0IGxvd2VzdE9yZGVyLCBoaWdoV2F0ZXI7XG5cbiAgZm9yIChjb25zdCBbdW5pdCwgZGlmZmVyXSBvZiBkaWZmZXJzKSB7XG4gICAgaWYgKHVuaXRzLmluZGV4T2YodW5pdCkgPj0gMCkge1xuICAgICAgbG93ZXN0T3JkZXIgPSB1bml0O1xuXG4gICAgICByZXN1bHRzW3VuaXRdID0gZGlmZmVyKGN1cnNvciwgbGF0ZXIpO1xuICAgICAgaGlnaFdhdGVyID0gZWFybGllci5wbHVzKHJlc3VsdHMpO1xuXG4gICAgICBpZiAoaGlnaFdhdGVyID4gbGF0ZXIpIHtcbiAgICAgICAgcmVzdWx0c1t1bml0XS0tO1xuICAgICAgICBjdXJzb3IgPSBlYXJsaWVyLnBsdXMocmVzdWx0cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJzb3IgPSBoaWdoV2F0ZXI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFtjdXJzb3IsIHJlc3VsdHMsIGhpZ2hXYXRlciwgbG93ZXN0T3JkZXJdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoZWFybGllciwgbGF0ZXIsIHVuaXRzLCBvcHRzKSB7XG4gIGxldCBbY3Vyc29yLCByZXN1bHRzLCBoaWdoV2F0ZXIsIGxvd2VzdE9yZGVyXSA9IGhpZ2hPcmRlckRpZmZzKGVhcmxpZXIsIGxhdGVyLCB1bml0cyk7XG5cbiAgY29uc3QgcmVtYWluaW5nTWlsbGlzID0gbGF0ZXIgLSBjdXJzb3I7XG5cbiAgY29uc3QgbG93ZXJPcmRlclVuaXRzID0gdW5pdHMuZmlsdGVyKFxuICAgICh1KSA9PiBbXCJob3Vyc1wiLCBcIm1pbnV0ZXNcIiwgXCJzZWNvbmRzXCIsIFwibWlsbGlzZWNvbmRzXCJdLmluZGV4T2YodSkgPj0gMFxuICApO1xuXG4gIGlmIChsb3dlck9yZGVyVW5pdHMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGhpZ2hXYXRlciA8IGxhdGVyKSB7XG4gICAgICBoaWdoV2F0ZXIgPSBjdXJzb3IucGx1cyh7IFtsb3dlc3RPcmRlcl06IDEgfSk7XG4gICAgfVxuXG4gICAgaWYgKGhpZ2hXYXRlciAhPT0gY3Vyc29yKSB7XG4gICAgICByZXN1bHRzW2xvd2VzdE9yZGVyXSA9IChyZXN1bHRzW2xvd2VzdE9yZGVyXSB8fCAwKSArIHJlbWFpbmluZ01pbGxpcyAvIChoaWdoV2F0ZXIgLSBjdXJzb3IpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGR1cmF0aW9uID0gRHVyYXRpb24uZnJvbU9iamVjdChyZXN1bHRzLCBvcHRzKTtcblxuICBpZiAobG93ZXJPcmRlclVuaXRzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gRHVyYXRpb24uZnJvbU1pbGxpcyhyZW1haW5pbmdNaWxsaXMsIG9wdHMpXG4gICAgICAuc2hpZnRUbyguLi5sb3dlck9yZGVyVW5pdHMpXG4gICAgICAucGx1cyhkdXJhdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGR1cmF0aW9uO1xuICB9XG59XG4iLCJjb25zdCBudW1iZXJpbmdTeXN0ZW1zID0ge1xuICBhcmFiOiBcIltcXHUwNjYwLVxcdTA2NjldXCIsXG4gIGFyYWJleHQ6IFwiW1xcdTA2RjAtXFx1MDZGOV1cIixcbiAgYmFsaTogXCJbXFx1MUI1MC1cXHUxQjU5XVwiLFxuICBiZW5nOiBcIltcXHUwOUU2LVxcdTA5RUZdXCIsXG4gIGRldmE6IFwiW1xcdTA5NjYtXFx1MDk2Rl1cIixcbiAgZnVsbHdpZGU6IFwiW1xcdUZGMTAtXFx1RkYxOV1cIixcbiAgZ3VqcjogXCJbXFx1MEFFNi1cXHUwQUVGXVwiLFxuICBoYW5pZGVjOiBcIlvjgId85LiAfOS6jHzkuIl85ZubfOS6lHzlha185LiDfOWFq3zkuZ1dXCIsXG4gIGtobXI6IFwiW1xcdTE3RTAtXFx1MTdFOV1cIixcbiAga25kYTogXCJbXFx1MENFNi1cXHUwQ0VGXVwiLFxuICBsYW9vOiBcIltcXHUwRUQwLVxcdTBFRDldXCIsXG4gIGxpbWI6IFwiW1xcdTE5NDYtXFx1MTk0Rl1cIixcbiAgbWx5bTogXCJbXFx1MEQ2Ni1cXHUwRDZGXVwiLFxuICBtb25nOiBcIltcXHUxODEwLVxcdTE4MTldXCIsXG4gIG15bXI6IFwiW1xcdTEwNDAtXFx1MTA0OV1cIixcbiAgb3J5YTogXCJbXFx1MEI2Ni1cXHUwQjZGXVwiLFxuICB0YW1sZGVjOiBcIltcXHUwQkU2LVxcdTBCRUZdXCIsXG4gIHRlbHU6IFwiW1xcdTBDNjYtXFx1MEM2Rl1cIixcbiAgdGhhaTogXCJbXFx1MEU1MC1cXHUwRTU5XVwiLFxuICB0aWJ0OiBcIltcXHUwRjIwLVxcdTBGMjldXCIsXG4gIGxhdG46IFwiXFxcXGRcIixcbn07XG5cbmNvbnN0IG51bWJlcmluZ1N5c3RlbXNVVEYxNiA9IHtcbiAgYXJhYjogWzE2MzIsIDE2NDFdLFxuICBhcmFiZXh0OiBbMTc3NiwgMTc4NV0sXG4gIGJhbGk6IFs2OTkyLCA3MDAxXSxcbiAgYmVuZzogWzI1MzQsIDI1NDNdLFxuICBkZXZhOiBbMjQwNiwgMjQxNV0sXG4gIGZ1bGx3aWRlOiBbNjUyOTYsIDY1MzAzXSxcbiAgZ3VqcjogWzI3OTAsIDI3OTldLFxuICBraG1yOiBbNjExMiwgNjEyMV0sXG4gIGtuZGE6IFszMzAyLCAzMzExXSxcbiAgbGFvbzogWzM3OTIsIDM4MDFdLFxuICBsaW1iOiBbNjQ3MCwgNjQ3OV0sXG4gIG1seW06IFszNDMwLCAzNDM5XSxcbiAgbW9uZzogWzYxNjAsIDYxNjldLFxuICBteW1yOiBbNDE2MCwgNDE2OV0sXG4gIG9yeWE6IFsyOTE4LCAyOTI3XSxcbiAgdGFtbGRlYzogWzMwNDYsIDMwNTVdLFxuICB0ZWx1OiBbMzE3NCwgMzE4M10sXG4gIHRoYWk6IFszNjY0LCAzNjczXSxcbiAgdGlidDogWzM4NzIsIDM4ODFdLFxufTtcblxuY29uc3QgaGFuaWRlY0NoYXJzID0gbnVtYmVyaW5nU3lzdGVtcy5oYW5pZGVjLnJlcGxhY2UoL1tcXFt8XFxdXS9nLCBcIlwiKS5zcGxpdChcIlwiKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRGlnaXRzKHN0cikge1xuICBsZXQgdmFsdWUgPSBwYXJzZUludChzdHIsIDEwKTtcbiAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgIHZhbHVlID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICBpZiAoc3RyW2ldLnNlYXJjaChudW1iZXJpbmdTeXN0ZW1zLmhhbmlkZWMpICE9PSAtMSkge1xuICAgICAgICB2YWx1ZSArPSBoYW5pZGVjQ2hhcnMuaW5kZXhPZihzdHJbaV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbnVtYmVyaW5nU3lzdGVtc1VURjE2KSB7XG4gICAgICAgICAgY29uc3QgW21pbiwgbWF4XSA9IG51bWJlcmluZ1N5c3RlbXNVVEYxNltrZXldO1xuICAgICAgICAgIGlmIChjb2RlID49IG1pbiAmJiBjb2RlIDw9IG1heCkge1xuICAgICAgICAgICAgdmFsdWUgKz0gY29kZSAtIG1pbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWdpdFJlZ2V4KHsgbnVtYmVyaW5nU3lzdGVtIH0sIGFwcGVuZCA9IFwiXCIpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoYCR7bnVtYmVyaW5nU3lzdGVtc1tudW1iZXJpbmdTeXN0ZW0gfHwgXCJsYXRuXCJdfSR7YXBwZW5kfWApO1xufVxuIiwiaW1wb3J0IHsgcGFyc2VNaWxsaXMsIGlzVW5kZWZpbmVkLCB1bnRydW5jYXRlWWVhciwgc2lnbmVkT2Zmc2V0LCBoYXNPd25Qcm9wZXJ0eSB9IGZyb20gXCIuL3V0aWwuanNcIjtcbmltcG9ydCBGb3JtYXR0ZXIgZnJvbSBcIi4vZm9ybWF0dGVyLmpzXCI7XG5pbXBvcnQgRml4ZWRPZmZzZXRab25lIGZyb20gXCIuLi96b25lcy9maXhlZE9mZnNldFpvbmUuanNcIjtcbmltcG9ydCBJQU5BWm9uZSBmcm9tIFwiLi4vem9uZXMvSUFOQVpvbmUuanNcIjtcbmltcG9ydCBEYXRlVGltZSBmcm9tIFwiLi4vZGF0ZXRpbWUuanNcIjtcbmltcG9ydCB7IGRpZ2l0UmVnZXgsIHBhcnNlRGlnaXRzIH0gZnJvbSBcIi4vZGlnaXRzLmpzXCI7XG5pbXBvcnQgeyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvciB9IGZyb20gXCIuLi9lcnJvcnMuanNcIjtcblxuY29uc3QgTUlTU0lOR19GVFAgPSBcIm1pc3NpbmcgSW50bC5EYXRlVGltZUZvcm1hdC5mb3JtYXRUb1BhcnRzIHN1cHBvcnRcIjtcblxuZnVuY3Rpb24gaW50VW5pdChyZWdleCwgcG9zdCA9IChpKSA9PiBpKSB7XG4gIHJldHVybiB7IHJlZ2V4LCBkZXNlcjogKFtzXSkgPT4gcG9zdChwYXJzZURpZ2l0cyhzKSkgfTtcbn1cblxuY29uc3QgTkJTUCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMTYwKTtcbmNvbnN0IHNwYWNlT3JOQlNQID0gYFsgJHtOQlNQfV1gO1xuY29uc3Qgc3BhY2VPck5CU1BSZWdFeHAgPSBuZXcgUmVnRXhwKHNwYWNlT3JOQlNQLCBcImdcIik7XG5cbmZ1bmN0aW9uIGZpeExpc3RSZWdleChzKSB7XG4gIC8vIG1ha2UgZG90cyBvcHRpb25hbCBhbmQgYWxzbyBtYWtlIHRoZW0gbGl0ZXJhbFxuICAvLyBtYWtlIHNwYWNlIGFuZCBub24gYnJlYWthYmxlIHNwYWNlIGNoYXJhY3RlcnMgaW50ZXJjaGFuZ2VhYmxlXG4gIHJldHVybiBzLnJlcGxhY2UoL1xcLi9nLCBcIlxcXFwuP1wiKS5yZXBsYWNlKHNwYWNlT3JOQlNQUmVnRXhwLCBzcGFjZU9yTkJTUCk7XG59XG5cbmZ1bmN0aW9uIHN0cmlwSW5zZW5zaXRpdml0aWVzKHMpIHtcbiAgcmV0dXJuIHNcbiAgICAucmVwbGFjZSgvXFwuL2csIFwiXCIpIC8vIGlnbm9yZSBkb3RzIHRoYXQgd2VyZSBtYWRlIG9wdGlvbmFsXG4gICAgLnJlcGxhY2Uoc3BhY2VPck5CU1BSZWdFeHAsIFwiIFwiKSAvLyBpbnRlcmNoYW5nZSBzcGFjZSBhbmQgbmJzcFxuICAgIC50b0xvd2VyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiBvbmVPZihzdHJpbmdzLCBzdGFydEluZGV4KSB7XG4gIGlmIChzdHJpbmdzID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZ2V4OiBSZWdFeHAoc3RyaW5ncy5tYXAoZml4TGlzdFJlZ2V4KS5qb2luKFwifFwiKSksXG4gICAgICBkZXNlcjogKFtzXSkgPT5cbiAgICAgICAgc3RyaW5ncy5maW5kSW5kZXgoKGkpID0+IHN0cmlwSW5zZW5zaXRpdml0aWVzKHMpID09PSBzdHJpcEluc2Vuc2l0aXZpdGllcyhpKSkgKyBzdGFydEluZGV4LFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gb2Zmc2V0KHJlZ2V4LCBncm91cHMpIHtcbiAgcmV0dXJuIHsgcmVnZXgsIGRlc2VyOiAoWywgaCwgbV0pID0+IHNpZ25lZE9mZnNldChoLCBtKSwgZ3JvdXBzIH07XG59XG5cbmZ1bmN0aW9uIHNpbXBsZShyZWdleCkge1xuICByZXR1cm4geyByZWdleCwgZGVzZXI6IChbc10pID0+IHMgfTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlVG9rZW4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1tcXC1cXFtcXF17fSgpKis/LixcXFxcXFxeJHwjXFxzXS9nLCBcIlxcXFwkJlwiKTtcbn1cblxuZnVuY3Rpb24gdW5pdEZvclRva2VuKHRva2VuLCBsb2MpIHtcbiAgY29uc3Qgb25lID0gZGlnaXRSZWdleChsb2MpLFxuICAgIHR3byA9IGRpZ2l0UmVnZXgobG9jLCBcInsyfVwiKSxcbiAgICB0aHJlZSA9IGRpZ2l0UmVnZXgobG9jLCBcInszfVwiKSxcbiAgICBmb3VyID0gZGlnaXRSZWdleChsb2MsIFwiezR9XCIpLFxuICAgIHNpeCA9IGRpZ2l0UmVnZXgobG9jLCBcIns2fVwiKSxcbiAgICBvbmVPclR3byA9IGRpZ2l0UmVnZXgobG9jLCBcInsxLDJ9XCIpLFxuICAgIG9uZVRvVGhyZWUgPSBkaWdpdFJlZ2V4KGxvYywgXCJ7MSwzfVwiKSxcbiAgICBvbmVUb1NpeCA9IGRpZ2l0UmVnZXgobG9jLCBcInsxLDZ9XCIpLFxuICAgIG9uZVRvTmluZSA9IGRpZ2l0UmVnZXgobG9jLCBcInsxLDl9XCIpLFxuICAgIHR3b1RvRm91ciA9IGRpZ2l0UmVnZXgobG9jLCBcInsyLDR9XCIpLFxuICAgIGZvdXJUb1NpeCA9IGRpZ2l0UmVnZXgobG9jLCBcIns0LDZ9XCIpLFxuICAgIGxpdGVyYWwgPSAodCkgPT4gKHsgcmVnZXg6IFJlZ0V4cChlc2NhcGVUb2tlbih0LnZhbCkpLCBkZXNlcjogKFtzXSkgPT4gcywgbGl0ZXJhbDogdHJ1ZSB9KSxcbiAgICB1bml0YXRlID0gKHQpID0+IHtcbiAgICAgIGlmICh0b2tlbi5saXRlcmFsKSB7XG4gICAgICAgIHJldHVybiBsaXRlcmFsKHQpO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0LnZhbCkge1xuICAgICAgICAvLyBlcmFcbiAgICAgICAgY2FzZSBcIkdcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLmVyYXMoXCJzaG9ydFwiLCBmYWxzZSksIDApO1xuICAgICAgICBjYXNlIFwiR0dcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLmVyYXMoXCJsb25nXCIsIGZhbHNlKSwgMCk7XG4gICAgICAgIC8vIHllYXJzXG4gICAgICAgIGNhc2UgXCJ5XCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lVG9TaXgpO1xuICAgICAgICBjYXNlIFwieXlcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d29Ub0ZvdXIsIHVudHJ1bmNhdGVZZWFyKTtcbiAgICAgICAgY2FzZSBcInl5eXlcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChmb3VyKTtcbiAgICAgICAgY2FzZSBcInl5eXl5XCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQoZm91clRvU2l4KTtcbiAgICAgICAgY2FzZSBcInl5eXl5eVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHNpeCk7XG4gICAgICAgIC8vIG1vbnRoc1xuICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcIk1NXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgY2FzZSBcIk1NTVwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MubW9udGhzKFwic2hvcnRcIiwgdHJ1ZSwgZmFsc2UpLCAxKTtcbiAgICAgICAgY2FzZSBcIk1NTU1cIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLm1vbnRocyhcImxvbmdcIiwgdHJ1ZSwgZmFsc2UpLCAxKTtcbiAgICAgICAgY2FzZSBcIkxcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJMTFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIGNhc2UgXCJMTExcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLm1vbnRocyhcInNob3J0XCIsIGZhbHNlLCBmYWxzZSksIDEpO1xuICAgICAgICBjYXNlIFwiTExMTFwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MubW9udGhzKFwibG9uZ1wiLCBmYWxzZSwgZmFsc2UpLCAxKTtcbiAgICAgICAgLy8gZGF0ZXNcbiAgICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJkZFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIC8vIG9yZGluYWxzXG4gICAgICAgIGNhc2UgXCJvXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lVG9UaHJlZSk7XG4gICAgICAgIGNhc2UgXCJvb29cIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0aHJlZSk7XG4gICAgICAgIC8vIHRpbWVcbiAgICAgICAgY2FzZSBcIkhIXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJoaFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwibW1cIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICBjYXNlIFwibVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcInFcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJxcVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIGNhc2UgXCJzXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwic3NcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICBjYXNlIFwiU1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZVRvVGhyZWUpO1xuICAgICAgICBjYXNlIFwiU1NTXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodGhyZWUpO1xuICAgICAgICBjYXNlIFwidVwiOlxuICAgICAgICAgIHJldHVybiBzaW1wbGUob25lVG9OaW5lKTtcbiAgICAgICAgY2FzZSBcInV1XCI6XG4gICAgICAgICAgcmV0dXJuIHNpbXBsZShvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJ1dXVcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmUpO1xuICAgICAgICAvLyBtZXJpZGllbVxuICAgICAgICBjYXNlIFwiYVwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MubWVyaWRpZW1zKCksIDApO1xuICAgICAgICAvLyB3ZWVrWWVhciAoaylcbiAgICAgICAgY2FzZSBcImtra2tcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChmb3VyKTtcbiAgICAgICAgY2FzZSBcImtrXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvVG9Gb3VyLCB1bnRydW5jYXRlWWVhcik7XG4gICAgICAgIC8vIHdlZWtOdW1iZXIgKFcpXG4gICAgICAgIGNhc2UgXCJXXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwiV1dcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICAvLyB3ZWVrZGF5c1xuICAgICAgICBjYXNlIFwiRVwiOlxuICAgICAgICBjYXNlIFwiY1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZSk7XG4gICAgICAgIGNhc2UgXCJFRUVcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLndlZWtkYXlzKFwic2hvcnRcIiwgZmFsc2UsIGZhbHNlKSwgMSk7XG4gICAgICAgIGNhc2UgXCJFRUVFXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy53ZWVrZGF5cyhcImxvbmdcIiwgZmFsc2UsIGZhbHNlKSwgMSk7XG4gICAgICAgIGNhc2UgXCJjY2NcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLndlZWtkYXlzKFwic2hvcnRcIiwgdHJ1ZSwgZmFsc2UpLCAxKTtcbiAgICAgICAgY2FzZSBcImNjY2NcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLndlZWtkYXlzKFwibG9uZ1wiLCB0cnVlLCBmYWxzZSksIDEpO1xuICAgICAgICAvLyBvZmZzZXQvem9uZVxuICAgICAgICBjYXNlIFwiWlwiOlxuICAgICAgICBjYXNlIFwiWlpcIjpcbiAgICAgICAgICByZXR1cm4gb2Zmc2V0KG5ldyBSZWdFeHAoYChbKy1dJHtvbmVPclR3by5zb3VyY2V9KSg/OjooJHt0d28uc291cmNlfSkpP2ApLCAyKTtcbiAgICAgICAgY2FzZSBcIlpaWlwiOlxuICAgICAgICAgIHJldHVybiBvZmZzZXQobmV3IFJlZ0V4cChgKFsrLV0ke29uZU9yVHdvLnNvdXJjZX0pKCR7dHdvLnNvdXJjZX0pP2ApLCAyKTtcbiAgICAgICAgLy8gd2UgZG9uJ3Qgc3VwcG9ydCBaWlpaIChQU1QpIG9yIFpaWlpaIChQYWNpZmljIFN0YW5kYXJkIFRpbWUpIGluIHBhcnNpbmdcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBkb24ndCBoYXZlIGFueSB3YXkgdG8gZmlndXJlIG91dCB3aGF0IHRoZXkgYXJlXG4gICAgICAgIGNhc2UgXCJ6XCI6XG4gICAgICAgICAgcmV0dXJuIHNpbXBsZSgvW2Etel8rLS9dezEsMjU2fT8vaSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGxpdGVyYWwodCk7XG4gICAgICB9XG4gICAgfTtcblxuICBjb25zdCB1bml0ID0gdW5pdGF0ZSh0b2tlbikgfHwge1xuICAgIGludmFsaWRSZWFzb246IE1JU1NJTkdfRlRQLFxuICB9O1xuXG4gIHVuaXQudG9rZW4gPSB0b2tlbjtcblxuICByZXR1cm4gdW5pdDtcbn1cblxuY29uc3QgcGFydFR5cGVTdHlsZVRvVG9rZW5WYWwgPSB7XG4gIHllYXI6IHtcbiAgICBcIjItZGlnaXRcIjogXCJ5eVwiLFxuICAgIG51bWVyaWM6IFwieXl5eXlcIixcbiAgfSxcbiAgbW9udGg6IHtcbiAgICBudW1lcmljOiBcIk1cIixcbiAgICBcIjItZGlnaXRcIjogXCJNTVwiLFxuICAgIHNob3J0OiBcIk1NTVwiLFxuICAgIGxvbmc6IFwiTU1NTVwiLFxuICB9LFxuICBkYXk6IHtcbiAgICBudW1lcmljOiBcImRcIixcbiAgICBcIjItZGlnaXRcIjogXCJkZFwiLFxuICB9LFxuICB3ZWVrZGF5OiB7XG4gICAgc2hvcnQ6IFwiRUVFXCIsXG4gICAgbG9uZzogXCJFRUVFXCIsXG4gIH0sXG4gIGRheXBlcmlvZDogXCJhXCIsXG4gIGRheVBlcmlvZDogXCJhXCIsXG4gIGhvdXI6IHtcbiAgICBudW1lcmljOiBcImhcIixcbiAgICBcIjItZGlnaXRcIjogXCJoaFwiLFxuICB9LFxuICBtaW51dGU6IHtcbiAgICBudW1lcmljOiBcIm1cIixcbiAgICBcIjItZGlnaXRcIjogXCJtbVwiLFxuICB9LFxuICBzZWNvbmQ6IHtcbiAgICBudW1lcmljOiBcInNcIixcbiAgICBcIjItZGlnaXRcIjogXCJzc1wiLFxuICB9LFxuICB0aW1lWm9uZU5hbWU6IHtcbiAgICBsb25nOiBcIlpaWlpaXCIsXG4gICAgc2hvcnQ6IFwiWlpaXCIsXG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0b2tlbkZvclBhcnQocGFydCwgZm9ybWF0T3B0cykge1xuICBjb25zdCB7IHR5cGUsIHZhbHVlIH0gPSBwYXJ0O1xuXG4gIGlmICh0eXBlID09PSBcImxpdGVyYWxcIikge1xuICAgIHJldHVybiB7XG4gICAgICBsaXRlcmFsOiB0cnVlLFxuICAgICAgdmFsOiB2YWx1ZSxcbiAgICB9O1xuICB9XG5cbiAgY29uc3Qgc3R5bGUgPSBmb3JtYXRPcHRzW3R5cGVdO1xuXG4gIGxldCB2YWwgPSBwYXJ0VHlwZVN0eWxlVG9Ub2tlblZhbFt0eXBlXTtcbiAgaWYgKHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIpIHtcbiAgICB2YWwgPSB2YWxbc3R5bGVdO1xuICB9XG5cbiAgaWYgKHZhbCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaXRlcmFsOiBmYWxzZSxcbiAgICAgIHZhbCxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gYnVpbGRSZWdleCh1bml0cykge1xuICBjb25zdCByZSA9IHVuaXRzLm1hcCgodSkgPT4gdS5yZWdleCkucmVkdWNlKChmLCByKSA9PiBgJHtmfSgke3Iuc291cmNlfSlgLCBcIlwiKTtcbiAgcmV0dXJuIFtgXiR7cmV9JGAsIHVuaXRzXTtcbn1cblxuZnVuY3Rpb24gbWF0Y2goaW5wdXQsIHJlZ2V4LCBoYW5kbGVycykge1xuICBjb25zdCBtYXRjaGVzID0gaW5wdXQubWF0Y2gocmVnZXgpO1xuXG4gIGlmIChtYXRjaGVzKSB7XG4gICAgY29uc3QgYWxsID0ge307XG4gICAgbGV0IG1hdGNoSW5kZXggPSAxO1xuICAgIGZvciAoY29uc3QgaSBpbiBoYW5kbGVycykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5KGhhbmRsZXJzLCBpKSkge1xuICAgICAgICBjb25zdCBoID0gaGFuZGxlcnNbaV0sXG4gICAgICAgICAgZ3JvdXBzID0gaC5ncm91cHMgPyBoLmdyb3VwcyArIDEgOiAxO1xuICAgICAgICBpZiAoIWgubGl0ZXJhbCAmJiBoLnRva2VuKSB7XG4gICAgICAgICAgYWxsW2gudG9rZW4udmFsWzBdXSA9IGguZGVzZXIobWF0Y2hlcy5zbGljZShtYXRjaEluZGV4LCBtYXRjaEluZGV4ICsgZ3JvdXBzKSk7XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2hJbmRleCArPSBncm91cHM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbbWF0Y2hlcywgYWxsXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW21hdGNoZXMsIHt9XTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkYXRlVGltZUZyb21NYXRjaGVzKG1hdGNoZXMpIHtcbiAgY29uc3QgdG9GaWVsZCA9ICh0b2tlbikgPT4ge1xuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgIHJldHVybiBcIm1pbGxpc2Vjb25kXCI7XG4gICAgICBjYXNlIFwic1wiOlxuICAgICAgICByZXR1cm4gXCJzZWNvbmRcIjtcbiAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgIHJldHVybiBcIm1pbnV0ZVwiO1xuICAgICAgY2FzZSBcImhcIjpcbiAgICAgIGNhc2UgXCJIXCI6XG4gICAgICAgIHJldHVybiBcImhvdXJcIjtcbiAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgIHJldHVybiBcImRheVwiO1xuICAgICAgY2FzZSBcIm9cIjpcbiAgICAgICAgcmV0dXJuIFwib3JkaW5hbFwiO1xuICAgICAgY2FzZSBcIkxcIjpcbiAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgIHJldHVybiBcIm1vbnRoXCI7XG4gICAgICBjYXNlIFwieVwiOlxuICAgICAgICByZXR1cm4gXCJ5ZWFyXCI7XG4gICAgICBjYXNlIFwiRVwiOlxuICAgICAgY2FzZSBcImNcIjpcbiAgICAgICAgcmV0dXJuIFwid2Vla2RheVwiO1xuICAgICAgY2FzZSBcIldcIjpcbiAgICAgICAgcmV0dXJuIFwid2Vla051bWJlclwiO1xuICAgICAgY2FzZSBcImtcIjpcbiAgICAgICAgcmV0dXJuIFwid2Vla1llYXJcIjtcbiAgICAgIGNhc2UgXCJxXCI6XG4gICAgICAgIHJldHVybiBcInF1YXJ0ZXJcIjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICBsZXQgem9uZSA9IG51bGw7XG4gIGxldCBzcGVjaWZpY09mZnNldDtcbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLnopKSB7XG4gICAgem9uZSA9IElBTkFab25lLmNyZWF0ZShtYXRjaGVzLnopO1xuICB9XG5cbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLlopKSB7XG4gICAgaWYgKCF6b25lKSB7XG4gICAgICB6b25lID0gbmV3IEZpeGVkT2Zmc2V0Wm9uZShtYXRjaGVzLlopO1xuICAgIH1cbiAgICBzcGVjaWZpY09mZnNldCA9IG1hdGNoZXMuWjtcbiAgfVxuXG4gIGlmICghaXNVbmRlZmluZWQobWF0Y2hlcy5xKSkge1xuICAgIG1hdGNoZXMuTSA9IChtYXRjaGVzLnEgLSAxKSAqIDMgKyAxO1xuICB9XG5cbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLmgpKSB7XG4gICAgaWYgKG1hdGNoZXMuaCA8IDEyICYmIG1hdGNoZXMuYSA9PT0gMSkge1xuICAgICAgbWF0Y2hlcy5oICs9IDEyO1xuICAgIH0gZWxzZSBpZiAobWF0Y2hlcy5oID09PSAxMiAmJiBtYXRjaGVzLmEgPT09IDApIHtcbiAgICAgIG1hdGNoZXMuaCA9IDA7XG4gICAgfVxuICB9XG5cbiAgaWYgKG1hdGNoZXMuRyA9PT0gMCAmJiBtYXRjaGVzLnkpIHtcbiAgICBtYXRjaGVzLnkgPSAtbWF0Y2hlcy55O1xuICB9XG5cbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLnUpKSB7XG4gICAgbWF0Y2hlcy5TID0gcGFyc2VNaWxsaXMobWF0Y2hlcy51KTtcbiAgfVxuXG4gIGNvbnN0IHZhbHMgPSBPYmplY3Qua2V5cyhtYXRjaGVzKS5yZWR1Y2UoKHIsIGspID0+IHtcbiAgICBjb25zdCBmID0gdG9GaWVsZChrKTtcbiAgICBpZiAoZikge1xuICAgICAgcltmXSA9IG1hdGNoZXNba107XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH0sIHt9KTtcblxuICByZXR1cm4gW3ZhbHMsIHpvbmUsIHNwZWNpZmljT2Zmc2V0XTtcbn1cblxubGV0IGR1bW15RGF0ZVRpbWVDYWNoZSA9IG51bGw7XG5cbmZ1bmN0aW9uIGdldER1bW15RGF0ZVRpbWUoKSB7XG4gIGlmICghZHVtbXlEYXRlVGltZUNhY2hlKSB7XG4gICAgZHVtbXlEYXRlVGltZUNhY2hlID0gRGF0ZVRpbWUuZnJvbU1pbGxpcygxNTU1NTU1NTU1NTU1KTtcbiAgfVxuXG4gIHJldHVybiBkdW1teURhdGVUaW1lQ2FjaGU7XG59XG5cbmZ1bmN0aW9uIG1heWJlRXhwYW5kTWFjcm9Ub2tlbih0b2tlbiwgbG9jYWxlKSB7XG4gIGlmICh0b2tlbi5saXRlcmFsKSB7XG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG5cbiAgY29uc3QgZm9ybWF0T3B0cyA9IEZvcm1hdHRlci5tYWNyb1Rva2VuVG9Gb3JtYXRPcHRzKHRva2VuLnZhbCk7XG4gIGNvbnN0IHRva2VucyA9IGZvcm1hdE9wdHNUb1Rva2Vucyhmb3JtYXRPcHRzLCBsb2NhbGUpO1xuXG4gIGlmICh0b2tlbnMgPT0gbnVsbCB8fCB0b2tlbnMuaW5jbHVkZXModW5kZWZpbmVkKSkge1xuICAgIHJldHVybiB0b2tlbjtcbiAgfVxuXG4gIHJldHVybiB0b2tlbnM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRNYWNyb1Rva2Vucyh0b2tlbnMsIGxvY2FsZSkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdCguLi50b2tlbnMubWFwKCh0KSA9PiBtYXliZUV4cGFuZE1hY3JvVG9rZW4odCwgbG9jYWxlKSkpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cGxhaW5Gcm9tVG9rZW5zKGxvY2FsZSwgaW5wdXQsIGZvcm1hdCkge1xuICBjb25zdCB0b2tlbnMgPSBleHBhbmRNYWNyb1Rva2VucyhGb3JtYXR0ZXIucGFyc2VGb3JtYXQoZm9ybWF0KSwgbG9jYWxlKSxcbiAgICB1bml0cyA9IHRva2Vucy5tYXAoKHQpID0+IHVuaXRGb3JUb2tlbih0LCBsb2NhbGUpKSxcbiAgICBkaXNxdWFsaWZ5aW5nVW5pdCA9IHVuaXRzLmZpbmQoKHQpID0+IHQuaW52YWxpZFJlYXNvbik7XG5cbiAgaWYgKGRpc3F1YWxpZnlpbmdVbml0KSB7XG4gICAgcmV0dXJuIHsgaW5wdXQsIHRva2VucywgaW52YWxpZFJlYXNvbjogZGlzcXVhbGlmeWluZ1VuaXQuaW52YWxpZFJlYXNvbiB9O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IFtyZWdleFN0cmluZywgaGFuZGxlcnNdID0gYnVpbGRSZWdleCh1bml0cyksXG4gICAgICByZWdleCA9IFJlZ0V4cChyZWdleFN0cmluZywgXCJpXCIpLFxuICAgICAgW3Jhd01hdGNoZXMsIG1hdGNoZXNdID0gbWF0Y2goaW5wdXQsIHJlZ2V4LCBoYW5kbGVycyksXG4gICAgICBbcmVzdWx0LCB6b25lLCBzcGVjaWZpY09mZnNldF0gPSBtYXRjaGVzXG4gICAgICAgID8gZGF0ZVRpbWVGcm9tTWF0Y2hlcyhtYXRjaGVzKVxuICAgICAgICA6IFtudWxsLCBudWxsLCB1bmRlZmluZWRdO1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eShtYXRjaGVzLCBcImFcIikgJiYgaGFzT3duUHJvcGVydHkobWF0Y2hlcywgXCJIXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IoXG4gICAgICAgIFwiQ2FuJ3QgaW5jbHVkZSBtZXJpZGllbSB3aGVuIHNwZWNpZnlpbmcgMjQtaG91ciBmb3JtYXRcIlxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgaW5wdXQsIHRva2VucywgcmVnZXgsIHJhd01hdGNoZXMsIG1hdGNoZXMsIHJlc3VsdCwgem9uZSwgc3BlY2lmaWNPZmZzZXQgfTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VGcm9tVG9rZW5zKGxvY2FsZSwgaW5wdXQsIGZvcm1hdCkge1xuICBjb25zdCB7IHJlc3VsdCwgem9uZSwgc3BlY2lmaWNPZmZzZXQsIGludmFsaWRSZWFzb24gfSA9IGV4cGxhaW5Gcm9tVG9rZW5zKGxvY2FsZSwgaW5wdXQsIGZvcm1hdCk7XG4gIHJldHVybiBbcmVzdWx0LCB6b25lLCBzcGVjaWZpY09mZnNldCwgaW52YWxpZFJlYXNvbl07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRPcHRzVG9Ub2tlbnMoZm9ybWF0T3B0cywgbG9jYWxlKSB7XG4gIGlmICghZm9ybWF0T3B0cykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgZm9ybWF0dGVyID0gRm9ybWF0dGVyLmNyZWF0ZShsb2NhbGUsIGZvcm1hdE9wdHMpO1xuICBjb25zdCBwYXJ0cyA9IGZvcm1hdHRlci5mb3JtYXREYXRlVGltZVBhcnRzKGdldER1bW15RGF0ZVRpbWUoKSk7XG4gIHJldHVybiBwYXJ0cy5tYXAoKHApID0+IHRva2VuRm9yUGFydChwLCBmb3JtYXRPcHRzKSk7XG59XG4iLCJpbXBvcnQge1xuICBpbnRlZ2VyQmV0d2VlbixcbiAgaXNMZWFwWWVhcixcbiAgdGltZU9iamVjdCxcbiAgZGF5c0luWWVhcixcbiAgZGF5c0luTW9udGgsXG4gIHdlZWtzSW5XZWVrWWVhcixcbiAgaXNJbnRlZ2VyLFxufSBmcm9tIFwiLi91dGlsLmpzXCI7XG5pbXBvcnQgSW52YWxpZCBmcm9tIFwiLi9pbnZhbGlkLmpzXCI7XG5cbmNvbnN0IG5vbkxlYXBMYWRkZXIgPSBbMCwgMzEsIDU5LCA5MCwgMTIwLCAxNTEsIDE4MSwgMjEyLCAyNDMsIDI3MywgMzA0LCAzMzRdLFxuICBsZWFwTGFkZGVyID0gWzAsIDMxLCA2MCwgOTEsIDEyMSwgMTUyLCAxODIsIDIxMywgMjQ0LCAyNzQsIDMwNSwgMzM1XTtcblxuZnVuY3Rpb24gdW5pdE91dE9mUmFuZ2UodW5pdCwgdmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBJbnZhbGlkKFxuICAgIFwidW5pdCBvdXQgb2YgcmFuZ2VcIixcbiAgICBgeW91IHNwZWNpZmllZCAke3ZhbHVlfSAob2YgdHlwZSAke3R5cGVvZiB2YWx1ZX0pIGFzIGEgJHt1bml0fSwgd2hpY2ggaXMgaW52YWxpZGBcbiAgKTtcbn1cblxuZnVuY3Rpb24gZGF5T2ZXZWVrKHllYXIsIG1vbnRoLCBkYXkpIHtcbiAgY29uc3QgZCA9IG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoIC0gMSwgZGF5KSk7XG5cbiAgaWYgKHllYXIgPCAxMDAgJiYgeWVhciA+PSAwKSB7XG4gICAgZC5zZXRVVENGdWxsWWVhcihkLmdldFVUQ0Z1bGxZZWFyKCkgLSAxOTAwKTtcbiAgfVxuXG4gIGNvbnN0IGpzID0gZC5nZXRVVENEYXkoKTtcblxuICByZXR1cm4ganMgPT09IDAgPyA3IDoganM7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVPcmRpbmFsKHllYXIsIG1vbnRoLCBkYXkpIHtcbiAgcmV0dXJuIGRheSArIChpc0xlYXBZZWFyKHllYXIpID8gbGVhcExhZGRlciA6IG5vbkxlYXBMYWRkZXIpW21vbnRoIC0gMV07XG59XG5cbmZ1bmN0aW9uIHVuY29tcHV0ZU9yZGluYWwoeWVhciwgb3JkaW5hbCkge1xuICBjb25zdCB0YWJsZSA9IGlzTGVhcFllYXIoeWVhcikgPyBsZWFwTGFkZGVyIDogbm9uTGVhcExhZGRlcixcbiAgICBtb250aDAgPSB0YWJsZS5maW5kSW5kZXgoKGkpID0+IGkgPCBvcmRpbmFsKSxcbiAgICBkYXkgPSBvcmRpbmFsIC0gdGFibGVbbW9udGgwXTtcbiAgcmV0dXJuIHsgbW9udGg6IG1vbnRoMCArIDEsIGRheSB9O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdyZWdvcmlhblRvV2VlayhncmVnT2JqKSB7XG4gIGNvbnN0IHsgeWVhciwgbW9udGgsIGRheSB9ID0gZ3JlZ09iaixcbiAgICBvcmRpbmFsID0gY29tcHV0ZU9yZGluYWwoeWVhciwgbW9udGgsIGRheSksXG4gICAgd2Vla2RheSA9IGRheU9mV2Vlayh5ZWFyLCBtb250aCwgZGF5KTtcblxuICBsZXQgd2Vla051bWJlciA9IE1hdGguZmxvb3IoKG9yZGluYWwgLSB3ZWVrZGF5ICsgMTApIC8gNyksXG4gICAgd2Vla1llYXI7XG5cbiAgaWYgKHdlZWtOdW1iZXIgPCAxKSB7XG4gICAgd2Vla1llYXIgPSB5ZWFyIC0gMTtcbiAgICB3ZWVrTnVtYmVyID0gd2Vla3NJbldlZWtZZWFyKHdlZWtZZWFyKTtcbiAgfSBlbHNlIGlmICh3ZWVrTnVtYmVyID4gd2Vla3NJbldlZWtZZWFyKHllYXIpKSB7XG4gICAgd2Vla1llYXIgPSB5ZWFyICsgMTtcbiAgICB3ZWVrTnVtYmVyID0gMTtcbiAgfSBlbHNlIHtcbiAgICB3ZWVrWWVhciA9IHllYXI7XG4gIH1cblxuICByZXR1cm4geyB3ZWVrWWVhciwgd2Vla051bWJlciwgd2Vla2RheSwgLi4udGltZU9iamVjdChncmVnT2JqKSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2Vla1RvR3JlZ29yaWFuKHdlZWtEYXRhKSB7XG4gIGNvbnN0IHsgd2Vla1llYXIsIHdlZWtOdW1iZXIsIHdlZWtkYXkgfSA9IHdlZWtEYXRhLFxuICAgIHdlZWtkYXlPZkphbjQgPSBkYXlPZldlZWsod2Vla1llYXIsIDEsIDQpLFxuICAgIHllYXJJbkRheXMgPSBkYXlzSW5ZZWFyKHdlZWtZZWFyKTtcblxuICBsZXQgb3JkaW5hbCA9IHdlZWtOdW1iZXIgKiA3ICsgd2Vla2RheSAtIHdlZWtkYXlPZkphbjQgLSAzLFxuICAgIHllYXI7XG5cbiAgaWYgKG9yZGluYWwgPCAxKSB7XG4gICAgeWVhciA9IHdlZWtZZWFyIC0gMTtcbiAgICBvcmRpbmFsICs9IGRheXNJblllYXIoeWVhcik7XG4gIH0gZWxzZSBpZiAob3JkaW5hbCA+IHllYXJJbkRheXMpIHtcbiAgICB5ZWFyID0gd2Vla1llYXIgKyAxO1xuICAgIG9yZGluYWwgLT0gZGF5c0luWWVhcih3ZWVrWWVhcik7XG4gIH0gZWxzZSB7XG4gICAgeWVhciA9IHdlZWtZZWFyO1xuICB9XG5cbiAgY29uc3QgeyBtb250aCwgZGF5IH0gPSB1bmNvbXB1dGVPcmRpbmFsKHllYXIsIG9yZGluYWwpO1xuICByZXR1cm4geyB5ZWFyLCBtb250aCwgZGF5LCAuLi50aW1lT2JqZWN0KHdlZWtEYXRhKSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3JlZ29yaWFuVG9PcmRpbmFsKGdyZWdEYXRhKSB7XG4gIGNvbnN0IHsgeWVhciwgbW9udGgsIGRheSB9ID0gZ3JlZ0RhdGE7XG4gIGNvbnN0IG9yZGluYWwgPSBjb21wdXRlT3JkaW5hbCh5ZWFyLCBtb250aCwgZGF5KTtcbiAgcmV0dXJuIHsgeWVhciwgb3JkaW5hbCwgLi4udGltZU9iamVjdChncmVnRGF0YSkgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9yZGluYWxUb0dyZWdvcmlhbihvcmRpbmFsRGF0YSkge1xuICBjb25zdCB7IHllYXIsIG9yZGluYWwgfSA9IG9yZGluYWxEYXRhO1xuICBjb25zdCB7IG1vbnRoLCBkYXkgfSA9IHVuY29tcHV0ZU9yZGluYWwoeWVhciwgb3JkaW5hbCk7XG4gIHJldHVybiB7IHllYXIsIG1vbnRoLCBkYXksIC4uLnRpbWVPYmplY3Qob3JkaW5hbERhdGEpIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNJbnZhbGlkV2Vla0RhdGEob2JqKSB7XG4gIGNvbnN0IHZhbGlkWWVhciA9IGlzSW50ZWdlcihvYmoud2Vla1llYXIpLFxuICAgIHZhbGlkV2VlayA9IGludGVnZXJCZXR3ZWVuKG9iai53ZWVrTnVtYmVyLCAxLCB3ZWVrc0luV2Vla1llYXIob2JqLndlZWtZZWFyKSksXG4gICAgdmFsaWRXZWVrZGF5ID0gaW50ZWdlckJldHdlZW4ob2JqLndlZWtkYXksIDEsIDcpO1xuXG4gIGlmICghdmFsaWRZZWFyKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwid2Vla1llYXJcIiwgb2JqLndlZWtZZWFyKTtcbiAgfSBlbHNlIGlmICghdmFsaWRXZWVrKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwid2Vla1wiLCBvYmoud2Vlayk7XG4gIH0gZWxzZSBpZiAoIXZhbGlkV2Vla2RheSkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIndlZWtkYXlcIiwgb2JqLndlZWtkYXkpO1xuICB9IGVsc2UgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzSW52YWxpZE9yZGluYWxEYXRhKG9iaikge1xuICBjb25zdCB2YWxpZFllYXIgPSBpc0ludGVnZXIob2JqLnllYXIpLFxuICAgIHZhbGlkT3JkaW5hbCA9IGludGVnZXJCZXR3ZWVuKG9iai5vcmRpbmFsLCAxLCBkYXlzSW5ZZWFyKG9iai55ZWFyKSk7XG5cbiAgaWYgKCF2YWxpZFllYXIpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJ5ZWFyXCIsIG9iai55ZWFyKTtcbiAgfSBlbHNlIGlmICghdmFsaWRPcmRpbmFsKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwib3JkaW5hbFwiLCBvYmoub3JkaW5hbCk7XG4gIH0gZWxzZSByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNJbnZhbGlkR3JlZ29yaWFuRGF0YShvYmopIHtcbiAgY29uc3QgdmFsaWRZZWFyID0gaXNJbnRlZ2VyKG9iai55ZWFyKSxcbiAgICB2YWxpZE1vbnRoID0gaW50ZWdlckJldHdlZW4ob2JqLm1vbnRoLCAxLCAxMiksXG4gICAgdmFsaWREYXkgPSBpbnRlZ2VyQmV0d2VlbihvYmouZGF5LCAxLCBkYXlzSW5Nb250aChvYmoueWVhciwgb2JqLm1vbnRoKSk7XG5cbiAgaWYgKCF2YWxpZFllYXIpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJ5ZWFyXCIsIG9iai55ZWFyKTtcbiAgfSBlbHNlIGlmICghdmFsaWRNb250aCkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIm1vbnRoXCIsIG9iai5tb250aCk7XG4gIH0gZWxzZSBpZiAoIXZhbGlkRGF5KSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwiZGF5XCIsIG9iai5kYXkpO1xuICB9IGVsc2UgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzSW52YWxpZFRpbWVEYXRhKG9iaikge1xuICBjb25zdCB7IGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCB9ID0gb2JqO1xuICBjb25zdCB2YWxpZEhvdXIgPVxuICAgICAgaW50ZWdlckJldHdlZW4oaG91ciwgMCwgMjMpIHx8XG4gICAgICAoaG91ciA9PT0gMjQgJiYgbWludXRlID09PSAwICYmIHNlY29uZCA9PT0gMCAmJiBtaWxsaXNlY29uZCA9PT0gMCksXG4gICAgdmFsaWRNaW51dGUgPSBpbnRlZ2VyQmV0d2VlbihtaW51dGUsIDAsIDU5KSxcbiAgICB2YWxpZFNlY29uZCA9IGludGVnZXJCZXR3ZWVuKHNlY29uZCwgMCwgNTkpLFxuICAgIHZhbGlkTWlsbGlzZWNvbmQgPSBpbnRlZ2VyQmV0d2VlbihtaWxsaXNlY29uZCwgMCwgOTk5KTtcblxuICBpZiAoIXZhbGlkSG91cikge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcImhvdXJcIiwgaG91cik7XG4gIH0gZWxzZSBpZiAoIXZhbGlkTWludXRlKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwibWludXRlXCIsIG1pbnV0ZSk7XG4gIH0gZWxzZSBpZiAoIXZhbGlkU2Vjb25kKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwic2Vjb25kXCIsIHNlY29uZCk7XG4gIH0gZWxzZSBpZiAoIXZhbGlkTWlsbGlzZWNvbmQpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJtaWxsaXNlY29uZFwiLCBtaWxsaXNlY29uZCk7XG4gIH0gZWxzZSByZXR1cm4gZmFsc2U7XG59XG4iLCJpbXBvcnQgRHVyYXRpb24gZnJvbSBcIi4vZHVyYXRpb24uanNcIjtcbmltcG9ydCBJbnRlcnZhbCBmcm9tIFwiLi9pbnRlcnZhbC5qc1wiO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gXCIuL3NldHRpbmdzLmpzXCI7XG5pbXBvcnQgSW5mbyBmcm9tIFwiLi9pbmZvLmpzXCI7XG5pbXBvcnQgRm9ybWF0dGVyIGZyb20gXCIuL2ltcGwvZm9ybWF0dGVyLmpzXCI7XG5pbXBvcnQgRml4ZWRPZmZzZXRab25lIGZyb20gXCIuL3pvbmVzL2ZpeGVkT2Zmc2V0Wm9uZS5qc1wiO1xuaW1wb3J0IExvY2FsZSBmcm9tIFwiLi9pbXBsL2xvY2FsZS5qc1wiO1xuaW1wb3J0IHtcbiAgaXNVbmRlZmluZWQsXG4gIG1heWJlQXJyYXksXG4gIGlzRGF0ZSxcbiAgaXNOdW1iZXIsXG4gIGJlc3RCeSxcbiAgZGF5c0luTW9udGgsXG4gIGRheXNJblllYXIsXG4gIGlzTGVhcFllYXIsXG4gIHdlZWtzSW5XZWVrWWVhcixcbiAgbm9ybWFsaXplT2JqZWN0LFxuICByb3VuZFRvLFxuICBvYmpUb0xvY2FsVFMsXG4gIHBhZFN0YXJ0LFxufSBmcm9tIFwiLi9pbXBsL3V0aWwuanNcIjtcbmltcG9ydCB7IG5vcm1hbGl6ZVpvbmUgfSBmcm9tIFwiLi9pbXBsL3pvbmVVdGlsLmpzXCI7XG5pbXBvcnQgZGlmZiBmcm9tIFwiLi9pbXBsL2RpZmYuanNcIjtcbmltcG9ydCB7IHBhcnNlUkZDMjgyMkRhdGUsIHBhcnNlSVNPRGF0ZSwgcGFyc2VIVFRQRGF0ZSwgcGFyc2VTUUwgfSBmcm9tIFwiLi9pbXBsL3JlZ2V4UGFyc2VyLmpzXCI7XG5pbXBvcnQge1xuICBwYXJzZUZyb21Ub2tlbnMsXG4gIGV4cGxhaW5Gcm9tVG9rZW5zLFxuICBmb3JtYXRPcHRzVG9Ub2tlbnMsXG4gIGV4cGFuZE1hY3JvVG9rZW5zLFxufSBmcm9tIFwiLi9pbXBsL3Rva2VuUGFyc2VyLmpzXCI7XG5pbXBvcnQge1xuICBncmVnb3JpYW5Ub1dlZWssXG4gIHdlZWtUb0dyZWdvcmlhbixcbiAgZ3JlZ29yaWFuVG9PcmRpbmFsLFxuICBvcmRpbmFsVG9HcmVnb3JpYW4sXG4gIGhhc0ludmFsaWRHcmVnb3JpYW5EYXRhLFxuICBoYXNJbnZhbGlkV2Vla0RhdGEsXG4gIGhhc0ludmFsaWRPcmRpbmFsRGF0YSxcbiAgaGFzSW52YWxpZFRpbWVEYXRhLFxufSBmcm9tIFwiLi9pbXBsL2NvbnZlcnNpb25zLmpzXCI7XG5pbXBvcnQgKiBhcyBGb3JtYXRzIGZyb20gXCIuL2ltcGwvZm9ybWF0cy5qc1wiO1xuaW1wb3J0IHtcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3IsXG4gIENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yLFxuICBJbnZhbGlkVW5pdEVycm9yLFxuICBJbnZhbGlkRGF0ZVRpbWVFcnJvcixcbn0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgSW52YWxpZCBmcm9tIFwiLi9pbXBsL2ludmFsaWQuanNcIjtcblxuY29uc3QgSU5WQUxJRCA9IFwiSW52YWxpZCBEYXRlVGltZVwiO1xuY29uc3QgTUFYX0RBVEUgPSA4LjY0ZTE1O1xuXG5mdW5jdGlvbiB1bnN1cHBvcnRlZFpvbmUoem9uZSkge1xuICByZXR1cm4gbmV3IEludmFsaWQoXCJ1bnN1cHBvcnRlZCB6b25lXCIsIGB0aGUgem9uZSBcIiR7em9uZS5uYW1lfVwiIGlzIG5vdCBzdXBwb3J0ZWRgKTtcbn1cblxuLy8gd2UgY2FjaGUgd2VlayBkYXRhIG9uIHRoZSBEVCBvYmplY3QgYW5kIHRoaXMgaW50ZXJtZWRpYXRlcyB0aGUgY2FjaGVcbmZ1bmN0aW9uIHBvc3NpYmx5Q2FjaGVkV2Vla0RhdGEoZHQpIHtcbiAgaWYgKGR0LndlZWtEYXRhID09PSBudWxsKSB7XG4gICAgZHQud2Vla0RhdGEgPSBncmVnb3JpYW5Ub1dlZWsoZHQuYyk7XG4gIH1cbiAgcmV0dXJuIGR0LndlZWtEYXRhO1xufVxuXG4vLyBjbG9uZSByZWFsbHkgbWVhbnMsIFwibWFrZSBhIG5ldyBvYmplY3Qgd2l0aCB0aGVzZSBtb2RpZmljYXRpb25zXCIuIGFsbCBcInNldHRlcnNcIiByZWFsbHkgdXNlIHRoaXNcbi8vIHRvIGNyZWF0ZSBhIG5ldyBvYmplY3Qgd2hpbGUgb25seSBjaGFuZ2luZyBzb21lIG9mIHRoZSBwcm9wZXJ0aWVzXG5mdW5jdGlvbiBjbG9uZShpbnN0LCBhbHRzKSB7XG4gIGNvbnN0IGN1cnJlbnQgPSB7XG4gICAgdHM6IGluc3QudHMsXG4gICAgem9uZTogaW5zdC56b25lLFxuICAgIGM6IGluc3QuYyxcbiAgICBvOiBpbnN0Lm8sXG4gICAgbG9jOiBpbnN0LmxvYyxcbiAgICBpbnZhbGlkOiBpbnN0LmludmFsaWQsXG4gIH07XG4gIHJldHVybiBuZXcgRGF0ZVRpbWUoeyAuLi5jdXJyZW50LCAuLi5hbHRzLCBvbGQ6IGN1cnJlbnQgfSk7XG59XG5cbi8vIGZpbmQgdGhlIHJpZ2h0IG9mZnNldCBhIGdpdmVuIGxvY2FsIHRpbWUuIFRoZSBvIGlucHV0IGlzIG91ciBndWVzcywgd2hpY2ggZGV0ZXJtaW5lcyB3aGljaFxuLy8gb2Zmc2V0IHdlJ2xsIHBpY2sgaW4gYW1iaWd1b3VzIGNhc2VzIChlLmcuIHRoZXJlIGFyZSB0d28gMyBBTXMgYi9jIEZhbGxiYWNrIERTVClcbmZ1bmN0aW9uIGZpeE9mZnNldChsb2NhbFRTLCBvLCB0eikge1xuICAvLyBPdXIgVVRDIHRpbWUgaXMganVzdCBhIGd1ZXNzIGJlY2F1c2Ugb3VyIG9mZnNldCBpcyBqdXN0IGEgZ3Vlc3NcbiAgbGV0IHV0Y0d1ZXNzID0gbG9jYWxUUyAtIG8gKiA2MCAqIDEwMDA7XG5cbiAgLy8gVGVzdCB3aGV0aGVyIHRoZSB6b25lIG1hdGNoZXMgdGhlIG9mZnNldCBmb3IgdGhpcyB0c1xuICBjb25zdCBvMiA9IHR6Lm9mZnNldCh1dGNHdWVzcyk7XG5cbiAgLy8gSWYgc28sIG9mZnNldCBkaWRuJ3QgY2hhbmdlIGFuZCB3ZSdyZSBkb25lXG4gIGlmIChvID09PSBvMikge1xuICAgIHJldHVybiBbdXRjR3Vlc3MsIG9dO1xuICB9XG5cbiAgLy8gSWYgbm90LCBjaGFuZ2UgdGhlIHRzIGJ5IHRoZSBkaWZmZXJlbmNlIGluIHRoZSBvZmZzZXRcbiAgdXRjR3Vlc3MgLT0gKG8yIC0gbykgKiA2MCAqIDEwMDA7XG5cbiAgLy8gSWYgdGhhdCBnaXZlcyB1cyB0aGUgbG9jYWwgdGltZSB3ZSB3YW50LCB3ZSdyZSBkb25lXG4gIGNvbnN0IG8zID0gdHoub2Zmc2V0KHV0Y0d1ZXNzKTtcbiAgaWYgKG8yID09PSBvMykge1xuICAgIHJldHVybiBbdXRjR3Vlc3MsIG8yXTtcbiAgfVxuXG4gIC8vIElmIGl0J3MgZGlmZmVyZW50LCB3ZSdyZSBpbiBhIGhvbGUgdGltZS4gVGhlIG9mZnNldCBoYXMgY2hhbmdlZCwgYnV0IHRoZSB3ZSBkb24ndCBhZGp1c3QgdGhlIHRpbWVcbiAgcmV0dXJuIFtsb2NhbFRTIC0gTWF0aC5taW4obzIsIG8zKSAqIDYwICogMTAwMCwgTWF0aC5tYXgobzIsIG8zKV07XG59XG5cbi8vIGNvbnZlcnQgYW4gZXBvY2ggdGltZXN0YW1wIGludG8gYSBjYWxlbmRhciBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gb2Zmc2V0XG5mdW5jdGlvbiB0c1RvT2JqKHRzLCBvZmZzZXQpIHtcbiAgdHMgKz0gb2Zmc2V0ICogNjAgKiAxMDAwO1xuXG4gIGNvbnN0IGQgPSBuZXcgRGF0ZSh0cyk7XG5cbiAgcmV0dXJuIHtcbiAgICB5ZWFyOiBkLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgbW9udGg6IGQuZ2V0VVRDTW9udGgoKSArIDEsXG4gICAgZGF5OiBkLmdldFVUQ0RhdGUoKSxcbiAgICBob3VyOiBkLmdldFVUQ0hvdXJzKCksXG4gICAgbWludXRlOiBkLmdldFVUQ01pbnV0ZXMoKSxcbiAgICBzZWNvbmQ6IGQuZ2V0VVRDU2Vjb25kcygpLFxuICAgIG1pbGxpc2Vjb25kOiBkLmdldFVUQ01pbGxpc2Vjb25kcygpLFxuICB9O1xufVxuXG4vLyBjb252ZXJ0IGEgY2FsZW5kYXIgb2JqZWN0IHRvIGEgZXBvY2ggdGltZXN0YW1wXG5mdW5jdGlvbiBvYmpUb1RTKG9iaiwgb2Zmc2V0LCB6b25lKSB7XG4gIHJldHVybiBmaXhPZmZzZXQob2JqVG9Mb2NhbFRTKG9iaiksIG9mZnNldCwgem9uZSk7XG59XG5cbi8vIGNyZWF0ZSBhIG5ldyBEVCBpbnN0YW5jZSBieSBhZGRpbmcgYSBkdXJhdGlvbiwgYWRqdXN0aW5nIGZvciBEU1RzXG5mdW5jdGlvbiBhZGp1c3RUaW1lKGluc3QsIGR1cikge1xuICBjb25zdCBvUHJlID0gaW5zdC5vLFxuICAgIHllYXIgPSBpbnN0LmMueWVhciArIE1hdGgudHJ1bmMoZHVyLnllYXJzKSxcbiAgICBtb250aCA9IGluc3QuYy5tb250aCArIE1hdGgudHJ1bmMoZHVyLm1vbnRocykgKyBNYXRoLnRydW5jKGR1ci5xdWFydGVycykgKiAzLFxuICAgIGMgPSB7XG4gICAgICAuLi5pbnN0LmMsXG4gICAgICB5ZWFyLFxuICAgICAgbW9udGgsXG4gICAgICBkYXk6XG4gICAgICAgIE1hdGgubWluKGluc3QuYy5kYXksIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSkgK1xuICAgICAgICBNYXRoLnRydW5jKGR1ci5kYXlzKSArXG4gICAgICAgIE1hdGgudHJ1bmMoZHVyLndlZWtzKSAqIDcsXG4gICAgfSxcbiAgICBtaWxsaXNUb0FkZCA9IER1cmF0aW9uLmZyb21PYmplY3Qoe1xuICAgICAgeWVhcnM6IGR1ci55ZWFycyAtIE1hdGgudHJ1bmMoZHVyLnllYXJzKSxcbiAgICAgIHF1YXJ0ZXJzOiBkdXIucXVhcnRlcnMgLSBNYXRoLnRydW5jKGR1ci5xdWFydGVycyksXG4gICAgICBtb250aHM6IGR1ci5tb250aHMgLSBNYXRoLnRydW5jKGR1ci5tb250aHMpLFxuICAgICAgd2Vla3M6IGR1ci53ZWVrcyAtIE1hdGgudHJ1bmMoZHVyLndlZWtzKSxcbiAgICAgIGRheXM6IGR1ci5kYXlzIC0gTWF0aC50cnVuYyhkdXIuZGF5cyksXG4gICAgICBob3VyczogZHVyLmhvdXJzLFxuICAgICAgbWludXRlczogZHVyLm1pbnV0ZXMsXG4gICAgICBzZWNvbmRzOiBkdXIuc2Vjb25kcyxcbiAgICAgIG1pbGxpc2Vjb25kczogZHVyLm1pbGxpc2Vjb25kcyxcbiAgICB9KS5hcyhcIm1pbGxpc2Vjb25kc1wiKSxcbiAgICBsb2NhbFRTID0gb2JqVG9Mb2NhbFRTKGMpO1xuXG4gIGxldCBbdHMsIG9dID0gZml4T2Zmc2V0KGxvY2FsVFMsIG9QcmUsIGluc3Quem9uZSk7XG5cbiAgaWYgKG1pbGxpc1RvQWRkICE9PSAwKSB7XG4gICAgdHMgKz0gbWlsbGlzVG9BZGQ7XG4gICAgLy8gdGhhdCBjb3VsZCBoYXZlIGNoYW5nZWQgdGhlIG9mZnNldCBieSBnb2luZyBvdmVyIGEgRFNULCBidXQgd2Ugd2FudCB0byBrZWVwIHRoZSB0cyB0aGUgc2FtZVxuICAgIG8gPSBpbnN0LnpvbmUub2Zmc2V0KHRzKTtcbiAgfVxuXG4gIHJldHVybiB7IHRzLCBvIH07XG59XG5cbi8vIGhlbHBlciB1c2VmdWwgaW4gdHVybmluZyB0aGUgcmVzdWx0cyBvZiBwYXJzaW5nIGludG8gcmVhbCBkYXRlc1xuLy8gYnkgaGFuZGxpbmcgdGhlIHpvbmUgb3B0aW9uc1xuZnVuY3Rpb24gcGFyc2VEYXRhVG9EYXRlVGltZShwYXJzZWQsIHBhcnNlZFpvbmUsIG9wdHMsIGZvcm1hdCwgdGV4dCwgc3BlY2lmaWNPZmZzZXQpIHtcbiAgY29uc3QgeyBzZXRab25lLCB6b25lIH0gPSBvcHRzO1xuICBpZiAocGFyc2VkICYmIE9iamVjdC5rZXlzKHBhcnNlZCkubGVuZ3RoICE9PSAwKSB7XG4gICAgY29uc3QgaW50ZXJwcmV0YXRpb25ab25lID0gcGFyc2VkWm9uZSB8fCB6b25lLFxuICAgICAgaW5zdCA9IERhdGVUaW1lLmZyb21PYmplY3QocGFyc2VkLCB7XG4gICAgICAgIC4uLm9wdHMsXG4gICAgICAgIHpvbmU6IGludGVycHJldGF0aW9uWm9uZSxcbiAgICAgICAgc3BlY2lmaWNPZmZzZXQsXG4gICAgICB9KTtcbiAgICByZXR1cm4gc2V0Wm9uZSA/IGluc3QgOiBpbnN0LnNldFpvbmUoem9uZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoXG4gICAgICBuZXcgSW52YWxpZChcInVucGFyc2FibGVcIiwgYHRoZSBpbnB1dCBcIiR7dGV4dH1cIiBjYW4ndCBiZSBwYXJzZWQgYXMgJHtmb3JtYXR9YClcbiAgICApO1xuICB9XG59XG5cbi8vIGlmIHlvdSB3YW50IHRvIG91dHB1dCBhIHRlY2huaWNhbCBmb3JtYXQgKGUuZy4gUkZDIDI4MjIpLCB0aGlzIGhlbHBlclxuLy8gaGVscHMgaGFuZGxlIHRoZSBkZXRhaWxzXG5mdW5jdGlvbiB0b1RlY2hGb3JtYXQoZHQsIGZvcm1hdCwgYWxsb3daID0gdHJ1ZSkge1xuICByZXR1cm4gZHQuaXNWYWxpZFxuICAgID8gRm9ybWF0dGVyLmNyZWF0ZShMb2NhbGUuY3JlYXRlKFwiZW4tVVNcIiksIHtcbiAgICAgICAgYWxsb3daLFxuICAgICAgICBmb3JjZVNpbXBsZTogdHJ1ZSxcbiAgICAgIH0pLmZvcm1hdERhdGVUaW1lRnJvbVN0cmluZyhkdCwgZm9ybWF0KVxuICAgIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gdG9JU09EYXRlKG8sIGV4dGVuZGVkKSB7XG4gIGNvbnN0IGxvbmdGb3JtYXQgPSBvLmMueWVhciA+IDk5OTkgfHwgby5jLnllYXIgPCAwO1xuICBsZXQgYyA9IFwiXCI7XG4gIGlmIChsb25nRm9ybWF0ICYmIG8uYy55ZWFyID49IDApIGMgKz0gXCIrXCI7XG4gIGMgKz0gcGFkU3RhcnQoby5jLnllYXIsIGxvbmdGb3JtYXQgPyA2IDogNCk7XG5cbiAgaWYgKGV4dGVuZGVkKSB7XG4gICAgYyArPSBcIi1cIjtcbiAgICBjICs9IHBhZFN0YXJ0KG8uYy5tb250aCk7XG4gICAgYyArPSBcIi1cIjtcbiAgICBjICs9IHBhZFN0YXJ0KG8uYy5kYXkpO1xuICB9IGVsc2Uge1xuICAgIGMgKz0gcGFkU3RhcnQoby5jLm1vbnRoKTtcbiAgICBjICs9IHBhZFN0YXJ0KG8uYy5kYXkpO1xuICB9XG4gIHJldHVybiBjO1xufVxuXG5mdW5jdGlvbiB0b0lTT1RpbWUoXG4gIG8sXG4gIGV4dGVuZGVkLFxuICBzdXBwcmVzc1NlY29uZHMsXG4gIHN1cHByZXNzTWlsbGlzZWNvbmRzLFxuICBpbmNsdWRlT2Zmc2V0LFxuICBleHRlbmRlZFpvbmVcbikge1xuICBsZXQgYyA9IHBhZFN0YXJ0KG8uYy5ob3VyKTtcbiAgaWYgKGV4dGVuZGVkKSB7XG4gICAgYyArPSBcIjpcIjtcbiAgICBjICs9IHBhZFN0YXJ0KG8uYy5taW51dGUpO1xuICAgIGlmIChvLmMuc2Vjb25kICE9PSAwIHx8ICFzdXBwcmVzc1NlY29uZHMpIHtcbiAgICAgIGMgKz0gXCI6XCI7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGMgKz0gcGFkU3RhcnQoby5jLm1pbnV0ZSk7XG4gIH1cblxuICBpZiAoby5jLnNlY29uZCAhPT0gMCB8fCAhc3VwcHJlc3NTZWNvbmRzKSB7XG4gICAgYyArPSBwYWRTdGFydChvLmMuc2Vjb25kKTtcblxuICAgIGlmIChvLmMubWlsbGlzZWNvbmQgIT09IDAgfHwgIXN1cHByZXNzTWlsbGlzZWNvbmRzKSB7XG4gICAgICBjICs9IFwiLlwiO1xuICAgICAgYyArPSBwYWRTdGFydChvLmMubWlsbGlzZWNvbmQsIDMpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpbmNsdWRlT2Zmc2V0KSB7XG4gICAgaWYgKG8uaXNPZmZzZXRGaXhlZCAmJiBvLm9mZnNldCA9PT0gMCAmJiAhZXh0ZW5kZWRab25lKSB7XG4gICAgICBjICs9IFwiWlwiO1xuICAgIH0gZWxzZSBpZiAoby5vIDwgMCkge1xuICAgICAgYyArPSBcIi1cIjtcbiAgICAgIGMgKz0gcGFkU3RhcnQoTWF0aC50cnVuYygtby5vIC8gNjApKTtcbiAgICAgIGMgKz0gXCI6XCI7XG4gICAgICBjICs9IHBhZFN0YXJ0KE1hdGgudHJ1bmMoLW8ubyAlIDYwKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGMgKz0gXCIrXCI7XG4gICAgICBjICs9IHBhZFN0YXJ0KE1hdGgudHJ1bmMoby5vIC8gNjApKTtcbiAgICAgIGMgKz0gXCI6XCI7XG4gICAgICBjICs9IHBhZFN0YXJ0KE1hdGgudHJ1bmMoby5vICUgNjApKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZXh0ZW5kZWRab25lKSB7XG4gICAgYyArPSBcIltcIiArIG8uem9uZS5pYW5hTmFtZSArIFwiXVwiO1xuICB9XG4gIHJldHVybiBjO1xufVxuXG4vLyBkZWZhdWx0cyBmb3IgdW5zcGVjaWZpZWQgdW5pdHMgaW4gdGhlIHN1cHBvcnRlZCBjYWxlbmRhcnNcbmNvbnN0IGRlZmF1bHRVbml0VmFsdWVzID0ge1xuICAgIG1vbnRoOiAxLFxuICAgIGRheTogMSxcbiAgICBob3VyOiAwLFxuICAgIG1pbnV0ZTogMCxcbiAgICBzZWNvbmQ6IDAsXG4gICAgbWlsbGlzZWNvbmQ6IDAsXG4gIH0sXG4gIGRlZmF1bHRXZWVrVW5pdFZhbHVlcyA9IHtcbiAgICB3ZWVrTnVtYmVyOiAxLFxuICAgIHdlZWtkYXk6IDEsXG4gICAgaG91cjogMCxcbiAgICBtaW51dGU6IDAsXG4gICAgc2Vjb25kOiAwLFxuICAgIG1pbGxpc2Vjb25kOiAwLFxuICB9LFxuICBkZWZhdWx0T3JkaW5hbFVuaXRWYWx1ZXMgPSB7XG4gICAgb3JkaW5hbDogMSxcbiAgICBob3VyOiAwLFxuICAgIG1pbnV0ZTogMCxcbiAgICBzZWNvbmQ6IDAsXG4gICAgbWlsbGlzZWNvbmQ6IDAsXG4gIH07XG5cbi8vIFVuaXRzIGluIHRoZSBzdXBwb3J0ZWQgY2FsZW5kYXJzLCBzb3J0ZWQgYnkgYmlnbmVzc1xuY29uc3Qgb3JkZXJlZFVuaXRzID0gW1wieWVhclwiLCBcIm1vbnRoXCIsIFwiZGF5XCIsIFwiaG91clwiLCBcIm1pbnV0ZVwiLCBcInNlY29uZFwiLCBcIm1pbGxpc2Vjb25kXCJdLFxuICBvcmRlcmVkV2Vla1VuaXRzID0gW1xuICAgIFwid2Vla1llYXJcIixcbiAgICBcIndlZWtOdW1iZXJcIixcbiAgICBcIndlZWtkYXlcIixcbiAgICBcImhvdXJcIixcbiAgICBcIm1pbnV0ZVwiLFxuICAgIFwic2Vjb25kXCIsXG4gICAgXCJtaWxsaXNlY29uZFwiLFxuICBdLFxuICBvcmRlcmVkT3JkaW5hbFVuaXRzID0gW1wieWVhclwiLCBcIm9yZGluYWxcIiwgXCJob3VyXCIsIFwibWludXRlXCIsIFwic2Vjb25kXCIsIFwibWlsbGlzZWNvbmRcIl07XG5cbi8vIHN0YW5kYXJkaXplIGNhc2UgYW5kIHBsdXJhbGl0eSBpbiB1bml0c1xuZnVuY3Rpb24gbm9ybWFsaXplVW5pdCh1bml0KSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSB7XG4gICAgeWVhcjogXCJ5ZWFyXCIsXG4gICAgeWVhcnM6IFwieWVhclwiLFxuICAgIG1vbnRoOiBcIm1vbnRoXCIsXG4gICAgbW9udGhzOiBcIm1vbnRoXCIsXG4gICAgZGF5OiBcImRheVwiLFxuICAgIGRheXM6IFwiZGF5XCIsXG4gICAgaG91cjogXCJob3VyXCIsXG4gICAgaG91cnM6IFwiaG91clwiLFxuICAgIG1pbnV0ZTogXCJtaW51dGVcIixcbiAgICBtaW51dGVzOiBcIm1pbnV0ZVwiLFxuICAgIHF1YXJ0ZXI6IFwicXVhcnRlclwiLFxuICAgIHF1YXJ0ZXJzOiBcInF1YXJ0ZXJcIixcbiAgICBzZWNvbmQ6IFwic2Vjb25kXCIsXG4gICAgc2Vjb25kczogXCJzZWNvbmRcIixcbiAgICBtaWxsaXNlY29uZDogXCJtaWxsaXNlY29uZFwiLFxuICAgIG1pbGxpc2Vjb25kczogXCJtaWxsaXNlY29uZFwiLFxuICAgIHdlZWtkYXk6IFwid2Vla2RheVwiLFxuICAgIHdlZWtkYXlzOiBcIndlZWtkYXlcIixcbiAgICB3ZWVrbnVtYmVyOiBcIndlZWtOdW1iZXJcIixcbiAgICB3ZWVrc251bWJlcjogXCJ3ZWVrTnVtYmVyXCIsXG4gICAgd2Vla251bWJlcnM6IFwid2Vla051bWJlclwiLFxuICAgIHdlZWt5ZWFyOiBcIndlZWtZZWFyXCIsXG4gICAgd2Vla3llYXJzOiBcIndlZWtZZWFyXCIsXG4gICAgb3JkaW5hbDogXCJvcmRpbmFsXCIsXG4gIH1bdW5pdC50b0xvd2VyQ2FzZSgpXTtcblxuICBpZiAoIW5vcm1hbGl6ZWQpIHRocm93IG5ldyBJbnZhbGlkVW5pdEVycm9yKHVuaXQpO1xuXG4gIHJldHVybiBub3JtYWxpemVkO1xufVxuXG4vLyB0aGlzIGlzIGEgZHVtYmVkIGRvd24gdmVyc2lvbiBvZiBmcm9tT2JqZWN0KCkgdGhhdCBydW5zIGFib3V0IDYwJSBmYXN0ZXJcbi8vIGJ1dCBkb2Vzbid0IGRvIGFueSB2YWxpZGF0aW9uLCBtYWtlcyBhIGJ1bmNoIG9mIGFzc3VtcHRpb25zIGFib3V0IHdoYXQgdW5pdHNcbi8vIGFyZSBwcmVzZW50LCBhbmQgc28gb24uXG5mdW5jdGlvbiBxdWlja0RUKG9iaiwgb3B0cykge1xuICBjb25zdCB6b25lID0gbm9ybWFsaXplWm9uZShvcHRzLnpvbmUsIFNldHRpbmdzLmRlZmF1bHRab25lKSxcbiAgICBsb2MgPSBMb2NhbGUuZnJvbU9iamVjdChvcHRzKSxcbiAgICB0c05vdyA9IFNldHRpbmdzLm5vdygpO1xuXG4gIGxldCB0cywgbztcblxuICAvLyBhc3N1bWUgd2UgaGF2ZSB0aGUgaGlnaGVyLW9yZGVyIHVuaXRzXG4gIGlmICghaXNVbmRlZmluZWQob2JqLnllYXIpKSB7XG4gICAgZm9yIChjb25zdCB1IG9mIG9yZGVyZWRVbml0cykge1xuICAgICAgaWYgKGlzVW5kZWZpbmVkKG9ialt1XSkpIHtcbiAgICAgICAgb2JqW3VdID0gZGVmYXVsdFVuaXRWYWx1ZXNbdV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaW52YWxpZCA9IGhhc0ludmFsaWRHcmVnb3JpYW5EYXRhKG9iaikgfHwgaGFzSW52YWxpZFRpbWVEYXRhKG9iaik7XG4gICAgaWYgKGludmFsaWQpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKGludmFsaWQpO1xuICAgIH1cblxuICAgIGNvbnN0IG9mZnNldFByb3ZpcyA9IHpvbmUub2Zmc2V0KHRzTm93KTtcbiAgICBbdHMsIG9dID0gb2JqVG9UUyhvYmosIG9mZnNldFByb3Zpcywgem9uZSk7XG4gIH0gZWxzZSB7XG4gICAgdHMgPSB0c05vdztcbiAgfVxuXG4gIHJldHVybiBuZXcgRGF0ZVRpbWUoeyB0cywgem9uZSwgbG9jLCBvIH0pO1xufVxuXG5mdW5jdGlvbiBkaWZmUmVsYXRpdmUoc3RhcnQsIGVuZCwgb3B0cykge1xuICBjb25zdCByb3VuZCA9IGlzVW5kZWZpbmVkKG9wdHMucm91bmQpID8gdHJ1ZSA6IG9wdHMucm91bmQsXG4gICAgZm9ybWF0ID0gKGMsIHVuaXQpID0+IHtcbiAgICAgIGMgPSByb3VuZFRvKGMsIHJvdW5kIHx8IG9wdHMuY2FsZW5kYXJ5ID8gMCA6IDIsIHRydWUpO1xuICAgICAgY29uc3QgZm9ybWF0dGVyID0gZW5kLmxvYy5jbG9uZShvcHRzKS5yZWxGb3JtYXR0ZXIob3B0cyk7XG4gICAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdChjLCB1bml0KTtcbiAgICB9LFxuICAgIGRpZmZlciA9ICh1bml0KSA9PiB7XG4gICAgICBpZiAob3B0cy5jYWxlbmRhcnkpIHtcbiAgICAgICAgaWYgKCFlbmQuaGFzU2FtZShzdGFydCwgdW5pdCkpIHtcbiAgICAgICAgICByZXR1cm4gZW5kLnN0YXJ0T2YodW5pdCkuZGlmZihzdGFydC5zdGFydE9mKHVuaXQpLCB1bml0KS5nZXQodW5pdCk7XG4gICAgICAgIH0gZWxzZSByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBlbmQuZGlmZihzdGFydCwgdW5pdCkuZ2V0KHVuaXQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgaWYgKG9wdHMudW5pdCkge1xuICAgIHJldHVybiBmb3JtYXQoZGlmZmVyKG9wdHMudW5pdCksIG9wdHMudW5pdCk7XG4gIH1cblxuICBmb3IgKGNvbnN0IHVuaXQgb2Ygb3B0cy51bml0cykge1xuICAgIGNvbnN0IGNvdW50ID0gZGlmZmVyKHVuaXQpO1xuICAgIGlmIChNYXRoLmFicyhjb3VudCkgPj0gMSkge1xuICAgICAgcmV0dXJuIGZvcm1hdChjb3VudCwgdW5pdCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmb3JtYXQoc3RhcnQgPiBlbmQgPyAtMCA6IDAsIG9wdHMudW5pdHNbb3B0cy51bml0cy5sZW5ndGggLSAxXSk7XG59XG5cbmZ1bmN0aW9uIGxhc3RPcHRzKGFyZ0xpc3QpIHtcbiAgbGV0IG9wdHMgPSB7fSxcbiAgICBhcmdzO1xuICBpZiAoYXJnTGlzdC5sZW5ndGggPiAwICYmIHR5cGVvZiBhcmdMaXN0W2FyZ0xpc3QubGVuZ3RoIC0gMV0gPT09IFwib2JqZWN0XCIpIHtcbiAgICBvcHRzID0gYXJnTGlzdFthcmdMaXN0Lmxlbmd0aCAtIDFdO1xuICAgIGFyZ3MgPSBBcnJheS5mcm9tKGFyZ0xpc3QpLnNsaWNlKDAsIGFyZ0xpc3QubGVuZ3RoIC0gMSk7XG4gIH0gZWxzZSB7XG4gICAgYXJncyA9IEFycmF5LmZyb20oYXJnTGlzdCk7XG4gIH1cbiAgcmV0dXJuIFtvcHRzLCBhcmdzXTtcbn1cblxuLyoqXG4gKiBBIERhdGVUaW1lIGlzIGFuIGltbXV0YWJsZSBkYXRhIHN0cnVjdHVyZSByZXByZXNlbnRpbmcgYSBzcGVjaWZpYyBkYXRlIGFuZCB0aW1lIGFuZCBhY2NvbXBhbnlpbmcgbWV0aG9kcy4gSXQgY29udGFpbnMgY2xhc3MgYW5kIGluc3RhbmNlIG1ldGhvZHMgZm9yIGNyZWF0aW5nLCBwYXJzaW5nLCBpbnRlcnJvZ2F0aW5nLCB0cmFuc2Zvcm1pbmcsIGFuZCBmb3JtYXR0aW5nIHRoZW0uXG4gKlxuICogQSBEYXRlVGltZSBjb21wcmlzZXMgb2Y6XG4gKiAqIEEgdGltZXN0YW1wLiBFYWNoIERhdGVUaW1lIGluc3RhbmNlIHJlZmVycyB0byBhIHNwZWNpZmljIG1pbGxpc2Vjb25kIG9mIHRoZSBVbml4IGVwb2NoLlxuICogKiBBIHRpbWUgem9uZS4gRWFjaCBpbnN0YW5jZSBpcyBjb25zaWRlcmVkIGluIHRoZSBjb250ZXh0IG9mIGEgc3BlY2lmaWMgem9uZSAoYnkgZGVmYXVsdCB0aGUgbG9jYWwgc3lzdGVtJ3Mgem9uZSkuXG4gKiAqIENvbmZpZ3VyYXRpb24gcHJvcGVydGllcyB0aGF0IGVmZmVjdCBob3cgb3V0cHV0IHN0cmluZ3MgYXJlIGZvcm1hdHRlZCwgc3VjaCBhcyBgbG9jYWxlYCwgYG51bWJlcmluZ1N5c3RlbWAsIGFuZCBgb3V0cHV0Q2FsZW5kYXJgLlxuICpcbiAqIEhlcmUgaXMgYSBicmllZiBvdmVydmlldyBvZiB0aGUgbW9zdCBjb21tb25seSB1c2VkIGZ1bmN0aW9uYWxpdHkgaXQgcHJvdmlkZXM6XG4gKlxuICogKiAqKkNyZWF0aW9uKio6IFRvIGNyZWF0ZSBhIERhdGVUaW1lIGZyb20gaXRzIGNvbXBvbmVudHMsIHVzZSBvbmUgb2YgaXRzIGZhY3RvcnkgY2xhc3MgbWV0aG9kczoge0BsaW5rIERhdGVUaW1lLmxvY2FsfSwge0BsaW5rIERhdGVUaW1lLnV0Y30sIGFuZCAobW9zdCBmbGV4aWJseSkge0BsaW5rIERhdGVUaW1lLmZyb21PYmplY3R9LiBUbyBjcmVhdGUgb25lIGZyb20gYSBzdGFuZGFyZCBzdHJpbmcgZm9ybWF0LCB1c2Uge0BsaW5rIERhdGVUaW1lLmZyb21JU099LCB7QGxpbmsgRGF0ZVRpbWUuZnJvbUhUVFB9LCBhbmQge0BsaW5rIERhdGVUaW1lLmZyb21SRkMyODIyfS4gVG8gY3JlYXRlIG9uZSBmcm9tIGEgY3VzdG9tIHN0cmluZyBmb3JtYXQsIHVzZSB7QGxpbmsgRGF0ZVRpbWUuZnJvbUZvcm1hdH0uIFRvIGNyZWF0ZSBvbmUgZnJvbSBhIG5hdGl2ZSBKUyBkYXRlLCB1c2Uge0BsaW5rIERhdGVUaW1lLmZyb21KU0RhdGV9LlxuICogKiAqKkdyZWdvcmlhbiBjYWxlbmRhciBhbmQgdGltZSoqOiBUbyBleGFtaW5lIHRoZSBHcmVnb3JpYW4gcHJvcGVydGllcyBvZiBhIERhdGVUaW1lIGluZGl2aWR1YWxseSAoaS5lIGFzIG9wcG9zZWQgdG8gY29sbGVjdGl2ZWx5IHRocm91Z2gge0BsaW5rIERhdGVUaW1lI3RvT2JqZWN0fSksIHVzZSB0aGUge0BsaW5rIERhdGVUaW1lI3llYXJ9LCB7QGxpbmsgRGF0ZVRpbWUjbW9udGh9LFxuICoge0BsaW5rIERhdGVUaW1lI2RheX0sIHtAbGluayBEYXRlVGltZSNob3VyfSwge0BsaW5rIERhdGVUaW1lI21pbnV0ZX0sIHtAbGluayBEYXRlVGltZSNzZWNvbmR9LCB7QGxpbmsgRGF0ZVRpbWUjbWlsbGlzZWNvbmR9IGFjY2Vzc29ycy5cbiAqICogKipXZWVrIGNhbGVuZGFyKio6IEZvciBJU08gd2VlayBjYWxlbmRhciBhdHRyaWJ1dGVzLCBzZWUgdGhlIHtAbGluayBEYXRlVGltZSN3ZWVrWWVhcn0sIHtAbGluayBEYXRlVGltZSN3ZWVrTnVtYmVyfSwgYW5kIHtAbGluayBEYXRlVGltZSN3ZWVrZGF5fSBhY2Nlc3NvcnMuXG4gKiAqICoqQ29uZmlndXJhdGlvbioqIFNlZSB0aGUge0BsaW5rIERhdGVUaW1lI2xvY2FsZX0gYW5kIHtAbGluayBEYXRlVGltZSNudW1iZXJpbmdTeXN0ZW19IGFjY2Vzc29ycy5cbiAqICogKipUcmFuc2Zvcm1hdGlvbioqOiBUbyB0cmFuc2Zvcm0gdGhlIERhdGVUaW1lIGludG8gb3RoZXIgRGF0ZVRpbWVzLCB1c2Uge0BsaW5rIERhdGVUaW1lI3NldH0sIHtAbGluayBEYXRlVGltZSNyZWNvbmZpZ3VyZX0sIHtAbGluayBEYXRlVGltZSNzZXRab25lfSwge0BsaW5rIERhdGVUaW1lI3NldExvY2FsZX0sIHtAbGluayBEYXRlVGltZS5wbHVzfSwge0BsaW5rIERhdGVUaW1lI21pbnVzfSwge0BsaW5rIERhdGVUaW1lI2VuZE9mfSwge0BsaW5rIERhdGVUaW1lI3N0YXJ0T2Z9LCB7QGxpbmsgRGF0ZVRpbWUjdG9VVEN9LCBhbmQge0BsaW5rIERhdGVUaW1lI3RvTG9jYWx9LlxuICogKiAqKk91dHB1dCoqOiBUbyBjb252ZXJ0IHRoZSBEYXRlVGltZSB0byBvdGhlciByZXByZXNlbnRhdGlvbnMsIHVzZSB0aGUge0BsaW5rIERhdGVUaW1lI3RvUmVsYXRpdmV9LCB7QGxpbmsgRGF0ZVRpbWUjdG9SZWxhdGl2ZUNhbGVuZGFyfSwge0BsaW5rIERhdGVUaW1lI3RvSlNPTn0sIHtAbGluayBEYXRlVGltZSN0b0lTT30sIHtAbGluayBEYXRlVGltZSN0b0hUVFB9LCB7QGxpbmsgRGF0ZVRpbWUjdG9PYmplY3R9LCB7QGxpbmsgRGF0ZVRpbWUjdG9SRkMyODIyfSwge0BsaW5rIERhdGVUaW1lI3RvU3RyaW5nfSwge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSwge0BsaW5rIERhdGVUaW1lI3RvRm9ybWF0fSwge0BsaW5rIERhdGVUaW1lI3RvTWlsbGlzfSBhbmQge0BsaW5rIERhdGVUaW1lI3RvSlNEYXRlfS5cbiAqXG4gKiBUaGVyZSdzIHBsZW50eSBvdGhlcnMgZG9jdW1lbnRlZCBiZWxvdy4gSW4gYWRkaXRpb24sIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHN1YnRsZXIgdG9waWNzIGxpa2UgaW50ZXJuYXRpb25hbGl6YXRpb24sIHRpbWUgem9uZXMsIGFsdGVybmF0aXZlIGNhbGVuZGFycywgdmFsaWRpdHksIGFuZCBzbyBvbiwgc2VlIHRoZSBleHRlcm5hbCBkb2N1bWVudGF0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEYXRlVGltZSB7XG4gIC8qKlxuICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIGNvbnN0IHpvbmUgPSBjb25maWcuem9uZSB8fCBTZXR0aW5ncy5kZWZhdWx0Wm9uZTtcblxuICAgIGxldCBpbnZhbGlkID1cbiAgICAgIGNvbmZpZy5pbnZhbGlkIHx8XG4gICAgICAoTnVtYmVyLmlzTmFOKGNvbmZpZy50cykgPyBuZXcgSW52YWxpZChcImludmFsaWQgaW5wdXRcIikgOiBudWxsKSB8fFxuICAgICAgKCF6b25lLmlzVmFsaWQgPyB1bnN1cHBvcnRlZFpvbmUoem9uZSkgOiBudWxsKTtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnRzID0gaXNVbmRlZmluZWQoY29uZmlnLnRzKSA/IFNldHRpbmdzLm5vdygpIDogY29uZmlnLnRzO1xuXG4gICAgbGV0IGMgPSBudWxsLFxuICAgICAgbyA9IG51bGw7XG4gICAgaWYgKCFpbnZhbGlkKSB7XG4gICAgICBjb25zdCB1bmNoYW5nZWQgPSBjb25maWcub2xkICYmIGNvbmZpZy5vbGQudHMgPT09IHRoaXMudHMgJiYgY29uZmlnLm9sZC56b25lLmVxdWFscyh6b25lKTtcblxuICAgICAgaWYgKHVuY2hhbmdlZCkge1xuICAgICAgICBbYywgb10gPSBbY29uZmlnLm9sZC5jLCBjb25maWcub2xkLm9dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgb3QgPSB6b25lLm9mZnNldCh0aGlzLnRzKTtcbiAgICAgICAgYyA9IHRzVG9PYmoodGhpcy50cywgb3QpO1xuICAgICAgICBpbnZhbGlkID0gTnVtYmVyLmlzTmFOKGMueWVhcikgPyBuZXcgSW52YWxpZChcImludmFsaWQgaW5wdXRcIikgOiBudWxsO1xuICAgICAgICBjID0gaW52YWxpZCA/IG51bGwgOiBjO1xuICAgICAgICBvID0gaW52YWxpZCA/IG51bGwgOiBvdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl96b25lID0gem9uZTtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmxvYyA9IGNvbmZpZy5sb2MgfHwgTG9jYWxlLmNyZWF0ZSgpO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaW52YWxpZCA9IGludmFsaWQ7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy53ZWVrRGF0YSA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jID0gYztcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLm8gPSBvO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaXNMdXhvbkRhdGVUaW1lID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIENPTlNUUlVDVFxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmb3IgdGhlIGN1cnJlbnQgaW5zdGFudCwgaW4gdGhlIHN5c3RlbSdzIHRpbWUgem9uZS5cbiAgICpcbiAgICogVXNlIFNldHRpbmdzIHRvIG92ZXJyaWRlIHRoZXNlIGRlZmF1bHQgdmFsdWVzIGlmIG5lZWRlZC5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9JU08oKSAvL34+IG5vdyBpbiB0aGUgSVNPIGZvcm1hdFxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBub3coKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlVGltZSh7fSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbG9jYWwgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt5ZWFyXSAtIFRoZSBjYWxlbmRhciB5ZWFyLiBJZiBvbWl0dGVkIChhcyBpbiwgY2FsbCBgbG9jYWwoKWAgd2l0aCBubyBhcmd1bWVudHMpLCB0aGUgY3VycmVudCB0aW1lIHdpbGwgYmUgdXNlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW21vbnRoPTFdIC0gVGhlIG1vbnRoLCAxLWluZGV4ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkYXk9MV0gLSBUaGUgZGF5IG9mIHRoZSBtb250aCwgMS1pbmRleGVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbaG91cj0wXSAtIFRoZSBob3VyIG9mIHRoZSBkYXksIGluIDI0LWhvdXIgdGltZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW21pbnV0ZT0wXSAtIFRoZSBtaW51dGUgb2YgdGhlIGhvdXIsIG1lYW5pbmcgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA1OVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NlY29uZD0wXSAtIFRoZSBzZWNvbmQgb2YgdGhlIG1pbnV0ZSwgbWVhbmluZyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDU5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWlsbGlzZWNvbmQ9MF0gLSBUaGUgbWlsbGlzZWNvbmQgb2YgdGhlIHNlY29uZCwgbWVhbmluZyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDk5OVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gbm93XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKHsgem9uZTogXCJBbWVyaWNhL05ld19Zb3JrXCIgfSkgICAgICAvL34+IG5vdywgaW4gVVMgZWFzdCBjb2FzdCB0aW1lXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAxLTAxVDAwOjAwOjAwXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDMpICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTAxVDAwOjAwOjAwXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDMsIDEyLCB7IGxvY2FsZTogXCJmclwiIH0pICAgICAvL34+IDIwMTctMDMtMTJUMDA6MDA6MDAsIHdpdGggYSBGcmVuY2ggbG9jYWxlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDMsIDEyLCA1KSAgICAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDA1OjAwOjAwXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDMsIDEyLCA1LCB7IHpvbmU6IFwidXRjXCIgfSkgICAvL34+IDIwMTctMDMtMTJUMDU6MDA6MDAsIGluIFVUQ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzLCAxMiwgNSwgNDUpICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTo0NTowMFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzLCAxMiwgNSwgNDUsIDEwKSAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTo0NToxMFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzLCAxMiwgNSwgNDUsIDEwLCA3NjUpICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTo0NToxMC43NjVcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgbG9jYWwoKSB7XG4gICAgY29uc3QgW29wdHMsIGFyZ3NdID0gbGFzdE9wdHMoYXJndW1lbnRzKSxcbiAgICAgIFt5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmRdID0gYXJncztcbiAgICByZXR1cm4gcXVpY2tEVCh7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCB9LCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBpbiBVVENcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt5ZWFyXSAtIFRoZSBjYWxlbmRhciB5ZWFyLiBJZiBvbWl0dGVkIChhcyBpbiwgY2FsbCBgdXRjKClgIHdpdGggbm8gYXJndW1lbnRzKSwgdGhlIGN1cnJlbnQgdGltZSB3aWxsIGJlIHVzZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttb250aD0xXSAtIFRoZSBtb250aCwgMS1pbmRleGVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZGF5PTFdIC0gVGhlIGRheSBvZiB0aGUgbW9udGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtob3VyPTBdIC0gVGhlIGhvdXIgb2YgdGhlIGRheSwgaW4gMjQtaG91ciB0aW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWludXRlPTBdIC0gVGhlIG1pbnV0ZSBvZiB0aGUgaG91ciwgbWVhbmluZyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDU5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2Vjb25kPTBdIC0gVGhlIHNlY29uZCBvZiB0aGUgbWludXRlLCBtZWFuaW5nIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgNTlcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttaWxsaXNlY29uZD0wXSAtIFRoZSBtaWxsaXNlY29uZCBvZiB0aGUgc2Vjb25kLCBtZWFuaW5nIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgOTk5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxvY2FsZV0gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMub3V0cHV0Q2FsZW5kYXJdIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubnVtYmVyaW5nU3lzdGVtXSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gbm93XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3KSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMS0wMVQwMDowMDowMFpcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTAxVDAwOjAwOjAwWlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNywgMywgMTIpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDA6MDA6MDBaXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzLCAxMiwgNSkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTowMDowMFpcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMsIDEyLCA1LCA0NSkgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDA1OjQ1OjAwWlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNywgMywgMTIsIDUsIDQ1LCB7IGxvY2FsZTogXCJmclwiIH0pICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTo0NTowMFogd2l0aCBhIEZyZW5jaCBsb2NhbGVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMsIDEyLCA1LCA0NSwgMTApICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDA1OjQ1OjEwWlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNywgMywgMTIsIDUsIDQ1LCAxMCwgNzY1LCB7IGxvY2FsZTogXCJmclwiIH0pIC8vfj4gMjAxNy0wMy0xMlQwNTo0NToxMC43NjVaIHdpdGggYSBGcmVuY2ggbG9jYWxlXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIHV0YygpIHtcbiAgICBjb25zdCBbb3B0cywgYXJnc10gPSBsYXN0T3B0cyhhcmd1bWVudHMpLFxuICAgICAgW3llYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZF0gPSBhcmdzO1xuXG4gICAgb3B0cy56b25lID0gRml4ZWRPZmZzZXRab25lLnV0Y0luc3RhbmNlO1xuICAgIHJldHVybiBxdWlja0RUKHsgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kIH0sIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYSBKYXZhU2NyaXB0IERhdGUgb2JqZWN0LiBVc2VzIHRoZSBkZWZhdWx0IHpvbmUuXG4gICAqIEBwYXJhbSB7RGF0ZX0gZGF0ZSAtIGEgSmF2YVNjcmlwdCBEYXRlIG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRpb25zLnpvbmU9J2xvY2FsJ10gLSB0aGUgem9uZSB0byBwbGFjZSB0aGUgRGF0ZVRpbWUgaW50b1xuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tSlNEYXRlKGRhdGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHRzID0gaXNEYXRlKGRhdGUpID8gZGF0ZS52YWx1ZU9mKCkgOiBOYU47XG4gICAgaWYgKE51bWJlci5pc05hTih0cykpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKFwiaW52YWxpZCBpbnB1dFwiKTtcbiAgICB9XG5cbiAgICBjb25zdCB6b25lVG9Vc2UgPSBub3JtYWxpemVab25lKG9wdGlvbnMuem9uZSwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpO1xuICAgIGlmICghem9uZVRvVXNlLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKHVuc3VwcG9ydGVkWm9uZSh6b25lVG9Vc2UpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IERhdGVUaW1lKHtcbiAgICAgIHRzOiB0cyxcbiAgICAgIHpvbmU6IHpvbmVUb1VzZSxcbiAgICAgIGxvYzogTG9jYWxlLmZyb21PYmplY3Qob3B0aW9ucyksXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGVwb2NoIChtZWFuaW5nIHNpbmNlIDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuIFVzZXMgdGhlIGRlZmF1bHQgem9uZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pbGxpc2Vjb25kcyAtIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSAxOTcwIFVUQ1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRpb25zLnpvbmU9J2xvY2FsJ10gLSB0aGUgem9uZSB0byBwbGFjZSB0aGUgRGF0ZVRpbWUgaW50b1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubG9jYWxlXSAtIGEgbG9jYWxlIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tTWlsbGlzKG1pbGxpc2Vjb25kcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFpc051bWJlcihtaWxsaXNlY29uZHMpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXG4gICAgICAgIGBmcm9tTWlsbGlzIHJlcXVpcmVzIGEgbnVtZXJpY2FsIGlucHV0LCBidXQgcmVjZWl2ZWQgYSAke3R5cGVvZiBtaWxsaXNlY29uZHN9IHdpdGggdmFsdWUgJHttaWxsaXNlY29uZHN9YFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKG1pbGxpc2Vjb25kcyA8IC1NQVhfREFURSB8fCBtaWxsaXNlY29uZHMgPiBNQVhfREFURSkge1xuICAgICAgLy8gdGhpcyBpc24ndCBwZXJmZWN0IGJlY2F1c2UgYmVjYXVzZSB3ZSBjYW4gc3RpbGwgZW5kIHVwIG91dCBvZiByYW5nZSBiZWNhdXNlIG9mIGFkZGl0aW9uYWwgc2hpZnRpbmcsIGJ1dCBpdCdzIGEgc3RhcnRcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKFwiVGltZXN0YW1wIG91dCBvZiByYW5nZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlVGltZSh7XG4gICAgICAgIHRzOiBtaWxsaXNlY29uZHMsXG4gICAgICAgIHpvbmU6IG5vcm1hbGl6ZVpvbmUob3B0aW9ucy56b25lLCBTZXR0aW5ncy5kZWZhdWx0Wm9uZSksXG4gICAgICAgIGxvYzogTG9jYWxlLmZyb21PYmplY3Qob3B0aW9ucyksXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhIG51bWJlciBvZiBzZWNvbmRzIHNpbmNlIHRoZSBlcG9jaCAobWVhbmluZyBzaW5jZSAxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLiBVc2VzIHRoZSBkZWZhdWx0IHpvbmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzZWNvbmRzIC0gYSBudW1iZXIgb2Ygc2Vjb25kcyBzaW5jZSAxOTcwIFVUQ1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRpb25zLnpvbmU9J2xvY2FsJ10gLSB0aGUgem9uZSB0byBwbGFjZSB0aGUgRGF0ZVRpbWUgaW50b1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubG9jYWxlXSAtIGEgbG9jYWxlIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tU2Vjb25kcyhzZWNvbmRzLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIWlzTnVtYmVyKHNlY29uZHMpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJmcm9tU2Vjb25kcyByZXF1aXJlcyBhIG51bWVyaWNhbCBpbnB1dFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlVGltZSh7XG4gICAgICAgIHRzOiBzZWNvbmRzICogMTAwMCxcbiAgICAgICAgem9uZTogbm9ybWFsaXplWm9uZShvcHRpb25zLnpvbmUsIFNldHRpbmdzLmRlZmF1bHRab25lKSxcbiAgICAgICAgbG9jOiBMb2NhbGUuZnJvbU9iamVjdChvcHRpb25zKSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGEgSmF2YVNjcmlwdCBvYmplY3Qgd2l0aCBrZXlzIGxpa2UgJ3llYXInIGFuZCAnaG91cicgd2l0aCByZWFzb25hYmxlIGRlZmF1bHRzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gdGhlIG9iamVjdCB0byBjcmVhdGUgdGhlIERhdGVUaW1lIGZyb21cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai55ZWFyIC0gYSB5ZWFyLCBzdWNoIGFzIDE5ODdcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5tb250aCAtIGEgbW9udGgsIDEtMTJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5kYXkgLSBhIGRheSBvZiB0aGUgbW9udGgsIDEtMzEsIGRlcGVuZGluZyBvbiB0aGUgbW9udGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5vcmRpbmFsIC0gZGF5IG9mIHRoZSB5ZWFyLCAxLTM2NSBvciAzNjZcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai53ZWVrWWVhciAtIGFuIElTTyB3ZWVrIHllYXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai53ZWVrTnVtYmVyIC0gYW4gSVNPIHdlZWsgbnVtYmVyLCBiZXR3ZWVuIDEgYW5kIDUyIG9yIDUzLCBkZXBlbmRpbmcgb24gdGhlIHllYXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai53ZWVrZGF5IC0gYW4gSVNPIHdlZWtkYXksIDEtNywgd2hlcmUgMSBpcyBNb25kYXkgYW5kIDcgaXMgU3VuZGF5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouaG91ciAtIGhvdXIgb2YgdGhlIGRheSwgMC0yM1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm1pbnV0ZSAtIG1pbnV0ZSBvZiB0aGUgaG91ciwgMC01OVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLnNlY29uZCAtIHNlY29uZCBvZiB0aGUgbWludXRlLCAwLTU5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubWlsbGlzZWNvbmQgLSBtaWxsaXNlY29uZCBvZiB0aGUgc2Vjb25kLCAwLTk5OVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoaXMgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdHMuem9uZT0nbG9jYWwnXSAtIGludGVycHJldCB0aGUgbnVtYmVycyBpbiB0aGUgY29udGV4dCBvZiBhIHBhcnRpY3VsYXIgem9uZS4gQ2FuIHRha2UgYW55IHZhbHVlIHRha2VuIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byBzZXRab25lKClcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nc3lzdGVtJ3MgbG9jYWxlJ10gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbU9iamVjdCh7IHllYXI6IDE5ODIsIG1vbnRoOiA1LCBkYXk6IDI1fSkudG9JU09EYXRlKCkgLy89PiAnMTk4Mi0wNS0yNSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbU9iamVjdCh7IHllYXI6IDE5ODIgfSkudG9JU09EYXRlKCkgLy89PiAnMTk4Mi0wMS0wMSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbU9iamVjdCh7IGhvdXI6IDEwLCBtaW51dGU6IDI2LCBzZWNvbmQ6IDYgfSkgLy9+PiB0b2RheSBhdCAxMDoyNjowNlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tT2JqZWN0KHsgaG91cjogMTAsIG1pbnV0ZTogMjYsIHNlY29uZDogNiB9LCB7IHpvbmU6ICd1dGMnIH0pLFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tT2JqZWN0KHsgaG91cjogMTAsIG1pbnV0ZTogMjYsIHNlY29uZDogNiB9LCB7IHpvbmU6ICdsb2NhbCcgfSlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbU9iamVjdCh7IGhvdXI6IDEwLCBtaW51dGU6IDI2LCBzZWNvbmQ6IDYgfSwgeyB6b25lOiAnQW1lcmljYS9OZXdfWW9yaycgfSlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbU9iamVjdCh7IHdlZWtZZWFyOiAyMDE2LCB3ZWVrTnVtYmVyOiAyLCB3ZWVrZGF5OiAzIH0pLnRvSVNPRGF0ZSgpIC8vPT4gJzIwMTYtMDEtMTMnXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21PYmplY3Qob2JqLCBvcHRzID0ge30pIHtcbiAgICBvYmogPSBvYmogfHwge307XG4gICAgY29uc3Qgem9uZVRvVXNlID0gbm9ybWFsaXplWm9uZShvcHRzLnpvbmUsIFNldHRpbmdzLmRlZmF1bHRab25lKTtcbiAgICBpZiAoIXpvbmVUb1VzZS5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZCh1bnN1cHBvcnRlZFpvbmUoem9uZVRvVXNlKSk7XG4gICAgfVxuXG4gICAgY29uc3QgdHNOb3cgPSBTZXR0aW5ncy5ub3coKSxcbiAgICAgIG9mZnNldFByb3ZpcyA9ICFpc1VuZGVmaW5lZChvcHRzLnNwZWNpZmljT2Zmc2V0KVxuICAgICAgICA/IG9wdHMuc3BlY2lmaWNPZmZzZXRcbiAgICAgICAgOiB6b25lVG9Vc2Uub2Zmc2V0KHRzTm93KSxcbiAgICAgIG5vcm1hbGl6ZWQgPSBub3JtYWxpemVPYmplY3Qob2JqLCBub3JtYWxpemVVbml0KSxcbiAgICAgIGNvbnRhaW5zT3JkaW5hbCA9ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLm9yZGluYWwpLFxuICAgICAgY29udGFpbnNHcmVnb3JZZWFyID0gIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQueWVhciksXG4gICAgICBjb250YWluc0dyZWdvck1EID0gIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQubW9udGgpIHx8ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLmRheSksXG4gICAgICBjb250YWluc0dyZWdvciA9IGNvbnRhaW5zR3JlZ29yWWVhciB8fCBjb250YWluc0dyZWdvck1ELFxuICAgICAgZGVmaW5pdGVXZWVrRGVmID0gbm9ybWFsaXplZC53ZWVrWWVhciB8fCBub3JtYWxpemVkLndlZWtOdW1iZXIsXG4gICAgICBsb2MgPSBMb2NhbGUuZnJvbU9iamVjdChvcHRzKTtcblxuICAgIC8vIGNhc2VzOlxuICAgIC8vIGp1c3QgYSB3ZWVrZGF5IC0+IHRoaXMgd2VlaydzIGluc3RhbmNlIG9mIHRoYXQgd2Vla2RheSwgbm8gd29ycmllc1xuICAgIC8vIChncmVnb3JpYW4gZGF0YSBvciBvcmRpbmFsKSArICh3ZWVrWWVhciBvciB3ZWVrTnVtYmVyKSAtPiBlcnJvclxuICAgIC8vIChncmVnb3JpYW4gbW9udGggb3IgZGF5KSArIG9yZGluYWwgLT4gZXJyb3JcbiAgICAvLyBvdGhlcndpc2UganVzdCB1c2Ugd2Vla3Mgb3Igb3JkaW5hbHMgb3IgZ3JlZ29yaWFuLCBkZXBlbmRpbmcgb24gd2hhdCdzIHNwZWNpZmllZFxuXG4gICAgaWYgKChjb250YWluc0dyZWdvciB8fCBjb250YWluc09yZGluYWwpICYmIGRlZmluaXRlV2Vla0RlZikge1xuICAgICAgdGhyb3cgbmV3IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yKFxuICAgICAgICBcIkNhbid0IG1peCB3ZWVrWWVhci93ZWVrTnVtYmVyIHVuaXRzIHdpdGggeWVhci9tb250aC9kYXkgb3Igb3JkaW5hbHNcIlxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoY29udGFpbnNHcmVnb3JNRCAmJiBjb250YWluc09yZGluYWwpIHtcbiAgICAgIHRocm93IG5ldyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvcihcIkNhbid0IG1peCBvcmRpbmFsIGRhdGVzIHdpdGggbW9udGgvZGF5XCIpO1xuICAgIH1cblxuICAgIGNvbnN0IHVzZVdlZWtEYXRhID0gZGVmaW5pdGVXZWVrRGVmIHx8IChub3JtYWxpemVkLndlZWtkYXkgJiYgIWNvbnRhaW5zR3JlZ29yKTtcblxuICAgIC8vIGNvbmZpZ3VyZSBvdXJzZWx2ZXMgdG8gZGVhbCB3aXRoIGdyZWdvcmlhbiBkYXRlcyBvciB3ZWVrIHN0dWZmXG4gICAgbGV0IHVuaXRzLFxuICAgICAgZGVmYXVsdFZhbHVlcyxcbiAgICAgIG9iak5vdyA9IHRzVG9PYmoodHNOb3csIG9mZnNldFByb3Zpcyk7XG4gICAgaWYgKHVzZVdlZWtEYXRhKSB7XG4gICAgICB1bml0cyA9IG9yZGVyZWRXZWVrVW5pdHM7XG4gICAgICBkZWZhdWx0VmFsdWVzID0gZGVmYXVsdFdlZWtVbml0VmFsdWVzO1xuICAgICAgb2JqTm93ID0gZ3JlZ29yaWFuVG9XZWVrKG9iak5vdyk7XG4gICAgfSBlbHNlIGlmIChjb250YWluc09yZGluYWwpIHtcbiAgICAgIHVuaXRzID0gb3JkZXJlZE9yZGluYWxVbml0cztcbiAgICAgIGRlZmF1bHRWYWx1ZXMgPSBkZWZhdWx0T3JkaW5hbFVuaXRWYWx1ZXM7XG4gICAgICBvYmpOb3cgPSBncmVnb3JpYW5Ub09yZGluYWwob2JqTm93KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdW5pdHMgPSBvcmRlcmVkVW5pdHM7XG4gICAgICBkZWZhdWx0VmFsdWVzID0gZGVmYXVsdFVuaXRWYWx1ZXM7XG4gICAgfVxuXG4gICAgLy8gc2V0IGRlZmF1bHQgdmFsdWVzIGZvciBtaXNzaW5nIHN0dWZmXG4gICAgbGV0IGZvdW5kRmlyc3QgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IHUgb2YgdW5pdHMpIHtcbiAgICAgIGNvbnN0IHYgPSBub3JtYWxpemVkW3VdO1xuICAgICAgaWYgKCFpc1VuZGVmaW5lZCh2KSkge1xuICAgICAgICBmb3VuZEZpcnN0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZm91bmRGaXJzdCkge1xuICAgICAgICBub3JtYWxpemVkW3VdID0gZGVmYXVsdFZhbHVlc1t1XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vcm1hbGl6ZWRbdV0gPSBvYmpOb3dbdV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gbWFrZSBzdXJlIHRoZSB2YWx1ZXMgd2UgaGF2ZSBhcmUgaW4gcmFuZ2VcbiAgICBjb25zdCBoaWdoZXJPcmRlckludmFsaWQgPSB1c2VXZWVrRGF0YVxuICAgICAgICA/IGhhc0ludmFsaWRXZWVrRGF0YShub3JtYWxpemVkKVxuICAgICAgICA6IGNvbnRhaW5zT3JkaW5hbFxuICAgICAgICA/IGhhc0ludmFsaWRPcmRpbmFsRGF0YShub3JtYWxpemVkKVxuICAgICAgICA6IGhhc0ludmFsaWRHcmVnb3JpYW5EYXRhKG5vcm1hbGl6ZWQpLFxuICAgICAgaW52YWxpZCA9IGhpZ2hlck9yZGVySW52YWxpZCB8fCBoYXNJbnZhbGlkVGltZURhdGEobm9ybWFsaXplZCk7XG5cbiAgICBpZiAoaW52YWxpZCkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoaW52YWxpZCk7XG4gICAgfVxuXG4gICAgLy8gY29tcHV0ZSB0aGUgYWN0dWFsIHRpbWVcbiAgICBjb25zdCBncmVnb3JpYW4gPSB1c2VXZWVrRGF0YVxuICAgICAgICA/IHdlZWtUb0dyZWdvcmlhbihub3JtYWxpemVkKVxuICAgICAgICA6IGNvbnRhaW5zT3JkaW5hbFxuICAgICAgICA/IG9yZGluYWxUb0dyZWdvcmlhbihub3JtYWxpemVkKVxuICAgICAgICA6IG5vcm1hbGl6ZWQsXG4gICAgICBbdHNGaW5hbCwgb2Zmc2V0RmluYWxdID0gb2JqVG9UUyhncmVnb3JpYW4sIG9mZnNldFByb3Zpcywgem9uZVRvVXNlKSxcbiAgICAgIGluc3QgPSBuZXcgRGF0ZVRpbWUoe1xuICAgICAgICB0czogdHNGaW5hbCxcbiAgICAgICAgem9uZTogem9uZVRvVXNlLFxuICAgICAgICBvOiBvZmZzZXRGaW5hbCxcbiAgICAgICAgbG9jLFxuICAgICAgfSk7XG5cbiAgICAvLyBncmVnb3JpYW4gZGF0YSArIHdlZWtkYXkgc2VydmVzIG9ubHkgdG8gdmFsaWRhdGVcbiAgICBpZiAobm9ybWFsaXplZC53ZWVrZGF5ICYmIGNvbnRhaW5zR3JlZ29yICYmIG9iai53ZWVrZGF5ICE9PSBpbnN0LndlZWtkYXkpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKFxuICAgICAgICBcIm1pc21hdGNoZWQgd2Vla2RheVwiLFxuICAgICAgICBgeW91IGNhbid0IHNwZWNpZnkgYm90aCBhIHdlZWtkYXkgb2YgJHtub3JtYWxpemVkLndlZWtkYXl9IGFuZCBhIGRhdGUgb2YgJHtpbnN0LnRvSVNPKCl9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGFuIElTTyA4NjAxIHN0cmluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBJU08gc3RyaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0byBhZmZlY3QgdGhlIGNyZWF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRzLnpvbmU9J2xvY2FsJ10gLSB1c2UgdGhpcyB6b25lIGlmIG5vIG9mZnNldCBpcyBzcGVjaWZpZWQgaW4gdGhlIGlucHV0IHN0cmluZyBpdHNlbGYuIFdpbGwgYWxzbyBjb252ZXJ0IHRoZSB0aW1lIHRvIHRoaXMgem9uZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNldFpvbmU9ZmFsc2VdIC0gb3ZlcnJpZGUgdGhlIHpvbmUgd2l0aCBhIGZpeGVkLW9mZnNldCB6b25lIHNwZWNpZmllZCBpbiB0aGUgc3RyaW5nIGl0c2VsZiwgaWYgaXQgc3BlY2lmaWVzIG9uZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdzeXN0ZW0ncyBsb2NhbGUnXSAtIGEgbG9jYWxlIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5vdXRwdXRDYWxlbmRhcl0gLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5udW1iZXJpbmdTeXN0ZW1dIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUlTTygnMjAxNi0wNS0yNVQwOTowODozNC4xMjMnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSVNPKCcyMDE2LTA1LTI1VDA5OjA4OjM0LjEyMyswNjowMCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21JU08oJzIwMTYtMDUtMjVUMDk6MDg6MzQuMTIzKzA2OjAwJywge3NldFpvbmU6IHRydWV9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSVNPKCcyMDE2LTA1LTI1VDA5OjA4OjM0LjEyMycsIHt6b25lOiAndXRjJ30pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21JU08oJzIwMTYtVzA1LTQnKVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tSVNPKHRleHQsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IFt2YWxzLCBwYXJzZWRab25lXSA9IHBhcnNlSVNPRGF0ZSh0ZXh0KTtcbiAgICByZXR1cm4gcGFyc2VEYXRhVG9EYXRlVGltZSh2YWxzLCBwYXJzZWRab25lLCBvcHRzLCBcIklTTyA4NjAxXCIsIHRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYW4gUkZDIDI4MjIgc3RyaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIFJGQyAyODIyIHN0cmluZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdG8gYWZmZWN0IHRoZSBjcmVhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0cy56b25lPSdsb2NhbCddIC0gY29udmVydCB0aGUgdGltZSB0byB0aGlzIHpvbmUuIFNpbmNlIHRoZSBvZmZzZXQgaXMgYWx3YXlzIHNwZWNpZmllZCBpbiB0aGUgc3RyaW5nIGl0c2VsZiwgdGhpcyBoYXMgbm8gZWZmZWN0IG9uIHRoZSBpbnRlcnByZXRhdGlvbiBvZiBzdHJpbmcsIG1lcmVseSB0aGUgem9uZSB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGlzIGV4cHJlc3NlZCBpbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zZXRab25lPWZhbHNlXSAtIG92ZXJyaWRlIHRoZSB6b25lIHdpdGggYSBmaXhlZC1vZmZzZXQgem9uZSBzcGVjaWZpZWQgaW4gdGhlIHN0cmluZyBpdHNlbGYsIGlmIGl0IHNwZWNpZmllcyBvbmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nc3lzdGVtJ3MgbG9jYWxlJ10gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVJGQzI4MjIoJzI1IE5vdiAyMDE2IDEzOjIzOjEyIEdNVCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21SRkMyODIyKCdGcmksIDI1IE5vdiAyMDE2IDEzOjIzOjEyICswNjAwJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVJGQzI4MjIoJzI1IE5vdiAyMDE2IDEzOjIzIFonKVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tUkZDMjgyMih0ZXh0LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBbdmFscywgcGFyc2VkWm9uZV0gPSBwYXJzZVJGQzI4MjJEYXRlKHRleHQpO1xuICAgIHJldHVybiBwYXJzZURhdGFUb0RhdGVUaW1lKHZhbHMsIHBhcnNlZFpvbmUsIG9wdHMsIFwiUkZDIDI4MjJcIiwgdGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhbiBIVFRQIGhlYWRlciBkYXRlXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1Byb3RvY29scy9yZmMyNjE2L3JmYzI2MTYtc2VjMy5odG1sI3NlYzMuMy4xXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIEhUVFAgaGVhZGVyIGRhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRvIGFmZmVjdCB0aGUgY3JlYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdHMuem9uZT0nbG9jYWwnXSAtIGNvbnZlcnQgdGhlIHRpbWUgdG8gdGhpcyB6b25lLiBTaW5jZSBIVFRQIGRhdGVzIGFyZSBhbHdheXMgaW4gVVRDLCB0aGlzIGhhcyBubyBlZmZlY3Qgb24gdGhlIGludGVycHJldGF0aW9uIG9mIHN0cmluZywgbWVyZWx5IHRoZSB6b25lIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaXMgZXhwcmVzc2VkIGluLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNldFpvbmU9ZmFsc2VdIC0gb3ZlcnJpZGUgdGhlIHpvbmUgd2l0aCB0aGUgZml4ZWQtb2Zmc2V0IHpvbmUgc3BlY2lmaWVkIGluIHRoZSBzdHJpbmcuIEZvciBIVFRQIGRhdGVzLCB0aGlzIGlzIGFsd2F5cyBVVEMsIHNvIHRoaXMgb3B0aW9uIGlzIGVxdWl2YWxlbnQgdG8gc2V0dGluZyB0aGUgYHpvbmVgIG9wdGlvbiB0byAndXRjJywgYnV0IHRoaXMgb3B0aW9uIGlzIGluY2x1ZGVkIGZvciBjb25zaXN0ZW5jeSB3aXRoIHNpbWlsYXIgbWV0aG9kcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nc3lzdGVtJ3MgbG9jYWxlJ10gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUhUVFAoJ1N1biwgMDYgTm92IDE5OTQgMDg6NDk6MzcgR01UJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUhUVFAoJ1N1bmRheSwgMDYtTm92LTk0IDA4OjQ5OjM3IEdNVCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21IVFRQKCdTdW4gTm92ICA2IDA4OjQ5OjM3IDE5OTQnKVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tSFRUUCh0ZXh0LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBbdmFscywgcGFyc2VkWm9uZV0gPSBwYXJzZUhUVFBEYXRlKHRleHQpO1xuICAgIHJldHVybiBwYXJzZURhdGFUb0RhdGVUaW1lKHZhbHMsIHBhcnNlZFpvbmUsIG9wdHMsIFwiSFRUUFwiLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGFuIGlucHV0IHN0cmluZyBhbmQgZm9ybWF0IHN0cmluZy5cbiAgICogRGVmYXVsdHMgdG8gZW4tVVMgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZCwgcmVnYXJkbGVzcyBvZiB0aGUgc3lzdGVtJ3MgbG9jYWxlLiBGb3IgYSB0YWJsZSBvZiB0b2tlbnMgYW5kIHRoZWlyIGludGVycHJldGF0aW9ucywgc2VlIFtoZXJlXShodHRwczovL21vbWVudC5naXRodWIuaW8vbHV4b24vIy9wYXJzaW5nP2lkPXRhYmxlLW9mLXRva2VucykuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm10IC0gdGhlIGZvcm1hdCB0aGUgc3RyaW5nIGlzIGV4cGVjdGVkIHRvIGJlIGluIChzZWUgdGhlIGxpbmsgYmVsb3cgZm9yIHRoZSBmb3JtYXRzKVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdG8gYWZmZWN0IHRoZSBjcmVhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0cy56b25lPSdsb2NhbCddIC0gdXNlIHRoaXMgem9uZSBpZiBubyBvZmZzZXQgaXMgc3BlY2lmaWVkIGluIHRoZSBpbnB1dCBzdHJpbmcgaXRzZWxmLiBXaWxsIGFsc28gY29udmVydCB0aGUgRGF0ZVRpbWUgdG8gdGhpcyB6b25lXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2V0Wm9uZT1mYWxzZV0gLSBvdmVycmlkZSB0aGUgem9uZSB3aXRoIGEgem9uZSBzcGVjaWZpZWQgaW4gdGhlIHN0cmluZyBpdHNlbGYsIGlmIGl0IHNwZWNpZmllcyBvbmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nZW4tVVMnXSAtIGEgbG9jYWxlIHN0cmluZyB0byB1c2Ugd2hlbiBwYXJzaW5nLiBXaWxsIGFsc28gc2V0IHRoZSBEYXRlVGltZSB0byB0aGlzIGxvY2FsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byB1c2Ugd2hlbiBwYXJzaW5nLiBXaWxsIGFsc28gc2V0IHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgdG8gdGhpcyBudW1iZXJpbmcgc3lzdGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tRm9ybWF0KHRleHQsIGZtdCwgb3B0cyA9IHt9KSB7XG4gICAgaWYgKGlzVW5kZWZpbmVkKHRleHQpIHx8IGlzVW5kZWZpbmVkKGZtdCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImZyb21Gb3JtYXQgcmVxdWlyZXMgYW4gaW5wdXQgc3RyaW5nIGFuZCBhIGZvcm1hdFwiKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IGxvY2FsZSA9IG51bGwsIG51bWJlcmluZ1N5c3RlbSA9IG51bGwgfSA9IG9wdHMsXG4gICAgICBsb2NhbGVUb1VzZSA9IExvY2FsZS5mcm9tT3B0cyh7XG4gICAgICAgIGxvY2FsZSxcbiAgICAgICAgbnVtYmVyaW5nU3lzdGVtLFxuICAgICAgICBkZWZhdWx0VG9FTjogdHJ1ZSxcbiAgICAgIH0pLFxuICAgICAgW3ZhbHMsIHBhcnNlZFpvbmUsIHNwZWNpZmljT2Zmc2V0LCBpbnZhbGlkXSA9IHBhcnNlRnJvbVRva2Vucyhsb2NhbGVUb1VzZSwgdGV4dCwgZm10KTtcbiAgICBpZiAoaW52YWxpZCkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoaW52YWxpZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwYXJzZURhdGFUb0RhdGVUaW1lKHZhbHMsIHBhcnNlZFpvbmUsIG9wdHMsIGBmb3JtYXQgJHtmbXR9YCwgdGV4dCwgc3BlY2lmaWNPZmZzZXQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgZnJvbUZvcm1hdCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgZnJvbVN0cmluZyh0ZXh0LCBmbXQsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiBEYXRlVGltZS5mcm9tRm9ybWF0KHRleHQsIGZtdCwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhIFNRTCBkYXRlLCB0aW1lLCBvciBkYXRldGltZVxuICAgKiBEZWZhdWx0cyB0byBlbi1VUyBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkLCByZWdhcmRsZXNzIG9mIHRoZSBzeXN0ZW0ncyBsb2NhbGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgc3RyaW5nIHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0byBhZmZlY3QgdGhlIGNyZWF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRzLnpvbmU9J2xvY2FsJ10gLSB1c2UgdGhpcyB6b25lIGlmIG5vIG9mZnNldCBpcyBzcGVjaWZpZWQgaW4gdGhlIGlucHV0IHN0cmluZyBpdHNlbGYuIFdpbGwgYWxzbyBjb252ZXJ0IHRoZSBEYXRlVGltZSB0byB0aGlzIHpvbmVcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zZXRab25lPWZhbHNlXSAtIG92ZXJyaWRlIHRoZSB6b25lIHdpdGggYSB6b25lIHNwZWNpZmllZCBpbiB0aGUgc3RyaW5nIGl0c2VsZiwgaWYgaXQgc3BlY2lmaWVzIG9uZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdlbi1VUyddIC0gYSBsb2NhbGUgc3RyaW5nIHRvIHVzZSB3aGVuIHBhcnNpbmcuIFdpbGwgYWxzbyBzZXQgdGhlIERhdGVUaW1lIHRvIHRoaXMgbG9jYWxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHVzZSB3aGVuIHBhcnNpbmcuIFdpbGwgYWxzbyBzZXQgdGhlIHJlc3VsdGluZyBEYXRlVGltZSB0byB0aGlzIG51bWJlcmluZyBzeXN0ZW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1IDA5OjEyOjM0JylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNSAwOToxMjozNC4zNDInKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1IDA5OjEyOjM0LjM0MiswNjowMCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUgMDk6MTI6MzQuMzQyIEFtZXJpY2EvTG9zX0FuZ2VsZXMnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1IDA5OjEyOjM0LjM0MiBBbWVyaWNhL0xvc19BbmdlbGVzJywgeyBzZXRab25lOiB0cnVlIH0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUgMDk6MTI6MzQuMzQyJywgeyB6b25lOiAnQW1lcmljYS9Mb3NfQW5nZWxlcycgfSlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMDk6MTI6MzQuMzQyJylcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbVNRTCh0ZXh0LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBbdmFscywgcGFyc2VkWm9uZV0gPSBwYXJzZVNRTCh0ZXh0KTtcbiAgICByZXR1cm4gcGFyc2VEYXRhVG9EYXRlVGltZSh2YWxzLCBwYXJzZWRab25lLCBvcHRzLCBcIlNRTFwiLCB0ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW52YWxpZCBEYXRlVGltZS5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gcmVhc29uIC0gc2ltcGxlIHN0cmluZyBvZiB3aHkgdGhpcyBEYXRlVGltZSBpcyBpbnZhbGlkLiBTaG91bGQgbm90IGNvbnRhaW4gcGFyYW1ldGVycyBvciBhbnl0aGluZyBlbHNlIGRhdGEtZGVwZW5kZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZXhwbGFuYXRpb249bnVsbF0gLSBsb25nZXIgZXhwbGFuYXRpb24sIG1heSBpbmNsdWRlIHBhcmFtZXRlcnMgYW5kIG90aGVyIHVzZWZ1bCBkZWJ1Z2dpbmcgaW5mb3JtYXRpb25cbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgaW52YWxpZChyZWFzb24sIGV4cGxhbmF0aW9uID0gbnVsbCkge1xuICAgIGlmICghcmVhc29uKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJuZWVkIHRvIHNwZWNpZnkgYSByZWFzb24gdGhlIERhdGVUaW1lIGlzIGludmFsaWRcIik7XG4gICAgfVxuXG4gICAgY29uc3QgaW52YWxpZCA9IHJlYXNvbiBpbnN0YW5jZW9mIEludmFsaWQgPyByZWFzb24gOiBuZXcgSW52YWxpZChyZWFzb24sIGV4cGxhbmF0aW9uKTtcblxuICAgIGlmIChTZXR0aW5ncy50aHJvd09uSW52YWxpZCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWREYXRlVGltZUVycm9yKGludmFsaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IERhdGVUaW1lKHsgaW52YWxpZCB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gb2JqZWN0IGlzIGFuIGluc3RhbmNlIG9mIERhdGVUaW1lLiBXb3JrcyBhY3Jvc3MgY29udGV4dCBib3VuZGFyaWVzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNEYXRlVGltZShvKSB7XG4gICAgcmV0dXJuIChvICYmIG8uaXNMdXhvbkRhdGVUaW1lKSB8fCBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9kdWNlIHRoZSBmb3JtYXQgc3RyaW5nIGZvciBhIHNldCBvZiBvcHRpb25zXG4gICAqIEBwYXJhbSBmb3JtYXRPcHRzXG4gICAqIEBwYXJhbSBsb2NhbGVPcHRzXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgcGFyc2VGb3JtYXRGb3JPcHRzKGZvcm1hdE9wdHMsIGxvY2FsZU9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHRva2VuTGlzdCA9IGZvcm1hdE9wdHNUb1Rva2Vucyhmb3JtYXRPcHRzLCBMb2NhbGUuZnJvbU9iamVjdChsb2NhbGVPcHRzKSk7XG4gICAgcmV0dXJuICF0b2tlbkxpc3QgPyBudWxsIDogdG9rZW5MaXN0Lm1hcCgodCkgPT4gKHQgPyB0LnZhbCA6IG51bGwpKS5qb2luKFwiXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2R1Y2UgdGhlIHRoZSBmdWxseSBleHBhbmRlZCBmb3JtYXQgdG9rZW4gZm9yIHRoZSBsb2NhbGVcbiAgICogRG9lcyBOT1QgcXVvdGUgY2hhcmFjdGVycywgc28gcXVvdGVkIHRva2VucyB3aWxsIG5vdCByb3VuZCB0cmlwIGNvcnJlY3RseVxuICAgKiBAcGFyYW0gZm10XG4gICAqIEBwYXJhbSBsb2NhbGVPcHRzXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZXhwYW5kRm9ybWF0KGZtdCwgbG9jYWxlT3B0cyA9IHt9KSB7XG4gICAgY29uc3QgZXhwYW5kZWQgPSBleHBhbmRNYWNyb1Rva2VucyhGb3JtYXR0ZXIucGFyc2VGb3JtYXQoZm10KSwgTG9jYWxlLmZyb21PYmplY3QobG9jYWxlT3B0cykpO1xuICAgIHJldHVybiBleHBhbmRlZC5tYXAoKHQpID0+IHQudmFsKS5qb2luKFwiXCIpO1xuICB9XG5cbiAgLy8gSU5GT1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIG9mIHVuaXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gYSB1bml0IHN1Y2ggYXMgJ21pbnV0ZScgb3IgJ2RheSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNywgNCkuZ2V0KCdtb250aCcpOyAvLz0+IDdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNywgNCkuZ2V0KCdkYXknKTsgLy89PiA0XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldCh1bml0KSB7XG4gICAgcmV0dXJuIHRoaXNbdW5pdF07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBEYXRlVGltZSBpcyB2YWxpZC4gSW52YWxpZCBEYXRlVGltZXMgb2NjdXIgd2hlbjpcbiAgICogKiBUaGUgRGF0ZVRpbWUgd2FzIGNyZWF0ZWQgZnJvbSBpbnZhbGlkIGNhbGVuZGFyIGluZm9ybWF0aW9uLCBzdWNoIGFzIHRoZSAxM3RoIG1vbnRoIG9yIEZlYnJ1YXJ5IDMwXG4gICAqICogVGhlIERhdGVUaW1lIHdhcyBjcmVhdGVkIGJ5IGFuIG9wZXJhdGlvbiBvbiBhbm90aGVyIGludmFsaWQgZGF0ZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPT09IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBlcnJvciBjb2RlIGlmIHRoaXMgRGF0ZVRpbWUgaXMgaW52YWxpZCwgb3IgbnVsbCBpZiB0aGUgRGF0ZVRpbWUgaXMgdmFsaWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBpbnZhbGlkUmVhc29uKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPyB0aGlzLmludmFsaWQucmVhc29uIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGV4cGxhbmF0aW9uIG9mIHdoeSB0aGlzIERhdGVUaW1lIGJlY2FtZSBpbnZhbGlkLCBvciBudWxsIGlmIHRoZSBEYXRlVGltZSBpcyB2YWxpZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGludmFsaWRFeHBsYW5hdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID8gdGhpcy5pbnZhbGlkLmV4cGxhbmF0aW9uIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxvY2FsZSBvZiBhIERhdGVUaW1lLCBzdWNoICdlbi1HQicuIFRoZSBsb2NhbGUgaXMgdXNlZCB3aGVuIGZvcm1hdHRpbmcgdGhlIERhdGVUaW1lXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbG9jYWxlKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmxvYy5sb2NhbGUgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbnVtYmVyaW5nIHN5c3RlbSBvZiBhIERhdGVUaW1lLCBzdWNoICdiZW5nJy4gVGhlIG51bWJlcmluZyBzeXN0ZW0gaXMgdXNlZCB3aGVuIGZvcm1hdHRpbmcgdGhlIERhdGVUaW1lXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbnVtYmVyaW5nU3lzdGVtKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmxvYy5udW1iZXJpbmdTeXN0ZW0gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgb3V0cHV0IGNhbGVuZGFyIG9mIGEgRGF0ZVRpbWUsIHN1Y2ggJ2lzbGFtaWMnLiBUaGUgb3V0cHV0IGNhbGVuZGFyIGlzIHVzZWQgd2hlbiBmb3JtYXR0aW5nIHRoZSBEYXRlVGltZVxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG91dHB1dENhbGVuZGFyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmxvYy5vdXRwdXRDYWxlbmRhciA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0aW1lIHpvbmUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgRGF0ZVRpbWUuXG4gICAqIEB0eXBlIHtab25lfVxuICAgKi9cbiAgZ2V0IHpvbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3pvbmU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lIG9mIHRoZSB0aW1lIHpvbmUuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgem9uZU5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuem9uZS5uYW1lIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHllYXJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLnllYXIgLy89PiAyMDE3XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgeWVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLnllYXIgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBxdWFydGVyXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5xdWFydGVyIC8vPT4gMlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHF1YXJ0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IE1hdGguY2VpbCh0aGlzLmMubW9udGggLyAzKSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1vbnRoICgxLTEyKS5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLm1vbnRoIC8vPT4gNVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1vbnRoKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMubW9udGggOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkYXkgb2YgdGhlIG1vbnRoICgxLTMwaXNoKS5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLmRheSAvLz0+IDI1XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgZGF5KCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMuZGF5IDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaG91ciBvZiB0aGUgZGF5ICgwLTIzKS5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUsIDkpLmhvdXIgLy89PiA5XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgaG91cigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLmhvdXIgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtaW51dGUgb2YgdGhlIGhvdXIgKDAtNTkpLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSwgOSwgMzApLm1pbnV0ZSAvLz0+IDMwXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbWludXRlKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMubWludXRlIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2Vjb25kIG9mIHRoZSBtaW51dGUgKDAtNTkpLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSwgOSwgMzAsIDUyKS5zZWNvbmQgLy89PiA1MlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHNlY29uZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLnNlY29uZCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pbGxpc2Vjb25kIG9mIHRoZSBzZWNvbmQgKDAtOTk5KS5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUsIDksIDMwLCA1MiwgNjU0KS5taWxsaXNlY29uZCAvLz0+IDY1NFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1pbGxpc2Vjb25kKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMubWlsbGlzZWNvbmQgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB3ZWVrIHllYXJcbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDEyLCAzMSkud2Vla1llYXIgLy89PiAyMDE1XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2Vla1llYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHBvc3NpYmx5Q2FjaGVkV2Vla0RhdGEodGhpcykud2Vla1llYXIgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB3ZWVrIG51bWJlciBvZiB0aGUgd2VlayB5ZWFyICgxLTUyaXNoKS5cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS53ZWVrTnVtYmVyIC8vPT4gMjFcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB3ZWVrTnVtYmVyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBwb3NzaWJseUNhY2hlZFdlZWtEYXRhKHRoaXMpLndlZWtOdW1iZXIgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkYXkgb2YgdGhlIHdlZWsuXG4gICAqIDEgaXMgTW9uZGF5IGFuZCA3IGlzIFN1bmRheVxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMTEsIDMxKS53ZWVrZGF5IC8vPT4gNFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdlZWtkYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHBvc3NpYmx5Q2FjaGVkV2Vla0RhdGEodGhpcykud2Vla2RheSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG9yZGluYWwgKG1lYW5pbmcgdGhlIGRheSBvZiB0aGUgeWVhcilcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLm9yZGluYWwgLy89PiAxNDVcbiAgICogQHR5cGUge251bWJlcnxEYXRlVGltZX1cbiAgICovXG4gIGdldCBvcmRpbmFsKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBncmVnb3JpYW5Ub09yZGluYWwodGhpcy5jKS5vcmRpbmFsIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaHVtYW4gcmVhZGFibGUgc2hvcnQgbW9udGggbmFtZSwgc3VjaCBhcyAnT2N0Jy5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDEwLCAzMCkubW9udGhTaG9ydCAvLz0+IE9jdFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG1vbnRoU2hvcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IEluZm8ubW9udGhzKFwic2hvcnRcIiwgeyBsb2NPYmo6IHRoaXMubG9jIH0pW3RoaXMubW9udGggLSAxXSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBodW1hbiByZWFkYWJsZSBsb25nIG1vbnRoIG5hbWUsIHN1Y2ggYXMgJ09jdG9iZXInLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMTAsIDMwKS5tb250aExvbmcgLy89PiBPY3RvYmVyXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbW9udGhMb25nKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBJbmZvLm1vbnRocyhcImxvbmdcIiwgeyBsb2NPYmo6IHRoaXMubG9jIH0pW3RoaXMubW9udGggLSAxXSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBodW1hbiByZWFkYWJsZSBzaG9ydCB3ZWVrZGF5LCBzdWNoIGFzICdNb24nLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMTAsIDMwKS53ZWVrZGF5U2hvcnQgLy89PiBNb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCB3ZWVrZGF5U2hvcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IEluZm8ud2Vla2RheXMoXCJzaG9ydFwiLCB7IGxvY09iajogdGhpcy5sb2MgfSlbdGhpcy53ZWVrZGF5IC0gMV0gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaHVtYW4gcmVhZGFibGUgbG9uZyB3ZWVrZGF5LCBzdWNoIGFzICdNb25kYXknLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMTAsIDMwKS53ZWVrZGF5TG9uZyAvLz0+IE1vbmRheVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IHdlZWtkYXlMb25nKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBJbmZvLndlZWtkYXlzKFwibG9uZ1wiLCB7IGxvY09iajogdGhpcy5sb2MgfSlbdGhpcy53ZWVrZGF5IC0gMV0gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgVVRDIG9mZnNldCBvZiB0aGlzIERhdGVUaW1lIGluIG1pbnV0ZXNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkub2Zmc2V0IC8vPT4gLTI0MFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKS5vZmZzZXQgLy89PiAwXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgb2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyArdGhpcy5vIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2hvcnQgaHVtYW4gbmFtZSBmb3IgdGhlIHpvbmUncyBjdXJyZW50IG9mZnNldCwgZm9yIGV4YW1wbGUgXCJFU1RcIiBvciBcIkVEVFwiLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBvZmZzZXROYW1lU2hvcnQoKSB7XG4gICAgaWYgKHRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIHRoaXMuem9uZS5vZmZzZXROYW1lKHRoaXMudHMsIHtcbiAgICAgICAgZm9ybWF0OiBcInNob3J0XCIsXG4gICAgICAgIGxvY2FsZTogdGhpcy5sb2NhbGUsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbG9uZyBodW1hbiBuYW1lIGZvciB0aGUgem9uZSdzIGN1cnJlbnQgb2Zmc2V0LCBmb3IgZXhhbXBsZSBcIkVhc3Rlcm4gU3RhbmRhcmQgVGltZVwiIG9yIFwiRWFzdGVybiBEYXlsaWdodCBUaW1lXCIuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG9mZnNldE5hbWVMb25nKCkge1xuICAgIGlmICh0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnpvbmUub2Zmc2V0TmFtZSh0aGlzLnRzLCB7XG4gICAgICAgIGZvcm1hdDogXCJsb25nXCIsXG4gICAgICAgIGxvY2FsZTogdGhpcy5sb2NhbGUsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB3aGV0aGVyIHRoaXMgem9uZSdzIG9mZnNldCBldmVyIGNoYW5nZXMsIGFzIGluIGEgRFNULlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc09mZnNldEZpeGVkKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnpvbmUuaXNVbml2ZXJzYWwgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB3aGV0aGVyIHRoZSBEYXRlVGltZSBpcyBpbiBhIERTVC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNJbkRTVCgpIHtcbiAgICBpZiAodGhpcy5pc09mZnNldEZpeGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMub2Zmc2V0ID4gdGhpcy5zZXQoeyBtb250aDogMSwgZGF5OiAxIH0pLm9mZnNldCB8fFxuICAgICAgICB0aGlzLm9mZnNldCA+IHRoaXMuc2V0KHsgbW9udGg6IDUgfSkub2Zmc2V0XG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBEYXRlVGltZSBpcyBpbiBhIGxlYXAgeWVhciwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTYpLmlzSW5MZWFwWWVhciAvLz0+IHRydWVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxMykuaXNJbkxlYXBZZWFyIC8vPT4gZmFsc2VcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNJbkxlYXBZZWFyKCkge1xuICAgIHJldHVybiBpc0xlYXBZZWFyKHRoaXMueWVhcik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGRheXMgaW4gdGhpcyBEYXRlVGltZSdzIG1vbnRoXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTYsIDIpLmRheXNJbk1vbnRoIC8vPT4gMjlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNiwgMykuZGF5c0luTW9udGggLy89PiAzMVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRheXNJbk1vbnRoKCkge1xuICAgIHJldHVybiBkYXlzSW5Nb250aCh0aGlzLnllYXIsIHRoaXMubW9udGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBkYXlzIGluIHRoaXMgRGF0ZVRpbWUncyB5ZWFyXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTYpLmRheXNJblllYXIgLy89PiAzNjZcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxMykuZGF5c0luWWVhciAvLz0+IDM2NVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRheXNJblllYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IGRheXNJblllYXIodGhpcy55ZWFyKSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygd2Vla3MgaW4gdGhpcyBEYXRlVGltZSdzIHllYXJcbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMDQpLndlZWtzSW5XZWVrWWVhciAvLz0+IDUzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTMpLndlZWtzSW5XZWVrWWVhciAvLz0+IDUyXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2Vla3NJbldlZWtZZWFyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB3ZWVrc0luV2Vla1llYXIodGhpcy53ZWVrWWVhcikgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVzb2x2ZWQgSW50bCBvcHRpb25zIGZvciB0aGlzIERhdGVUaW1lLlxuICAgKiBUaGlzIGlzIHVzZWZ1bCBpbiB1bmRlcnN0YW5kaW5nIHRoZSBiZWhhdmlvciBvZiBmb3JtYXR0aW5nIG1ldGhvZHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSB0aGUgc2FtZSBvcHRpb25zIGFzIHRvTG9jYWxlU3RyaW5nXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHJlc29sdmVkTG9jYWxlT3B0aW9ucyhvcHRzID0ge30pIHtcbiAgICBjb25zdCB7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBjYWxlbmRhciB9ID0gRm9ybWF0dGVyLmNyZWF0ZShcbiAgICAgIHRoaXMubG9jLmNsb25lKG9wdHMpLFxuICAgICAgb3B0c1xuICAgICkucmVzb2x2ZWRPcHRpb25zKHRoaXMpO1xuICAgIHJldHVybiB7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhcjogY2FsZW5kYXIgfTtcbiAgfVxuXG4gIC8vIFRSQU5TRk9STVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBEYXRlVGltZSdzIHpvbmUgdG8gVVRDLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqXG4gICAqIEVxdWl2YWxlbnQgdG8ge0BsaW5rIERhdGVUaW1lI3NldFpvbmV9KCd1dGMnKVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29mZnNldD0wXSAtIG9wdGlvbmFsbHksIGFuIG9mZnNldCBmcm9tIFVUQyBpbiBtaW51dGVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cz17fV0gLSBvcHRpb25zIHRvIHBhc3MgdG8gYHNldFpvbmUoKWBcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICB0b1VUQyhvZmZzZXQgPSAwLCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5zZXRab25lKEZpeGVkT2Zmc2V0Wm9uZS5pbnN0YW5jZShvZmZzZXQpLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBEYXRlVGltZSdzIHpvbmUgdG8gdGhlIGhvc3QncyBsb2NhbCB6b25lLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqXG4gICAqIEVxdWl2YWxlbnQgdG8gYHNldFpvbmUoJ2xvY2FsJylgXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgdG9Mb2NhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRab25lKFNldHRpbmdzLmRlZmF1bHRab25lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBEYXRlVGltZSdzIHpvbmUgdG8gc3BlY2lmaWVkIHpvbmUuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEYXRlVGltZS5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhlIHNldHRlciBrZWVwcyB0aGUgdW5kZXJseWluZyB0aW1lIHRoZSBzYW1lIChhcyBpbiwgdGhlIHNhbWUgdGltZXN0YW1wKSwgYnV0IHRoZSBuZXcgaW5zdGFuY2Ugd2lsbCByZXBvcnQgZGlmZmVyZW50IGxvY2FsIHRpbWVzIGFuZCBjb25zaWRlciBEU1RzIHdoZW4gbWFraW5nIGNvbXB1dGF0aW9ucywgYXMgd2l0aCB7QGxpbmsgRGF0ZVRpbWUjcGx1c30uIFlvdSBtYXkgd2lzaCB0byB1c2Uge0BsaW5rIERhdGVUaW1lI3RvTG9jYWx9IGFuZCB7QGxpbmsgRGF0ZVRpbWUjdG9VVEN9IHdoaWNoIHByb3ZpZGUgc2ltcGxlIGNvbnZlbmllbmNlIHdyYXBwZXJzIGZvciBjb21tb25seSB1c2VkIHpvbmVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbem9uZT0nbG9jYWwnXSAtIGEgem9uZSBpZGVudGlmaWVyLiBBcyBhIHN0cmluZywgdGhhdCBjYW4gYmUgYW55IElBTkEgem9uZSBzdXBwb3J0ZWQgYnkgdGhlIGhvc3QgZW52aXJvbm1lbnQsIG9yIGEgZml4ZWQtb2Zmc2V0IG5hbWUgb2YgdGhlIGZvcm0gJ1VUQyszJywgb3IgdGhlIHN0cmluZ3MgJ2xvY2FsJyBvciAndXRjJy4gWW91IG1heSBhbHNvIHN1cHBseSBhbiBpbnN0YW5jZSBvZiBhIHtAbGluayBEYXRlVGltZSNab25lfSBjbGFzcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMua2VlcExvY2FsVGltZT1mYWxzZV0gLSBJZiB0cnVlLCBhZGp1c3QgdGhlIHVuZGVybHlpbmcgdGltZSBzbyB0aGF0IHRoZSBsb2NhbCB0aW1lIHN0YXlzIHRoZSBzYW1lLCBidXQgaW4gdGhlIHRhcmdldCB6b25lLiBZb3Ugc2hvdWxkIHJhcmVseSBuZWVkIHRoaXMuXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc2V0Wm9uZSh6b25lLCB7IGtlZXBMb2NhbFRpbWUgPSBmYWxzZSwga2VlcENhbGVuZGFyVGltZSA9IGZhbHNlIH0gPSB7fSkge1xuICAgIHpvbmUgPSBub3JtYWxpemVab25lKHpvbmUsIFNldHRpbmdzLmRlZmF1bHRab25lKTtcbiAgICBpZiAoem9uZS5lcXVhbHModGhpcy56b25lKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIGlmICghem9uZS5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZCh1bnN1cHBvcnRlZFpvbmUoem9uZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbmV3VFMgPSB0aGlzLnRzO1xuICAgICAgaWYgKGtlZXBMb2NhbFRpbWUgfHwga2VlcENhbGVuZGFyVGltZSkge1xuICAgICAgICBjb25zdCBvZmZzZXRHdWVzcyA9IHpvbmUub2Zmc2V0KHRoaXMudHMpO1xuICAgICAgICBjb25zdCBhc09iaiA9IHRoaXMudG9PYmplY3QoKTtcbiAgICAgICAgW25ld1RTXSA9IG9ialRvVFMoYXNPYmosIG9mZnNldEd1ZXNzLCB6b25lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHRzOiBuZXdUUywgem9uZSB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG9yIG91dHB1dENhbGVuZGFyLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIC0gdGhlIHByb3BlcnRpZXMgdG8gc2V0XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5yZWNvbmZpZ3VyZSh7IGxvY2FsZTogJ2VuLUdCJyB9KVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHJlY29uZmlndXJlKHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyIH0gPSB7fSkge1xuICAgIGNvbnN0IGxvYyA9IHRoaXMubG9jLmNsb25lKHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyIH0pO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IGxvYyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBsb2NhbGUuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEYXRlVGltZS5cbiAgICogSnVzdCBhIGNvbnZlbmllbnQgYWxpYXMgZm9yIHJlY29uZmlndXJlKHsgbG9jYWxlIH0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5zZXRMb2NhbGUoJ2VuLUdCJylcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzZXRMb2NhbGUobG9jYWxlKSB7XG4gICAgcmV0dXJuIHRoaXMucmVjb25maWd1cmUoeyBsb2NhbGUgfSk7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgdmFsdWVzIG9mIHNwZWNpZmllZCB1bml0cy4gUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIERhdGVUaW1lLlxuICAgKiBZb3UgY2FuIG9ubHkgc2V0IHVuaXRzIHdpdGggdGhpcyBtZXRob2Q7IGZvciBcInNldHRpbmdcIiBtZXRhZGF0YSwgc2VlIHtAbGluayBEYXRlVGltZSNyZWNvbmZpZ3VyZX0gYW5kIHtAbGluayBEYXRlVGltZSNzZXRab25lfS5cbiAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlcyAtIGEgbWFwcGluZyBvZiB1bml0cyB0byBudW1iZXJzXG4gICAqIEBleGFtcGxlIGR0LnNldCh7IHllYXI6IDIwMTcgfSlcbiAgICogQGV4YW1wbGUgZHQuc2V0KHsgaG91cjogOCwgbWludXRlOiAzMCB9KVxuICAgKiBAZXhhbXBsZSBkdC5zZXQoeyB3ZWVrZGF5OiA1IH0pXG4gICAqIEBleGFtcGxlIGR0LnNldCh7IHllYXI6IDIwMDUsIG9yZGluYWw6IDIzNCB9KVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHNldCh2YWx1ZXMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG5cbiAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplT2JqZWN0KHZhbHVlcywgbm9ybWFsaXplVW5pdCksXG4gICAgICBzZXR0aW5nV2Vla1N0dWZmID1cbiAgICAgICAgIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQud2Vla1llYXIpIHx8XG4gICAgICAgICFpc1VuZGVmaW5lZChub3JtYWxpemVkLndlZWtOdW1iZXIpIHx8XG4gICAgICAgICFpc1VuZGVmaW5lZChub3JtYWxpemVkLndlZWtkYXkpLFxuICAgICAgY29udGFpbnNPcmRpbmFsID0gIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQub3JkaW5hbCksXG4gICAgICBjb250YWluc0dyZWdvclllYXIgPSAhaXNVbmRlZmluZWQobm9ybWFsaXplZC55ZWFyKSxcbiAgICAgIGNvbnRhaW5zR3JlZ29yTUQgPSAhaXNVbmRlZmluZWQobm9ybWFsaXplZC5tb250aCkgfHwgIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQuZGF5KSxcbiAgICAgIGNvbnRhaW5zR3JlZ29yID0gY29udGFpbnNHcmVnb3JZZWFyIHx8IGNvbnRhaW5zR3JlZ29yTUQsXG4gICAgICBkZWZpbml0ZVdlZWtEZWYgPSBub3JtYWxpemVkLndlZWtZZWFyIHx8IG5vcm1hbGl6ZWQud2Vla051bWJlcjtcblxuICAgIGlmICgoY29udGFpbnNHcmVnb3IgfHwgY29udGFpbnNPcmRpbmFsKSAmJiBkZWZpbml0ZVdlZWtEZWYpIHtcbiAgICAgIHRocm93IG5ldyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvcihcbiAgICAgICAgXCJDYW4ndCBtaXggd2Vla1llYXIvd2Vla051bWJlciB1bml0cyB3aXRoIHllYXIvbW9udGgvZGF5IG9yIG9yZGluYWxzXCJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRhaW5zR3JlZ29yTUQgJiYgY29udGFpbnNPcmRpbmFsKSB7XG4gICAgICB0aHJvdyBuZXcgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IoXCJDYW4ndCBtaXggb3JkaW5hbCBkYXRlcyB3aXRoIG1vbnRoL2RheVwiKTtcbiAgICB9XG5cbiAgICBsZXQgbWl4ZWQ7XG4gICAgaWYgKHNldHRpbmdXZWVrU3R1ZmYpIHtcbiAgICAgIG1peGVkID0gd2Vla1RvR3JlZ29yaWFuKHsgLi4uZ3JlZ29yaWFuVG9XZWVrKHRoaXMuYyksIC4uLm5vcm1hbGl6ZWQgfSk7XG4gICAgfSBlbHNlIGlmICghaXNVbmRlZmluZWQobm9ybWFsaXplZC5vcmRpbmFsKSkge1xuICAgICAgbWl4ZWQgPSBvcmRpbmFsVG9HcmVnb3JpYW4oeyAuLi5ncmVnb3JpYW5Ub09yZGluYWwodGhpcy5jKSwgLi4ubm9ybWFsaXplZCB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWl4ZWQgPSB7IC4uLnRoaXMudG9PYmplY3QoKSwgLi4ubm9ybWFsaXplZCB9O1xuXG4gICAgICAvLyBpZiB3ZSBkaWRuJ3Qgc2V0IHRoZSBkYXkgYnV0IHdlIGVuZGVkIHVwIG9uIGFuIG92ZXJmbG93IGRhdGUsXG4gICAgICAvLyB1c2UgdGhlIGxhc3QgZGF5IG9mIHRoZSByaWdodCBtb250aFxuICAgICAgaWYgKGlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQuZGF5KSkge1xuICAgICAgICBtaXhlZC5kYXkgPSBNYXRoLm1pbihkYXlzSW5Nb250aChtaXhlZC55ZWFyLCBtaXhlZC5tb250aCksIG1peGVkLmRheSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgW3RzLCBvXSA9IG9ialRvVFMobWl4ZWQsIHRoaXMubywgdGhpcy56b25lKTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB0cywgbyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBwZXJpb2Qgb2YgdGltZSB0byB0aGlzIERhdGVUaW1lIGFuZCByZXR1cm4gdGhlIHJlc3VsdGluZyBEYXRlVGltZVxuICAgKlxuICAgKiBBZGRpbmcgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG9yIG1pbGxpc2Vjb25kcyBpbmNyZWFzZXMgdGhlIHRpbWVzdGFtcCBieSB0aGUgcmlnaHQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcy4gQWRkaW5nIGRheXMsIG1vbnRocywgb3IgeWVhcnMgc2hpZnRzIHRoZSBjYWxlbmRhciwgYWNjb3VudGluZyBmb3IgRFNUcyBhbmQgbGVhcCB5ZWFycyBhbG9uZyB0aGUgd2F5LiBUaHVzLCBgZHQucGx1cyh7IGhvdXJzOiAyNCB9KWAgbWF5IHJlc3VsdCBpbiBhIGRpZmZlcmVudCB0aW1lIHRoYW4gYGR0LnBsdXMoeyBkYXlzOiAxIH0pYCBpZiB0aGVyZSdzIGEgRFNUIHNoaWZ0IGluIGJldHdlZW4uXG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSBUaGUgYW1vdW50IHRvIGFkZC4gRWl0aGVyIGEgTHV4b24gRHVyYXRpb24sIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgdGhlIG9iamVjdCBhcmd1bWVudCB0byBEdXJhdGlvbi5mcm9tT2JqZWN0KClcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cygxMjMpIC8vfj4gaW4gMTIzIG1pbGxpc2Vjb25kc1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgbWludXRlczogMTUgfSkgLy9+PiBpbiAxNSBtaW51dGVzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBkYXlzOiAxIH0pIC8vfj4gdGhpcyB0aW1lIHRvbW9ycm93XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBkYXlzOiAtMSB9KSAvL34+IHRoaXMgdGltZSB5ZXN0ZXJkYXlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGhvdXJzOiAzLCBtaW51dGVzOiAxMyB9KSAvL34+IGluIDMgaHIsIDEzIG1pblxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMywgbWludXRlczogMTMgfSkpIC8vfj4gaW4gMyBociwgMTMgbWluXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgcGx1cyhkdXJhdGlvbikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgYWRqdXN0VGltZSh0aGlzLCBkdXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJ0cmFjdCBhIHBlcmlvZCBvZiB0aW1lIHRvIHRoaXMgRGF0ZVRpbWUgYW5kIHJldHVybiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lXG4gICAqIFNlZSB7QGxpbmsgRGF0ZVRpbWUjcGx1c31cbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBhbW91bnQgdG8gc3VidHJhY3QuIEVpdGhlciBhIEx1eG9uIER1cmF0aW9uLCBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIHRoZSBvYmplY3QgYXJndW1lbnQgdG8gRHVyYXRpb24uZnJvbU9iamVjdCgpXG4gICBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIG1pbnVzKGR1cmF0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb24pLm5lZ2F0ZSgpO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCBhZGp1c3RUaW1lKHRoaXMsIGR1cikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhpcyBEYXRlVGltZSB0byB0aGUgYmVnaW5uaW5nIG9mIGEgdW5pdCBvZiB0aW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIFRoZSB1bml0IHRvIGdvIHRvIHRoZSBiZWdpbm5pbmcgb2YuIENhbiBiZSAneWVhcicsICdxdWFydGVyJywgJ21vbnRoJywgJ3dlZWsnLCAnZGF5JywgJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCcsIG9yICdtaWxsaXNlY29uZCcuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMpLnN0YXJ0T2YoJ21vbnRoJykudG9JU09EYXRlKCk7IC8vPT4gJzIwMTQtMDMtMDEnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMpLnN0YXJ0T2YoJ3llYXInKS50b0lTT0RhdGUoKTsgLy89PiAnMjAxNC0wMS0wMSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMykuc3RhcnRPZignd2VlaycpLnRvSVNPRGF0ZSgpOyAvLz0+ICcyMDE0LTAzLTAzJywgd2Vla3MgYWx3YXlzIHN0YXJ0IG9uIE1vbmRheXNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMywgNSwgMzApLnN0YXJ0T2YoJ2RheScpLnRvSVNPVGltZSgpOyAvLz0+ICcwMDowMC4wMDAtMDU6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMsIDUsIDMwKS5zdGFydE9mKCdob3VyJykudG9JU09UaW1lKCk7IC8vPT4gJzA1OjAwOjAwLjAwMC0wNTowMCdcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGFydE9mKHVuaXQpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgbyA9IHt9LFxuICAgICAgbm9ybWFsaXplZFVuaXQgPSBEdXJhdGlvbi5ub3JtYWxpemVVbml0KHVuaXQpO1xuICAgIHN3aXRjaCAobm9ybWFsaXplZFVuaXQpIHtcbiAgICAgIGNhc2UgXCJ5ZWFyc1wiOlxuICAgICAgICBvLm1vbnRoID0gMTtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgXCJxdWFydGVyc1wiOlxuICAgICAgY2FzZSBcIm1vbnRoc1wiOlxuICAgICAgICBvLmRheSA9IDE7XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIFwid2Vla3NcIjpcbiAgICAgIGNhc2UgXCJkYXlzXCI6XG4gICAgICAgIG8uaG91ciA9IDA7XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIFwiaG91cnNcIjpcbiAgICAgICAgby5taW51dGUgPSAwO1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSBcIm1pbnV0ZXNcIjpcbiAgICAgICAgby5zZWNvbmQgPSAwO1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSBcInNlY29uZHNcIjpcbiAgICAgICAgby5taWxsaXNlY29uZCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1pbGxpc2Vjb25kc1wiOlxuICAgICAgICBicmVhaztcbiAgICAgIC8vIG5vIGRlZmF1bHQsIGludmFsaWQgdW5pdHMgdGhyb3cgaW4gbm9ybWFsaXplVW5pdCgpXG4gICAgfVxuXG4gICAgaWYgKG5vcm1hbGl6ZWRVbml0ID09PSBcIndlZWtzXCIpIHtcbiAgICAgIG8ud2Vla2RheSA9IDE7XG4gICAgfVxuXG4gICAgaWYgKG5vcm1hbGl6ZWRVbml0ID09PSBcInF1YXJ0ZXJzXCIpIHtcbiAgICAgIGNvbnN0IHEgPSBNYXRoLmNlaWwodGhpcy5tb250aCAvIDMpO1xuICAgICAgby5tb250aCA9IChxIC0gMSkgKiAzICsgMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zZXQobyk7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGlzIERhdGVUaW1lIHRvIHRoZSBlbmQgKG1lYW5pbmcgdGhlIGxhc3QgbWlsbGlzZWNvbmQpIG9mIGEgdW5pdCBvZiB0aW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gVGhlIHVuaXQgdG8gZ28gdG8gdGhlIGVuZCBvZi4gQ2FuIGJlICd5ZWFyJywgJ3F1YXJ0ZXInLCAnbW9udGgnLCAnd2VlaycsICdkYXknLCAnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJywgb3IgJ21pbGxpc2Vjb25kJy5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMykuZW5kT2YoJ21vbnRoJykudG9JU08oKTsgLy89PiAnMjAxNC0wMy0zMVQyMzo1OTo1OS45OTktMDU6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMpLmVuZE9mKCd5ZWFyJykudG9JU08oKTsgLy89PiAnMjAxNC0xMi0zMVQyMzo1OTo1OS45OTktMDU6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMpLmVuZE9mKCd3ZWVrJykudG9JU08oKTsgLy8gPT4gJzIwMTQtMDMtMDlUMjM6NTk6NTkuOTk5LTA1OjAwJywgd2Vla3Mgc3RhcnQgb24gTW9uZGF5c1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzLCA1LCAzMCkuZW5kT2YoJ2RheScpLnRvSVNPKCk7IC8vPT4gJzIwMTQtMDMtMDNUMjM6NTk6NTkuOTk5LTA1OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzLCA1LCAzMCkuZW5kT2YoJ2hvdXInKS50b0lTTygpOyAvLz0+ICcyMDE0LTAzLTAzVDA1OjU5OjU5Ljk5OS0wNTowMCdcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBlbmRPZih1bml0KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZFxuICAgICAgPyB0aGlzLnBsdXMoeyBbdW5pdF06IDEgfSlcbiAgICAgICAgICAuc3RhcnRPZih1bml0KVxuICAgICAgICAgIC5taW51cygxKVxuICAgICAgOiB0aGlzO1xuICB9XG5cbiAgLy8gT1VUUFVUXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBmb3JtYXR0ZWQgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgZm9ybWF0IHN0cmluZy5cbiAgICogKipZb3UgbWF5IG5vdCB3YW50IHRoaXMuKiogU2VlIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9yIGEgbW9yZSBmbGV4aWJsZSBmb3JtYXR0aW5nIHRvb2wuIEZvciBhIHRhYmxlIG9mIHRva2VucyBhbmQgdGhlaXIgaW50ZXJwcmV0YXRpb25zLCBzZWUgW2hlcmVdKGh0dHBzOi8vbW9tZW50LmdpdGh1Yi5pby9sdXhvbi8jL2Zvcm1hdHRpbmc/aWQ9dGFibGUtb2YtdG9rZW5zKS5cbiAgICogRGVmYXVsdHMgdG8gZW4tVVMgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZCwgcmVnYXJkbGVzcyBvZiB0aGUgc3lzdGVtJ3MgbG9jYWxlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm10IC0gdGhlIGZvcm1hdCBzdHJpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRzIHRvIG92ZXJyaWRlIHRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgb24gdGhpcyBEYXRlVGltZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0Zvcm1hdCgneXl5eSBMTEwgZGQnKSAvLz0+ICcyMDE3IEFwciAyMidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkuc2V0TG9jYWxlKCdmcicpLnRvRm9ybWF0KCd5eXl5IExMTCBkZCcpIC8vPT4gJzIwMTcgYXZyLiAyMidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Gb3JtYXQoJ3l5eXkgTExMIGRkJywgeyBsb2NhbGU6IFwiZnJcIiB9KSAvLz0+ICcyMDE3IGF2ci4gMjInXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvRm9ybWF0KFwiSEggJ2hvdXJzIGFuZCcgbW0gJ21pbnV0ZXMnXCIpIC8vPT4gJzIwIGhvdXJzIGFuZCA1NSBtaW51dGVzJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0Zvcm1hdChmbXQsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRcbiAgICAgID8gRm9ybWF0dGVyLmNyZWF0ZSh0aGlzLmxvYy5yZWRlZmF1bHRUb0VOKG9wdHMpKS5mb3JtYXREYXRlVGltZUZyb21TdHJpbmcodGhpcywgZm10KVxuICAgICAgOiBJTlZBTElEO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsb2NhbGl6ZWQgc3RyaW5nIHJlcHJlc2VudGluZyB0aGlzIGRhdGUuIEFjY2VwdHMgdGhlIHNhbWUgb3B0aW9ucyBhcyB0aGUgSW50bC5EYXRlVGltZUZvcm1hdCBjb25zdHJ1Y3RvciBhbmQgYW55IHByZXNldHMgZGVmaW5lZCBieSBMdXhvbiwgc3VjaCBhcyBgRGF0ZVRpbWUuREFURV9GVUxMYCBvciBgRGF0ZVRpbWUuVElNRV9TSU1QTEVgLlxuICAgKiBUaGUgZXhhY3QgYmVoYXZpb3Igb2YgdGhpcyBtZXRob2QgaXMgYnJvd3Nlci1zcGVjaWZpYywgYnV0IGluIGdlbmVyYWwgaXQgd2lsbCByZXR1cm4gYW4gYXBwcm9wcmlhdGUgcmVwcmVzZW50YXRpb25cbiAgICogb2YgdGhlIERhdGVUaW1lIGluIHRoZSBhc3NpZ25lZCBsb2NhbGUuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGVUaW1lRm9ybWF0XG4gICAqIEBwYXJhbSBmb3JtYXRPcHRzIHtPYmplY3R9IC0gSW50bC5EYXRlVGltZUZvcm1hdCBjb25zdHJ1Y3RvciBvcHRpb25zIGFuZCBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRzIHRvIG92ZXJyaWRlIHRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgb24gdGhpcyBEYXRlVGltZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZygpOyAvLz0+IDQvMjAvMjAxN1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5zZXRMb2NhbGUoJ2VuLWdiJykudG9Mb2NhbGVTdHJpbmcoKTsgLy89PiAnMjAvMDQvMjAxNydcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuREFURV9GVUxMKTsgLy89PiAnQXByaWwgMjAsIDIwMTcnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLkRBVEVfRlVMTCwgeyBsb2NhbGU6ICdmcicgfSk7IC8vPT4gJzI4IGFvw7t0IDIwMjInXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLlRJTUVfU0lNUExFKTsgLy89PiAnMTE6MzIgQU0nXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLkRBVEVUSU1FX1NIT1JUKTsgLy89PiAnNC8yMC8yMDE3LCAxMTozMiBBTSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoeyB3ZWVrZGF5OiAnbG9uZycsIG1vbnRoOiAnbG9uZycsIGRheTogJzItZGlnaXQnIH0pOyAvLz0+ICdUaHVyc2RheSwgQXByaWwgMjAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKHsgd2Vla2RheTogJ3Nob3J0JywgbW9udGg6ICdzaG9ydCcsIGRheTogJzItZGlnaXQnLCBob3VyOiAnMi1kaWdpdCcsIG1pbnV0ZTogJzItZGlnaXQnIH0pOyAvLz0+ICdUaHUsIEFwciAyMCwgMTE6MjcgQU0nXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKHsgaG91cjogJzItZGlnaXQnLCBtaW51dGU6ICcyLWRpZ2l0JywgaG91ckN5Y2xlOiAnaDIzJyB9KTsgLy89PiAnMTE6MzInXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvTG9jYWxlU3RyaW5nKGZvcm1hdE9wdHMgPSBGb3JtYXRzLkRBVEVfU0hPUlQsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRcbiAgICAgID8gRm9ybWF0dGVyLmNyZWF0ZSh0aGlzLmxvYy5jbG9uZShvcHRzKSwgZm9ybWF0T3B0cykuZm9ybWF0RGF0ZVRpbWUodGhpcylcbiAgICAgIDogSU5WQUxJRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGZvcm1hdCBcInBhcnRzXCIsIG1lYW5pbmcgaW5kaXZpZHVhbCB0b2tlbnMgYWxvbmcgd2l0aCBtZXRhZGF0YS4gVGhpcyBpcyBhbGxvd3MgY2FsbGVycyB0byBwb3N0LXByb2Nlc3MgaW5kaXZpZHVhbCBzZWN0aW9ucyBvZiB0aGUgZm9ybWF0dGVkIG91dHB1dC5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZVRpbWVGb3JtYXQvZm9ybWF0VG9QYXJ0c1xuICAgKiBAcGFyYW0gb3B0cyB7T2JqZWN0fSAtIEludGwuRGF0ZVRpbWVGb3JtYXQgY29uc3RydWN0b3Igb3B0aW9ucywgc2FtZSBhcyBgdG9Mb2NhbGVTdHJpbmdgLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVBhcnRzKCk7IC8vPT4gW1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy89PiAgIHsgdHlwZTogJ2RheScsIHZhbHVlOiAnMjUnIH0sXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLz0+ICAgeyB0eXBlOiAnbGl0ZXJhbCcsIHZhbHVlOiAnLycgfSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vPT4gICB7IHR5cGU6ICdtb250aCcsIHZhbHVlOiAnMDUnIH0sXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLz0+ICAgeyB0eXBlOiAnbGl0ZXJhbCcsIHZhbHVlOiAnLycgfSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vPT4gICB7IHR5cGU6ICd5ZWFyJywgdmFsdWU6ICcxOTgyJyB9XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLz0+IF1cbiAgICovXG4gIHRvTG9jYWxlUGFydHMob3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZFxuICAgICAgPyBGb3JtYXR0ZXIuY3JlYXRlKHRoaXMubG9jLmNsb25lKG9wdHMpLCBvcHRzKS5mb3JtYXREYXRlVGltZVBhcnRzKHRoaXMpXG4gICAgICA6IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnN1cHByZXNzTWlsbGlzZWNvbmRzPWZhbHNlXSAtIGV4Y2x1ZGUgbWlsbGlzZWNvbmRzIGZyb20gdGhlIGZvcm1hdCBpZiB0aGV5J3JlIDBcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zdXBwcmVzc1NlY29uZHM9ZmFsc2VdIC0gZXhjbHVkZSBzZWNvbmRzIGZyb20gdGhlIGZvcm1hdCBpZiB0aGV5J3JlIDBcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlT2Zmc2V0PXRydWVdIC0gaW5jbHVkZSB0aGUgb2Zmc2V0LCBzdWNoIGFzICdaJyBvciAnLTA0OjAwJ1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmV4dGVuZGVkWm9uZT1mYWxzZV0gLSBhZGQgdGhlIHRpbWUgem9uZSBmb3JtYXQgZXh0ZW5zaW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5mb3JtYXQ9J2V4dGVuZGVkJ10gLSBjaG9vc2UgYmV0d2VlbiB0aGUgYmFzaWMgYW5kIGV4dGVuZGVkIGZvcm1hdFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMTk4MywgNSwgMjUpLnRvSVNPKCkgLy89PiAnMTk4Mi0wNS0yNVQwMDowMDowMC4wMDBaJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0lTTygpIC8vPT4gJzIwMTctMDQtMjJUMjA6NDc6MDUuMzM1LTA0OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0lTTyh7IGluY2x1ZGVPZmZzZXQ6IGZhbHNlIH0pIC8vPT4gJzIwMTctMDQtMjJUMjA6NDc6MDUuMzM1J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0lTTyh7IGZvcm1hdDogJ2Jhc2ljJyB9KSAvLz0+ICcyMDE3MDQyMlQyMDQ3MDUuMzM1LTA0MDAnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPKHtcbiAgICBmb3JtYXQgPSBcImV4dGVuZGVkXCIsXG4gICAgc3VwcHJlc3NTZWNvbmRzID0gZmFsc2UsXG4gICAgc3VwcHJlc3NNaWxsaXNlY29uZHMgPSBmYWxzZSxcbiAgICBpbmNsdWRlT2Zmc2V0ID0gdHJ1ZSxcbiAgICBleHRlbmRlZFpvbmUgPSBmYWxzZSxcbiAgfSA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGV4dCA9IGZvcm1hdCA9PT0gXCJleHRlbmRlZFwiO1xuXG4gICAgbGV0IGMgPSB0b0lTT0RhdGUodGhpcywgZXh0KTtcbiAgICBjICs9IFwiVFwiO1xuICAgIGMgKz0gdG9JU09UaW1lKHRoaXMsIGV4dCwgc3VwcHJlc3NTZWNvbmRzLCBzdXBwcmVzc01pbGxpc2Vjb25kcywgaW5jbHVkZU9mZnNldCwgZXh0ZW5kZWRab25lKTtcbiAgICByZXR1cm4gYztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSdzIGRhdGUgY29tcG9uZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuZm9ybWF0PSdleHRlbmRlZCddIC0gY2hvb3NlIGJldHdlZW4gdGhlIGJhc2ljIGFuZCBleHRlbmRlZCBmb3JtYXRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDE5ODIsIDUsIDI1KS50b0lTT0RhdGUoKSAvLz0+ICcxOTgyLTA1LTI1J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMTk4MiwgNSwgMjUpLnRvSVNPRGF0ZSh7IGZvcm1hdDogJ2Jhc2ljJyB9KSAvLz0+ICcxOTgyMDUyNSdcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU09EYXRlKHsgZm9ybWF0ID0gXCJleHRlbmRlZFwiIH0gPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9JU09EYXRlKHRoaXMsIGZvcm1hdCA9PT0gXCJleHRlbmRlZFwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSdzIHdlZWsgZGF0ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMTk4MiwgNSwgMjUpLnRvSVNPV2Vla0RhdGUoKSAvLz0+ICcxOTgyLVcyMS0yJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTT1dlZWtEYXRlKCkge1xuICAgIHJldHVybiB0b1RlY2hGb3JtYXQodGhpcywgXCJra2trLSdXJ1dXLWNcIik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUncyB0aW1lIGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zdXBwcmVzc01pbGxpc2Vjb25kcz1mYWxzZV0gLSBleGNsdWRlIG1pbGxpc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3VwcHJlc3NTZWNvbmRzPWZhbHNlXSAtIGV4Y2x1ZGUgc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldD10cnVlXSAtIGluY2x1ZGUgdGhlIG9mZnNldCwgc3VjaCBhcyAnWicgb3IgJy0wNDowMCdcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5leHRlbmRlZFpvbmU9dHJ1ZV0gLSBhZGQgdGhlIHRpbWUgem9uZSBmb3JtYXQgZXh0ZW5zaW9uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZVByZWZpeD1mYWxzZV0gLSBpbmNsdWRlIHRoZSBgVGAgcHJlZml4XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5mb3JtYXQ9J2V4dGVuZGVkJ10gLSBjaG9vc2UgYmV0d2VlbiB0aGUgYmFzaWMgYW5kIGV4dGVuZGVkIGZvcm1hdFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKS5zZXQoeyBob3VyOiA3LCBtaW51dGU6IDM0IH0pLnRvSVNPVGltZSgpIC8vPT4gJzA3OjM0OjE5LjM2MVonXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpLnNldCh7IGhvdXI6IDcsIG1pbnV0ZTogMzQsIHNlY29uZHM6IDAsIG1pbGxpc2Vjb25kczogMCB9KS50b0lTT1RpbWUoeyBzdXBwcmVzc1NlY29uZHM6IHRydWUgfSkgLy89PiAnMDc6MzRaJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKS5zZXQoeyBob3VyOiA3LCBtaW51dGU6IDM0IH0pLnRvSVNPVGltZSh7IGZvcm1hdDogJ2Jhc2ljJyB9KSAvLz0+ICcwNzM0MTkuMzYxWidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkuc2V0KHsgaG91cjogNywgbWludXRlOiAzNCB9KS50b0lTT1RpbWUoeyBpbmNsdWRlUHJlZml4OiB0cnVlIH0pIC8vPT4gJ1QwNzozNDoxOS4zNjFaJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTT1RpbWUoe1xuICAgIHN1cHByZXNzTWlsbGlzZWNvbmRzID0gZmFsc2UsXG4gICAgc3VwcHJlc3NTZWNvbmRzID0gZmFsc2UsXG4gICAgaW5jbHVkZU9mZnNldCA9IHRydWUsXG4gICAgaW5jbHVkZVByZWZpeCA9IGZhbHNlLFxuICAgIGV4dGVuZGVkWm9uZSA9IGZhbHNlLFxuICAgIGZvcm1hdCA9IFwiZXh0ZW5kZWRcIixcbiAgfSA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGxldCBjID0gaW5jbHVkZVByZWZpeCA/IFwiVFwiIDogXCJcIjtcbiAgICByZXR1cm4gKFxuICAgICAgYyArXG4gICAgICB0b0lTT1RpbWUoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIGZvcm1hdCA9PT0gXCJleHRlbmRlZFwiLFxuICAgICAgICBzdXBwcmVzc1NlY29uZHMsXG4gICAgICAgIHN1cHByZXNzTWlsbGlzZWNvbmRzLFxuICAgICAgICBpbmNsdWRlT2Zmc2V0LFxuICAgICAgICBleHRlbmRlZFpvbmVcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gUkZDIDI4MjItY29tcGF0aWJsZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNCwgNywgMTMpLnRvUkZDMjgyMigpIC8vPT4gJ1N1biwgMTMgSnVsIDIwMTQgMDA6MDA6MDAgKzAwMDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDcsIDEzKS50b1JGQzI4MjIoKSAvLz0+ICdTdW4sIDEzIEp1bCAyMDE0IDAwOjAwOjAwIC0wNDAwJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1JGQzI4MjIoKSB7XG4gICAgcmV0dXJuIHRvVGVjaEZvcm1hdCh0aGlzLCBcIkVFRSwgZGQgTExMIHl5eXkgSEg6bW06c3MgWlpaXCIsIGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBIVFRQIGhlYWRlcnMuIFRoZSBvdXRwdXQgaXMgYWx3YXlzIGV4cHJlc3NlZCBpbiBHTVQuXG4gICAqIFNwZWNpZmljYWxseSwgdGhlIHN0cmluZyBjb25mb3JtcyB0byBSRkMgMTEyMy5cbiAgICogQHNlZSBodHRwczovL3d3dy53My5vcmcvUHJvdG9jb2xzL3JmYzI2MTYvcmZjMjYxNi1zZWMzLmh0bWwjc2VjMy4zLjFcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTQsIDcsIDEzKS50b0hUVFAoKSAvLz0+ICdTdW4sIDEzIEp1bCAyMDE0IDAwOjAwOjAwIEdNVCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTQsIDcsIDEzLCAxOSkudG9IVFRQKCkgLy89PiAnU3VuLCAxMyBKdWwgMjAxNCAxOTowMDowMCBHTVQnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSFRUUCgpIHtcbiAgICByZXR1cm4gdG9UZWNoRm9ybWF0KHRoaXMudG9VVEMoKSwgXCJFRUUsIGRkIExMTCB5eXl5IEhIOm1tOnNzICdHTVQnXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIFNRTCBEYXRlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE0LCA3LCAxMykudG9TUUxEYXRlKCkgLy89PiAnMjAxNC0wNy0xMydcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9TUUxEYXRlKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRvSVNPRGF0ZSh0aGlzLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBTUUwgVGltZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlWm9uZT1mYWxzZV0gLSBpbmNsdWRlIHRoZSB6b25lLCBzdWNoIGFzICdBbWVyaWNhL05ld19Zb3JrJy4gT3ZlcnJpZGVzIGluY2x1ZGVPZmZzZXQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldD10cnVlXSAtIGluY2x1ZGUgdGhlIG9mZnNldCwgc3VjaCBhcyAnWicgb3IgJy0wNDowMCdcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlT2Zmc2V0U3BhY2U9dHJ1ZV0gLSBpbmNsdWRlIHRoZSBzcGFjZSBiZXR3ZWVuIHRoZSB0aW1lIGFuZCB0aGUgb2Zmc2V0LCBzdWNoIGFzICcwNToxNToxNi4zNDUgLTA0OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKS50b1NRTCgpIC8vPT4gJzA1OjE1OjE2LjM0NSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9TUUwoKSAvLz0+ICcwNToxNToxNi4zNDUgLTA0OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b1NRTCh7IGluY2x1ZGVPZmZzZXQ6IGZhbHNlIH0pIC8vPT4gJzA1OjE1OjE2LjM0NSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9TUUwoeyBpbmNsdWRlWm9uZTogZmFsc2UgfSkgLy89PiAnMDU6MTU6MTYuMzQ1IEFtZXJpY2EvTmV3X1lvcmsnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU1FMVGltZSh7IGluY2x1ZGVPZmZzZXQgPSB0cnVlLCBpbmNsdWRlWm9uZSA9IGZhbHNlLCBpbmNsdWRlT2Zmc2V0U3BhY2UgPSB0cnVlIH0gPSB7fSkge1xuICAgIGxldCBmbXQgPSBcIkhIOm1tOnNzLlNTU1wiO1xuXG4gICAgaWYgKGluY2x1ZGVab25lIHx8IGluY2x1ZGVPZmZzZXQpIHtcbiAgICAgIGlmIChpbmNsdWRlT2Zmc2V0U3BhY2UpIHtcbiAgICAgICAgZm10ICs9IFwiIFwiO1xuICAgICAgfVxuICAgICAgaWYgKGluY2x1ZGVab25lKSB7XG4gICAgICAgIGZtdCArPSBcInpcIjtcbiAgICAgIH0gZWxzZSBpZiAoaW5jbHVkZU9mZnNldCkge1xuICAgICAgICBmbXQgKz0gXCJaWlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0b1RlY2hGb3JtYXQodGhpcywgZm10LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBTUUwgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZVpvbmU9ZmFsc2VdIC0gaW5jbHVkZSB0aGUgem9uZSwgc3VjaCBhcyAnQW1lcmljYS9OZXdfWW9yaycuIE92ZXJyaWRlcyBpbmNsdWRlT2Zmc2V0LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVPZmZzZXQ9dHJ1ZV0gLSBpbmNsdWRlIHRoZSBvZmZzZXQsIHN1Y2ggYXMgJ1onIG9yICctMDQ6MDAnXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldFNwYWNlPXRydWVdIC0gaW5jbHVkZSB0aGUgc3BhY2UgYmV0d2VlbiB0aGUgdGltZSBhbmQgdGhlIG9mZnNldCwgc3VjaCBhcyAnMDU6MTU6MTYuMzQ1IC0wNDowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTQsIDcsIDEzKS50b1NRTCgpIC8vPT4gJzIwMTQtMDctMTMgMDA6MDA6MDAuMDAwIFonXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDcsIDEzKS50b1NRTCgpIC8vPT4gJzIwMTQtMDctMTMgMDA6MDA6MDAuMDAwIC0wNDowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgNywgMTMpLnRvU1FMKHsgaW5jbHVkZU9mZnNldDogZmFsc2UgfSkgLy89PiAnMjAxNC0wNy0xMyAwMDowMDowMC4wMDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDcsIDEzKS50b1NRTCh7IGluY2x1ZGVab25lOiB0cnVlIH0pIC8vPT4gJzIwMTQtMDctMTMgMDA6MDA6MDAuMDAwIEFtZXJpY2EvTmV3X1lvcmsnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU1FMKG9wdHMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gYCR7dGhpcy50b1NRTERhdGUoKX0gJHt0aGlzLnRvU1FMVGltZShvcHRzKX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgZGVidWdnaW5nXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnRvSVNPKCkgOiBJTlZBTElEO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVwb2NoIG1pbGxpc2Vjb25kcyBvZiB0aGlzIERhdGVUaW1lLiBBbGlhcyBvZiB7QGxpbmsgRGF0ZVRpbWUjdG9NaWxsaXN9XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHZhbHVlT2YoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9NaWxsaXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlcG9jaCBtaWxsaXNlY29uZHMgb2YgdGhpcyBEYXRlVGltZS5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgdG9NaWxsaXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudHMgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZXBvY2ggc2Vjb25kcyBvZiB0aGlzIERhdGVUaW1lLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICB0b1NlY29uZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudHMgLyAxMDAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVwb2NoIHNlY29uZHMgKGFzIGEgd2hvbGUgbnVtYmVyKSBvZiB0aGlzIERhdGVUaW1lLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICB0b1VuaXhJbnRlZ2VyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBNYXRoLmZsb29yKHRoaXMudHMgLyAxMDAwKSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBKU09OLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9JU08oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgQlNPTiBzZXJpYWxpemFibGUgZXF1aXZhbGVudCB0byB0aGlzIERhdGVUaW1lLlxuICAgKiBAcmV0dXJuIHtEYXRlfVxuICAgKi9cbiAgdG9CU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvSlNEYXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIEphdmFTY3JpcHQgb2JqZWN0IHdpdGggdGhpcyBEYXRlVGltZSdzIHllYXIsIG1vbnRoLCBkYXksIGFuZCBzbyBvbi5cbiAgICogQHBhcmFtIG9wdHMgLSBvcHRpb25zIGZvciBnZW5lcmF0aW5nIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlQ29uZmlnPWZhbHNlXSAtIGluY2x1ZGUgY29uZmlndXJhdGlvbiBhdHRyaWJ1dGVzIGluIHRoZSBvdXRwdXRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9PYmplY3QoKSAvLz0+IHsgeWVhcjogMjAxNywgbW9udGg6IDQsIGRheTogMjIsIGhvdXI6IDIwLCBtaW51dGU6IDQ5LCBzZWNvbmQ6IDQyLCBtaWxsaXNlY29uZDogMjY4IH1cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgdG9PYmplY3Qob3B0cyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB7fTtcblxuICAgIGNvbnN0IGJhc2UgPSB7IC4uLnRoaXMuYyB9O1xuXG4gICAgaWYgKG9wdHMuaW5jbHVkZUNvbmZpZykge1xuICAgICAgYmFzZS5vdXRwdXRDYWxlbmRhciA9IHRoaXMub3V0cHV0Q2FsZW5kYXI7XG4gICAgICBiYXNlLm51bWJlcmluZ1N5c3RlbSA9IHRoaXMubG9jLm51bWJlcmluZ1N5c3RlbTtcbiAgICAgIGJhc2UubG9jYWxlID0gdGhpcy5sb2MubG9jYWxlO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgSmF2YVNjcmlwdCBEYXRlIGVxdWl2YWxlbnQgdG8gdGhpcyBEYXRlVGltZS5cbiAgICogQHJldHVybiB7RGF0ZX1cbiAgICovXG4gIHRvSlNEYXRlKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLmlzVmFsaWQgPyB0aGlzLnRzIDogTmFOKTtcbiAgfVxuXG4gIC8vIENPTVBBUkVcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdHdvIERhdGVUaW1lcyBhcyBhIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBvdGhlckRhdGVUaW1lIC0gdGhlIERhdGVUaW1lIHRvIGNvbXBhcmUgdGhpcyBvbmUgdG9cbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IFt1bml0PVsnbWlsbGlzZWNvbmRzJ11dIC0gdGhlIHVuaXQgb3IgYXJyYXkgb2YgdW5pdHMgKHN1Y2ggYXMgJ2hvdXJzJyBvciAnZGF5cycpIHRvIGluY2x1ZGUgaW4gdGhlIGR1cmF0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdGhhdCBhZmZlY3QgdGhlIGNyZWF0aW9uIG9mIHRoZSBEdXJhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGkxID0gRGF0ZVRpbWUuZnJvbUlTTygnMTk4Mi0wNS0yNVQwOTo0NScpLFxuICAgKiAgICAgaTIgPSBEYXRlVGltZS5mcm9tSVNPKCcxOTgzLTEwLTE0VDEwOjMwJyk7XG4gICAqIGkyLmRpZmYoaTEpLnRvT2JqZWN0KCkgLy89PiB7IG1pbGxpc2Vjb25kczogNDM4MDc1MDAwMDAgfVxuICAgKiBpMi5kaWZmKGkxLCAnaG91cnMnKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMTIxNjguNzUgfVxuICAgKiBpMi5kaWZmKGkxLCBbJ21vbnRocycsICdkYXlzJ10pLnRvT2JqZWN0KCkgLy89PiB7IG1vbnRoczogMTYsIGRheXM6IDE5LjAzMTI1IH1cbiAgICogaTIuZGlmZihpMSwgWydtb250aHMnLCAnZGF5cycsICdob3VycyddKS50b09iamVjdCgpIC8vPT4geyBtb250aHM6IDE2LCBkYXlzOiAxOSwgaG91cnM6IDAuNzUgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIGRpZmYob3RoZXJEYXRlVGltZSwgdW5pdCA9IFwibWlsbGlzZWNvbmRzXCIsIG9wdHMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkIHx8ICFvdGhlckRhdGVUaW1lLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5pbnZhbGlkKFwiY3JlYXRlZCBieSBkaWZmaW5nIGFuIGludmFsaWQgRGF0ZVRpbWVcIik7XG4gICAgfVxuXG4gICAgY29uc3QgZHVyT3B0cyA9IHsgbG9jYWxlOiB0aGlzLmxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtOiB0aGlzLm51bWJlcmluZ1N5c3RlbSwgLi4ub3B0cyB9O1xuXG4gICAgY29uc3QgdW5pdHMgPSBtYXliZUFycmF5KHVuaXQpLm1hcChEdXJhdGlvbi5ub3JtYWxpemVVbml0KSxcbiAgICAgIG90aGVySXNMYXRlciA9IG90aGVyRGF0ZVRpbWUudmFsdWVPZigpID4gdGhpcy52YWx1ZU9mKCksXG4gICAgICBlYXJsaWVyID0gb3RoZXJJc0xhdGVyID8gdGhpcyA6IG90aGVyRGF0ZVRpbWUsXG4gICAgICBsYXRlciA9IG90aGVySXNMYXRlciA/IG90aGVyRGF0ZVRpbWUgOiB0aGlzLFxuICAgICAgZGlmZmVkID0gZGlmZihlYXJsaWVyLCBsYXRlciwgdW5pdHMsIGR1ck9wdHMpO1xuXG4gICAgcmV0dXJuIG90aGVySXNMYXRlciA/IGRpZmZlZC5uZWdhdGUoKSA6IGRpZmZlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGlzIERhdGVUaW1lIGFuZCByaWdodCBub3cuXG4gICAqIFNlZSB7QGxpbmsgRGF0ZVRpbWUjZGlmZn1cbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IFt1bml0PVsnbWlsbGlzZWNvbmRzJ11dIC0gdGhlIHVuaXQgb3IgdW5pdHMgdW5pdHMgKHN1Y2ggYXMgJ2hvdXJzJyBvciAnZGF5cycpIHRvIGluY2x1ZGUgaW4gdGhlIGR1cmF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0aGF0IGFmZmVjdCB0aGUgY3JlYXRpb24gb2YgdGhlIER1cmF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIGRpZmZOb3codW5pdCA9IFwibWlsbGlzZWNvbmRzXCIsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmRpZmYoRGF0ZVRpbWUubm93KCksIHVuaXQsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBJbnRlcnZhbCBzcGFubmluZyBiZXR3ZWVuIHRoaXMgRGF0ZVRpbWUgYW5kIGFub3RoZXIgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtEYXRlVGltZX0gb3RoZXJEYXRlVGltZSAtIHRoZSBvdGhlciBlbmQgcG9pbnQgb2YgdGhlIEludGVydmFsXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgdW50aWwob3RoZXJEYXRlVGltZSkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHRoaXMsIG90aGVyRGF0ZVRpbWUpIDogdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIERhdGVUaW1lIGlzIGluIHRoZSBzYW1lIHVuaXQgb2YgdGltZSBhcyBhbm90aGVyIERhdGVUaW1lLlxuICAgKiBIaWdoZXItb3JkZXIgdW5pdHMgbXVzdCBhbHNvIGJlIGlkZW50aWNhbCBmb3IgdGhpcyBmdW5jdGlvbiB0byByZXR1cm4gYHRydWVgLlxuICAgKiBOb3RlIHRoYXQgdGltZSB6b25lcyBhcmUgKippZ25vcmVkKiogaW4gdGhpcyBjb21wYXJpc29uLCB3aGljaCBjb21wYXJlcyB0aGUgKipsb2NhbCoqIGNhbGVuZGFyIHRpbWUuIFVzZSB7QGxpbmsgRGF0ZVRpbWUjc2V0Wm9uZX0gdG8gY29udmVydCBvbmUgb2YgdGhlIGRhdGVzIGlmIG5lZWRlZC5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gb3RoZXJEYXRlVGltZSAtIHRoZSBvdGhlciBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIHRoZSB1bml0IG9mIHRpbWUgdG8gY2hlY2sgc2FtZW5lc3Mgb25cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkuaGFzU2FtZShvdGhlckRULCAnZGF5Jyk7IC8vfj4gdHJ1ZSBpZiBvdGhlckRUIGlzIGluIHRoZSBzYW1lIGN1cnJlbnQgY2FsZW5kYXIgZGF5XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNTYW1lKG90aGVyRGF0ZVRpbWUsIHVuaXQpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgY29uc3QgaW5wdXRNcyA9IG90aGVyRGF0ZVRpbWUudmFsdWVPZigpO1xuICAgIGNvbnN0IGFkanVzdGVkVG9ab25lID0gdGhpcy5zZXRab25lKG90aGVyRGF0ZVRpbWUuem9uZSwgeyBrZWVwTG9jYWxUaW1lOiB0cnVlIH0pO1xuICAgIHJldHVybiBhZGp1c3RlZFRvWm9uZS5zdGFydE9mKHVuaXQpIDw9IGlucHV0TXMgJiYgaW5wdXRNcyA8PSBhZGp1c3RlZFRvWm9uZS5lbmRPZih1bml0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFcXVhbGl0eSBjaGVja1xuICAgKiBUd28gRGF0ZVRpbWVzIGFyZSBlcXVhbCBpZiBhbmQgb25seSBpZiB0aGV5IHJlcHJlc2VudCB0aGUgc2FtZSBtaWxsaXNlY29uZCwgaGF2ZSB0aGUgc2FtZSB6b25lIGFuZCBsb2NhdGlvbiwgYW5kIGFyZSBib3RoIHZhbGlkLlxuICAgKiBUbyBjb21wYXJlIGp1c3QgdGhlIG1pbGxpc2Vjb25kIHZhbHVlcywgdXNlIGArZHQxID09PSArZHQyYC5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gb3RoZXIgLSB0aGUgb3RoZXIgRGF0ZVRpbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmlzVmFsaWQgJiZcbiAgICAgIG90aGVyLmlzVmFsaWQgJiZcbiAgICAgIHRoaXMudmFsdWVPZigpID09PSBvdGhlci52YWx1ZU9mKCkgJiZcbiAgICAgIHRoaXMuem9uZS5lcXVhbHMob3RoZXIuem9uZSkgJiZcbiAgICAgIHRoaXMubG9jLmVxdWFscyhvdGhlci5sb2MpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdGhpcyB0aW1lIHJlbGF0aXZlIHRvIG5vdywgc3VjaCBhcyBcImluIHR3byBkYXlzXCIuIENhbiBvbmx5IGludGVybmF0aW9uYWxpemUgaWYgeW91clxuICAgKiBwbGF0Zm9ybSBzdXBwb3J0cyBJbnRsLlJlbGF0aXZlVGltZUZvcm1hdC4gUm91bmRzIGRvd24gYnkgZGVmYXVsdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIHRoYXQgYWZmZWN0IHRoZSBvdXRwdXRcbiAgICogQHBhcmFtIHtEYXRlVGltZX0gW29wdGlvbnMuYmFzZT1EYXRlVGltZS5ub3coKV0gLSB0aGUgRGF0ZVRpbWUgdG8gdXNlIGFzIHRoZSBiYXNpcyB0byB3aGljaCB0aGlzIHRpbWUgaXMgY29tcGFyZWQuIERlZmF1bHRzIHRvIG5vdy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnN0eWxlPVwibG9uZ1wiXSAtIHRoZSBzdHlsZSBvZiB1bml0cywgbXVzdCBiZSBcImxvbmdcIiwgXCJzaG9ydFwiLCBvciBcIm5hcnJvd1wiXG4gICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBvcHRpb25zLnVuaXQgLSB1c2UgYSBzcGVjaWZpYyB1bml0IG9yIGFycmF5IG9mIHVuaXRzOyBpZiBvbWl0dGVkLCBvciBhbiBhcnJheSwgdGhlIG1ldGhvZCB3aWxsIHBpY2sgdGhlIGJlc3QgdW5pdC4gVXNlIGFuIGFycmF5IG9yIG9uZSBvZiBcInllYXJzXCIsIFwicXVhcnRlcnNcIiwgXCJtb250aHNcIiwgXCJ3ZWVrc1wiLCBcImRheXNcIiwgXCJob3Vyc1wiLCBcIm1pbnV0ZXNcIiwgb3IgXCJzZWNvbmRzXCJcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yb3VuZD10cnVlXSAtIHdoZXRoZXIgdG8gcm91bmQgdGhlIG51bWJlcnMgaW4gdGhlIG91dHB1dC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnBhZGRpbmc9MF0gLSBwYWRkaW5nIGluIG1pbGxpc2Vjb25kcy4gVGhpcyBhbGxvd3MgeW91IHRvIHJvdW5kIHVwIHRoZSByZXN1bHQgaWYgaXQgZml0cyBpbnNpZGUgdGhlIHRocmVzaG9sZC4gRG9uJ3QgdXNlIGluIGNvbWJpbmF0aW9uIHdpdGgge3JvdW5kOiBmYWxzZX0gYmVjYXVzZSB0aGUgZGVjaW1hbCBvdXRwdXQgd2lsbCBpbmNsdWRlIHRoZSBwYWRkaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5sb2NhbGUgLSBvdmVycmlkZSB0aGUgbG9jYWxlIG9mIHRoaXMgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubnVtYmVyaW5nU3lzdGVtIC0gb3ZlcnJpZGUgdGhlIG51bWJlcmluZ1N5c3RlbSBvZiB0aGlzIERhdGVUaW1lLiBUaGUgSW50bCBzeXN0ZW0gbWF5IGNob29zZSBub3QgdG8gaG9ub3IgdGhpc1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgZGF5czogMSB9KS50b1JlbGF0aXZlKCkgLy89PiBcImluIDEgZGF5XCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkuc2V0TG9jYWxlKFwiZXNcIikudG9SZWxhdGl2ZSh7IGRheXM6IDEgfSkgLy89PiBcImRlbnRybyBkZSAxIGTDrWFcIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgZGF5czogMSB9KS50b1JlbGF0aXZlKHsgbG9jYWxlOiBcImZyXCIgfSkgLy89PiBcImRhbnMgMjMgaGV1cmVzXCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkubWludXMoeyBkYXlzOiAyIH0pLnRvUmVsYXRpdmUoKSAvLz0+IFwiMiBkYXlzIGFnb1wiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLm1pbnVzKHsgZGF5czogMiB9KS50b1JlbGF0aXZlKHsgdW5pdDogXCJob3Vyc1wiIH0pIC8vPT4gXCI0OCBob3VycyBhZ29cIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5taW51cyh7IGhvdXJzOiAzNiB9KS50b1JlbGF0aXZlKHsgcm91bmQ6IGZhbHNlIH0pIC8vPT4gXCIxLjUgZGF5cyBhZ29cIlxuICAgKi9cbiAgdG9SZWxhdGl2ZShvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgYmFzZSA9IG9wdGlvbnMuYmFzZSB8fCBEYXRlVGltZS5mcm9tT2JqZWN0KHt9LCB7IHpvbmU6IHRoaXMuem9uZSB9KSxcbiAgICAgIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmcgPyAodGhpcyA8IGJhc2UgPyAtb3B0aW9ucy5wYWRkaW5nIDogb3B0aW9ucy5wYWRkaW5nKSA6IDA7XG4gICAgbGV0IHVuaXRzID0gW1wieWVhcnNcIiwgXCJtb250aHNcIiwgXCJkYXlzXCIsIFwiaG91cnNcIiwgXCJtaW51dGVzXCIsIFwic2Vjb25kc1wiXTtcbiAgICBsZXQgdW5pdCA9IG9wdGlvbnMudW5pdDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLnVuaXQpKSB7XG4gICAgICB1bml0cyA9IG9wdGlvbnMudW5pdDtcbiAgICAgIHVuaXQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBkaWZmUmVsYXRpdmUoYmFzZSwgdGhpcy5wbHVzKHBhZGRpbmcpLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgbnVtZXJpYzogXCJhbHdheXNcIixcbiAgICAgIHVuaXRzLFxuICAgICAgdW5pdCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZGF0ZSByZWxhdGl2ZSB0byB0b2RheSwgc3VjaCBhcyBcInllc3RlcmRheVwiIG9yIFwibmV4dCBtb250aFwiLlxuICAgKiBPbmx5IGludGVybmF0aW9uYWxpemVzIG9uIHBsYXRmb3JtcyB0aGF0IHN1cHBvcnRzIEludGwuUmVsYXRpdmVUaW1lRm9ybWF0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgdGhhdCBhZmZlY3QgdGhlIG91dHB1dFxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBbb3B0aW9ucy5iYXNlPURhdGVUaW1lLm5vdygpXSAtIHRoZSBEYXRlVGltZSB0byB1c2UgYXMgdGhlIGJhc2lzIHRvIHdoaWNoIHRoaXMgdGltZSBpcyBjb21wYXJlZC4gRGVmYXVsdHMgdG8gbm93LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5sb2NhbGUgLSBvdmVycmlkZSB0aGUgbG9jYWxlIG9mIHRoaXMgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudW5pdCAtIHVzZSBhIHNwZWNpZmljIHVuaXQ7IGlmIG9taXR0ZWQsIHRoZSBtZXRob2Qgd2lsbCBwaWNrIHRoZSB1bml0LiBVc2Ugb25lIG9mIFwieWVhcnNcIiwgXCJxdWFydGVyc1wiLCBcIm1vbnRoc1wiLCBcIndlZWtzXCIsIG9yIFwiZGF5c1wiXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm51bWJlcmluZ1N5c3RlbSAtIG92ZXJyaWRlIHRoZSBudW1iZXJpbmdTeXN0ZW0gb2YgdGhpcyBEYXRlVGltZS4gVGhlIEludGwgc3lzdGVtIG1heSBjaG9vc2Ugbm90IHRvIGhvbm9yIHRoaXNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGRheXM6IDEgfSkudG9SZWxhdGl2ZUNhbGVuZGFyKCkgLy89PiBcInRvbW9ycm93XCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkuc2V0TG9jYWxlKFwiZXNcIikucGx1cyh7IGRheXM6IDEgfSkudG9SZWxhdGl2ZSgpIC8vPT4gXCJcIm1hw7FhbmFcIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgZGF5czogMSB9KS50b1JlbGF0aXZlQ2FsZW5kYXIoeyBsb2NhbGU6IFwiZnJcIiB9KSAvLz0+IFwiZGVtYWluXCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkubWludXMoeyBkYXlzOiAyIH0pLnRvUmVsYXRpdmVDYWxlbmRhcigpIC8vPT4gXCIyIGRheXMgYWdvXCJcbiAgICovXG4gIHRvUmVsYXRpdmVDYWxlbmRhcihvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIG51bGw7XG5cbiAgICByZXR1cm4gZGlmZlJlbGF0aXZlKG9wdGlvbnMuYmFzZSB8fCBEYXRlVGltZS5mcm9tT2JqZWN0KHt9LCB7IHpvbmU6IHRoaXMuem9uZSB9KSwgdGhpcywge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIG51bWVyaWM6IFwiYXV0b1wiLFxuICAgICAgdW5pdHM6IFtcInllYXJzXCIsIFwibW9udGhzXCIsIFwiZGF5c1wiXSxcbiAgICAgIGNhbGVuZGFyeTogdHJ1ZSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG1pbiBvZiBzZXZlcmFsIGRhdGUgdGltZXNcbiAgICogQHBhcmFtIHsuLi5EYXRlVGltZX0gZGF0ZVRpbWVzIC0gdGhlIERhdGVUaW1lcyBmcm9tIHdoaWNoIHRvIGNob29zZSB0aGUgbWluaW11bVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX0gdGhlIG1pbiBEYXRlVGltZSwgb3IgdW5kZWZpbmVkIGlmIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50XG4gICAqL1xuICBzdGF0aWMgbWluKC4uLmRhdGVUaW1lcykge1xuICAgIGlmICghZGF0ZVRpbWVzLmV2ZXJ5KERhdGVUaW1lLmlzRGF0ZVRpbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJtaW4gcmVxdWlyZXMgYWxsIGFyZ3VtZW50cyBiZSBEYXRlVGltZXNcIik7XG4gICAgfVxuICAgIHJldHVybiBiZXN0QnkoZGF0ZVRpbWVzLCAoaSkgPT4gaS52YWx1ZU9mKCksIE1hdGgubWluKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG1heCBvZiBzZXZlcmFsIGRhdGUgdGltZXNcbiAgICogQHBhcmFtIHsuLi5EYXRlVGltZX0gZGF0ZVRpbWVzIC0gdGhlIERhdGVUaW1lcyBmcm9tIHdoaWNoIHRvIGNob29zZSB0aGUgbWF4aW11bVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX0gdGhlIG1heCBEYXRlVGltZSwgb3IgdW5kZWZpbmVkIGlmIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50XG4gICAqL1xuICBzdGF0aWMgbWF4KC4uLmRhdGVUaW1lcykge1xuICAgIGlmICghZGF0ZVRpbWVzLmV2ZXJ5KERhdGVUaW1lLmlzRGF0ZVRpbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJtYXggcmVxdWlyZXMgYWxsIGFyZ3VtZW50cyBiZSBEYXRlVGltZXNcIik7XG4gICAgfVxuICAgIHJldHVybiBiZXN0QnkoZGF0ZVRpbWVzLCAoaSkgPT4gaS52YWx1ZU9mKCksIE1hdGgubWF4KTtcbiAgfVxuXG4gIC8vIE1JU0NcblxuICAvKipcbiAgICogRXhwbGFpbiBob3cgYSBzdHJpbmcgd291bGQgYmUgcGFyc2VkIGJ5IGZyb21Gb3JtYXQoKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZtdCAtIHRoZSBmb3JtYXQgdGhlIHN0cmluZyBpcyBleHBlY3RlZCB0byBiZSBpbiAoc2VlIGRlc2NyaXB0aW9uKVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgdGFrZW4gYnkgZnJvbUZvcm1hdCgpXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBmcm9tRm9ybWF0RXhwbGFpbih0ZXh0LCBmbXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgbG9jYWxlID0gbnVsbCwgbnVtYmVyaW5nU3lzdGVtID0gbnVsbCB9ID0gb3B0aW9ucyxcbiAgICAgIGxvY2FsZVRvVXNlID0gTG9jYWxlLmZyb21PcHRzKHtcbiAgICAgICAgbG9jYWxlLFxuICAgICAgICBudW1iZXJpbmdTeXN0ZW0sXG4gICAgICAgIGRlZmF1bHRUb0VOOiB0cnVlLFxuICAgICAgfSk7XG4gICAgcmV0dXJuIGV4cGxhaW5Gcm9tVG9rZW5zKGxvY2FsZVRvVXNlLCB0ZXh0LCBmbXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBmcm9tRm9ybWF0RXhwbGFpbiBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgZnJvbVN0cmluZ0V4cGxhaW4odGV4dCwgZm10LCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gRGF0ZVRpbWUuZnJvbUZvcm1hdEV4cGxhaW4odGV4dCwgZm10LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8vIEZPUk1BVCBQUkVTRVRTXG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgMTAvMTQvMTk4M1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFX1NIT1JUKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVfU0hPUlQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0IDE0LCAxOTgzJ1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFX01FRCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFX01FRDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdGcmksIE9jdCAxNCwgMTk4MydcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURV9NRURfV0lUSF9XRUVLREFZKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVfTUVEX1dJVEhfV0VFS0RBWTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdPY3RvYmVyIDE0LCAxOTgzJ1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFX0ZVTEwoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURV9GVUxMO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ1R1ZXNkYXksIE9jdG9iZXIgMTQsIDE5ODMnXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVfSFVHRSgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFX0hVR0U7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzAgQU0nLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgVElNRV9TSU1QTEUoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuVElNRV9TSU1QTEU7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzA6MjMgQU0nLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgVElNRV9XSVRIX1NFQ09ORFMoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuVElNRV9XSVRIX1NFQ09ORFM7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzA6MjMgQU0gRURUJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfV0lUSF9TSE9SVF9PRkZTRVQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuVElNRV9XSVRIX1NIT1JUX09GRlNFVDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMDoyMyBBTSBFYXN0ZXJuIERheWxpZ2h0IFRpbWUnLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgVElNRV9XSVRIX0xPTkdfT0ZGU0VUKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfV0lUSF9MT05HX09GRlNFVDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMCcsIGFsd2F5cyAyNC1ob3VyLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FXzI0X1NJTVBMRSgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FXzI0X1NJTVBMRTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMDoyMycsIGFsd2F5cyAyNC1ob3VyLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FXzI0X1dJVEhfU0VDT05EUygpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FXzI0X1dJVEhfU0VDT05EUztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMDoyMyBFRFQnLCBhbHdheXMgMjQtaG91ci5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgVElNRV8yNF9XSVRIX1NIT1JUX09GRlNFVCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FXzI0X1dJVEhfU0hPUlRfT0ZGU0VUO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzIEVhc3Rlcm4gRGF5bGlnaHQgVGltZScsIGFsd2F5cyAyNC1ob3VyLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FXzI0X1dJVEhfTE9OR19PRkZTRVQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuVElNRV8yNF9XSVRIX0xPTkdfT0ZGU0VUO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzEwLzE0LzE5ODMsIDk6MzAgQU0nLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfU0hPUlQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfU0hPUlQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMTAvMTQvMTk4MywgOTozMDozMyBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9TSE9SVF9XSVRIX1NFQ09ORFMoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfU0hPUlRfV0lUSF9TRUNPTkRTO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ09jdCAxNCwgMTk4MywgOTozMCBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9NRUQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfTUVEO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ09jdCAxNCwgMTk4MywgOTozMDozMyBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9NRURfV0lUSF9TRUNPTkRTKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX01FRF9XSVRIX1NFQ09ORFM7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnRnJpLCAxNCBPY3QgMTk4MywgOTozMCBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9NRURfV0lUSF9XRUVLREFZKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX01FRF9XSVRIX1dFRUtEQVk7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0b2JlciAxNCwgMTk4MywgOTozMCBBTSBFRFQnLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfRlVMTCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9GVUxMO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ09jdG9iZXIgMTQsIDE5ODMsIDk6MzA6MzMgQU0gRURUJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX0ZVTExfV0lUSF9TRUNPTkRTKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX0ZVTExfV0lUSF9TRUNPTkRTO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ0ZyaWRheSwgT2N0b2JlciAxNCwgMTk4MywgOTozMCBBTSBFYXN0ZXJuIERheWxpZ2h0IFRpbWUnLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfSFVHRSgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9IVUdFO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ0ZyaWRheSwgT2N0b2JlciAxNCwgMTk4MywgOTozMDozMyBBTSBFYXN0ZXJuIERheWxpZ2h0IFRpbWUnLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfSFVHRV9XSVRIX1NFQ09ORFMoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfSFVHRV9XSVRIX1NFQ09ORFM7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJpZW5kbHlEYXRlVGltZShkYXRlVGltZWlzaCkge1xuICBpZiAoRGF0ZVRpbWUuaXNEYXRlVGltZShkYXRlVGltZWlzaCkpIHtcbiAgICByZXR1cm4gZGF0ZVRpbWVpc2g7XG4gIH0gZWxzZSBpZiAoZGF0ZVRpbWVpc2ggJiYgZGF0ZVRpbWVpc2gudmFsdWVPZiAmJiBpc051bWJlcihkYXRlVGltZWlzaC52YWx1ZU9mKCkpKSB7XG4gICAgcmV0dXJuIERhdGVUaW1lLmZyb21KU0RhdGUoZGF0ZVRpbWVpc2gpO1xuICB9IGVsc2UgaWYgKGRhdGVUaW1laXNoICYmIHR5cGVvZiBkYXRlVGltZWlzaCA9PT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBEYXRlVGltZS5mcm9tT2JqZWN0KGRhdGVUaW1laXNoKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXG4gICAgICBgVW5rbm93biBkYXRldGltZSBhcmd1bWVudDogJHtkYXRlVGltZWlzaH0sIG9mIHR5cGUgJHt0eXBlb2YgZGF0ZVRpbWVpc2h9YFxuICAgICk7XG4gIH1cbn1cbiIsImltcG9ydCBEYXRlVGltZSBmcm9tIFwiLi9kYXRldGltZS5qc1wiO1xuaW1wb3J0IER1cmF0aW9uIGZyb20gXCIuL2R1cmF0aW9uLmpzXCI7XG5pbXBvcnQgSW50ZXJ2YWwgZnJvbSBcIi4vaW50ZXJ2YWwuanNcIjtcbmltcG9ydCBJbmZvIGZyb20gXCIuL2luZm8uanNcIjtcbmltcG9ydCBab25lIGZyb20gXCIuL3pvbmUuanNcIjtcbmltcG9ydCBGaXhlZE9mZnNldFpvbmUgZnJvbSBcIi4vem9uZXMvZml4ZWRPZmZzZXRab25lLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4vem9uZXMvSUFOQVpvbmUuanNcIjtcbmltcG9ydCBJbnZhbGlkWm9uZSBmcm9tIFwiLi96b25lcy9pbnZhbGlkWm9uZS5qc1wiO1xuaW1wb3J0IFN5c3RlbVpvbmUgZnJvbSBcIi4vem9uZXMvc3lzdGVtWm9uZS5qc1wiO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gXCIuL3NldHRpbmdzLmpzXCI7XG5cbmNvbnN0IFZFUlNJT04gPSBcIjMuMi4xXCI7XG5cbmV4cG9ydCB7XG4gIFZFUlNJT04sXG4gIERhdGVUaW1lLFxuICBEdXJhdGlvbixcbiAgSW50ZXJ2YWwsXG4gIEluZm8sXG4gIFpvbmUsXG4gIEZpeGVkT2Zmc2V0Wm9uZSxcbiAgSUFOQVpvbmUsXG4gIEludmFs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aUJBQWlCO0VBQ3ZCQyxJQUFJLEVBQUUsaUJBQWlCO0VBQ3ZCQyxPQUFPLEVBQUUsaUJBQWlCO0VBQzFCQyxJQUFJLEVBQUUsaUJBQWlCO0VBQ3ZCQyxJQUFJLEVBQUUsaUJBQWlCO0VBQ3ZCQyxJQUFJLEVBQUUsaUJBQWlCO0VBQ3ZCQyxJQUFJLEVBQUU7QUFDUixDQUFDO0FBRUQsTUFBTUMscUJBQXFCLEdBQUc7RUFDNUJyQixJQUFJLEVBQUUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDO0VBQ2xCQyxPQUFPLEVBQUUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDO0VBQ3JCQyxJQUFJLEVBQUUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDO0VBQ2xCQyxJQUFJLEVBQUUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDO0VBQ2xCQyxJQUFJLEVBQUUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDO0VBQ2xCQyxRQUFRLEVBQUUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDO0VBQ3hCQyxJQUFJLEVBQUUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDO0VBQ2xCRSxJQUFJLEVBQUUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDO0VBQ2xCQyxJQUFJLEVBQUUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDO0VBQ2xCQyxJQUFJLEVBQUUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDO0VBQ2xCQyxJQUFJLEVBQUUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDO0VBQ2xCQyxJQUFJLEVBQUUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDO0VBQ2xCQyxJQUFJLEVBQUUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDO0VBQ2xCQyxJQUFJLEVBQUUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDO0VBQ2xCQyxJQUFJLEVBQUUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDO0VBQ2xCQyxPQUFPLEVBQUUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDO0VBQ3JCQyxJQUFJLEVBQUUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDO0VBQ2xCQyxJQUFJLEVBQUUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDO0VBQ2xCQyxJQUFJLEVBQUUsQ0FBQyxJQUFJLEVBQUUsSUFBSTtBQUNuQixDQUFDO0FBRUQsTUFBTUcsWUFBWSxHQUFHdkIsZ0JBQWdCLENBQUNRLE9BQU8sQ0FBQzVuQixPQUFPLENBQUMsVUFBVSxFQUFFLEVBQUUsQ0FBQyxDQUFDaWpCLEtBQUssQ0FBQyxFQUFFLENBQUM7QUFFeEUsU0FBUzJGLFdBQVdBLENBQUNsSSxHQUFHLEVBQUU7RUFDL0IsSUFBSTNmLEtBQUssR0FBR0csUUFBUSxDQUFDd2YsR0FBRyxFQUFFLEVBQUUsQ0FBQztFQUM3QixJQUFJOWUsS0FBSyxDQUFDYixLQUFLLENBQUMsRUFBRTtJQUNoQkEsS0FBSyxHQUFHLEVBQUU7SUFDVixLQUFLLElBQUlGLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBRzZmLEdBQUcsQ0FBQzVmLE1BQU0sRUFBRUQsQ0FBQyxFQUFFLEVBQUU7TUFDbkMsTUFBTWdvQixJQUFJLEdBQUduSSxHQUFHLENBQUNvSSxVQUFVLENBQUNqb0IsQ0FBQyxDQUFDO01BRTlCLElBQUk2ZixHQUFHLENBQUM3ZixDQUFDLENBQUMsQ0FBQ2tvQixNQUFNLENBQUMzQixnQkFBZ0IsQ0FBQ1EsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUU7UUFDbEQ3bUIsS0FBSyxJQUFJNG5CLFlBQVksQ0FBQzdrQixPQUFPLENBQUM0YyxHQUFHLENBQUM3ZixDQUFDLENBQUMsQ0FBQztNQUN2QyxDQUFDLE1BQU07UUFDTCxLQUFLLE1BQU02QixHQUFHLElBQUlnbUIscUJBQXFCLEVBQUU7VUFDdkMsTUFBTSxDQUFDTSxHQUFHLEVBQUVDLEdBQUcsQ0FBQyxHQUFHUCxxQkFBcUIsQ0FBQ2htQixHQUFHLENBQUM7VUFDN0MsSUFBSW1tQixJQUFJLElBQUlHLEdBQUcsSUFBSUgsSUFBSSxJQUFJSSxHQUFHLEVBQUU7WUFDOUJsb0IsS0FBSyxJQUFJOG5CLElBQUksR0FBR0csR0FBRztVQUNyQjtRQUNGO01BQ0Y7SUFDRjtJQUNBLE9BQU85bkIsUUFBUSxDQUFDSCxLQUFLLEVBQUUsRUFBRSxDQUFDO0VBQzVCLENBQUMsTUFBTTtJQUNMLE9BQU9BLEtBQUs7RUFDZDtBQUNGO0FBRU8sU0FBU21vQixVQUFVQSxDQUFDO0VBQUU5a0I7QUFBZ0IsQ0FBQyxFQUFFK2tCLE1BQU0sR0FBRyxFQUFFLEVBQUU7RUFDM0QsT0FBTyxJQUFJaFMsTUFBTSxDQUFFLEdBQUVpUSxnQkFBZ0IsQ0FBQ2hqQixlQUFlLElBQUksTUFBTSxDQUFJLEdBQUEra0IsTUFBTyxFQUFDLENBQUM7QUFDOUU7QUNsRUEsTUFBTUMsV0FBVyxHQUFHLG1EQUFtRDtBQUV2RSxTQUFTQyxPQUFPQSxDQUFDelIsS0FBSyxFQUFFMFIsSUFBSSxHQUFJem9CLENBQUMsSUFBS0EsQ0FBQyxFQUFFO0VBQ3ZDLE9BQU87SUFBRStXLEtBQUs7SUFBRTJSLEtBQUssRUFBRUEsQ0FBQyxDQUFDM3RCLENBQUMsQ0FBQyxLQUFLMHRCLElBQUksQ0FBQ1YsV0FBVyxDQUFDaHRCLENBQUMsQ0FBQztHQUFHO0FBQ3hEO0FBRUEsTUFBTTR0QixJQUFJLEdBQUdDLE1BQU0sQ0FBQ0MsWUFBWSxDQUFDLEdBQUcsQ0FBQztBQUNyQyxNQUFNQyxXQUFXLEdBQVEsS0FBQUgsSUFBTztBQUNoQyxNQUFNSSxpQkFBaUIsR0FBRyxJQUFJelMsTUFBTSxDQUFDd1MsV0FBVyxFQUFFLEdBQUcsQ0FBQztBQUV0RCxTQUFTRSxZQUFZQSxDQUFDanVCLENBQUMsRUFBRTtFQUN2QjtFQUNBO0VBQ0EsT0FBT0EsQ0FBQyxDQUFDb0UsT0FBTyxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQ0EsT0FBTyxDQUFDNHBCLGlCQUFpQixFQUFFRCxXQUFXLENBQUM7QUFDekU7QUFFQSxTQUFTRyxvQkFBb0JBLENBQUNsdUIsQ0FBQyxFQUFFO0VBQy9CLE9BQU9BLENBQUMsQ0FDTG9FLE9BQU8sQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDO0VBQUEsQ0FDbEJBLE9BQU8sQ0FBQzRwQixpQkFBaUIsRUFBRSxHQUFHLENBQUM7RUFBQSxDQUMvQnpmLFdBQVcsRUFBRTtBQUNsQjtBQUVBLFNBQVM0ZixLQUFLQSxDQUFDQyxPQUFPLEVBQUVDLFVBQVUsRUFBRTtFQUNsQyxJQUFJRCxPQUFPLEtBQUssSUFBSSxFQUFFO0lBQ3BCLE9BQU8sSUFBSTtFQUNiLENBQUMsTUFBTTtJQUNMLE9BQU87TUFDTHBTLEtBQUssRUFBRVQsTUFBTSxDQUFDNlMsT0FBTyxDQUFDdGdCLEdBQUcsQ0FBQ21nQixZQUFZLENBQUMsQ0FBQ0ssSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO01BQ2xEWCxLQUFLLEVBQUVBLENBQUMsQ0FBQzN0QixDQUFDLENBQUMsS0FDVG91QixPQUFPLENBQUNHLFNBQVMsQ0FBRXRwQixDQUFDLElBQUtpcEIsb0JBQW9CLENBQUNsdUIsQ0FBQyxDQUFDLEtBQUtrdUIsb0JBQW9CLENBQUNqcEIsQ0FBQyxDQUFDLENBQUMsR0FBR29wQjtLQUNuRjtFQUNIO0FBQ0Y7QUFFQSxTQUFTMXJCLE1BQU1BLENBQUNxWixLQUFLLEVBQUV3UyxNQUFNLEVBQUU7RUFDN0IsT0FBTztJQUFFeFMsS0FBSztJQUFFMlIsS0FBSyxFQUFFQSxDQUFDLEdBQUdjLENBQUMsRUFBRW5nQixDQUFDLENBQUMsS0FBS1ksWUFBWSxDQUFDdWYsQ0FBQyxFQUFFbmdCLENBQUMsQ0FBQztJQUFFa2dCO0dBQVE7QUFDbkU7QUFFQSxTQUFTRSxNQUFNQSxDQUFDMVMsS0FBSyxFQUFFO0VBQ3JCLE9BQU87SUFBRUEsS0FBSztJQUFFMlIsS0FBSyxFQUFFQSxDQUFDLENBQUMzdEIsQ0FBQyxDQUFDLEtBQUtBO0dBQUc7QUFDckM7QUFFQSxTQUFTMnVCLFdBQVdBLENBQUN4cEIsS0FBSyxFQUFFO0VBQzFCLE9BQU9BLEtBQUssQ0FBQ2YsT0FBTyxDQUFDLDZCQUE2QixFQUFFLE1BQU0sQ0FBQztBQUM3RDtBQUVBLFNBQVN3cUIsWUFBWUEsQ0FBQzlYLEtBQUssRUFBRXhOLEdBQUcsRUFBRTtFQUNoQyxNQUFNdWxCLEdBQUcsR0FBR3ZCLFVBQVUsQ0FBQ2hrQixHQUFHLENBQUM7SUFDekJ3bEIsR0FBRyxHQUFHeEIsVUFBVSxDQUFDaGtCLEdBQUcsRUFBRSxLQUFLLENBQUM7SUFDNUJ5bEIsS0FBSyxHQUFHekIsVUFBVSxDQUFDaGtCLEdBQUcsRUFBRSxLQUFLLENBQUM7SUFDOUIwbEIsSUFBSSxHQUFHMUIsVUFBVSxDQUFDaGtCLEdBQUcsRUFBRSxLQUFLLENBQUM7SUFDN0IybEIsR0FBRyxHQUFHM0IsVUFBVSxDQUFDaGtCLEdBQUcsRUFBRSxLQUFLLENBQUM7SUFDNUI0bEIsUUFBUSxHQUFHNUIsVUFBVSxDQUFDaGtCLEdBQUcsRUFBRSxPQUFPLENBQUM7SUFDbkM2bEIsVUFBVSxHQUFHN0IsVUFBVSxDQUFDaGtCLEdBQUcsRUFBRSxPQUFPLENBQUM7SUFDckM4bEIsUUFBUSxHQUFHOUIsVUFBVSxDQUFDaGtCLEdBQUcsRUFBRSxPQUFPLENBQUM7SUFDbkMrbEIsU0FBUyxHQUFHL0IsVUFBVSxDQUFDaGtCLEdBQUcsRUFBRSxPQUFPLENBQUM7SUFDcENnbUIsU0FBUyxHQUFHaEMsVUFBVSxDQUFDaGtCLEdBQUcsRUFBRSxPQUFPLENBQUM7SUFDcENpbUIsU0FBUyxHQUFHakMsVUFBVSxDQUFDaGtCLEdBQUcsRUFBRSxPQUFPLENBQUM7SUFDcEN5TixPQUFPLEdBQUlqSCxDQUFDLEtBQU07TUFBRWtNLEtBQUssRUFBRVQsTUFBTSxDQUFDb1QsV0FBVyxDQUFDN2UsQ0FBQyxDQUFDa0gsR0FBRyxDQUFDLENBQUM7TUFBRTJXLEtBQUssRUFBRUEsQ0FBQyxDQUFDM3RCLENBQUMsQ0FBQyxLQUFLQSxDQUFDO01BQUUrVyxPQUFPLEVBQUU7SUFBSyxDQUFDLENBQUM7SUFDMUZ5WSxPQUFPLEdBQUkxZixDQUFDLElBQUs7TUFDZixJQUFJZ0gsS0FBSyxDQUFDQyxPQUFPLEVBQUU7UUFDakIsT0FBT0EsT0FBTyxDQUFDakgsQ0FBQyxDQUFDO01BQ25CO01BQ0EsUUFBUUEsQ0FBQyxDQUFDa0gsR0FBRztRQUNYO1FBQ0EsS0FBSyxHQUFHO1VBQ04sT0FBT21YLEtBQUssQ0FBQzdrQixHQUFHLENBQUN5RSxJQUFJLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUMzQyxLQUFLLElBQUk7VUFDUCxPQUFPb2dCLEtBQUssQ0FBQzdrQixHQUFHLENBQUN5RSxJQUFJLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUMxQztRQUNBLEtBQUssR0FBRztVQUNOLE9BQU8wZixPQUFPLENBQUMyQixRQUFRLENBQUM7UUFDMUIsS0FBSyxJQUFJO1VBQ1AsT0FBTzNCLE9BQU8sQ0FBQzZCLFNBQVMsRUFBRTViLGNBQWMsQ0FBQztRQUMzQyxLQUFLLE1BQU07VUFDVCxPQUFPK1osT0FBTyxDQUFDdUIsSUFBSSxDQUFDO1FBQ3RCLEtBQUssT0FBTztVQUNWLE9BQU92QixPQUFPLENBQUM4QixTQUFTLENBQUM7UUFDM0IsS0FBSyxRQUFRO1VBQ1gsT0FBTzlCLE9BQU8sQ0FBQ3dCLEdBQUcsQ0FBQztRQUNyQjtRQUNBLEtBQUssR0FBRztVQUNOLE9BQU94QixPQUFPLENBQUN5QixRQUFRLENBQUM7UUFDMUIsS0FBSyxJQUFJO1VBQ1AsT0FBT3pCLE9BQU8sQ0FBQ3FCLEdBQUcsQ0FBQztRQUNyQixLQUFLLEtBQUs7VUFDUixPQUFPWCxLQUFLLENBQUM3a0IsR0FBRyxDQUFDbUUsTUFBTSxDQUFDLE9BQU8sRUFBRSxJQUFJLEVBQUUsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ25ELEtBQUssTUFBTTtVQUNULE9BQU8wZ0IsS0FBSyxDQUFDN2tCLEdBQUcsQ0FBQ21FLE1BQU0sQ0FBQyxNQUFNLEVBQUUsSUFBSSxFQUFFLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUNsRCxLQUFLLEdBQUc7VUFDTixPQUFPZ2dCLE9BQU8sQ0FBQ3lCLFFBQVEsQ0FBQztRQUMxQixLQUFLLElBQUk7VUFDUCxPQUFPekIsT0FBTyxDQUFDcUIsR0FBRyxDQUFDO1FBQ3JCLEtBQUssS0FBSztVQUNSLE9BQU9YLEtBQUssQ0FBQzdrQixHQUFHLENBQUNtRSxNQUFNLENBQUMsT0FBTyxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDcEQsS0FBSyxNQUFNO1VBQ1QsT0FBTzBnQixLQUFLLENBQUM3a0IsR0FBRyxDQUFDbUUsTUFBTSxDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ25EO1FBQ0EsS0FBSyxHQUFHO1VBQ04sT0FBT2dnQixPQUFPLENBQUN5QixRQUFRLENBQUM7UUFDMUIsS0FBSyxJQUFJO1VBQ1AsT0FBT3pCLE9BQU8sQ0FBQ3FCLEdBQUcsQ0FBQztRQUNyQjtRQUNBLEtBQUssR0FBRztVQUNOLE9BQU9yQixPQUFPLENBQUMwQixVQUFVLENBQUM7UUFDNUIsS0FBSyxLQUFLO1VBQ1IsT0FBTzFCLE9BQU8sQ0FBQ3NCLEtBQUssQ0FBQztRQUN2QjtRQUNBLEtBQUssSUFBSTtVQUNQLE9BQU90QixPQUFPLENBQUNxQixHQUFHLENBQUM7UUFDckIsS0FBSyxHQUFHO1VBQ04sT0FBT3JCLE9BQU8sQ0FBQ3lCLFFBQVEsQ0FBQztRQUMxQixLQUFLLElBQUk7VUFDUCxPQUFPekIsT0FBTyxDQUFDcUIsR0FBRyxDQUFDO1FBQ3JCLEtBQUssR0FBRztVQUNOLE9BQU9yQixPQUFPLENBQUN5QixRQUFRLENBQUM7UUFDMUIsS0FBSyxJQUFJO1VBQ1AsT0FBT3pCLE9BQU8sQ0FBQ3FCLEdBQUcsQ0FBQztRQUNyQixLQUFLLEdBQUc7VUFDTixPQUFPckIsT0FBTyxDQUFDeUIsUUFBUSxDQUFDO1FBQzFCLEtBQUssR0FBRztVQUNOLE9BQU96QixPQUFPLENBQUN5QixRQUFRLENBQUM7UUFDMUIsS0FBSyxJQUFJO1VBQ1AsT0FBT3pCLE9BQU8sQ0FBQ3FCLEdBQUcsQ0FBQztRQUNyQixLQUFLLEdBQUc7VUFDTixPQUFPckIsT0FBTyxDQUFDeUIsUUFBUSxDQUFDO1FBQzFCLEtBQUssSUFBSTtVQUNQLE9BQU96QixPQUFPLENBQUNxQixHQUFHLENBQUM7UUFDckIsS0FBSyxHQUFHO1VBQ04sT0FBT3JCLE9BQU8sQ0FBQzBCLFVBQVUsQ0FBQztRQUM1QixLQUFLLEtBQUs7VUFDUixPQUFPMUIsT0FBTyxDQUFDc0IsS0FBSyxDQUFDO1FBQ3ZCLEtBQUssR0FBRztVQUNOLE9BQU9MLE1BQU0sQ0FBQ1csU0FBUyxDQUFDO1FBQzFCLEtBQUssSUFBSTtVQUNQLE9BQU9YLE1BQU0sQ0FBQ1EsUUFBUSxDQUFDO1FBQ3pCLEtBQUssS0FBSztVQUNSLE9BQU96QixPQUFPLENBQUNvQixHQUFHLENBQUM7UUFDckI7UUFDQSxLQUFLLEdBQUc7VUFDTixPQUFPVixLQUFLLENBQUM3a0IsR0FBRyxDQUFDdUUsU0FBUyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ2xDO1FBQ0EsS0FBSyxNQUFNO1VBQ1QsT0FBTzRmLE9BQU8sQ0FBQ3VCLElBQUksQ0FBQztRQUN0QixLQUFLLElBQUk7VUFDUCxPQUFPdkIsT0FBTyxDQUFDNkIsU0FBUyxFQUFFNWIsY0FBYyxDQUFDO1FBQzNDO1FBQ0EsS0FBSyxHQUFHO1VBQ04sT0FBTytaLE9BQU8sQ0FBQ3lCLFFBQVEsQ0FBQztRQUMxQixLQUFLLElBQUk7VUFDUCxPQUFPekIsT0FBTyxDQUFDcUIsR0FBRyxDQUFDO1FBQ3JCO1FBQ0EsS0FBSyxHQUFHO1FBQ1IsS0FBSyxHQUFHO1VBQ04sT0FBT3JCLE9BQU8sQ0FBQ29CLEdBQUcsQ0FBQztRQUNyQixLQUFLLEtBQUs7VUFDUixPQUFPVixLQUFLLENBQUM3a0IsR0FBRyxDQUFDc0UsUUFBUSxDQUFDLE9BQU8sRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3RELEtBQUssTUFBTTtVQUNULE9BQU91Z0IsS0FBSyxDQUFDN2tCLEdBQUcsQ0FBQ3NFLFFBQVEsQ0FBQyxNQUFNLEVBQUUsS0FBSyxFQUFFLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUNyRCxLQUFLLEtBQUs7VUFDUixPQUFPdWdCLEtBQUssQ0FBQzdrQixHQUFHLENBQUNzRSxRQUFRLENBQUMsT0FBTyxFQUFFLElBQUksRUFBRSxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDckQsS0FBSyxNQUFNO1VBQ1QsT0FBT3VnQixLQUFLLENBQUM3a0IsR0FBRyxDQUFDc0UsUUFBUSxDQUFDLE1BQU0sRUFBRSxJQUFJLEVBQUUsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3BEO1FBQ0EsS0FBSyxHQUFHO1FBQ1IsS0FBSyxJQUFJO1VBQ1AsT0FBT2pMLE1BQU0sQ0FBQyxJQUFJNFksTUFBTSxDQUFFLFFBQU8yVCxRQUFRLENBQUM1VCxNQUFPLFNBQVF3VCxHQUFHLENBQUN4VCxNQUFPLEtBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUMvRSxLQUFLLEtBQUs7VUFDUixPQUFPM1ksTUFBTSxDQUFDLElBQUk0WSxNQUFNLENBQUUsUUFBTzJULFFBQVEsQ0FBQzVULE1BQU8sS0FBSXdULEdBQUcsQ0FBQ3hULE1BQU8sSUFBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQzFFO1FBQ0E7UUFDQSxLQUFLLEdBQUc7VUFDTixPQUFPb1QsTUFBTSxDQUFDLG9CQUFvQixDQUFDO1FBQ3JDO1VBQ0UsT0FBTzNYLE9BQU8sQ0FBQ2pILENBQUMsQ0FBQztNQUFBO0tBRXRCO0VBRUgsTUFBTWxRLElBQUksR0FBRzR2QixPQUFPLENBQUMxWSxLQUFLLENBQUMsSUFBSTtJQUM3QnVQLGFBQWEsRUFBRW1IO0dBQ2hCO0VBRUQ1dEIsSUFBSSxDQUFDa1gsS0FBSyxHQUFHQSxLQUFLO0VBRWxCLE9BQU9sWCxJQUFJO0FBQ2I7QUFFQSxNQUFNNnZCLHVCQUF1QixHQUFHO0VBQzlCdHZCLElBQUksRUFBRTtJQUNKLFNBQVMsRUFBRSxJQUFJO0lBQ2Z1TCxPQUFPLEVBQUU7R0FDVjtFQUNEdEwsS0FBSyxFQUFFO0lBQ0xzTCxPQUFPLEVBQUUsR0FBRztJQUNaLFNBQVMsRUFBRSxJQUFJO0lBQ2Zna0IsS0FBSyxFQUFFLEtBQUs7SUFDWkMsSUFBSSxFQUFFO0dBQ1A7RUFDRHR2QixHQUFHLEVBQUU7SUFDSHFMLE9BQU8sRUFBRSxHQUFHO0lBQ1osU0FBUyxFQUFFO0dBQ1o7RUFDRGxMLE9BQU8sRUFBRTtJQUNQa3ZCLEtBQUssRUFBRSxLQUFLO0lBQ1pDLElBQUksRUFBRTtHQUNQO0VBQ0RDLFNBQVMsRUFBRSxHQUFHO0VBQ2RDLFNBQVMsRUFBRSxHQUFHO0VBQ2RqdkIsSUFBSSxFQUFFO0lBQ0o4SyxPQUFPLEVBQUUsR0FBRztJQUNaLFNBQVMsRUFBRTtHQUNaO0VBQ0Q3SyxNQUFNLEVBQUU7SUFDTjZLLE9BQU8sRUFBRSxHQUFHO0lBQ1osU0FBUyxFQUFFO0dBQ1o7RUFDRDNLLE1BQU0sRUFBRTtJQUNOMkssT0FBTyxFQUFFLEdBQUc7SUFDWixTQUFTLEVBQUU7R0FDWjtFQUNEekssWUFBWSxFQUFFO0lBQ1owdUIsSUFBSSxFQUFFLE9BQU87SUFDYkQsS0FBSyxFQUFFO0VBQ1Q7QUFDRixDQUFDO0FBRUQsU0FBU0ksWUFBWUEsQ0FBQ0MsSUFBSSxFQUFFblgsVUFBVSxFQUFFO0VBQ3RDLE1BQU07SUFBRTFXLElBQUk7SUFBRWlEO0VBQU0sQ0FBQyxHQUFHNHFCLElBQUk7RUFFNUIsSUFBSTd0QixJQUFJLEtBQUssU0FBUyxFQUFFO0lBQ3RCLE9BQU87TUFDTDZVLE9BQU8sRUFBRSxJQUFJO01BQ2JDLEdBQUcsRUFBRTdSO0tBQ047RUFDSDtFQUVBLE1BQU1rRyxLQUFLLEdBQUd1TixVQUFVLENBQUMxVyxJQUFJLENBQUM7RUFFOUIsSUFBSThVLEdBQUcsR0FBR3lZLHVCQUF1QixDQUFDdnRCLElBQUksQ0FBQztFQUN2QyxJQUFJLE9BQU84VSxHQUFHLEtBQUssUUFBUSxFQUFFO0lBQzNCQSxHQUFHLEdBQUdBLEdBQUcsQ0FBQzNMLEtBQUssQ0FBQztFQUNsQjtFQUVBLElBQUkyTCxHQUFHLEVBQUU7SUFDUCxPQUFPO01BQ0xELE9BQU8sRUFBRSxLQUFLO01BQ2RDO0tBQ0Q7RUFDSDtFQUVBLE9BQU9sTSxTQUFTO0FBQ2xCO0FBRUEsU0FBU2tsQixVQUFVQSxDQUFDbGEsS0FBSyxFQUFFO0VBQ3pCLE1BQU1tYSxFQUFFLEdBQUduYSxLQUFLLENBQUNoSSxHQUFHLENBQUUyRyxDQUFDLElBQUtBLENBQUMsQ0FBQ3VILEtBQUssQ0FBQyxDQUFDbEwsTUFBTSxDQUFDLENBQUNoSSxDQUFDLEVBQUVrRyxDQUFDLEtBQVEsR0FBQWxHLENBQUssSUFBQWtHLENBQUMsQ0FBQ3NNLE1BQVMsS0FBRSxFQUFFLENBQUM7RUFDOUUsT0FBTyxDQUFLLElBQUEyVSxFQUFLLEtBQUVuYSxLQUFLLENBQUM7QUFDM0I7QUFFQSxTQUFTN0csS0FBS0EsQ0FBQ0ksS0FBSyxFQUFFMk0sS0FBSyxFQUFFa1UsUUFBUSxFQUFFO0VBQ3JDLE1BQU1DLE9BQU8sR0FBRzlnQixLQUFLLENBQUNKLEtBQUssQ0FBQytNLEtBQUssQ0FBQztFQUVsQyxJQUFJbVUsT0FBTyxFQUFFO0lBQ1gsTUFBTUMsR0FBRyxHQUFHLEVBQUU7SUFDZCxJQUFJQyxVQUFVLEdBQUcsQ0FBQztJQUNsQixLQUFLLE1BQU1wckIsQ0FBQyxJQUFJaXJCLFFBQVEsRUFBRTtNQUN4QixJQUFJNWUsY0FBYyxDQUFDNGUsUUFBUSxFQUFFanJCLENBQUMsQ0FBQyxFQUFFO1FBQy9CLE1BQU13cEIsQ0FBQyxHQUFHeUIsUUFBUSxDQUFDanJCLENBQUMsQ0FBQztVQUNuQnVwQixNQUFNLEdBQUdDLENBQUMsQ0FBQ0QsTUFBTSxHQUFHQyxDQUFDLENBQUNELE1BQU0sR0FBRyxDQUFDLEdBQUcsQ0FBQztRQUN0QyxJQUFJLENBQUNDLENBQUMsQ0FBQzFYLE9BQU8sSUFBSTBYLENBQUMsQ0FBQzNYLEtBQUssRUFBRTtVQUN6QnNaLEdBQUcsQ0FBQzNCLENBQUMsQ0FBQzNYLEtBQUssQ0FBQ0UsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUd5WCxDQUFDLENBQUNkLEtBQUssQ0FBQ3dDLE9BQU8sQ0FBQ3BXLEtBQUssQ0FBQ3NXLFVBQVUsRUFBRUEsVUFBVSxHQUFHN0IsTUFBTSxDQUFDLENBQUM7UUFDL0U7UUFDQTZCLFVBQVUsSUFBSTdCLE1BQU07TUFDdEI7SUFDRjtJQUNBLE9BQU8sQ0FBQzJCLE9BQU8sRUFBRUMsR0FBRyxDQUFDO0VBQ3ZCLENBQUMsTUFBTTtJQUNMLE9BQU8sQ0FBQ0QsT0FBTyxFQUFFLEVBQUUsQ0FBQztFQUN0QjtBQUNGO0FBRUEsU0FBU0csbUJBQW1CQSxDQUFDSCxPQUFPLEVBQUU7RUFDcEMsTUFBTUksT0FBTyxHQUFJelosS0FBSyxJQUFLO0lBQ3pCLFFBQVFBLEtBQUs7TUFDWCxLQUFLLEdBQUc7UUFDTixPQUFPLGFBQWE7TUFDdEIsS0FBSyxHQUFHO1FBQ04sT0FBTyxRQUFRO01BQ2pCLEtBQUssR0FBRztRQUNOLE9BQU8sUUFBUTtNQUNqQixLQUFLLEdBQUc7TUFDUixLQUFLLEdBQUc7UUFDTixPQUFPLE1BQU07TUFDZixLQUFLLEdBQUc7UUFDTixPQUFPLEtBQUs7TUFDZCxLQUFLLEdBQUc7UUFDTixPQUFPLFNBQVM7TUFDbEIsS0FBSyxHQUFHO01BQ1IsS0FBSyxHQUFHO1FBQ04sT0FBTyxPQUFPO01BQ2hCLEtBQUssR0FBRztRQUNOLE9BQU8sTUFBTTtNQUNmLEtBQUssR0FBRztNQUNSLEtBQUssR0FBRztRQUNOLE9BQU8sU0FBUztNQUNsQixLQUFLLEdBQUc7UUFDTixPQUFPLFlBQVk7TUFDckIsS0FBSyxHQUFHO1FBQ04sT0FBTyxVQUFVO01BQ25CLEtBQUssR0FBRztRQUNOLE9BQU8sU0FBUztNQUNsQjtRQUNFLE9BQU8sSUFBSTtJQUFBO0dBRWhCO0VBRUQsSUFBSWxULElBQUksR0FBRyxJQUFJO0VBQ2YsSUFBSTRzQixjQUFjO0VBQ2xCLElBQUksQ0FBQ25yQixXQUFXLENBQUM4cUIsT0FBTyxDQUFDdGxCLENBQUMsQ0FBQyxFQUFFO0lBQzNCakgsSUFBSSxHQUFHNEIsUUFBUSxDQUFDQyxNQUFNLENBQUMwcUIsT0FBTyxDQUFDdGxCLENBQUMsQ0FBQztFQUNuQztFQUVBLElBQUksQ0FBQ3hGLFdBQVcsQ0FBQzhxQixPQUFPLENBQUNNLENBQUMsQ0FBQyxFQUFFO0lBQzNCLElBQUksQ0FBQzdzQixJQUFJLEVBQUU7TUFDVEEsSUFBSSxHQUFHLElBQUlpTCxlQUFlLENBQUNzaEIsT0FBTyxDQUFDTSxDQUFDLENBQUM7SUFDdkM7SUFDQUQsY0FBYyxHQUFHTCxPQUFPLENBQUNNLENBQUM7RUFDNUI7RUFFQSxJQUFJLENBQUNwckIsV0FBVyxDQUFDOHFCLE9BQU8sQ0FBQ08sQ0FBQyxDQUFDLEVBQUU7SUFDM0JQLE9BQU8sQ0FBQ1EsQ0FBQyxHQUFHLENBQUNSLE9BQU8sQ0FBQ08sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQztFQUNyQztFQUVBLElBQUksQ0FBQ3JyQixXQUFXLENBQUM4cUIsT0FBTyxDQUFDMUIsQ0FBQyxDQUFDLEVBQUU7SUFDM0IsSUFBSTBCLE9BQU8sQ0FBQzFCLENBQUMsR0FBRyxFQUFFLElBQUkwQixPQUFPLENBQUMvZSxDQUFDLEtBQUssQ0FBQyxFQUFFO01BQ3JDK2UsT0FBTyxDQUFDMUIsQ0FBQyxJQUFJLEVBQUU7SUFDakIsQ0FBQyxNQUFNLElBQUkwQixPQUFPLENBQUMxQixDQUFDLEtBQUssRUFBRSxJQUFJMEIsT0FBTyxDQUFDL2UsQ0FBQyxLQUFLLENBQUMsRUFBRTtNQUM5QytlLE9BQU8sQ0FBQzFCLENBQUMsR0FBRyxDQUFDO0lBQ2Y7RUFDRjtFQUVBLElBQUkwQixPQUFPLENBQUNTLENBQUMsS0FBSyxDQUFDLElBQUlULE9BQU8sQ0FBQ1UsQ0FBQyxFQUFFO0lBQ2hDVixPQUFPLENBQUNVLENBQUMsR0FBRyxDQUFDVixPQUFPLENBQUNVLENBQUM7RUFDeEI7RUFFQSxJQUFJLENBQUN4ckIsV0FBVyxDQUFDOHFCLE9BQU8sQ0FBQzFiLENBQUMsQ0FBQyxFQUFFO0lBQzNCMGIsT0FBTyxDQUFDVyxDQUFDLEdBQUczZSxXQUFXLENBQUNnZSxPQUFPLENBQUMxYixDQUFDLENBQUM7RUFDcEM7RUFFQSxNQUFNdU8sSUFBSSxHQUFHNVksTUFBTSxDQUFDQyxJQUFJLENBQUM4bEIsT0FBTyxDQUFDLENBQUNyZixNQUFNLENBQUMsQ0FBQzlCLENBQUMsRUFBRXFDLENBQUMsS0FBSztJQUNqRCxNQUFNdkksQ0FBQyxHQUFHeW5CLE9BQU8sQ0FBQ2xmLENBQUMsQ0FBQztJQUNwQixJQUFJdkksQ0FBQyxFQUFFO01BQ0xrRyxDQUFDLENBQUNsRyxDQUFDLENBQUMsR0FBR3FuQixPQUFPLENBQUM5ZSxDQUFDLENBQUM7SUFDbkI7SUFFQSxPQUFPckMsQ0FBQztHQUNULEVBQUUsRUFBRSxDQUFDO0VBRU4sT0FBTyxDQUFDZ1UsSUFBSSxFQUFFcGYsSUFBSSxFQUFFNHNCLGNBQWMsQ0FBQztBQUNyQztBQUVBLElBQUlPLGtCQUFrQixHQUFHLElBQUk7QUFFN0IsU0FBU0MsZ0JBQWdCQSxDQUFBLEVBQUc7RUFDMUIsSUFBSSxDQUFDRCxrQkFBa0IsRUFBRTtJQUN2QkEsa0JBQWtCLEdBQUc5bkIsUUFBUSxDQUFDZ0MsVUFBVSxDQUFDLGFBQWEsQ0FBQztFQUN6RDtFQUVBLE9BQU84bEIsa0JBQWtCO0FBQzNCO0FBRUEsU0FBU0UscUJBQXFCQSxDQUFDbmEsS0FBSyxFQUFFeFQsTUFBTSxFQUFFO0VBQzVDLElBQUl3VCxLQUFLLENBQUNDLE9BQU8sRUFBRTtJQUNqQixPQUFPRCxLQUFLO0VBQ2Q7RUFFQSxNQUFNOEIsVUFBVSxHQUFHUixTQUFTLENBQUNuQixzQkFBc0IsQ0FBQ0gsS0FBSyxDQUFDRSxHQUFHLENBQUM7RUFDOUQsTUFBTXlELE1BQU0sR0FBR3lXLGtCQUFrQixDQUFDdFksVUFBVSxFQUFFdFYsTUFBTSxDQUFDO0VBRXJELElBQUltWCxNQUFNLElBQUksSUFBSSxJQUFJQSxNQUFNLENBQUM3UixRQUFRLENBQUNrQyxTQUFTLENBQUMsRUFBRTtJQUNoRCxPQUFPZ00sS0FBSztFQUNkO0VBRUEsT0FBTzJELE1BQU07QUFDZjtBQUVPLFNBQVMwVyxpQkFBaUJBLENBQUMxVyxNQUFNLEVBQUVuWCxNQUFNLEVBQUU7RUFDaEQsT0FBT2tOLEtBQUssQ0FBQ0wsU0FBUyxDQUFDeUssTUFBTSxDQUFDLEdBQUdILE1BQU0sQ0FBQzNNLEdBQUcsQ0FBRWdDLENBQUMsSUFBS21oQixxQkFBcUIsQ0FBQ25oQixDQUFDLEVBQUV4TSxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQ3ZGOztBQUVBO0FBQ0E7QUFDQTs7QUFFTyxTQUFTOHRCLGlCQUFpQkEsQ0FBQzl0QixNQUFNLEVBQUUrTCxLQUFLLEVBQUUzTSxNQUFNLEVBQUU7RUFDdkQsTUFBTStYLE1BQU0sR0FBRzBXLGlCQUFpQixDQUFDL1ksU0FBUyxDQUFDQyxXQUFXLENBQUMzVixNQUFNLENBQUMsRUFBRVksTUFBTSxDQUFDO0lBQ3JFd1MsS0FBSyxHQUFHMkUsTUFBTSxDQUFDM00sR0FBRyxDQUFFZ0MsQ0FBQyxJQUFLOGUsWUFBWSxDQUFDOWUsQ0FBQyxFQUFFeE0sTUFBTSxDQUFDLENBQUM7SUFDbEQrdEIsaUJBQWlCLEdBQUd2YixLQUFLLENBQUN6SCxJQUFJLENBQUV5QixDQUFDLElBQUtBLENBQUMsQ0FBQ3VXLGFBQWEsQ0FBQztFQUV4RCxJQUFJZ0wsaUJBQWlCLEVBQUU7SUFDckIsT0FBTztNQUFFaGlCLEtBQUs7TUFBRW9MLE1BQU07TUFBRTRMLGFBQWEsRUFBRWdMLGlCQUFpQixDQUFDaEw7S0FBZTtFQUMxRSxDQUFDLE1BQU07SUFDTCxNQUFNLENBQUNpTCxXQUFXLEVBQUVwQixRQUFRLENBQUMsR0FBR0YsVUFBVSxDQUFDbGEsS0FBSyxDQUFDO01BQy9Da0csS0FBSyxHQUFHVCxNQUFNLENBQUMrVixXQUFXLEVBQUUsR0FBRyxDQUFDO01BQ2hDLENBQUNDLFVBQVUsRUFBRXBCLE9BQU8sQ0FBQyxHQUFHbGhCLEtBQUssQ0FBQ0ksS0FBSyxFQUFFMk0sS0FBSyxFQUFFa1UsUUFBUSxDQUFDO01BQ3JELENBQUM1USxNQUFNLEVBQUUxYixJQUFJLEVBQUU0c0IsY0FBYyxDQUFDLEdBQUdMLE9BQU8sR0FDcENHLG1CQUFtQixDQUFDSCxPQUFPLENBQUMsR0FDNUIsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFcmxCLFNBQVMsQ0FBQztJQUM3QixJQUFJd0csY0FBYyxDQUFDNmUsT0FBTyxFQUFFLEdBQUcsQ0FBQyxJQUFJN2UsY0FBYyxDQUFDNmUsT0FBTyxFQUFFLEdBQUcsQ0FBQyxFQUFFO01BQ2hFLE1BQU0sSUFBSXp3Qiw2QkFBNkIsQ0FDckMsdURBQXVELENBQ3hEO0lBQ0g7SUFDQSxPQUFPO01BQUUyUCxLQUFLO01BQUVvTCxNQUFNO01BQUV1QixLQUFLO01BQUV1VixVQUFVO01BQUVwQixPQUFPO01BQUU3USxNQUFNO01BQUUxYixJQUFJO01BQUU0c0I7S0FBZ0I7RUFDcEY7QUFDRjtBQUVPLFNBQVNnQixlQUFlQSxDQUFDbHVCLE1BQU0sRUFBRStMLEtBQUssRUFBRTNNLE1BQU0sRUFBRTtFQUNyRCxNQUFNO0lBQUU0YyxNQUFNO0lBQUUxYixJQUFJO0lBQUU0c0IsY0FBYztJQUFFbks7R0FBZSxHQUFHK0ssaUJBQWlCLENBQUM5dEIsTUFBTSxFQUFFK0wsS0FBSyxFQUFFM00sTUFBTSxDQUFDO0VBQ2hHLE9BQU8sQ0FBQzRjLE1BQU0sRUFBRTFiLElBQUksRUFBRTRzQixjQUFjLEVBQUVuSyxhQUFhLENBQUM7QUFDdEQ7QUFFTyxTQUFTNkssa0JBQWtCQSxDQUFDdFksVUFBVSxFQUFFdFYsTUFBTSxFQUFFO0VBQ3JELElBQUksQ0FBQ3NWLFVBQVUsRUFBRTtJQUNmLE9BQU8sSUFBSTtFQUNiO0VBRUEsTUFBTTZZLFNBQVMsR0FBR3JaLFNBQVMsQ0FBQzNTLE1BQU0sQ0FBQ25DLE1BQU0sRUFBRXNWLFVBQVUsQ0FBQztFQUN0RCxNQUFNOFksS0FBSyxHQUFHRCxTQUFTLENBQUN6WSxtQkFBbUIsQ0FBQ2dZLGdCQUFnQixFQUFFLENBQUM7RUFDL0QsT0FBT1UsS0FBSyxDQUFDNWpCLEdBQUcsQ0FBRXlMLENBQUMsSUFBS3VXLFlBQVksQ0FBQ3ZXLENBQUMsRUFBRVgsVUFBVSxDQUFDLENBQUM7QUFDdEQ7QUMzYUEsTUFBTStZLGFBQWEsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDO0VBQzNFQyxVQUFVLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQztBQUV0RSxTQUFTQyxjQUFjQSxDQUFDanlCLElBQUksRUFBRXVGLEtBQUssRUFBRTtFQUNuQyxPQUFPLElBQUk2VixPQUFPLENBQ2hCLG1CQUFtQixFQUNsQixpQkFBZ0I3VixLQUFNLGFBQVksT0FBT0EsS0FBZSxVQUFBdkYsSUFBSyxvQkFBbUIsQ0FDbEY7QUFDSDtBQUVBLFNBQVNreUIsU0FBU0EsQ0FBQzN4QixJQUFJLEVBQUVDLEtBQUssRUFBRUMsR0FBRyxFQUFFO0VBQ25DLE1BQU00UyxDQUFDLEdBQUcsSUFBSXpQLElBQUksQ0FBQ0EsSUFBSSxDQUFDMFAsR0FBRyxDQUFDL1MsSUFBSSxFQUFFQyxLQUFLLEdBQUcsQ0FBQyxFQUFFQyxHQUFHLENBQUMsQ0FBQztFQUVsRCxJQUFJRixJQUFJLEdBQUcsR0FBRyxJQUFJQSxJQUFJLElBQUksQ0FBQyxFQUFFO0lBQzNCOFMsQ0FBQyxDQUFDRSxjQUFjLENBQUNGLENBQUMsQ0FBQ0csY0FBYyxFQUFFLEdBQUcsSUFBSSxDQUFDO0VBQzdDO0VBRUEsTUFBTTJlLEVBQUUsR0FBRzllLENBQUMsQ0FBQytlLFNBQVMsRUFBRTtFQUV4QixPQUFPRCxFQUFFLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBR0EsRUFBRTtBQUMxQjtBQUVBLFNBQVNFLGNBQWNBLENBQUM5eEIsSUFBSSxFQUFFQyxLQUFLLEVBQUVDLEdBQUcsRUFBRTtFQUN4QyxPQUFPQSxHQUFHLEdBQUcsQ0FBQ3VTLFVBQVUsQ0FBQ3pTLElBQUksQ0FBQyxHQUFHeXhCLFVBQVUsR0FBR0QsYUFBYSxFQUFFdnhCLEtBQUssR0FBRyxDQUFDLENBQUM7QUFDekU7QUFFQSxTQUFTOHhCLGdCQUFnQkEsQ0FBQy94QixJQUFJLEVBQUU4WixPQUFPLEVBQUU7RUFDdkMsTUFBTWtZLEtBQUssR0FBR3ZmLFVBQVUsQ0FBQ3pTLElBQUksQ0FBQyxHQUFHeXhCLFVBQVUsR0FBR0QsYUFBYTtJQUN6RFMsTUFBTSxHQUFHRCxLQUFLLENBQUM1RCxTQUFTLENBQUV0cEIsQ0FBQyxJQUFLQSxDQUFDLEdBQUdnVixPQUFPLENBQUM7SUFDNUM1WixHQUFHLEdBQUc0WixPQUFPLEdBQUdrWSxLQUFLLENBQUNDLE1BQU0sQ0FBQztFQUMvQixPQUFPO0lBQUVoeUIsS0FBSyxFQUFFZ3lCLE1BQU0sR0FBRyxDQUFDO0lBQUUveEI7R0FBSztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRU8sU0FBU2d5QixlQUFlQSxDQUFDQyxPQUFPLEVBQUU7RUFDdkMsTUFBTTtNQUFFbnlCLElBQUk7TUFBRUMsS0FBSztNQUFFQztJQUFJLENBQUMsR0FBR2l5QixPQUFPO0lBQ2xDclksT0FBTyxHQUFHZ1ksY0FBYyxDQUFDOXhCLElBQUksRUFBRUMsS0FBSyxFQUFFQyxHQUFHLENBQUM7SUFDMUNHLE9BQU8sR0FBR3N4QixTQUFTLENBQUMzeEIsSUFBSSxFQUFFQyxLQUFLLEVBQUVDLEdBQUcsQ0FBQztFQUV2QyxJQUFJMlosVUFBVSxHQUFHN1QsSUFBSSxDQUFDK0QsS0FBSyxDQUFDLENBQUMrUCxPQUFPLEdBQUd6WixPQUFPLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUN2RDhTLFFBQVE7RUFFVixJQUFJMEcsVUFBVSxHQUFHLENBQUMsRUFBRTtJQUNsQjFHLFFBQVEsR0FBR25ULElBQUksR0FBRyxDQUFDO0lBQ25CNlosVUFBVSxHQUFHM0csZUFBZSxDQUFDQyxRQUFRLENBQUM7R0FDdkMsTUFBTSxJQUFJMEcsVUFBVSxHQUFHM0csZUFBZSxDQUFDbFQsSUFBSSxDQUFDLEVBQUU7SUFDN0NtVCxRQUFRLEdBQUduVCxJQUFJLEdBQUcsQ0FBQztJQUNuQjZaLFVBQVUsR0FBRyxDQUFDO0VBQ2hCLENBQUMsTUFBTTtJQUNMMUcsUUFBUSxHQUFHblQsSUFBSTtFQUNqQjtFQUVBLE9BQU87SUFBRW1ULFFBQVE7SUFBRTBHLFVBQVU7SUFBRXhaLE9BQU87SUFBRSxHQUFHdVUsVUFBVSxDQUFDdWQsT0FBTztHQUFHO0FBQ2xFO0FBRU8sU0FBU0MsZUFBZUEsQ0FBQ0MsUUFBUSxFQUFFO0VBQ3hDLE1BQU07TUFBRWxmLFFBQVE7TUFBRTBHLFVBQVU7TUFBRXhaO0lBQVEsQ0FBQyxHQUFHZ3lCLFFBQVE7SUFDaERDLGFBQWEsR0FBR1gsU0FBUyxDQUFDeGUsUUFBUSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDekNvZixVQUFVLEdBQUc3ZixVQUFVLENBQUNTLFFBQVEsQ0FBQztFQUVuQyxJQUFJMkcsT0FBTyxHQUFHRCxVQUFVLEdBQUcsQ0FBQyxHQUFHeFosT0FBTyxHQUFHaXlCLGFBQWEsR0FBRyxDQUFDO0lBQ3hEdHlCLElBQUk7RUFFTixJQUFJOFosT0FBTyxHQUFHLENBQUMsRUFBRTtJQUNmOVosSUFBSSxHQUFHbVQsUUFBUSxHQUFHLENBQUM7SUFDbkIyRyxPQUFPLElBQUlwSCxVQUFVLENBQUMxUyxJQUFJLENBQUM7RUFDN0IsQ0FBQyxNQUFNLElBQUk4WixPQUFPLEdBQUd5WSxVQUFVLEVBQUU7SUFDL0J2eUIsSUFBSSxHQUFHbVQsUUFBUSxHQUFHLENBQUM7SUFDbkIyRyxPQUFPLElBQUlwSCxVQUFVLENBQUNTLFFBQVEsQ0FBQztFQUNqQyxDQUFDLE1BQU07SUFDTG5ULElBQUksR0FBR21ULFFBQVE7RUFDakI7RUFFQSxNQUFNO0lBQUVsVCxLQUFLO0lBQUVDO0VBQUksQ0FBQyxHQUFHNnhCLGdCQUFnQixDQUFDL3hCLElBQUksRUFBRThaLE9BQU8sQ0FBQztFQUN0RCxPQUFPO0lBQUU5WixJQUFJO0lBQUVDLEtBQUs7SUFBRUMsR0FBRztJQUFFLEdBQUcwVSxVQUFVLENBQUN5ZCxRQUFRO0dBQUc7QUFDdEQ7QUFFTyxTQUFTRyxrQkFBa0JBLENBQUNDLFFBQVEsRUFBRTtFQUMzQyxNQUFNO0lBQUV6eUIsSUFBSTtJQUFFQyxLQUFLO0lBQUVDO0VBQUksQ0FBQyxHQUFHdXlCLFFBQVE7RUFDckMsTUFBTTNZLE9BQU8sR0FBR2dZLGNBQWMsQ0FBQzl4QixJQUFJLEVBQUVDLEtBQUssRUFBRUMsR0FBRyxDQUFDO0VBQ2hELE9BQU87SUFBRUYsSUFBSTtJQUFFOFosT0FBTztJQUFFLEdBQUdsRixVQUFVLENBQUM2ZCxRQUFRO0dBQUc7QUFDbkQ7QUFFTyxTQUFTQyxrQkFBa0JBLENBQUNDLFdBQVcsRUFBRTtFQUM5QyxNQUFNO0lBQUUzeUIsSUFBSTtJQUFFOFo7RUFBUSxDQUFDLEdBQUc2WSxXQUFXO0VBQ3JDLE1BQU07SUFBRTF5QixLQUFLO0lBQUVDO0VBQUksQ0FBQyxHQUFHNnhCLGdCQUFnQixDQUFDL3hCLElBQUksRUFBRThaLE9BQU8sQ0FBQztFQUN0RCxPQUFPO0lBQUU5WixJQUFJO0lBQUVDLEtBQUs7SUFBRUMsR0FBRztJQUFFLEdBQUcwVSxVQUFVLENBQUMrZCxXQUFXO0dBQUc7QUFDekQ7QUFFTyxTQUFTQyxrQkFBa0JBLENBQUM1aEIsR0FBRyxFQUFFO0VBQ3RDLE1BQU02aEIsU0FBUyxHQUFHL2lCLFNBQVMsQ0FBQ2tCLEdBQUcsQ0FBQ21DLFFBQVEsQ0FBQztJQUN2QzJmLFNBQVMsR0FBR3poQixjQUFjLENBQUNMLEdBQUcsQ0FBQzZJLFVBQVUsRUFBRSxDQUFDLEVBQUUzRyxlQUFlLENBQUNsQyxHQUFHLENBQUNtQyxRQUFRLENBQUMsQ0FBQztJQUM1RTRmLFlBQVksR0FBRzFoQixjQUFjLENBQUNMLEdBQUcsQ0FBQzNRLE9BQU8sRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0VBRWxELElBQUksQ0FBQ3d5QixTQUFTLEVBQUU7SUFDZCxPQUFPbkIsY0FBYyxDQUFDLFVBQVUsRUFBRTFnQixHQUFHLENBQUNtQyxRQUFRLENBQUM7RUFDakQsQ0FBQyxNQUFNLElBQUksQ0FBQzJmLFNBQVMsRUFBRTtJQUNyQixPQUFPcEIsY0FBYyxDQUFDLE1BQU0sRUFBRTFnQixHQUFHLENBQUM2UyxJQUFJLENBQUM7RUFDekMsQ0FBQyxNQUFNLElBQUksQ0FBQ2tQLFlBQVksRUFBRTtJQUN4QixPQUFPckIsY0FBYyxDQUFDLFNBQVMsRUFBRTFnQixHQUFHLENBQUMzUSxPQUFPLENBQUM7R0FDOUMsTUFBTSxPQUFPLEtBQUs7QUFDckI7QUFFTyxTQUFTMnlCLHFCQUFxQkEsQ0FBQ2hpQixHQUFHLEVBQUU7RUFDekMsTUFBTTZoQixTQUFTLEdBQUcvaUIsU0FBUyxDQUFDa0IsR0FBRyxDQUFDaFIsSUFBSSxDQUFDO0lBQ25DaXpCLFlBQVksR0FBRzVoQixjQUFjLENBQUNMLEdBQUcsQ0FBQzhJLE9BQU8sRUFBRSxDQUFDLEVBQUVwSCxVQUFVLENBQUMxQixHQUFHLENBQUNoUixJQUFJLENBQUMsQ0FBQztFQUVyRSxJQUFJLENBQUM2eUIsU0FBUyxFQUFFO0lBQ2QsT0FBT25CLGNBQWMsQ0FBQyxNQUFNLEVBQUUxZ0IsR0FBRyxDQUFDaFIsSUFBSSxDQUFDO0VBQ3pDLENBQUMsTUFBTSxJQUFJLENBQUNpekIsWUFBWSxFQUFFO0lBQ3hCLE9BQU92QixjQUFjLENBQUMsU0FBUyxFQUFFMWdCLEdBQUcsQ0FBQzhJLE9BQU8sQ0FBQztHQUM5QyxNQUFNLE9BQU8sS0FBSztBQUNyQjtBQUVPLFNBQVNvWix1QkFBdUJBLENBQUNsaUIsR0FBRyxFQUFFO0VBQzNDLE1BQU02aEIsU0FBUyxHQUFHL2lCLFNBQVMsQ0FBQ2tCLEdBQUcsQ0FBQ2hSLElBQUksQ0FBQztJQUNuQ216QixVQUFVLEdBQUc5aEIsY0FBYyxDQUFDTCxHQUFHLENBQUMvUSxLQUFLLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztJQUM3Q216QixRQUFRLEdBQUcvaEIsY0FBYyxDQUFDTCxHQUFHLENBQUM5USxHQUFHLEVBQUUsQ0FBQyxFQUFFeVMsV0FBVyxDQUFDM0IsR0FBRyxDQUFDaFIsSUFBSSxFQUFFZ1IsR0FBRyxDQUFDL1EsS0FBSyxDQUFDLENBQUM7RUFFekUsSUFBSSxDQUFDNHlCLFNBQVMsRUFBRTtJQUNkLE9BQU9uQixjQUFjLENBQUMsTUFBTSxFQUFFMWdCLEdBQUcsQ0FBQ2hSLElBQUksQ0FBQztFQUN6QyxDQUFDLE1BQU0sSUFBSSxDQUFDbXpCLFVBQVUsRUFBRTtJQUN0QixPQUFPekIsY0FBYyxDQUFDLE9BQU8sRUFBRTFnQixHQUFHLENBQUMvUSxLQUFLLENBQUM7RUFDM0MsQ0FBQyxNQUFNLElBQUksQ0FBQ216QixRQUFRLEVBQUU7SUFDcEIsT0FBTzFCLGNBQWMsQ0FBQyxLQUFLLEVBQUUxZ0IsR0FBRyxDQUFDOVEsR0FBRyxDQUFDO0dBQ3RDLE1BQU0sT0FBTyxLQUFLO0FBQ3JCO0FBRU8sU0FBU216QixrQkFBa0JBLENBQUNyaUIsR0FBRyxFQUFFO0VBQ3RDLE1BQU07SUFBRXZRLElBQUk7SUFBRUMsTUFBTTtJQUFFRSxNQUFNO0lBQUV5RjtFQUFZLENBQUMsR0FBRzJLLEdBQUc7RUFDakQsTUFBTXNpQixTQUFTLEdBQ1hqaUIsY0FBYyxDQUFDNVEsSUFBSSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsSUFDMUJBLElBQUksS0FBSyxFQUFFLElBQUlDLE1BQU0sS0FBSyxDQUFDLElBQUlFLE1BQU0sS0FBSyxDQUFDLElBQUl5RixXQUFXLEtBQUssQ0FBRTtJQUNwRWt0QixXQUFXLEdBQUdsaUIsY0FBYyxDQUFDM1EsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7SUFDM0M4eUIsV0FBVyxHQUFHbmlCLGNBQWMsQ0FBQ3pRLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO0lBQzNDNnlCLGdCQUFnQixHQUFHcGlCLGNBQWMsQ0FBQ2hMLFdBQVcsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDO0VBRXhELElBQUksQ0FBQ2l0QixTQUFTLEVBQUU7SUFDZCxPQUFPNUIsY0FBYyxDQUFDLE1BQU0sRUFBRWp4QixJQUFJLENBQUM7RUFDckMsQ0FBQyxNQUFNLElBQUksQ0FBQzh5QixXQUFXLEVBQUU7SUFDdkIsT0FBTzdCLGNBQWMsQ0FBQyxRQUFRLEVBQUVoeEIsTUFBTSxDQUFDO0VBQ3pDLENBQUMsTUFBTSxJQUFJLENBQUM4eUIsV0FBVyxFQUFFO0lBQ3ZCLE9BQU85QixjQUFjLENBQUMsUUFBUSxFQUFFOXdCLE1BQU0sQ0FBQztFQUN6QyxDQUFDLE1BQU0sSUFBSSxDQUFDNnlCLGdCQUFnQixFQUFFO0lBQzVCLE9BQU8vQixjQUFjLENBQUMsYUFBYSxFQUFFcnJCLFdBQVcsQ0FBQztHQUNsRCxNQUFNLE9BQU8sS0FBSztBQUNyQjtBQzlHQSxNQUFNcXRCLE9BQU8sR0FBRyxrQkFBa0I7QUFDbEMsTUFBTUMsUUFBUSxHQUFHLE9BQU87QUFFeEIsU0FBU0MsZUFBZUEsQ0FBQ253QixJQUFJLEVBQUU7RUFDN0IsT0FBTyxJQUFJb1gsT0FBTyxDQUFDLGtCQUFrQixFQUFHLGFBQVlwWCxJQUFJLENBQUN6QixJQUFLLG9CQUFtQixDQUFDO0FBQ3BGOztBQUVBO0FBQ0EsU0FBUzZ4QixzQkFBc0JBLENBQUNockIsRUFBRSxFQUFFO0VBQ2xDLElBQUlBLEVBQUUsQ0FBQ3dwQixRQUFRLEtBQUssSUFBSSxFQUFFO0lBQ3hCeHBCLEVBQUUsQ0FBQ3dwQixRQUFRLEdBQUdILGVBQWUsQ0FBQ3JwQixFQUFFLENBQUMwUCxDQUFDLENBQUM7RUFDckM7RUFDQSxPQUFPMVAsRUFBRSxDQUFDd3BCLFFBQVE7QUFDcEI7O0FBRUE7QUFDQTtBQUNBLFNBQVNwbEIsS0FBS0EsQ0FBQzZtQixJQUFJLEVBQUU1bUIsSUFBSSxFQUFFO0VBQ3pCLE1BQU1rTCxPQUFPLEdBQUc7SUFDZGhXLEVBQUUsRUFBRTB4QixJQUFJLENBQUMxeEIsRUFBRTtJQUNYcUIsSUFBSSxFQUFFcXdCLElBQUksQ0FBQ3J3QixJQUFJO0lBQ2Y4VSxDQUFDLEVBQUV1YixJQUFJLENBQUN2YixDQUFDO0lBQ1QxSSxDQUFDLEVBQUVpa0IsSUFBSSxDQUFDamtCLENBQUM7SUFDVDFHLEdBQUcsRUFBRTJxQixJQUFJLENBQUMzcUIsR0FBRztJQUNiaWEsT0FBTyxFQUFFMFEsSUFBSSxDQUFDMVE7R0FDZjtFQUNELE9BQU8sSUFBSXRhLFFBQVEsQ0FBQztJQUFFLEdBQUdzUCxPQUFPO0lBQUUsR0FBR2xMLElBQUk7SUFBRTZtQixHQUFHLEVBQUUzYjtFQUFRLENBQUMsQ0FBQztBQUM1RDs7QUFFQTtBQUNBO0FBQ0EsU0FBUzRiLFNBQVNBLENBQUNDLE9BQU8sRUFBRXBrQixDQUFDLEVBQUVxa0IsRUFBRSxFQUFFO0VBQ2pDO0VBQ0EsSUFBSUMsUUFBUSxHQUFHRixPQUFPLEdBQUdwa0IsQ0FBQyxHQUFHLEVBQUUsR0FBRyxJQUFJOztFQUV0QztFQUNBLE1BQU11a0IsRUFBRSxHQUFHRixFQUFFLENBQUMxeEIsTUFBTSxDQUFDMnhCLFFBQVEsQ0FBQzs7RUFFOUI7RUFDQSxJQUFJdGtCLENBQUMsS0FBS3VrQixFQUFFLEVBQUU7SUFDWixPQUFPLENBQUNELFFBQVEsRUFBRXRrQixDQUFDLENBQUM7RUFDdEI7O0VBRUE7RUFDQXNrQixRQUFRLElBQUksQ0FBQ0MsRUFBRSxHQUFHdmtCLENBQUMsSUFBSSxFQUFFLEdBQUcsSUFBSTs7RUFFaEM7RUFDQSxNQUFNd2tCLEVBQUUsR0FBR0gsRUFBRSxDQUFDMXhCLE1BQU0sQ0FBQzJ4QixRQUFRLENBQUM7RUFDOUIsSUFBSUMsRUFBRSxLQUFLQyxFQUFFLEVBQUU7SUFDYixPQUFPLENBQUNGLFFBQVEsRUFBRUMsRUFBRSxDQUFDO0VBQ3ZCOztFQUVBO0VBQ0EsT0FBTyxDQUFDSCxPQUFPLEdBQUdqdUIsSUFBSSxDQUFDaW5CLEdBQUcsQ0FBQ21ILEVBQUUsRUFBRUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxHQUFHLElBQUksRUFBRXJ1QixJQUFJLENBQUNrbkIsR0FBRyxDQUFDa0gsRUFBRSxFQUFFQyxFQUFFLENBQUMsQ0FBQztBQUNuRTs7QUFFQTtBQUNBLFNBQVNDLE9BQU9BLENBQUNseUIsRUFBRSxFQUFFSSxNQUFNLEVBQUU7RUFDM0JKLEVBQUUsSUFBSUksTUFBTSxHQUFHLEVBQUUsR0FBRyxJQUFJO0VBRXhCLE1BQU1zUSxDQUFDLEdBQUcsSUFBSXpQLElBQUksQ0FBQ2pCLEVBQUUsQ0FBQztFQUV0QixPQUFPO0lBQ0xwQyxJQUFJLEVBQUU4UyxDQUFDLENBQUNHLGNBQWMsRUFBRTtJQUN4QmhULEtBQUssRUFBRTZTLENBQUMsQ0FBQ3loQixXQUFXLEVBQUUsR0FBRyxDQUFDO0lBQzFCcjBCLEdBQUcsRUFBRTRTLENBQUMsQ0FBQzBoQixVQUFVLEVBQUU7SUFDbkIvekIsSUFBSSxFQUFFcVMsQ0FBQyxDQUFDMmhCLFdBQVcsRUFBRTtJQUNyQi96QixNQUFNLEVBQUVvUyxDQUFDLENBQUM0aEIsYUFBYSxFQUFFO0lBQ3pCOXpCLE1BQU0sRUFBRWtTLENBQUMsQ0FBQzZoQixhQUFhLEVBQUU7SUFDekJ0dUIsV0FBVyxFQUFFeU0sQ0FBQyxDQUFDOGhCLGtCQUFrQjtHQUNsQztBQUNIOztBQUVBO0FBQ0EsU0FBU0MsT0FBT0EsQ0FBQzdqQixHQUFHLEVBQUV4TyxNQUFNLEVBQUVpQixJQUFJLEVBQUU7RUFDbEMsT0FBT3V3QixTQUFTLENBQUM1dEIsWUFBWSxDQUFDNEssR0FBRyxDQUFDLEVBQUV4TyxNQUFNLEVBQUVpQixJQUFJLENBQUM7QUFDbkQ7O0FBRUE7QUFDQSxTQUFTcXhCLFVBQVVBLENBQUNoQixJQUFJLEVBQUU3WixHQUFHLEVBQUU7RUFDN0IsTUFBTThhLElBQUksR0FBR2pCLElBQUksQ0FBQ2prQixDQUFDO0lBQ2pCN1AsSUFBSSxHQUFHOHpCLElBQUksQ0FBQ3ZiLENBQUMsQ0FBQ3ZZLElBQUksR0FBR2dHLElBQUksQ0FBQ3VNLEtBQUssQ0FBQzBILEdBQUcsQ0FBQ3JFLEtBQUssQ0FBQztJQUMxQzNWLEtBQUssR0FBRzZ6QixJQUFJLENBQUN2YixDQUFDLENBQUN0WSxLQUFLLEdBQUcrRixJQUFJLENBQUN1TSxLQUFLLENBQUMwSCxHQUFHLENBQUMzTSxNQUFNLENBQUMsR0FBR3RILElBQUksQ0FBQ3VNLEtBQUssQ0FBQzBILEdBQUcsQ0FBQ3BFLFFBQVEsQ0FBQyxHQUFHLENBQUM7SUFDNUUwQyxDQUFDLEdBQUc7TUFDRixHQUFHdWIsSUFBSSxDQUFDdmIsQ0FBQztNQUNUdlksSUFBSTtNQUNKQyxLQUFLO01BQ0xDLEdBQUcsRUFDRDhGLElBQUksQ0FBQ2luQixHQUFHLENBQUM2RyxJQUFJLENBQUN2YixDQUFDLENBQUNyWSxHQUFHLEVBQUV5UyxXQUFXLENBQUMzUyxJQUFJLEVBQUVDLEtBQUssQ0FBQyxDQUFDLEdBQzlDK0YsSUFBSSxDQUFDdU0sS0FBSyxDQUFDMEgsR0FBRyxDQUFDbEUsSUFBSSxDQUFDLEdBQ3BCL1AsSUFBSSxDQUFDdU0sS0FBSyxDQUFDMEgsR0FBRyxDQUFDbkUsS0FBSyxDQUFDLEdBQUc7S0FDM0I7SUFDRGtmLFdBQVcsR0FBR2hULFFBQVEsQ0FBQzdWLFVBQVUsQ0FBQztNQUNoQ3lKLEtBQUssRUFBRXFFLEdBQUcsQ0FBQ3JFLEtBQUssR0FBRzVQLElBQUksQ0FBQ3VNLEtBQUssQ0FBQzBILEdBQUcsQ0FBQ3JFLEtBQUssQ0FBQztNQUN4Q0MsUUFBUSxFQUFFb0UsR0FBRyxDQUFDcEUsUUFBUSxHQUFHN1AsSUFBSSxDQUFDdU0sS0FBSyxDQUFDMEgsR0FBRyxDQUFDcEUsUUFBUSxDQUFDO01BQ2pEdkksTUFBTSxFQUFFMk0sR0FBRyxDQUFDM00sTUFBTSxHQUFHdEgsSUFBSSxDQUFDdU0sS0FBSyxDQUFDMEgsR0FBRyxDQUFDM00sTUFBTSxDQUFDO01BQzNDd0ksS0FBSyxFQUFFbUUsR0FBRyxDQUFDbkUsS0FBSyxHQUFHOVAsSUFBSSxDQUFDdU0sS0FBSyxDQUFDMEgsR0FBRyxDQUFDbkUsS0FBSyxDQUFDO01BQ3hDQyxJQUFJLEVBQUVrRSxHQUFHLENBQUNsRSxJQUFJLEdBQUcvUCxJQUFJLENBQUN1TSxLQUFLLENBQUMwSCxHQUFHLENBQUNsRSxJQUFJLENBQUM7TUFDckN2QixLQUFLLEVBQUV5RixHQUFHLENBQUN6RixLQUFLO01BQ2hCQyxPQUFPLEVBQUV3RixHQUFHLENBQUN4RixPQUFPO01BQ3BCdUIsT0FBTyxFQUFFaUUsR0FBRyxDQUFDakUsT0FBTztNQUNwQm1ILFlBQVksRUFBRWxELEdBQUcsQ0FBQ2tEO0lBQ3BCLENBQUMsQ0FBQyxDQUFDMEgsRUFBRSxDQUFDLGNBQWMsQ0FBQztJQUNyQm9QLE9BQU8sR0FBRzd0QixZQUFZLENBQUNtUyxDQUFDLENBQUM7RUFFM0IsSUFBSSxDQUFDblcsRUFBRSxFQUFFeU4sQ0FBQyxDQUFDLEdBQUdta0IsU0FBUyxDQUFDQyxPQUFPLEVBQUVjLElBQUksRUFBRWpCLElBQUksQ0FBQ3J3QixJQUFJLENBQUM7RUFFakQsSUFBSXV4QixXQUFXLEtBQUssQ0FBQyxFQUFFO0lBQ3JCNXlCLEVBQUUsSUFBSTR5QixXQUFXO0lBQ2pCO0lBQ0FubEIsQ0FBQyxHQUFHaWtCLElBQUksQ0FBQ3J3QixJQUFJLENBQUNqQixNQUFNLENBQUNKLEVBQUUsQ0FBQztFQUMxQjtFQUVBLE9BQU87SUFBRUEsRUFBRTtJQUFFeU47R0FBRztBQUNsQjs7QUFFQTtBQUNBO0FBQ0EsU0FBU29sQixtQkFBbUJBLENBQUMvd0IsTUFBTSxFQUFFZ3hCLFVBQVUsRUFBRTd5QixJQUFJLEVBQUVFLE1BQU0sRUFBRW9oQixJQUFJLEVBQUUwTSxjQUFjLEVBQUU7RUFDbkYsTUFBTTtJQUFFcEcsT0FBTztJQUFFeG1CO0VBQUssQ0FBQyxHQUFHcEIsSUFBSTtFQUM5QixJQUFJNkIsTUFBTSxJQUFJK0YsTUFBTSxDQUFDQyxJQUFJLENBQUNoRyxNQUFNLENBQUMsQ0FBQ2EsTUFBTSxLQUFLLENBQUMsRUFBRTtJQUM5QyxNQUFNb3dCLGtCQUFrQixHQUFHRCxVQUFVLElBQUl6eEIsSUFBSTtNQUMzQ3F3QixJQUFJLEdBQUdockIsUUFBUSxDQUFDcUQsVUFBVSxDQUFDakksTUFBTSxFQUFFO1FBQ2pDLEdBQUc3QixJQUFJO1FBQ1BvQixJQUFJLEVBQUUweEIsa0JBQWtCO1FBQ3hCOUU7TUFDRixDQUFDLENBQUM7SUFDSixPQUFPcEcsT0FBTyxHQUFHNkosSUFBSSxHQUFHQSxJQUFJLENBQUM3SixPQUFPLENBQUN4bUIsSUFBSSxDQUFDO0VBQzVDLENBQUMsTUFBTTtJQUNMLE9BQU9xRixRQUFRLENBQUNzYSxPQUFPLENBQ3JCLElBQUl2SSxPQUFPLENBQUMsWUFBWSxFQUFHLGNBQWE4SSxJQUFLLHdCQUF1QnBoQixNQUFPLEVBQUMsQ0FBQyxDQUM5RTtFQUNIO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBLFNBQVM2eUIsWUFBWUEsQ0FBQ3ZzQixFQUFFLEVBQUV0RyxNQUFNLEVBQUVrWCxNQUFNLEdBQUcsSUFBSSxFQUFFO0VBQy9DLE9BQU81USxFQUFFLENBQUNsRyxPQUFPLEdBQ2JzVixTQUFTLENBQUMzUyxNQUFNLENBQUNrRyxNQUFNLENBQUNsRyxNQUFNLENBQUMsT0FBTyxDQUFDLEVBQUU7SUFDdkNtVSxNQUFNO0lBQ041UCxXQUFXLEVBQUU7R0FDZCxDQUFDLENBQUN3UCx3QkFBd0IsQ0FBQ3hRLEVBQUUsRUFBRXRHLE1BQU0sQ0FBQyxHQUN2QyxJQUFJO0FBQ1Y7QUFFQSxTQUFTa25CLFNBQVNBLENBQUM1WixDQUFDLEVBQUV3bEIsUUFBUSxFQUFFO0VBQzlCLE1BQU1DLFVBQVUsR0FBR3psQixDQUFDLENBQUMwSSxDQUFDLENBQUN2WSxJQUFJLEdBQUcsSUFBSSxJQUFJNlAsQ0FBQyxDQUFDMEksQ0FBQyxDQUFDdlksSUFBSSxHQUFHLENBQUM7RUFDbEQsSUFBSXVZLENBQUMsR0FBRyxFQUFFO0VBQ1YsSUFBSStjLFVBQVUsSUFBSXpsQixDQUFDLENBQUMwSSxDQUFDLENBQUN2WSxJQUFJLElBQUksQ0FBQyxFQUFFdVksQ0FBQyxJQUFJLEdBQUc7RUFDekNBLENBQUMsSUFBSS9OLFFBQVEsQ0FBQ3FGLENBQUMsQ0FBQzBJLENBQUMsQ0FBQ3ZZLElBQUksRUFBRXMxQixVQUFVLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztFQUUzQyxJQUFJRCxRQUFRLEVBQUU7SUFDWjljLENBQUMsSUFBSSxHQUFHO0lBQ1JBLENBQUMsSUFBSS9OLFFBQVEsQ0FBQ3FGLENBQUMsQ0FBQzBJLENBQUMsQ0FBQ3RZLEtBQUssQ0FBQztJQUN4QnNZLENBQUMsSUFBSSxHQUFHO0lBQ1JBLENBQUMsSUFBSS9OLFFBQVEsQ0FBQ3FGLENBQUMsQ0FBQzBJLENBQUMsQ0FBQ3JZLEdBQUcsQ0FBQztFQUN4QixDQUFDLE1BQU07SUFDTHFZLENBQUMsSUFBSS9OLFFBQVEsQ0FBQ3FGLENBQUMsQ0FBQzBJLENBQUMsQ0FBQ3RZLEtBQUssQ0FBQztJQUN4QnNZLENBQUMsSUFBSS9OLFFBQVEsQ0FBQ3FGLENBQUMsQ0FBQzBJLENBQUMsQ0FBQ3JZLEdBQUcsQ0FBQztFQUN4QjtFQUNBLE9BQU9xWSxDQUFDO0FBQ1Y7QUFFQSxTQUFTOEwsU0FBU0EsQ0FDaEJ4VSxDQUFDLEVBQ0R3bEIsUUFBUSxFQUNSNVEsZUFBZSxFQUNmRCxvQkFBb0IsRUFDcEIrUSxhQUFhLEVBQ2JDLFlBQVksRUFDWjtFQUNBLElBQUlqZCxDQUFDLEdBQUcvTixRQUFRLENBQUNxRixDQUFDLENBQUMwSSxDQUFDLENBQUM5WCxJQUFJLENBQUM7RUFDMUIsSUFBSTQwQixRQUFRLEVBQUU7SUFDWjljLENBQUMsSUFBSSxHQUFHO0lBQ1JBLENBQUMsSUFBSS9OLFFBQVEsQ0FBQ3FGLENBQUMsQ0FBQzBJLENBQUMsQ0FBQzdYLE1BQU0sQ0FBQztJQUN6QixJQUFJbVAsQ0FBQyxDQUFDMEksQ0FBQyxDQUFDM1gsTUFBTSxLQUFLLENBQUMsSUFBSSxDQUFDNmpCLGVBQWUsRUFBRTtNQUN4Q2xNLENBQUMsSUFBSSxHQUFHO0lBQ1Y7RUFDRixDQUFDLE1BQU07SUFDTEEsQ0FBQyxJQUFJL04sUUFBUSxDQUFDcUYsQ0FBQyxDQUFDMEksQ0FBQyxDQUFDN1gsTUFBTSxDQUFDO0VBQzNCO0VBRUEsSUFBSW1QLENBQUMsQ0FBQzBJLENBQUMsQ0FBQzNYLE1BQU0sS0FBSyxDQUFDLElBQUksQ0FBQzZqQixlQUFlLEVBQUU7SUFDeENsTSxDQUFDLElBQUkvTixRQUFRLENBQUNxRixDQUFDLENBQUMwSSxDQUFDLENBQUMzWCxNQUFNLENBQUM7SUFFekIsSUFBSWlQLENBQUMsQ0FBQzBJLENBQUMsQ0FBQ2xTLFdBQVcsS0FBSyxDQUFDLElBQUksQ0FBQ21lLG9CQUFvQixFQUFFO01BQ2xEak0sQ0FBQyxJQUFJLEdBQUc7TUFDUkEsQ0FBQyxJQUFJL04sUUFBUSxDQUFDcUYsQ0FBQyxDQUFDMEksQ0FBQyxDQUFDbFMsV0FBVyxFQUFFLENBQUMsQ0FBQztJQUNuQztFQUNGO0VBRUEsSUFBSWt2QixhQUFhLEVBQUU7SUFDakIsSUFBSTFsQixDQUFDLENBQUMySixhQUFhLElBQUkzSixDQUFDLENBQUNyTixNQUFNLEtBQUssQ0FBQyxJQUFJLENBQUNnekIsWUFBWSxFQUFFO01BQ3REamQsQ0FBQyxJQUFJLEdBQUc7SUFDVixDQUFDLE1BQU0sSUFBSTFJLENBQUMsQ0FBQ0EsQ0FBQyxHQUFHLENBQUMsRUFBRTtNQUNsQjBJLENBQUMsSUFBSSxHQUFHO01BQ1JBLENBQUMsSUFBSS9OLFFBQVEsQ0FBQ3hFLElBQUksQ0FBQ3VNLEtBQUssQ0FBQyxDQUFDMUMsQ0FBQyxDQUFDQSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7TUFDcEMwSSxDQUFDLElBQUksR0FBRztNQUNSQSxDQUFDLElBQUkvTixRQUFRLENBQUN4RSxJQUFJLENBQUN1TSxLQUFLLENBQUMsQ0FBQzFDLENBQUMsQ0FBQ0EsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO0lBQ3RDLENBQUMsTUFBTTtNQUNMMEksQ0FBQyxJQUFJLEdBQUc7TUFDUkEsQ0FBQyxJQUFJL04sUUFBUSxDQUFDeEUsSUFBSSxDQUFDdU0sS0FBSyxDQUFDMUMsQ0FBQyxDQUFDQSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7TUFDbkMwSSxDQUFDLElBQUksR0FBRztNQUNSQSxDQUFDLElBQUkvTixRQUFRLENBQUN4RSxJQUFJLENBQUN1TSxLQUFLLENBQUMxQyxDQUFDLENBQUNBLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztJQUNyQztFQUNGO0VBRUEsSUFBSTJsQixZQUFZLEVBQUU7SUFDaEJqZCxDQUFDLElBQUksR0FBRyxHQUFHMUksQ0FBQyxDQUFDcE0sSUFBSSxDQUFDeEIsUUFBUSxHQUFHLEdBQUc7RUFDbEM7RUFDQSxPQUFPc1csQ0FBQztBQUNWOztBQUVBO0FBQ0EsTUFBTWtkLGlCQUFpQixHQUFHO0lBQ3RCeDFCLEtBQUssRUFBRSxDQUFDO0lBQ1JDLEdBQUcsRUFBRSxDQUFDO0lBQ05PLElBQUksRUFBRSxDQUFDO0lBQ1BDLE1BQU0sRUFBRSxDQUFDO0lBQ1RFLE1BQU0sRUFBRSxDQUFDO0lBQ1R5RixXQUFXLEVBQUU7R0FDZDtFQUNEcXZCLHFCQUFxQixHQUFHO0lBQ3RCN2IsVUFBVSxFQUFFLENBQUM7SUFDYnhaLE9BQU8sRUFBRSxDQUFDO0lBQ1ZJLElBQUksRUFBRSxDQUFDO0lBQ1BDLE1BQU0sRUFBRSxDQUFDO0lBQ1RFLE1BQU0sRUFBRSxDQUFDO0lBQ1R5RixXQUFXLEVBQUU7R0FDZDtFQUNEc3ZCLHdCQUF3QixHQUFHO0lBQ3pCN2IsT0FBTyxFQUFFLENBQUM7SUFDVnJaLElBQUksRUFBRSxDQUFDO0lBQ1BDLE1BQU0sRUFBRSxDQUFDO0lBQ1RFLE1BQU0sRUFBRSxDQUFDO0lBQ1R5RixXQUFXLEVBQUU7R0FDZDs7QUFFSDtBQUNBLE1BQU11dkIsWUFBWSxHQUFHLENBQUMsTUFBTSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsYUFBYSxDQUFDO0VBQ3RGQyxnQkFBZ0IsR0FBRyxDQUNqQixVQUFVLEVBQ1YsWUFBWSxFQUNaLFNBQVMsRUFDVCxNQUFNLEVBQ04sUUFBUSxFQUNSLFFBQVEsRUFDUixhQUFhLENBQ2Q7RUFDREMsbUJBQW1CLEdBQUcsQ0FBQyxNQUFNLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLGFBQWEsQ0FBQzs7QUFFdEY7QUFDQSxTQUFTeFMsYUFBYUEsQ0FBQzdqQixJQUFJLEVBQUU7RUFDM0IsTUFBTTRVLFVBQVUsR0FBRztJQUNqQnJVLElBQUksRUFBRSxNQUFNO0lBQ1o0VixLQUFLLEVBQUUsTUFBTTtJQUNiM1YsS0FBSyxFQUFFLE9BQU87SUFDZHFOLE1BQU0sRUFBRSxPQUFPO0lBQ2ZwTixHQUFHLEVBQUUsS0FBSztJQUNWNlYsSUFBSSxFQUFFLEtBQUs7SUFDWHRWLElBQUksRUFBRSxNQUFNO0lBQ1orVCxLQUFLLEVBQUUsTUFBTTtJQUNiOVQsTUFBTSxFQUFFLFFBQVE7SUFDaEIrVCxPQUFPLEVBQUUsUUFBUTtJQUNqQnNGLE9BQU8sRUFBRSxTQUFTO0lBQ2xCbEUsUUFBUSxFQUFFLFNBQVM7SUFDbkJqVixNQUFNLEVBQUUsUUFBUTtJQUNoQm9WLE9BQU8sRUFBRSxRQUFRO0lBQ2pCM1AsV0FBVyxFQUFFLGFBQWE7SUFDMUI4VyxZQUFZLEVBQUUsYUFBYTtJQUMzQjljLE9BQU8sRUFBRSxTQUFTO0lBQ2xCb04sUUFBUSxFQUFFLFNBQVM7SUFDbkJzb0IsVUFBVSxFQUFFLFlBQVk7SUFDeEJDLFdBQVcsRUFBRSxZQUFZO0lBQ3pCQyxXQUFXLEVBQUUsWUFBWTtJQUN6QkMsUUFBUSxFQUFFLFVBQVU7SUFDcEJDLFNBQVMsRUFBRSxVQUFVO0lBQ3JCcmMsT0FBTyxFQUFFO0VBQ1gsQ0FBQyxDQUFDcmEsSUFBSSxDQUFDMk8sV0FBVyxFQUFFLENBQUM7RUFFckIsSUFBSSxDQUFDaUcsVUFBVSxFQUFFLE1BQU0sSUFBSTdVLGdCQUFnQixDQUFDQyxJQUFJLENBQUM7RUFFakQsT0FBTzRVLFVBQVU7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUytoQixPQUFPQSxDQUFDcGxCLEdBQUcsRUFBRTNPLElBQUksRUFBRTtFQUMxQixNQUFNb0IsSUFBSSxHQUFHd0wsYUFBYSxDQUFDNU0sSUFBSSxDQUFDb0IsSUFBSSxFQUFFbUksUUFBUSxDQUFDdUQsV0FBVyxDQUFDO0lBQ3pEaEcsR0FBRyxHQUFHcUMsTUFBTSxDQUFDVyxVQUFVLENBQUM5SixJQUFJLENBQUM7SUFDN0JnMEIsS0FBSyxHQUFHenFCLFFBQVEsQ0FBQzJELEdBQUcsRUFBRTtFQUV4QixJQUFJbk4sRUFBRSxFQUFFeU4sQ0FBQzs7RUFFVDtFQUNBLElBQUksQ0FBQzNLLFdBQVcsQ0FBQzhMLEdBQUcsQ0FBQ2hSLElBQUksQ0FBQyxFQUFFO0lBQzFCLEtBQUssTUFBTXNVLENBQUMsSUFBSXNoQixZQUFZLEVBQUU7TUFDNUIsSUFBSTF3QixXQUFXLENBQUM4TCxHQUFHLENBQUNzRCxDQUFDLENBQUMsQ0FBQyxFQUFFO1FBQ3ZCdEQsR0FBRyxDQUFDc0QsQ0FBQyxDQUFDLEdBQUdtaEIsaUJBQWlCLENBQUNuaEIsQ0FBQyxDQUFDO01BQy9CO0lBQ0Y7SUFFQSxNQUFNOE8sT0FBTyxHQUFHOFAsdUJBQXVCLENBQUNsaUIsR0FBRyxDQUFDLElBQUlxaUIsa0JBQWtCLENBQUNyaUIsR0FBRyxDQUFDO0lBQ3ZFLElBQUlvUyxPQUFPLEVBQUU7TUFDWCxPQUFPdGEsUUFBUSxDQUFDc2EsT0FBTyxDQUFDQSxPQUFPLENBQUM7SUFDbEM7SUFFQSxNQUFNa1QsWUFBWSxHQUFHN3lCLElBQUksQ0FBQ2pCLE1BQU0sQ0FBQzZ6QixLQUFLLENBQUM7SUFDdkMsQ0FBQ2owQixFQUFFLEVBQUV5TixDQUFDLENBQUMsR0FBR2dsQixPQUFPLENBQUM3akIsR0FBRyxFQUFFc2xCLFlBQVksRUFBRTd5QixJQUFJLENBQUM7RUFDNUMsQ0FBQyxNQUFNO0lBQ0xyQixFQUFFLEdBQUdpMEIsS0FBSztFQUNaO0VBRUEsT0FBTyxJQUFJdnRCLFFBQVEsQ0FBQztJQUFFMUcsRUFBRTtJQUFFcUIsSUFBSTtJQUFFMEYsR0FBRztJQUFFMEc7RUFBRSxDQUFDLENBQUM7QUFDM0M7QUFFQSxTQUFTMG1CLFlBQVlBLENBQUN2ZCxLQUFLLEVBQUVFLEdBQUcsRUFBRTdXLElBQUksRUFBRTtFQUN0QyxNQUFNbVEsS0FBSyxHQUFHdE4sV0FBVyxDQUFDN0MsSUFBSSxDQUFDbVEsS0FBSyxDQUFDLEdBQUcsSUFBSSxHQUFHblEsSUFBSSxDQUFDbVEsS0FBSztJQUN2RGpRLE1BQU0sR0FBR0EsQ0FBQ2dXLENBQUMsRUFBRTlZLElBQUksS0FBSztNQUNwQjhZLENBQUMsR0FBR2hPLE9BQU8sQ0FBQ2dPLENBQUMsRUFBRS9GLEtBQUssSUFBSW5RLElBQUksQ0FBQ20wQixTQUFTLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxJQUFJLENBQUM7TUFDckQsTUFBTWxGLFNBQVMsR0FBR3BZLEdBQUcsQ0FBQy9QLEdBQUcsQ0FBQzhELEtBQUssQ0FBQzVLLElBQUksQ0FBQyxDQUFDaU0sWUFBWSxDQUFDak0sSUFBSSxDQUFDO01BQ3hELE9BQU9pdkIsU0FBUyxDQUFDL3VCLE1BQU0sQ0FBQ2dXLENBQUMsRUFBRTlZLElBQUksQ0FBQztLQUNqQztJQUNEeXJCLE1BQU0sR0FBSXpyQixJQUFJLElBQUs7TUFDakIsSUFBSTRDLElBQUksQ0FBQ20wQixTQUFTLEVBQUU7UUFDbEIsSUFBSSxDQUFDdGQsR0FBRyxDQUFDdU8sT0FBTyxDQUFDek8sS0FBSyxFQUFFdlosSUFBSSxDQUFDLEVBQUU7VUFDN0IsT0FBT3laLEdBQUcsQ0FBQ3FPLE9BQU8sQ0FBQzluQixJQUFJLENBQUMsQ0FBQytuQixJQUFJLENBQUN4TyxLQUFLLENBQUN1TyxPQUFPLENBQUM5bkIsSUFBSSxDQUFDLEVBQUVBLElBQUksQ0FBQyxDQUFDNGEsR0FBRyxDQUFDNWEsSUFBSSxDQUFDO1NBQ25FLE1BQU0sT0FBTyxDQUFDO01BQ2pCLENBQUMsTUFBTTtRQUNMLE9BQU95WixHQUFHLENBQUNzTyxJQUFJLENBQUN4TyxLQUFLLEVBQUV2WixJQUFJLENBQUMsQ0FBQzRhLEdBQUcsQ0FBQzVhLElBQUksQ0FBQztNQUN4QztLQUNEO0VBRUgsSUFBSTRDLElBQUksQ0FBQzVDLElBQUksRUFBRTtJQUNiLE9BQU84QyxNQUFNLENBQUMyb0IsTUFBTSxDQUFDN29CLElBQUksQ0FBQzVDLElBQUksQ0FBQyxFQUFFNEMsSUFBSSxDQUFDNUMsSUFBSSxDQUFDO0VBQzdDO0VBRUEsS0FBSyxNQUFNQSxJQUFJLElBQUk0QyxJQUFJLENBQUNzVCxLQUFLLEVBQUU7SUFDN0IsTUFBTXRLLEtBQUssR0FBRzZmLE1BQU0sQ0FBQ3pyQixJQUFJLENBQUM7SUFDMUIsSUFBSXVHLElBQUksQ0FBQ0MsR0FBRyxDQUFDb0YsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO01BQ3hCLE9BQU85SSxNQUFNLENBQUM4SSxLQUFLLEVBQUU1TCxJQUFJLENBQUM7SUFDNUI7RUFDRjtFQUNBLE9BQU84QyxNQUFNLENBQUN5VyxLQUFLLEdBQUdFLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUU3VyxJQUFJLENBQUNzVCxLQUFLLENBQUN0VCxJQUFJLENBQUNzVCxLQUFLLENBQUM1USxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDeEU7QUFFQSxTQUFTMHhCLFFBQVFBLENBQUNDLE9BQU8sRUFBRTtFQUN6QixJQUFJcjBCLElBQUksR0FBRyxFQUFFO0lBQ1hzMEIsSUFBSTtFQUNOLElBQUlELE9BQU8sQ0FBQzN4QixNQUFNLEdBQUcsQ0FBQyxJQUFJLE9BQU8yeEIsT0FBTyxDQUFDQSxPQUFPLENBQUMzeEIsTUFBTSxHQUFHLENBQUMsQ0FBQyxLQUFLLFFBQVEsRUFBRTtJQUN6RTFDLElBQUksR0FBR3EwQixPQUFPLENBQUNBLE9BQU8sQ0FBQzN4QixNQUFNLEdBQUcsQ0FBQyxDQUFDO0lBQ2xDNHhCLElBQUksR0FBR3RtQixLQUFLLENBQUN1bUIsSUFBSSxDQUFDRixPQUFPLENBQUMsQ0FBQzljLEtBQUssQ0FBQyxDQUFDLEVBQUU4YyxPQUFPLENBQUMzeEIsTUFBTSxHQUFHLENBQUMsQ0FBQztFQUN6RCxDQUFDLE1BQU07SUFDTDR4QixJQUFJLEdBQUd0bUIsS0FBSyxDQUFDdW1CLElBQUksQ0FBQ0YsT0FBTyxDQUFDO0VBQzVCO0VBQ0EsT0FBTyxDQUFDcjBCLElBQUksRUFBRXMwQixJQUFJLENBQUM7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlLE1BQU03dEIsUUFBUSxDQUFDO0VBQzVCO0FBQ0Y7QUFDQTtFQUNFNUosV0FBV0EsQ0FBQ2drQixNQUFNLEVBQUU7SUFDbEIsTUFBTXpmLElBQUksR0FBR3lmLE1BQU0sQ0FBQ3pmLElBQUksSUFBSW1JLFFBQVEsQ0FBQ3VELFdBQVc7SUFFaEQsSUFBSWlVLE9BQU8sR0FDVEYsTUFBTSxDQUFDRSxPQUFPLEtBQ2J2UCxNQUFNLENBQUNoTyxLQUFLLENBQUNxZCxNQUFNLENBQUM5Z0IsRUFBRSxDQUFDLEdBQUcsSUFBSXlZLE9BQU8sQ0FBQyxlQUFlLENBQUMsR0FBRyxJQUFJLENBQUMsS0FDOUQsQ0FBQ3BYLElBQUksQ0FBQ2QsT0FBTyxHQUFHaXhCLGVBQWUsQ0FBQ253QixJQUFJLENBQUMsR0FBRyxJQUFJLENBQUM7SUFDaEQ7QUFDSjtBQUNBO0lBQ0ksSUFBSSxDQUFDckIsRUFBRSxHQUFHOEMsV0FBVyxDQUFDZ2UsTUFBTSxDQUFDOWdCLEVBQUUsQ0FBQyxHQUFHd0osUUFBUSxDQUFDMkQsR0FBRyxFQUFFLEdBQUcyVCxNQUFNLENBQUM5Z0IsRUFBRTtJQUU3RCxJQUFJbVcsQ0FBQyxHQUFHLElBQUk7TUFDVjFJLENBQUMsR0FBRyxJQUFJO0lBQ1YsSUFBSSxDQUFDdVQsT0FBTyxFQUFFO01BQ1osTUFBTXlULFNBQVMsR0FBRzNULE1BQU0sQ0FBQzZRLEdBQUcsSUFBSTdRLE1BQU0sQ0FBQzZRLEdBQUcsQ0FBQzN4QixFQUFFLEtBQUssSUFBSSxDQUFDQSxFQUFFLElBQUk4Z0IsTUFBTSxDQUFDNlEsR0FBRyxDQUFDdHdCLElBQUksQ0FBQ2hCLE1BQU0sQ0FBQ2dCLElBQUksQ0FBQztNQUV6RixJQUFJb3pCLFNBQVMsRUFBRTtRQUNiLENBQUN0ZSxDQUFDLEVBQUUxSSxDQUFDLENBQUMsR0FBRyxDQUFDcVQsTUFBTSxDQUFDNlEsR0FBRyxDQUFDeGIsQ0FBQyxFQUFFMkssTUFBTSxDQUFDNlEsR0FBRyxDQUFDbGtCLENBQUMsQ0FBQztNQUN2QyxDQUFDLE1BQU07UUFDTCxNQUFNaW5CLEVBQUUsR0FBR3J6QixJQUFJLENBQUNqQixNQUFNLENBQUMsSUFBSSxDQUFDSixFQUFFLENBQUM7UUFDL0JtVyxDQUFDLEdBQUcrYixPQUFPLENBQUMsSUFBSSxDQUFDbHlCLEVBQUUsRUFBRTAwQixFQUFFLENBQUM7UUFDeEIxVCxPQUFPLEdBQUd2UCxNQUFNLENBQUNoTyxLQUFLLENBQUMwUyxDQUFDLENBQUN2WSxJQUFJLENBQUMsR0FBRyxJQUFJNmEsT0FBTyxDQUFDLGVBQWUsQ0FBQyxHQUFHLElBQUk7UUFDcEV0QyxDQUFDLEdBQUc2SyxPQUFPLEdBQUcsSUFBSSxHQUFHN0ssQ0FBQztRQUN0QjFJLENBQUMsR0FBR3VULE9BQU8sR0FBRyxJQUFJLEdBQUcwVCxFQUFFO01BQ3pCO0lBQ0Y7O0lBRUE7QUFDSjtBQUNBO0lBQ0ksSUFBSSxDQUFDQyxLQUFLLEdBQUd0ekIsSUFBSTtJQUNqQjtBQUNKO0FBQ0E7SUFDSSxJQUFJLENBQUMwRixHQUFHLEdBQUcrWixNQUFNLENBQUMvWixHQUFHLElBQUlxQyxNQUFNLENBQUNsRyxNQUFNLEVBQUU7SUFDeEM7QUFDSjtBQUNBO0lBQ0ksSUFBSSxDQUFDOGQsT0FBTyxHQUFHQSxPQUFPO0lBQ3RCO0FBQ0o7QUFDQTtJQUNJLElBQUksQ0FBQ2lQLFFBQVEsR0FBRyxJQUFJO0lBQ3BCO0FBQ0o7QUFDQTtJQUNJLElBQUksQ0FBQzlaLENBQUMsR0FBR0EsQ0FBQztJQUNWO0FBQ0o7QUFDQTtJQUNJLElBQUksQ0FBQzFJLENBQUMsR0FBR0EsQ0FBQztJQUNWO0FBQ0o7QUFDQTtJQUNJLElBQUksQ0FBQ21uQixlQUFlLEdBQUcsSUFBSTtFQUM3Qjs7RUFFQTs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFLE9BQU96bkIsR0FBR0EsQ0FBQSxFQUFHO0lBQ1gsT0FBTyxJQUFJekcsUUFBUSxDQUFDLEVBQUUsQ0FBQztFQUN6Qjs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRSxPQUFPdVUsS0FBS0EsQ0FBQSxFQUFHO0lBQ2IsTUFBTSxDQUFDaGIsSUFBSSxFQUFFczBCLElBQUksQ0FBQyxHQUFHRixRQUFRLENBQUNRLFNBQVMsQ0FBQztNQUN0QyxDQUFDajNCLElBQUksRUFBRUMsS0FBSyxFQUFFQyxHQUFHLEVBQUVPLElBQUksRUFBRUMsTUFBTSxFQUFFRSxNQUFNLEVBQUV5RixXQUFXLENBQUMsR0FBR3N3QixJQUFJO0lBQzlELE9BQU9QLE9BQU8sQ0FBQztNQUFFcDJCLElBQUk7TUFBRUMsS0FBSztNQUFFQyxHQUFHO01BQUVPLElBQUk7TUFBRUMsTUFBTTtNQUFFRSxNQUFNO01BQUV5RjtLQUFhLEVBQUVoRSxJQUFJLENBQUM7RUFDL0U7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0UsT0FBTzBHLEdBQUdBLENBQUEsRUFBRztJQUNYLE1BQU0sQ0FBQzFHLElBQUksRUFBRXMwQixJQUFJLENBQUMsR0FBR0YsUUFBUSxDQUFDUSxTQUFTLENBQUM7TUFDdEMsQ0FBQ2ozQixJQUFJLEVBQUVDLEtBQUssRUFBRUMsR0FBRyxFQUFFTyxJQUFJLEVBQUVDLE1BQU0sRUFBRUUsTUFBTSxFQUFFeUYsV0FBVyxDQUFDLEdBQUdzd0IsSUFBSTtJQUU5RHQwQixJQUFJLENBQUNvQixJQUFJLEdBQUdpTCxlQUFlLENBQUNDLFdBQVc7SUFDdkMsT0FBT3luQixPQUFPLENBQUM7TUFBRXAyQixJQUFJO01BQUVDLEtBQUs7TUFBRUMsR0FBRztNQUFFTyxJQUFJO01BQUVDLE1BQU07TUFBRUUsTUFBTTtNQUFFeUY7S0FBYSxFQUFFaEUsSUFBSSxDQUFDO0VBQy9FOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0UsT0FBTzYwQixVQUFVQSxDQUFDbnpCLElBQUksRUFBRW1FLE9BQU8sR0FBRyxFQUFFLEVBQUU7SUFDcEMsTUFBTTlGLEVBQUUsR0FBRzJOLE1BQU0sQ0FBQ2hNLElBQUksQ0FBQyxHQUFHQSxJQUFJLENBQUMrZ0IsT0FBTyxFQUFFLEdBQUdoZixHQUFHO0lBQzlDLElBQUkrTixNQUFNLENBQUNoTyxLQUFLLENBQUN6RCxFQUFFLENBQUMsRUFBRTtNQUNwQixPQUFPMEcsUUFBUSxDQUFDc2EsT0FBTyxDQUFDLGVBQWUsQ0FBQztJQUMxQztJQUVBLE1BQU0rVCxTQUFTLEdBQUdsb0IsYUFBYSxDQUFDL0csT0FBTyxDQUFDekUsSUFBSSxFQUFFbUksUUFBUSxDQUFDdUQsV0FBVyxDQUFDO0lBQ25FLElBQUksQ0FBQ2dvQixTQUFTLENBQUN4MEIsT0FBTyxFQUFFO01BQ3RCLE9BQU9tRyxRQUFRLENBQUNzYSxPQUFPLENBQUN3USxlQUFlLENBQUN1RCxTQUFTLENBQUMsQ0FBQztJQUNyRDtJQUVBLE9BQU8sSUFBSXJ1QixRQUFRLENBQUM7TUFDbEIxRyxFQUFFLEVBQUVBLEVBQUU7TUFDTnFCLElBQUksRUFBRTB6QixTQUFTO01BQ2ZodUIsR0FBRyxFQUFFcUMsTUFBTSxDQUFDVyxVQUFVLENBQUNqRSxPQUFPO0lBQ2hDLENBQUMsQ0FBQztFQUNKOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0UsT0FBTzRDLFVBQVVBLENBQUNxUyxZQUFZLEVBQUVqVixPQUFPLEdBQUcsRUFBRSxFQUFFO0lBQzVDLElBQUksQ0FBQ29ILFFBQVEsQ0FBQzZOLFlBQVksQ0FBQyxFQUFFO01BQzNCLE1BQU0sSUFBSXpkLG9CQUFvQixDQUMzQix5REFBd0QsT0FBT3lkLFlBQWEsZUFBY0EsWUFBYSxFQUFDLENBQzFHO0tBQ0YsTUFBTSxJQUFJQSxZQUFZLEdBQUcsQ0FBQ3dXLFFBQVEsSUFBSXhXLFlBQVksR0FBR3dXLFFBQVEsRUFBRTtNQUM5RDtNQUNBLE9BQU83cUIsUUFBUSxDQUFDc2EsT0FBTyxDQUFDLHdCQUF3QixDQUFDO0lBQ25ELENBQUMsTUFBTTtNQUNMLE9BQU8sSUFBSXRhLFFBQVEsQ0FBQztRQUNsQjFHLEVBQUUsRUFBRSthLFlBQVk7UUFDaEIxWixJQUFJLEVBQUV3TCxhQUFhLENBQUMvRyxPQUFPLENBQUN6RSxJQUFJLEVBQUVtSSxRQUFRLENBQUN1RCxXQUFXLENBQUM7UUFDdkRoRyxHQUFHLEVBQUVxQyxNQUFNLENBQUNXLFVBQVUsQ0FBQ2pFLE9BQU87TUFDaEMsQ0FBQyxDQUFDO0lBQ0o7RUFDRjs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFLE9BQU9rdkIsV0FBV0EsQ0FBQ3BoQixPQUFPLEVBQUU5TixPQUFPLEdBQUcsRUFBRSxFQUFFO0lBQ3hDLElBQUksQ0FBQ29ILFFBQVEsQ0FBQzBHLE9BQU8sQ0FBQyxFQUFFO01BQ3RCLE1BQU0sSUFBSXRXLG9CQUFvQixDQUFDLHdDQUF3QyxDQUFDO0lBQzFFLENBQUMsTUFBTTtNQUNMLE9BQU8sSUFBSW9KLFFBQVEsQ0FBQztRQUNsQjFHLEVBQUUsRUFBRTRULE9BQU8sR0FBRyxJQUFJO1FBQ2xCdlMsSUFBSSxFQUFFd0wsYUFBYSxDQUFDL0csT0FBTyxDQUFDekUsSUFBSSxFQUFFbUksUUFBUSxDQUFDdUQsV0FBVyxDQUFDO1FBQ3ZEaEcsR0FBRyxFQUFFcUMsTUFBTSxDQUFDVyxVQUFVLENBQUNqRSxPQUFPO01BQ2hDLENBQUMsQ0FBQztJQUNKO0VBQ0Y7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRSxPQUFPaUUsVUFBVUEsQ0FBQzZFLEdBQUcsRUFBRTNPLElBQUksR0FBRyxFQUFFLEVBQUU7SUFDaEMyTyxHQUFHLEdBQUdBLEdBQUcsSUFBSSxFQUFFO0lBQ2YsTUFBTW1tQixTQUFTLEdBQUdsb0IsYUFBYSxDQUFDNU0sSUFBSSxDQUFDb0IsSUFBSSxFQUFFbUksUUFBUSxDQUFDdUQsV0FBVyxDQUFDO0lBQ2hFLElBQUksQ0FBQ2dvQixTQUFTLENBQUN4MEIsT0FBTyxFQUFFO01BQ3RCLE9BQU9tRyxRQUFRLENBQUNzYSxPQUFPLENBQUN3USxlQUFlLENBQUN1RCxTQUFTLENBQUMsQ0FBQztJQUNyRDtJQUVBLE1BQU1kLEtBQUssR0FBR3pxQixRQUFRLENBQUMyRCxHQUFHLEVBQUU7TUFDMUIrbUIsWUFBWSxHQUFHLENBQUNweEIsV0FBVyxDQUFDN0MsSUFBSSxDQUFDZ3VCLGNBQWMsQ0FBQyxHQUM1Q2h1QixJQUFJLENBQUNndUIsY0FBYyxHQUNuQjhHLFNBQVMsQ0FBQzMwQixNQUFNLENBQUM2ekIsS0FBSyxDQUFDO01BQzNCaGlCLFVBQVUsR0FBR0YsZUFBZSxDQUFDbkQsR0FBRyxFQUFFc1MsYUFBYSxDQUFDO01BQ2hEK1QsZUFBZSxHQUFHLENBQUNueUIsV0FBVyxDQUFDbVAsVUFBVSxDQUFDeUYsT0FBTyxDQUFDO01BQ2xEd2Qsa0JBQWtCLEdBQUcsQ0FBQ3B5QixXQUFXLENBQUNtUCxVQUFVLENBQUNyVSxJQUFJLENBQUM7TUFDbER1M0IsZ0JBQWdCLEdBQUcsQ0FBQ3J5QixXQUFXLENBQUNtUCxVQUFVLENBQUNwVSxLQUFLLENBQUMsSUFBSSxDQUFDaUYsV0FBVyxDQUFDbVAsVUFBVSxDQUFDblUsR0FBRyxDQUFDO01BQ2pGczNCLGNBQWMsR0FBR0Ysa0JBQWtCLElBQUlDLGdCQUFnQjtNQUN2REUsZUFBZSxHQUFHcGpCLFVBQVUsQ0FBQ2xCLFFBQVEsSUFBSWtCLFVBQVUsQ0FBQ3dGLFVBQVU7TUFDOUQxUSxHQUFHLEdBQUdxQyxNQUFNLENBQUNXLFVBQVUsQ0FBQzlKLElBQUksQ0FBQzs7SUFFL0I7SUFDQTtJQUNBO0lBQ0E7SUFDQTs7SUFFQSxJQUFJLENBQUNtMUIsY0FBYyxJQUFJSCxlQUFlLEtBQUtJLGVBQWUsRUFBRTtNQUMxRCxNQUFNLElBQUlsNEIsNkJBQTZCLENBQ3JDLHFFQUFxRSxDQUN0RTtJQUNIO0lBRUEsSUFBSWc0QixnQkFBZ0IsSUFBSUYsZUFBZSxFQUFFO01BQ3ZDLE1BQU0sSUFBSTkzQiw2QkFBNkIsQ0FBQyx3Q0FBd0MsQ0FBQztJQUNuRjtJQUVBLE1BQU1tNEIsV0FBVyxHQUFHRCxlQUFlLElBQUtwakIsVUFBVSxDQUFDaFUsT0FBTyxJQUFJLENBQUNtM0IsY0FBZTs7SUFFOUU7SUFDQSxJQUFJN2hCLEtBQUs7TUFDUGdpQixhQUFhO01BQ2JDLE1BQU0sR0FBR3RELE9BQU8sQ0FBQytCLEtBQUssRUFBRUMsWUFBWSxDQUFDO0lBQ3ZDLElBQUlvQixXQUFXLEVBQUU7TUFDZi9oQixLQUFLLEdBQUdrZ0IsZ0JBQWdCO01BQ3hCOEIsYUFBYSxHQUFHakMscUJBQXFCO01BQ3JDa0MsTUFBTSxHQUFHMUYsZUFBZSxDQUFDMEYsTUFBTSxDQUFDO0tBQ2pDLE1BQU0sSUFBSVAsZUFBZSxFQUFFO01BQzFCMWhCLEtBQUssR0FBR21nQixtQkFBbUI7TUFDM0I2QixhQUFhLEdBQUdoQyx3QkFBd0I7TUFDeENpQyxNQUFNLEdBQUdwRixrQkFBa0IsQ0FBQ29GLE1BQU0sQ0FBQztJQUNyQyxDQUFDLE1BQU07TUFDTGppQixLQUFLLEdBQUdpZ0IsWUFBWTtNQUNwQitCLGFBQWEsR0FBR2xDLGlCQUFpQjtJQUNuQzs7SUFFQTtJQUNBLElBQUlvQyxVQUFVLEdBQUcsS0FBSztJQUN0QixLQUFLLE1BQU12akIsQ0FBQyxJQUFJcUIsS0FBSyxFQUFFO01BQ3JCLE1BQU1wQixDQUFDLEdBQUdGLFVBQVUsQ0FBQ0MsQ0FBQyxDQUFDO01BQ3ZCLElBQUksQ0FBQ3BQLFdBQVcsQ0FBQ3FQLENBQUMsQ0FBQyxFQUFFO1FBQ25Cc2pCLFVBQVUsR0FBRyxJQUFJO09BQ2xCLE1BQU0sSUFBSUEsVUFBVSxFQUFFO1FBQ3JCeGpCLFVBQVUsQ0FBQ0MsQ0FBQyxDQUFDLEdBQUdxakIsYUFBYSxDQUFDcmpCLENBQUMsQ0FBQztNQUNsQyxDQUFDLE1BQU07UUFDTEQsVUFBVSxDQUFDQyxDQUFDLENBQUMsR0FBR3NqQixNQUFNLENBQUN0akIsQ0FBQyxDQUFDO01BQzNCO0lBQ0Y7O0lBRUE7SUFDQSxNQUFNd2pCLGtCQUFrQixHQUFHSixXQUFXLEdBQ2hDOUUsa0JBQWtCLENBQUN2ZSxVQUFVLENBQUMsR0FDOUJnakIsZUFBZSxHQUNmckUscUJBQXFCLENBQUMzZSxVQUFVLENBQUMsR0FDakM2ZSx1QkFBdUIsQ0FBQzdlLFVBQVUsQ0FBQztNQUN2QytPLE9BQU8sR0FBRzBVLGtCQUFrQixJQUFJekUsa0JBQWtCLENBQUNoZixVQUFVLENBQUM7SUFFaEUsSUFBSStPLE9BQU8sRUFBRTtNQUNYLE9BQU90YSxRQUFRLENBQUNzYSxPQUFPLENBQUNBLE9BQU8sQ0FBQztJQUNsQzs7SUFFQTtJQUNBLE1BQU0yVSxTQUFTLEdBQUdMLFdBQVcsR0FDdkJ0RixlQUFlLENBQUMvZCxVQUFVLENBQUMsR0FDM0JnakIsZUFBZSxHQUNmM0Usa0JBQWtCLENBQUNyZSxVQUFVLENBQUMsR0FDOUJBLFVBQVU7TUFDZCxDQUFDMmpCLE9BQU8sRUFBRUMsV0FBVyxDQUFDLEdBQUdwRCxPQUFPLENBQUNrRCxTQUFTLEVBQUV6QixZQUFZLEVBQUVhLFNBQVMsQ0FBQztNQUNwRXJELElBQUksR0FBRyxJQUFJaHJCLFFBQVEsQ0FBQztRQUNsQjFHLEVBQUUsRUFBRTQxQixPQUFPO1FBQ1h2MEIsSUFBSSxFQUFFMHpCLFNBQVM7UUFDZnRuQixDQUFDLEVBQUVvb0IsV0FBVztRQUNkOXVCO01BQ0YsQ0FBQyxDQUFDOztJQUVKO0lBQ0EsSUFBSWtMLFVBQVUsQ0FBQ2hVLE9BQU8sSUFBSW0zQixjQUFjLElBQUl4bUIsR0FBRyxDQUFDM1EsT0FBTyxLQUFLeXpCLElBQUksQ0FBQ3p6QixPQUFPLEVBQUU7TUFDeEUsT0FBT3lJLFFBQVEsQ0FBQ3NhLE9BQU8sQ0FDckIsb0JBQW9CLEVBQ21CLHVDQUFBL08sVUFBVSxDQUFDaFUsT0FBUSxrQkFBaUJ5ekIsSUFBSSxDQUFDMVAsS0FBSyxFQUFHLEVBQUMsQ0FDMUY7SUFDSDtJQUVBLE9BQU8wUCxJQUFJO0VBQ2I7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRSxPQUFPcFEsT0FBT0EsQ0FBQ0MsSUFBSSxFQUFFdGhCLElBQUksR0FBRyxFQUFFLEVBQUU7SUFDOUIsTUFBTSxDQUFDd2dCLElBQUksRUFBRXFTLFVBQVUsQ0FBQyxHQUFHM1UsWUFBWSxDQUFDb0QsSUFBSSxDQUFDO0lBQzdDLE9BQU9zUixtQkFBbUIsQ0FBQ3BTLElBQUksRUFBRXFTLFVBQVUsRUFBRTd5QixJQUFJLEVBQUUsVUFBVSxFQUFFc2hCLElBQUksQ0FBQztFQUN0RTs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0UsT0FBT3VVLFdBQVdBLENBQUN2VSxJQUFJLEVBQUV0aEIsSUFBSSxHQUFHLEVBQUUsRUFBRTtJQUNsQyxNQUFNLENBQUN3Z0IsSUFBSSxFQUFFcVMsVUFBVSxDQUFDLEdBQUcxVSxnQkFBZ0IsQ0FBQ21ELElBQUksQ0FBQztJQUNqRCxPQUFPc1IsbUJBQW1CLENBQUNwUyxJQUFJLEVBQUVxUyxVQUFVLEVBQUU3eUIsSUFBSSxFQUFFLFVBQVUsRUFBRXNoQixJQUFJLENBQUM7RUFDdEU7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0UsT0FBT3dVLFFBQVFBLENBQUN4VSxJQUFJLEVBQUV0aEIsSUFBSSxHQUFHLEVBQUUsRUFBRTtJQUMvQixNQUFNLENBQUN3Z0IsSUFBSSxFQUFFcVMsVUFBVSxDQUFDLEdBQUd6VSxhQUFhLENBQUNrRCxJQUFJLENBQUM7SUFDOUMsT0FBT3NSLG1CQUFtQixDQUFDcFMsSUFBSSxFQUFFcVMsVUFBVSxFQUFFN3lCLElBQUksRUFBRSxNQUFNLEVBQUVBLElBQUksQ0FBQztFQUNsRTs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFLE9BQU8rMUIsVUFBVUEsQ0FBQ3pVLElBQUksRUFBRXhMLEdBQUcsRUFBRTlWLElBQUksR0FBRyxFQUFFLEVBQUU7SUFDdEMsSUFBSTZDLFdBQVcsQ0FBQ3llLElBQUksQ0FBQyxJQUFJemUsV0FBVyxDQUFDaVQsR0FBRyxDQUFDLEVBQUU7TUFDekMsTUFBTSxJQUFJelksb0JBQW9CLENBQUMsa0RBQWtELENBQUM7SUFDcEY7SUFFQSxNQUFNO1FBQUV5RCxNQUFNLEdBQUcsSUFBSTtRQUFFa0YsZUFBZSxHQUFHO01BQUssQ0FBQyxHQUFHaEcsSUFBSTtNQUNwRGcyQixXQUFXLEdBQUc3c0IsTUFBTSxDQUFDQyxRQUFRLENBQUM7UUFDNUJ0SSxNQUFNO1FBQ05rRixlQUFlO1FBQ2ZxRCxXQUFXLEVBQUU7TUFDZixDQUFDLENBQUM7TUFDRixDQUFDbVgsSUFBSSxFQUFFcVMsVUFBVSxFQUFFN0UsY0FBYyxFQUFFak4sT0FBTyxDQUFDLEdBQUdpTyxlQUFlLENBQUNnSCxXQUFXLEVBQUUxVSxJQUFJLEVBQUV4TCxHQUFHLENBQUM7SUFDdkYsSUFBSWlMLE9BQU8sRUFBRTtNQUNYLE9BQU90YSxRQUFRLENBQUNzYSxPQUFPLENBQUNBLE9BQU8sQ0FBQztJQUNsQyxDQUFDLE1BQU07TUFDTCxPQUFPNlIsbUJBQW1CLENBQUNwUyxJQUFJLEVBQUVxUyxVQUFVLEVBQUU3eUIsSUFBSSxFQUFHLFVBQVM4VixHQUFLLElBQUV3TCxJQUFJLEVBQUUwTSxjQUFjLENBQUM7SUFDM0Y7RUFDRjs7RUFFQTtBQUNGO0FBQ0E7RUFDRSxPQUFPaUksVUFBVUEsQ0FBQzNVLElBQUksRUFBRXhMLEdBQUcsRUFBRTlWLElBQUksR0FBRyxFQUFFLEVBQUU7SUFDdEMsT0FBT3lHLFFBQVEsQ0FBQ3N2QixVQUFVLENBQUN6VSxJQUFJLEVBQUV4TCxHQUFHLEVBQUU5VixJQUFJLENBQUM7RUFDN0M7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFLE9BQU9rMkIsT0FBT0EsQ0FBQzVVLElBQUksRUFBRXRoQixJQUFJLEdBQUcsRUFBRSxFQUFFO0lBQzlCLE1BQU0sQ0FBQ3dnQixJQUFJLEVBQUVxUyxVQUFVLENBQUMsR0FBR2xVLFFBQVEsQ0FBQzJDLElBQUksQ0FBQztJQUN6QyxPQUFPc1IsbUJBQW1CLENBQUNwUyxJQUFJLEVBQUVxUyxVQUFVLEVBQUU3eUIsSUFBSSxFQUFFLEtBQUssRUFBRXNoQixJQUFJLENBQUM7RUFDakU7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0UsT0FBT1AsT0FBT0EsQ0FBQ2prQixNQUFNLEVBQUUyYixXQUFXLEdBQUcsSUFBSSxFQUFFO0lBQ3pDLElBQUksQ0FBQzNiLE1BQU0sRUFBRTtNQUNYLE1BQU0sSUFBSU8sb0JBQW9CLENBQUMsa0RBQWtELENBQUM7SUFDcEY7SUFFQSxNQUFNMGpCLE9BQU8sR0FBR2prQixNQUFNLFlBQVkwYixPQUFPLEdBQUcxYixNQUFNLEdBQUcsSUFBSTBiLE9BQU8sQ0FBQzFiLE1BQU0sRUFBRTJiLFdBQVcsQ0FBQztJQUVyRixJQUFJbFAsUUFBUSxDQUFDNkQsY0FBYyxFQUFFO01BQzNCLE1BQU0sSUFBSXhRLG9CQUFvQixDQUFDbWtCLE9BQU8sQ0FBQztJQUN6QyxDQUFDLE1BQU07TUFDTCxPQUFPLElBQUl0YSxRQUFRLENBQUM7UUFBRXNhO01BQVEsQ0FBQyxDQUFDO0lBQ2xDO0VBQ0Y7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUNFLE9BQU9vVixVQUFVQSxDQUFDM29CLENBQUMsRUFBRTtJQUNuQixPQUFRQSxDQUFDLElBQUlBLENBQUMsQ0FBQ21uQixlQUFlLElBQUssS0FBSztFQUMxQzs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRSxPQUFPeUIsa0JBQWtCQSxDQUFDaGdCLFVBQVUsRUFBRWlnQixVQUFVLEdBQUcsRUFBRSxFQUFFO0lBQ3JELE1BQU1DLFNBQVMsR0FBRzVILGtCQUFrQixDQUFDdFksVUFBVSxFQUFFak4sTUFBTSxDQUFDVyxVQUFVLENBQUN1c0IsVUFBVSxDQUFDLENBQUM7SUFDL0UsT0FBTyxDQUFDQyxTQUFTLEdBQUcsSUFBSSxHQUFHQSxTQUFTLENBQUNockIsR0FBRyxDQUFFZ0MsQ0FBQyxJQUFNQSxDQUFDLEdBQUdBLENBQUMsQ0FBQ2tILEdBQUcsR0FBRyxJQUFLLENBQUMsQ0FBQ3NYLElBQUksQ0FBQyxFQUFFLENBQUM7RUFDOUU7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRSxPQUFPeUssWUFBWUEsQ0FBQ3pnQixHQUFHLEVBQUV1Z0IsVUFBVSxHQUFHLEVBQUUsRUFBRTtJQUN4QyxNQUFNRyxRQUFRLEdBQUc3SCxpQkFBaUIsQ0FBQy9ZLFNBQVMsQ0FBQ0MsV0FBVyxDQUFDQyxHQUFHLENBQUMsRUFBRTNNLE1BQU0sQ0FBQ1csVUFBVSxDQUFDdXNCLFVBQVUsQ0FBQyxDQUFDO0lBQzdGLE9BQU9HLFFBQVEsQ0FBQ2xyQixHQUFHLENBQUVnQyxDQUFDLElBQUtBLENBQUMsQ0FBQ2tILEdBQUcsQ0FBQyxDQUFDc1gsSUFBSSxDQUFDLEVBQUUsQ0FBQztFQUM1Qzs7RUFFQTs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFOVQsR0FBR0EsQ0FBQzVhLElBQUksRUFBRTtJQUNSLE9BQU8sSUFBSSxDQUFDQSxJQUFJLENBQUM7RUFDbkI7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0UsSUFBSWtELE9BQU9BLENBQUEsRUFBRztJQUNaLE9BQU8sSUFBSSxDQUFDeWdCLE9BQU8sS0FBSyxJQUFJO0VBQzlCOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0VBQ0UsSUFBSThDLGFBQWFBLENBQUEsRUFBRztJQUNsQixPQUFPLElBQUksQ0FBQzlDLE9BQU8sR0FBRyxJQUFJLENBQUNBLE9BQU8sQ0FBQ2prQixNQUFNLEdBQUcsSUFBSTtFQUNsRDs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtFQUNFLElBQUlnbkIsa0JBQWtCQSxDQUFBLEVBQUc7SUFDdkIsT0FBTyxJQUFJLENBQUMvQyxPQUFPLEdBQUcsSUFBSSxDQUFDQSxPQUFPLENBQUN0SSxXQUFXLEdBQUcsSUFBSTtFQUN2RDs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBQ0UsSUFBSTNYLE1BQU1BLENBQUEsRUFBRztJQUNYLE9BQU8sSUFBSSxDQUFDUixPQUFPLEdBQUcsSUFBSSxDQUFDd0csR0FBRyxDQUFDaEcsTUFBTSxHQUFHLElBQUk7RUFDOUM7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUNFLElBQUlrRixlQUFlQSxDQUFBLEVBQUc7SUFDcEIsT0FBTyxJQUFJLENBQUMxRixPQUFPLEdBQUcsSUFBSSxDQUFDd0csR0FBRyxDQUFDZCxlQUFlLEdBQUcsSUFBSTtFQUN2RDs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBQ0UsSUFBSUcsY0FBY0EsQ0FBQSxFQUFHO0lBQ25CLE9BQU8sSUFBSSxDQUFDN0YsT0FBTyxHQUFHLElBQUksQ0FBQ3dHLEdBQUcsQ0FBQ1gsY0FBYyxHQUFHLElBQUk7RUFDdEQ7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7RUFDRSxJQUFJL0UsSUFBSUEsQ0FBQSxFQUFHO0lBQ1QsT0FBTyxJQUFJLENBQUNzekIsS0FBSztFQUNuQjs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtFQUNFLElBQUlweEIsUUFBUUEsQ0FBQSxFQUFHO0lBQ2IsT0FBTyxJQUFJLENBQUNoRCxPQUFPLEdBQUcsSUFBSSxDQUFDYyxJQUFJLENBQUN6QixJQUFJLEdBQUcsSUFBSTtFQUM3Qzs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBQ0UsSUFBSWhDLElBQUlBLENBQUEsRUFBRztJQUNULE9BQU8sSUFBSSxDQUFDMkMsT0FBTyxHQUFHLElBQUksQ0FBQzRWLENBQUMsQ0FBQ3ZZLElBQUksR0FBRzhGLEdBQUc7RUFDekM7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUNFLElBQUlpVSxPQUFPQSxDQUFBLEVBQUc7SUFDWixPQUFPLElBQUksQ0FBQ3BYLE9BQU8sR0FBR3FELElBQUksQ0FBQ2tjLElBQUksQ0FBQyxJQUFJLENBQUMzSixDQUFDLENBQUN0WSxLQUFLLEdBQUcsQ0FBQyxDQUFDLEdBQUc2RixHQUFHO0VBQ3pEOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFDRSxJQUFJN0YsS0FBS0EsQ0FBQSxFQUFHO0lBQ1YsT0FBTyxJQUFJLENBQUMwQyxPQUFPLEdBQUcsSUFBSSxDQUFDNFYsQ0FBQyxDQUFDdFksS0FBSyxHQUFHNkYsR0FBRztFQUMxQzs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBQ0UsSUFBSTVGLEdBQUdBLENBQUEsRUFBRztJQUNSLE9BQU8sSUFBSSxDQUFDeUMsT0FBTyxHQUFHLElBQUksQ0FBQzRWLENBQUMsQ0FBQ3JZLEdBQUcsR0FBRzRGLEdBQUc7RUFDeEM7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUNFLElBQUlyRixJQUFJQSxDQUFBLEVBQUc7SUFDVCxPQUFPLElBQUksQ0FBQ2tDLE9BQU8sR0FBRyxJQUFJLENBQUM0VixDQUFDLENBQUM5WCxJQUFJLEdBQUdxRixHQUFHO0VBQ3pDOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFDRSxJQUFJcEYsTUFBTUEsQ0FBQSxFQUFHO0lBQ1gsT0FBTyxJQUFJLENBQUNpQyxPQUFPLEdBQUcsSUFBSSxDQUFDNFYsQ0FBQyxDQUFDN1gsTUFBTSxHQUFHb0YsR0FBRztFQUMzQzs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBQ0UsSUFBSWxGLE1BQU1BLENBQUEsRUFBRztJQUNYLE9BQU8sSUFBSSxDQUFDK0IsT0FBTyxHQUFHLElBQUksQ0FBQzRWLENBQUMsQ0FBQzNYLE1BQU0sR0FBR2tGLEdBQUc7RUFDM0M7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUNFLElBQUlPLFdBQVdBLENBQUEsRUFBRztJQUNoQixPQUFPLElBQUksQ0FBQzFELE9BQU8sR0FBRyxJQUFJLENBQUM0VixDQUFDLENBQUNsUyxXQUFXLEdBQUdQLEdBQUc7RUFDaEQ7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0UsSUFBSXFOLFFBQVFBLENBQUEsRUFBRztJQUNiLE9BQU8sSUFBSSxDQUFDeFEsT0FBTyxHQUFHa3hCLHNCQUFzQixDQUFDLElBQUksQ0FBQyxDQUFDMWdCLFFBQVEsR0FBR3JOLEdBQUc7RUFDbkU7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0UsSUFBSStULFVBQVVBLENBQUEsRUFBRztJQUNmLE9BQU8sSUFBSSxDQUFDbFgsT0FBTyxHQUFHa3hCLHNCQUFzQixDQUFDLElBQUksQ0FBQyxDQUFDaGEsVUFBVSxHQUFHL1QsR0FBRztFQUNyRTs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFLElBQUl6RixPQUFPQSxDQUFBLEVBQUc7SUFDWixPQUFPLElBQUksQ0FBQ3NDLE9BQU8sR0FBR2t4QixzQkFBc0IsQ0FBQyxJQUFJLENBQUMsQ0FBQ3h6QixPQUFPLEdBQUd5RixHQUFHO0VBQ2xFOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFDRSxJQUFJZ1UsT0FBT0EsQ0FBQSxFQUFHO0lBQ1osT0FBTyxJQUFJLENBQUNuWCxPQUFPLEdBQUc2dkIsa0JBQWtCLENBQUMsSUFBSSxDQUFDamEsQ0FBQyxDQUFDLENBQUN1QixPQUFPLEdBQUdoVSxHQUFHO0VBQ2hFOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFLElBQUlnekIsVUFBVUEsQ0FBQSxFQUFHO0lBQ2YsT0FBTyxJQUFJLENBQUNuMkIsT0FBTyxHQUFHbW5CLElBQUksQ0FBQ3hjLE1BQU0sQ0FBQyxPQUFPLEVBQUU7TUFBRTZjLE1BQU0sRUFBRSxJQUFJLENBQUNoaEI7S0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDbEosS0FBSyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUk7RUFDekY7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0UsSUFBSTg0QixTQUFTQSxDQUFBLEVBQUc7SUFDZCxPQUFPLElBQUksQ0FBQ3AyQixPQUFPLEdBQUdtbkIsSUFBSSxDQUFDeGMsTUFBTSxDQUFDLE1BQU0sRUFBRTtNQUFFNmMsTUFBTSxFQUFFLElBQUksQ0FBQ2hoQjtLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUNsSixLQUFLLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSTtFQUN4Rjs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRSxJQUFJKzRCLFlBQVlBLENBQUEsRUFBRztJQUNqQixPQUFPLElBQUksQ0FBQ3IyQixPQUFPLEdBQUdtbkIsSUFBSSxDQUFDcmMsUUFBUSxDQUFDLE9BQU8sRUFBRTtNQUFFMGMsTUFBTSxFQUFFLElBQUksQ0FBQ2hoQjtLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUM5SSxPQUFPLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSTtFQUM3Rjs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRSxJQUFJNDRCLFdBQVdBLENBQUEsRUFBRztJQUNoQixPQUFPLElBQUksQ0FBQ3QyQixPQUFPLEdBQUdtbkIsSUFBSSxDQUFDcmMsUUFBUSxDQUFDLE1BQU0sRUFBRTtNQUFFMGMsTUFBTSxFQUFFLElBQUksQ0FBQ2hoQjtLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUM5SSxPQUFPLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSTtFQUM1Rjs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRSxJQUFJbUMsTUFBTUEsQ0FBQSxFQUFHO0lBQ1gsT0FBTyxJQUFJLENBQUNHLE9BQU8sR0FBRyxDQUFDLElBQUksQ0FBQ2tOLENBQUMsR0FBRy9KLEdBQUc7RUFDckM7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUNFLElBQUlvekIsZUFBZUEsQ0FBQSxFQUFHO0lBQ3BCLElBQUksSUFBSSxDQUFDdjJCLE9BQU8sRUFBRTtNQUNoQixPQUFPLElBQUksQ0FBQ2MsSUFBSSxDQUFDdEIsVUFBVSxDQUFDLElBQUksQ0FBQ0MsRUFBRSxFQUFFO1FBQ25DRyxNQUFNLEVBQUUsT0FBTztRQUNmWSxNQUFNLEVBQUUsSUFBSSxDQUFDQTtNQUNmLENBQUMsQ0FBQztJQUNKLENBQUMsTUFBTTtNQUNMLE9BQU8sSUFBSTtJQUNiO0VBQ0Y7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUNFLElBQUlnMkIsY0FBY0EsQ0FBQSxFQUFHO0lBQ25CLElBQUksSUFBSSxDQUFDeDJCLE9BQU8sRUFBRTtNQUNoQixPQUFPLElBQUksQ0FBQ2MsSUFBSSxDQUFDdEIsVUFBVSxDQUFDLElBQUksQ0FBQ0MsRUFBRSxFQUFFO1FBQ25DRyxNQUFNLEVBQUUsTUFBTTtRQUNkWSxNQUFNLEVBQUUsSUFBSSxDQUFDQTtNQUNmLENBQUMsQ0FBQztJQUNKLENBQUMsTUFBTTtNQUNMLE9BQU8sSUFBSTtJQUNiO0VBQ0Y7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7RUFDRSxJQUFJcVcsYUFBYUEsQ0FBQSxFQUFHO0lBQ2xCLE9BQU8sSUFBSSxDQUFDN1csT0FBTyxHQUFHLElBQUksQ0FBQ2MsSUFBSSxDQUFDdkIsV0FBVyxHQUFHLElBQUk7RUFDcEQ7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7RUFDRSxJQUFJazNCLE9BQU9BLENBQUEsRUFBRztJQUNaLElBQUksSUFBSSxDQUFDNWYsYUFBYSxFQUFFO01BQ3RCLE9BQU8sS0FBSztJQUNkLENBQUMsTUFBTTtNQUNMLE9BQ0UsSUFBSSxDQUFDaFgsTUFBTSxHQUFHLElBQUksQ0FBQzZpQixHQUFHLENBQUM7UUFBRXBsQixLQUFLLEVBQUUsQ0FBQztRQUFFQyxHQUFHLEVBQUU7T0FBRyxDQUFDLENBQUNzQyxNQUFNLElBQ25ELElBQUksQ0FBQ0EsTUFBTSxHQUFHLElBQUksQ0FBQzZpQixHQUFHLENBQUM7UUFBRXBsQixLQUFLLEVBQUU7T0FBRyxDQUFDLENBQUN1QyxNQUFNO0lBRS9DO0VBQ0Y7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0UsSUFBSTYyQixZQUFZQSxDQUFBLEVBQUc7SUFDakIsT0FBTzVtQixVQUFVLENBQUMsSUFBSSxDQUFDelMsSUFBSSxDQUFDO0VBQzlCOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFLElBQUkyUyxXQUFXQSxDQUFBLEVBQUc7SUFDaEIsT0FBT0EsV0FBVyxDQUFDLElBQUksQ0FBQzNTLElBQUksRUFBRSxJQUFJLENBQUNDLEtBQUssQ0FBQztFQUMzQzs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRSxJQUFJeVMsVUFBVUEsQ0FBQSxFQUFHO0lBQ2YsT0FBTyxJQUFJLENBQUMvUCxPQUFPLEdBQUcrUCxVQUFVLENBQUMsSUFBSSxDQUFDMVMsSUFBSSxDQUFDLEdBQUc4RixHQUFHO0VBQ25EOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0UsSUFBSW9OLGVBQWVBLENBQUEsRUFBRztJQUNwQixPQUFPLElBQUksQ0FBQ3ZRLE9BQU8sR0FBR3VRLGVBQWUsQ0FBQyxJQUFJLENBQUNDLFFBQVEsQ0FBQyxHQUFHck4sR0FBRztFQUM1RDs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRXd6QixxQkFBcUJBLENBQUNqM0IsSUFBSSxHQUFHLEVBQUUsRUFBRTtJQUMvQixNQUFNO01BQUVjLE1BQU07TUFBRWtGLGVBQWU7TUFBRUM7S0FBVSxHQUFHMlAsU0FBUyxDQUFDM1MsTUFBTSxDQUM1RCxJQUFJLENBQUM2RCxHQUFHLENBQUM4RCxLQUFLLENBQUM1SyxJQUFJLENBQUMsRUFDcEJBLElBQUksQ0FDTCxDQUFDWSxlQUFlLENBQUMsSUFBSSxDQUFDO0lBQ3ZCLE9BQU87TUFBRUUsTUFBTTtNQUFFa0YsZUFBZTtNQUFFRyxjQUFjLEVBQUVGO0tBQVU7RUFDOUQ7O0VBRUE7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFc2lCLEtBQUtBLENBQUNwb0IsTUFBTSxHQUFHLENBQUMsRUFBRUgsSUFBSSxHQUFHLEVBQUUsRUFBRTtJQUMzQixPQUFPLElBQUksQ0FBQzRuQixPQUFPLENBQUN2YixlQUFlLENBQUM1TCxRQUFRLENBQUNOLE1BQU0sQ0FBQyxFQUFFSCxJQUFJLENBQUM7RUFDN0Q7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0VrM0IsT0FBT0EsQ0FBQSxFQUFHO0lBQ1IsT0FBTyxJQUFJLENBQUN0UCxPQUFPLENBQUNyZSxRQUFRLENBQUN1RCxXQUFXLENBQUM7RUFDM0M7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0U4YSxPQUFPQSxDQUFDeG1CLElBQUksRUFBRTtJQUFFb25CLGFBQWEsR0FBRyxLQUFLO0lBQUUyTyxnQkFBZ0IsR0FBRztHQUFPLEdBQUcsRUFBRSxFQUFFO0lBQ3RFLzFCLElBQUksR0FBR3dMLGFBQWEsQ0FBQ3hMLElBQUksRUFBRW1JLFFBQVEsQ0FBQ3VELFdBQVcsQ0FBQztJQUNoRCxJQUFJMUwsSUFBSSxDQUFDaEIsTUFBTSxDQUFDLElBQUksQ0FBQ2dCLElBQUksQ0FBQyxFQUFFO01BQzFCLE9BQU8sSUFBSTtJQUNiLENBQUMsTUFBTSxJQUFJLENBQUNBLElBQUksQ0FBQ2QsT0FBTyxFQUFFO01BQ3hCLE9BQU9tRyxRQUFRLENBQUNzYSxPQUFPLENBQUN3USxlQUFlLENBQUNud0IsSUFBSSxDQUFDLENBQUM7SUFDaEQsQ0FBQyxNQUFNO01BQ0wsSUFBSWcyQixLQUFLLEdBQUcsSUFBSSxDQUFDcjNCLEVBQUU7TUFDbkIsSUFBSXlvQixhQUFhLElBQUkyTyxnQkFBZ0IsRUFBRTtRQUNyQyxNQUFNRSxXQUFXLEdBQUdqMkIsSUFBSSxDQUFDakIsTUFBTSxDQUFDLElBQUksQ0FBQ0osRUFBRSxDQUFDO1FBQ3hDLE1BQU11M0IsS0FBSyxHQUFHLElBQUksQ0FBQ3hWLFFBQVEsRUFBRTtRQUM3QixDQUFDc1YsS0FBSyxDQUFDLEdBQUc1RSxPQUFPLENBQUM4RSxLQUFLLEVBQUVELFdBQVcsRUFBRWoyQixJQUFJLENBQUM7TUFDN0M7TUFDQSxPQUFPd0osS0FBSyxDQUFDLElBQUksRUFBRTtRQUFFN0ssRUFBRSxFQUFFcTNCLEtBQUs7UUFBRWgyQjtNQUFLLENBQUMsQ0FBQztJQUN6QztFQUNGOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFOGhCLFdBQVdBLENBQUM7SUFBRXBpQixNQUFNO0lBQUVrRixlQUFlO0lBQUVHO0dBQWdCLEdBQUcsRUFBRSxFQUFFO0lBQzVELE1BQU1XLEdBQUcsR0FBRyxJQUFJLENBQUNBLEdBQUcsQ0FBQzhELEtBQUssQ0FBQztNQUFFOUosTUFBTTtNQUFFa0YsZUFBZTtNQUFFRztJQUFlLENBQUMsQ0FBQztJQUN2RSxPQUFPeUUsS0FBSyxDQUFDLElBQUksRUFBRTtNQUFFOUQ7SUFBSSxDQUFDLENBQUM7RUFDN0I7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0V5d0IsU0FBU0EsQ0FBQ3oyQixNQUFNLEVBQUU7SUFDaEIsT0FBTyxJQUFJLENBQUNvaUIsV0FBVyxDQUFDO01BQUVwaUI7SUFBTyxDQUFDLENBQUM7RUFDckM7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRWtpQixHQUFHQSxDQUFDeEQsTUFBTSxFQUFFO0lBQ1YsSUFBSSxDQUFDLElBQUksQ0FBQ2xmLE9BQU8sRUFBRSxPQUFPLElBQUk7SUFFOUIsTUFBTTBSLFVBQVUsR0FBR0YsZUFBZSxDQUFDME4sTUFBTSxFQUFFeUIsYUFBYSxDQUFDO01BQ3ZEdVcsZ0JBQWdCLEdBQ2QsQ0FBQzMwQixXQUFXLENBQUNtUCxVQUFVLENBQUNsQixRQUFRLENBQUMsSUFDakMsQ0FBQ2pPLFdBQVcsQ0FBQ21QLFVBQVUsQ0FBQ3dGLFVBQVUsQ0FBQyxJQUNuQyxDQUFDM1UsV0FBVyxDQUFDbVAsVUFBVSxDQUFDaFUsT0FBTyxDQUFDO01BQ2xDZzNCLGVBQWUsR0FBRyxDQUFDbnlCLFdBQVcsQ0FBQ21QLFVBQVUsQ0FBQ3lGLE9BQU8sQ0FBQztNQUNsRHdkLGtCQUFrQixHQUFHLENBQUNweUIsV0FBVyxDQUFDbVAsVUFBVSxDQUFDclUsSUFBSSxDQUFDO01BQ2xEdTNCLGdCQUFnQixHQUFHLENBQUNyeUIsV0FBVyxDQUFDbVAsVUFBVSxDQUFDcFUsS0FBSyxDQUFDLElBQUksQ0FBQ2lGLFdBQVcsQ0FBQ21QLFVBQVUsQ0FBQ25VLEdBQUcsQ0FBQztNQUNqRnMzQixjQUFjLEdBQUdGLGtCQUFrQixJQUFJQyxnQkFBZ0I7TUFDdkRFLGVBQWUsR0FBR3BqQixVQUFVLENBQUNsQixRQUFRLElBQUlrQixVQUFVLENBQUN3RixVQUFVO0lBRWhFLElBQUksQ0FBQzJkLGNBQWMsSUFBSUgsZUFBZSxLQUFLSSxlQUFlLEVBQUU7TUFDMUQsTUFBTSxJQUFJbDRCLDZCQUE2QixDQUNyQyxxRUFBcUUsQ0FDdEU7SUFDSDtJQUVBLElBQUlnNEIsZ0JBQWdCLElBQUlGLGVBQWUsRUFBRTtNQUN2QyxNQUFNLElBQUk5M0IsNkJBQTZCLENBQUMsd0NBQXdDLENBQUM7SUFDbkY7SUFFQSxJQUFJK2xCLEtBQUs7SUFDVCxJQUFJdVUsZ0JBQWdCLEVBQUU7TUFDcEJ2VSxLQUFLLEdBQUc4TSxlQUFlLENBQUM7UUFBRSxHQUFHRixlQUFlLENBQUMsSUFBSSxDQUFDM1osQ0FBQyxDQUFDO1FBQUUsR0FBR2xFO01BQVcsQ0FBQyxDQUFDO0tBQ3ZFLE1BQU0sSUFBSSxDQUFDblAsV0FBVyxDQUFDbVAsVUFBVSxDQUFDeUYsT0FBTyxDQUFDLEVBQUU7TUFDM0N3TCxLQUFLLEdBQUdvTixrQkFBa0IsQ0FBQztRQUFFLEdBQUdGLGtCQUFrQixDQUFDLElBQUksQ0FBQ2phLENBQUMsQ0FBQztRQUFFLEdBQUdsRTtNQUFXLENBQUMsQ0FBQztJQUM5RSxDQUFDLE1BQU07TUFDTGlSLEtBQUssR0FBRztRQUFFLEdBQUcsSUFBSSxDQUFDbkIsUUFBUSxFQUFFO1FBQUUsR0FBRzlQO09BQVk7O01BRTdDO01BQ0E7TUFDQSxJQUFJblAsV0FBVyxDQUFDbVAsVUFBVSxDQUFDblUsR0FBRyxDQUFDLEVBQUU7UUFDL0JvbEIsS0FBSyxDQUFDcGxCLEdBQUcsR0FBRzhGLElBQUksQ0FBQ2luQixHQUFHLENBQUN0YSxXQUFXLENBQUMyUyxLQUFLLENBQUN0bEIsSUFBSSxFQUFFc2xCLEtBQUssQ0FBQ3JsQixLQUFLLENBQUMsRUFBRXFsQixLQUFLLENBQUNwbEIsR0FBRyxDQUFDO01BQ3ZFO0lBQ0Y7SUFFQSxNQUFNLENBQUNrQyxFQUFFLEVBQUV5TixDQUFDLENBQUMsR0FBR2dsQixPQUFPLENBQUN2UCxLQUFLLEVBQUUsSUFBSSxDQUFDelYsQ0FBQyxFQUFFLElBQUksQ0FBQ3BNLElBQUksQ0FBQztJQUNqRCxPQUFPd0osS0FBSyxDQUFDLElBQUksRUFBRTtNQUFFN0ssRUFBRTtNQUFFeU47SUFBRSxDQUFDLENBQUM7RUFDL0I7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRWtWLElBQUlBLENBQUNDLFFBQVEsRUFBRTtJQUNiLElBQUksQ0FBQyxJQUFJLENBQUNyaUIsT0FBTyxFQUFFLE9BQU8sSUFBSTtJQUM5QixNQUFNc1gsR0FBRyxHQUFHK0gsUUFBUSxDQUFDdUIsZ0JBQWdCLENBQUN5QixRQUFRLENBQUM7SUFDL0MsT0FBTy9YLEtBQUssQ0FBQyxJQUFJLEVBQUU2bkIsVUFBVSxDQUFDLElBQUksRUFBRTdhLEdBQUcsQ0FBQyxDQUFDO0VBQzNDOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFZ0wsS0FBS0EsQ0FBQ0QsUUFBUSxFQUFFO0lBQ2QsSUFBSSxDQUFDLElBQUksQ0FBQ3JpQixPQUFPLEVBQUUsT0FBTyxJQUFJO0lBQzlCLE1BQU1zWCxHQUFHLEdBQUcrSCxRQUFRLENBQUN1QixnQkFBZ0IsQ0FBQ3lCLFFBQVEsQ0FBQyxDQUFDRSxNQUFNLEVBQUU7SUFDeEQsT0FBT2pZLEtBQUssQ0FBQyxJQUFJLEVBQUU2bkIsVUFBVSxDQUFDLElBQUksRUFBRTdhLEdBQUcsQ0FBQyxDQUFDO0VBQzNDOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0VzTixPQUFPQSxDQUFDOW5CLElBQUksRUFBRTtJQUNaLElBQUksQ0FBQyxJQUFJLENBQUNrRCxPQUFPLEVBQUUsT0FBTyxJQUFJO0lBQzlCLE1BQU1rTixDQUFDLEdBQUcsRUFBRTtNQUNWaXFCLGNBQWMsR0FBRzlYLFFBQVEsQ0FBQ3NCLGFBQWEsQ0FBQzdqQixJQUFJLENBQUM7SUFDL0MsUUFBUXE2QixjQUFjO01BQ3BCLEtBQUssT0FBTztRQUNWanFCLENBQUMsQ0FBQzVQLEtBQUssR0FBRyxDQUFDO01BQ2I7TUFDQSxLQUFLLFVBQVU7TUFDZixLQUFLLFFBQVE7UUFDWDRQLENBQUMsQ0FBQzNQLEdBQUcsR0FBRyxDQUFDO01BQ1g7TUFDQSxLQUFLLE9BQU87TUFDWixLQUFLLE1BQU07UUFDVDJQLENBQUMsQ0FBQ3BQLElBQUksR0FBRyxDQUFDO01BQ1o7TUFDQSxLQUFLLE9BQU87UUFDVm9QLENBQUMsQ0FBQ25QLE1BQU0sR0FBRyxDQUFDO01BQ2Q7TUFDQSxLQUFLLFNBQVM7UUFDWm1QLENBQUMsQ0FBQ2pQLE1BQU0sR0FBRyxDQUFDO01BQ2Q7TUFDQSxLQUFLLFNBQVM7UUFDWmlQLENBQUMsQ0FBQ3hKLFdBQVcsR0FBRyxDQUFDO1FBQ2pCO01BR0Y7SUFBQTs7SUFHRixJQUFJeXpCLGNBQWMsS0FBSyxPQUFPLEVBQUU7TUFDOUJqcUIsQ0FBQyxDQUFDeFAsT0FBTyxHQUFHLENBQUM7SUFDZjtJQUVBLElBQUl5NUIsY0FBYyxLQUFLLFVBQVUsRUFBRTtNQUNqQyxNQUFNdkosQ0FBQyxHQUFHdnFCLElBQUksQ0FBQ2tjLElBQUksQ0FBQyxJQUFJLENBQUNqaUIsS0FBSyxHQUFHLENBQUMsQ0FBQztNQUNuQzRQLENBQUMsQ0FBQzVQLEtBQUssR0FBRyxDQUFDc3dCLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUM7SUFDM0I7SUFFQSxPQUFPLElBQUksQ0FBQ2xMLEdBQUcsQ0FBQ3hWLENBQUMsQ0FBQztFQUNwQjs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFa3FCLEtBQUtBLENBQUN0NkIsSUFBSSxFQUFFO0lBQ1YsT0FBTyxJQUFJLENBQUNrRCxPQUFPLEdBQ2YsSUFBSSxDQUFDb2lCLElBQUksQ0FBQztNQUFFLENBQUN0bEIsSUFBSSxHQUFHO0lBQUUsQ0FBQyxDQUFDLENBQ3JCOG5CLE9BQU8sQ0FBQzluQixJQUFJLENBQUMsQ0FDYndsQixLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQ1gsSUFBSTtFQUNWOztFQUVBOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFbkIsUUFBUUEsQ0FBQzNMLEdBQUcsRUFBRTlWLElBQUksR0FBRyxFQUFFLEVBQUU7SUFDdkIsT0FBTyxJQUFJLENBQUNNLE9BQU8sR0FDZnNWLFNBQVMsQ0FBQzNTLE1BQU0sQ0FBQyxJQUFJLENBQUM2RCxHQUFHLENBQUNpRSxhQUFhLENBQUMvSyxJQUFJLENBQUMsQ0FBQyxDQUFDZ1gsd0JBQXdCLENBQUMsSUFBSSxFQUFFbEIsR0FBRyxDQUFDLEdBQ2xGdWIsT0FBTztFQUNiOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0VsSyxjQUFjQSxDQUFDL1EsVUFBVSxHQUFHMVksVUFBa0IsRUFBRXNDLElBQUksR0FBRyxFQUFFLEVBQUU7SUFDekQsT0FBTyxJQUFJLENBQUNNLE9BQU8sR0FDZnNWLFNBQVMsQ0FBQzNTLE1BQU0sQ0FBQyxJQUFJLENBQUM2RCxHQUFHLENBQUM4RCxLQUFLLENBQUM1SyxJQUFJLENBQUMsRUFBRW9XLFVBQVUsQ0FBQyxDQUFDRyxjQUFjLENBQUMsSUFBSSxDQUFDLEdBQ3ZFOGEsT0FBTztFQUNiOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0VzRyxhQUFhQSxDQUFDMzNCLElBQUksR0FBRyxFQUFFLEVBQUU7SUFDdkIsT0FBTyxJQUFJLENBQUNNLE9BQU8sR0FDZnNWLFNBQVMsQ0FBQzNTLE1BQU0sQ0FBQyxJQUFJLENBQUM2RCxHQUFHLENBQUM4RCxLQUFLLENBQUM1SyxJQUFJLENBQUMsRUFBRUEsSUFBSSxDQUFDLENBQUN3VyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsR0FDdEUsRUFBRTtFQUNSOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRXVMLEtBQUtBLENBQUM7SUFDSjdoQixNQUFNLEdBQUcsVUFBVTtJQUNuQmtpQixlQUFlLEdBQUcsS0FBSztJQUN2QkQsb0JBQW9CLEdBQUcsS0FBSztJQUM1QitRLGFBQWEsR0FBRyxJQUFJO0lBQ3BCQyxZQUFZLEdBQUc7R0FDaEIsR0FBRyxFQUFFLEVBQUU7SUFDTixJQUFJLENBQUMsSUFBSSxDQUFDN3lCLE9BQU8sRUFBRTtNQUNqQixPQUFPLElBQUk7SUFDYjtJQUVBLE1BQU1zM0IsR0FBRyxHQUFHMTNCLE1BQU0sS0FBSyxVQUFVO0lBRWpDLElBQUlnVyxDQUFDLEdBQUdrUixTQUFTLENBQUMsSUFBSSxFQUFFd1EsR0FBRyxDQUFDO0lBQzVCMWhCLENBQUMsSUFBSSxHQUFHO0lBQ1JBLENBQUMsSUFBSThMLFNBQVMsQ0FBQyxJQUFJLEVBQUU0VixHQUFHLEVBQUV4VixlQUFlLEVBQUVELG9CQUFvQixFQUFFK1EsYUFBYSxFQUFFQyxZQUFZLENBQUM7SUFDN0YsT0FBT2pkLENBQUM7RUFDVjs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0VrUixTQUFTQSxDQUFDO0lBQUVsbkIsTUFBTSxHQUFHO0dBQVksR0FBRyxFQUFFLEVBQUU7SUFDdEMsSUFBSSxDQUFDLElBQUksQ0FBQ0ksT0FBTyxFQUFFO01BQ2pCLE9BQU8sSUFBSTtJQUNiO0lBRUEsT0FBTzhtQixTQUFTLENBQUMsSUFBSSxFQUFFbG5CLE1BQU0sS0FBSyxVQUFVLENBQUM7RUFDL0M7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUNFMjNCLGFBQWFBLENBQUEsRUFBRztJQUNkLE9BQU85RSxZQUFZLENBQUMsSUFBSSxFQUFFLGNBQWMsQ0FBQztFQUMzQzs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRS9RLFNBQVNBLENBQUM7SUFDUkcsb0JBQW9CLEdBQUcsS0FBSztJQUM1QkMsZUFBZSxHQUFHLEtBQUs7SUFDdkI4USxhQUFhLEdBQUcsSUFBSTtJQUNwQjdRLGFBQWEsR0FBRyxLQUFLO0lBQ3JCOFEsWUFBWSxHQUFHLEtBQUs7SUFDcEJqekIsTUFBTSxHQUFHO0dBQ1YsR0FBRyxFQUFFLEVBQUU7SUFDTixJQUFJLENBQUMsSUFBSSxDQUFDSSxPQUFPLEVBQUU7TUFDakIsT0FBTyxJQUFJO0lBQ2I7SUFFQSxJQUFJNFYsQ0FBQyxHQUFHbU0sYUFBYSxHQUFHLEdBQUcsR0FBRyxFQUFFO0lBQ2hDLE9BQ0VuTSxDQUFDLEdBQ0Q4TCxTQUFTLENBQ1AsSUFBSSxFQUNKOWhCLE1BQU0sS0FBSyxVQUFVLEVBQ3JCa2lCLGVBQWUsRUFDZkQsb0JBQW9CLEVBQ3BCK1EsYUFBYSxFQUNiQyxZQUFZLENBQ2I7RUFFTDs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRTJFLFNBQVNBLENBQUEsRUFBRztJQUNWLE9BQU8vRSxZQUFZLENBQUMsSUFBSSxFQUFFLCtCQUErQixFQUFFLEtBQUssQ0FBQztFQUNuRTs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0VnRixNQUFNQSxDQUFBLEVBQUc7SUFDUCxPQUFPaEYsWUFBWSxDQUFDLElBQUksQ0FBQ3hLLEtBQUssRUFBRSxFQUFFLGlDQUFpQyxDQUFDO0VBQ3RFOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFDRXlQLFNBQVNBLENBQUEsRUFBRztJQUNWLElBQUksQ0FBQyxJQUFJLENBQUMxM0IsT0FBTyxFQUFFO01BQ2pCLE9BQU8sSUFBSTtJQUNiO0lBQ0EsT0FBTzhtQixTQUFTLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQztFQUM5Qjs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRTZRLFNBQVNBLENBQUM7SUFBRS9FLGFBQWEsR0FBRyxJQUFJO0lBQUVnRixXQUFXLEdBQUcsS0FBSztJQUFFQyxrQkFBa0IsR0FBRztHQUFNLEdBQUcsRUFBRSxFQUFFO0lBQ3ZGLElBQUlyaUIsR0FBRyxHQUFHLGNBQWM7SUFFeEIsSUFBSW9pQixXQUFXLElBQUloRixhQUFhLEVBQUU7TUFDaEMsSUFBSWlGLGtCQUFrQixFQUFFO1FBQ3RCcmlCLEdBQUcsSUFBSSxHQUFHO01BQ1o7TUFDQSxJQUFJb2lCLFdBQVcsRUFBRTtRQUNmcGlCLEdBQUcsSUFBSSxHQUFHO09BQ1gsTUFBTSxJQUFJb2QsYUFBYSxFQUFFO1FBQ3hCcGQsR0FBRyxJQUFJLElBQUk7TUFDYjtJQUNGO0lBRUEsT0FBT2lkLFlBQVksQ0FBQyxJQUFJLEVBQUVqZCxHQUFHLEVBQUUsSUFBSSxDQUFDO0VBQ3RDOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFc2lCLEtBQUtBLENBQUNwNEIsSUFBSSxHQUFHLEVBQUUsRUFBRTtJQUNmLElBQUksQ0FBQyxJQUFJLENBQUNNLE9BQU8sRUFBRTtNQUNqQixPQUFPLElBQUk7SUFDYjtJQUVBLE9BQVUsT0FBSSxDQUFDMDNCLFNBQVMsRUFBRyxJQUFHLElBQUksQ0FBQ0MsU0FBUyxDQUFDajRCLElBQUksQ0FBRztFQUN0RDs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtFQUNFNE4sUUFBUUEsQ0FBQSxFQUFHO0lBQ1QsT0FBTyxJQUFJLENBQUN0TixPQUFPLEdBQUcsSUFBSSxDQUFDeWhCLEtBQUssRUFBRSxHQUFHc1AsT0FBTztFQUM5Qzs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtFQUNFNU8sT0FBT0EsQ0FBQSxFQUFHO0lBQ1IsT0FBTyxJQUFJLENBQUNQLFFBQVEsRUFBRTtFQUN4Qjs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtFQUNFQSxRQUFRQSxDQUFBLEVBQUc7SUFDVCxPQUFPLElBQUksQ0FBQzVoQixPQUFPLEdBQUcsSUFBSSxDQUFDUCxFQUFFLEdBQUcwRCxHQUFHO0VBQ3JDOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0VBQ0U0MEIsU0FBU0EsQ0FBQSxFQUFHO0lBQ1YsT0FBTyxJQUFJLENBQUMvM0IsT0FBTyxHQUFHLElBQUksQ0FBQ1AsRUFBRSxHQUFHLElBQUksR0FBRzBELEdBQUc7RUFDNUM7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7RUFDRTYwQixhQUFhQSxDQUFBLEVBQUc7SUFDZCxPQUFPLElBQUksQ0FBQ2g0QixPQUFPLEdBQUdxRCxJQUFJLENBQUMrRCxLQUFLLENBQUMsSUFBSSxDQUFDM0gsRUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHMEQsR0FBRztFQUN4RDs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtFQUNFOGUsTUFBTUEsQ0FBQSxFQUFHO0lBQ1AsT0FBTyxJQUFJLENBQUNSLEtBQUssRUFBRTtFQUNyQjs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtFQUNFd1csTUFBTUEsQ0FBQSxFQUFHO0lBQ1AsT0FBTyxJQUFJLENBQUM3dkIsUUFBUSxFQUFFO0VBQ3hCOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0VvWixRQUFRQSxDQUFDOWhCLElBQUksR0FBRyxFQUFFLEVBQUU7SUFDbEIsSUFBSSxDQUFDLElBQUksQ0FBQ00sT0FBTyxFQUFFLE9BQU8sRUFBRTtJQUU1QixNQUFNNEUsSUFBSSxHQUFHO01BQUUsR0FBRyxJQUFJLENBQUNnUjtLQUFHO0lBRTFCLElBQUlsVyxJQUFJLENBQUN3NEIsYUFBYSxFQUFFO01BQ3RCdHpCLElBQUksQ0FBQ2lCLGNBQWMsR0FBRyxJQUFJLENBQUNBLGNBQWM7TUFDekNqQixJQUFJLENBQUNjLGVBQWUsR0FBRyxJQUFJLENBQUNjLEdBQUcsQ0FBQ2QsZUFBZTtNQUMvQ2QsSUFBSSxDQUFDcEUsTUFBTSxHQUFHLElBQUksQ0FBQ2dHLEdBQUcsQ0FBQ2hHLE1BQU07SUFDL0I7SUFDQSxPQUFPb0UsSUFBSTtFQUNiOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0VBQ0V3RCxRQUFRQSxDQUFBLEVBQUc7SUFDVCxPQUFPLElBQUkxSCxJQUFJLENBQUMsSUFBSSxDQUFDVixPQUFPLEdBQUcsSUFBSSxDQUFDUCxFQUFFLEdBQUcwRCxHQUFHLENBQUM7RUFDL0M7O0VBRUE7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0UwaEIsSUFBSUEsQ0FBQ3NULGFBQWEsRUFBRXI3QixJQUFJLEdBQUcsY0FBYyxFQUFFNEMsSUFBSSxHQUFHLEVBQUUsRUFBRTtJQUNwRCxJQUFJLENBQUMsSUFBSSxDQUFDTSxPQUFPLElBQUksQ0FBQ200QixhQUFhLENBQUNuNEIsT0FBTyxFQUFFO01BQzNDLE9BQU9xZixRQUFRLENBQUNvQixPQUFPLENBQUMsd0NBQXdDLENBQUM7SUFDbkU7SUFFQSxNQUFNMlgsT0FBTyxHQUFHO01BQUU1M0IsTUFBTSxFQUFFLElBQUksQ0FBQ0EsTUFBTTtNQUFFa0YsZUFBZSxFQUFFLElBQUksQ0FBQ0EsZUFBZTtNQUFFLEdBQUdoRztLQUFNO0lBRXZGLE1BQU1zVCxLQUFLLEdBQUd4RixVQUFVLENBQUMxUSxJQUFJLENBQUMsQ0FBQ2tPLEdBQUcsQ0FBQ3FVLFFBQVEsQ0FBQ3NCLGFBQWEsQ0FBQztNQUN4RDBYLFlBQVksR0FBR0YsYUFBYSxDQUFDaFcsT0FBTyxFQUFFLEdBQUcsSUFBSSxDQUFDQSxPQUFPLEVBQUU7TUFDdkQyRixPQUFPLEdBQUd1USxZQUFZLEdBQUcsSUFBSSxHQUFHRixhQUFhO01BQzdDcFEsS0FBSyxHQUFHc1EsWUFBWSxHQUFHRixhQUFhLEdBQUcsSUFBSTtNQUMzQ0csTUFBTSxHQUFHelQsSUFBSSxDQUFDaUQsT0FBTyxFQUFFQyxLQUFLLEVBQUUvVSxLQUFLLEVBQUVvbEIsT0FBTyxDQUFDO0lBRS9DLE9BQU9DLFlBQVksR0FBR0MsTUFBTSxDQUFDL1YsTUFBTSxFQUFFLEdBQUcrVixNQUFNO0VBQ2hEOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRUMsT0FBT0EsQ0FBQ3o3QixJQUFJLEdBQUcsY0FBYyxFQUFFNEMsSUFBSSxHQUFHLEVBQUUsRUFBRTtJQUN4QyxPQUFPLElBQUksQ0FBQ21sQixJQUFJLENBQUMxZSxRQUFRLENBQUN5RyxHQUFHLEVBQUUsRUFBRTlQLElBQUksRUFBRTRDLElBQUksQ0FBQztFQUM5Qzs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBQ0U4NEIsS0FBS0EsQ0FBQ0wsYUFBYSxFQUFFO0lBQ25CLE9BQU8sSUFBSSxDQUFDbjRCLE9BQU8sR0FBRzhqQixRQUFRLENBQUNFLGFBQWEsQ0FBQyxJQUFJLEVBQUVtVSxhQUFhLENBQUMsR0FBRyxJQUFJO0VBQzFFOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFclQsT0FBT0EsQ0FBQ3FULGFBQWEsRUFBRXI3QixJQUFJLEVBQUU7SUFDM0IsSUFBSSxDQUFDLElBQUksQ0FBQ2tELE9BQU8sRUFBRSxPQUFPLEtBQUs7SUFFL0IsTUFBTXk0QixPQUFPLEdBQUdOLGFBQWEsQ0FBQ2hXLE9BQU8sRUFBRTtJQUN2QyxNQUFNdVcsY0FBYyxHQUFHLElBQUksQ0FBQ3BSLE9BQU8sQ0FBQzZRLGFBQWEsQ0FBQ3IzQixJQUFJLEVBQUU7TUFBRW9uQixhQUFhLEVBQUU7SUFBSyxDQUFDLENBQUM7SUFDaEYsT0FBT3dRLGNBQWMsQ0FBQzlULE9BQU8sQ0FBQzluQixJQUFJLENBQUMsSUFBSTI3QixPQUFPLElBQUlBLE9BQU8sSUFBSUMsY0FBYyxDQUFDdEIsS0FBSyxDQUFDdDZCLElBQUksQ0FBQztFQUN6Rjs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFZ0QsTUFBTUEsQ0FBQytMLEtBQUssRUFBRTtJQUNaLE9BQ0UsSUFBSSxDQUFDN0wsT0FBTyxJQUNaNkwsS0FBSyxDQUFDN0wsT0FBTyxJQUNiLElBQUksQ0FBQ21pQixPQUFPLEVBQUUsS0FBS3RXLEtBQUssQ0FBQ3NXLE9BQU8sRUFBRSxJQUNsQyxJQUFJLENBQUNyaEIsSUFBSSxDQUFDaEIsTUFBTSxDQUFDK0wsS0FBSyxDQUFDL0ssSUFBSSxDQUFDLElBQzVCLElBQUksQ0FBQzBGLEdBQUcsQ0FBQzFHLE1BQU0sQ0FBQytMLEtBQUssQ0FBQ3JGLEdBQUcsQ0FBQztFQUU5Qjs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRW15QixVQUFVQSxDQUFDcHpCLE9BQU8sR0FBRyxFQUFFLEVBQUU7SUFDdkIsSUFBSSxDQUFDLElBQUksQ0FBQ3ZGLE9BQU8sRUFBRSxPQUFPLElBQUk7SUFDOUIsTUFBTTRFLElBQUksR0FBR1csT0FBTyxDQUFDWCxJQUFJLElBQUl1QixRQUFRLENBQUNxRCxVQUFVLENBQUMsRUFBRSxFQUFFO1FBQUUxSSxJQUFJLEVBQUUsSUFBSSxDQUFDQTtNQUFLLENBQUMsQ0FBQztNQUN2RTgzQixPQUFPLEdBQUdyekIsT0FBTyxDQUFDcXpCLE9BQU8sR0FBSSxJQUFJLEdBQUdoMEIsSUFBSSxHQUFHLENBQUNXLE9BQU8sQ0FBQ3F6QixPQUFPLEdBQUdyekIsT0FBTyxDQUFDcXpCLE9BQU8sR0FBSSxDQUFDO0lBQ3BGLElBQUk1bEIsS0FBSyxHQUFHLENBQUMsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLFNBQVMsRUFBRSxTQUFTLENBQUM7SUFDdEUsSUFBSWxXLElBQUksR0FBR3lJLE9BQU8sQ0FBQ3pJLElBQUk7SUFDdkIsSUFBSTRRLEtBQUssQ0FBQ0MsT0FBTyxDQUFDcEksT0FBTyxDQUFDekksSUFBSSxDQUFDLEVBQUU7TUFDL0JrVyxLQUFLLEdBQUd6TixPQUFPLENBQUN6SSxJQUFJO01BQ3BCQSxJQUFJLEdBQUdrTCxTQUFTO0lBQ2xCO0lBQ0EsT0FBTzRyQixZQUFZLENBQUNodkIsSUFBSSxFQUFFLElBQUksQ0FBQ3dkLElBQUksQ0FBQ3dXLE9BQU8sQ0FBQyxFQUFFO01BQzVDLEdBQUdyekIsT0FBTztNQUNWcUQsT0FBTyxFQUFFLFFBQVE7TUFDakJvSyxLQUFLO01BQ0xsVztJQUNGLENBQUMsQ0FBQztFQUNKOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0UrN0Isa0JBQWtCQSxDQUFDdHpCLE9BQU8sR0FBRyxFQUFFLEVBQUU7SUFDL0IsSUFBSSxDQUFDLElBQUksQ0FBQ3ZGLE9BQU8sRUFBRSxPQUFPLElBQUk7SUFFOUIsT0FBTzR6QixZQUFZLENBQUNydUIsT0FBTyxDQUFDWCxJQUFJLElBQUl1QixRQUFRLENBQUNxRCxVQUFVLENBQUMsRUFBRSxFQUFFO01BQUUxSSxJQUFJLEVBQUUsSUFBSSxDQUFDQTtLQUFNLENBQUMsRUFBRSxJQUFJLEVBQUU7TUFDdEYsR0FBR3lFLE9BQU87TUFDVnFELE9BQU8sRUFBRSxNQUFNO01BQ2ZvSyxLQUFLLEVBQUUsQ0FBQyxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sQ0FBQztNQUNsQzZnQixTQUFTLEVBQUU7SUFDYixDQUFDLENBQUM7RUFDSjs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBQ0UsT0FBT3ZKLEdBQUdBLENBQUMsR0FBR2pGLFNBQVMsRUFBRTtJQUN2QixJQUFJLENBQUNBLFNBQVMsQ0FBQ3lULEtBQUssQ0FBQzN5QixRQUFRLENBQUMwdkIsVUFBVSxDQUFDLEVBQUU7TUFDekMsTUFBTSxJQUFJOTRCLG9CQUFvQixDQUFDLHlDQUF5QyxDQUFDO0lBQzNFO0lBQ0EsT0FBTzZRLE1BQU0sQ0FBQ3lYLFNBQVMsRUFBR2xqQixDQUFDLElBQUtBLENBQUMsQ0FBQ2dnQixPQUFPLEVBQUUsRUFBRTllLElBQUksQ0FBQ2luQixHQUFHLENBQUM7RUFDeEQ7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUNFLE9BQU9DLEdBQUdBLENBQUMsR0FBR2xGLFNBQVMsRUFBRTtJQUN2QixJQUFJLENBQUNBLFNBQVMsQ0FBQ3lULEtBQUssQ0FBQzN5QixRQUFRLENBQUMwdkIsVUFBVSxDQUFDLEVBQUU7TUFDekMsTUFBTSxJQUFJOTRCLG9CQUFvQixDQUFDLHlDQUF5QyxDQUFDO0lBQzNFO0lBQ0EsT0FBTzZRLE1BQU0sQ0FBQ3lYLFNBQVMsRUFBR2xqQixDQUFDLElBQUtBLENBQUMsQ0FBQ2dnQixPQUFPLEVBQUUsRUFBRTllLElBQUksQ0FBQ2tuQixHQUFHLENBQUM7RUFDeEQ7O0VBRUE7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRSxPQUFPd08saUJBQWlCQSxDQUFDL1gsSUFBSSxFQUFFeEwsR0FBRyxFQUFFalEsT0FBTyxHQUFHLEVBQUUsRUFBRTtJQUNoRCxNQUFNO1FBQUUvRSxNQUFNLEdBQUcsSUFBSTtRQUFFa0YsZUFBZSxHQUFHO01BQUssQ0FBQyxHQUFHSCxPQUFPO01BQ3ZEbXdCLFdBQVcsR0FBRzdzQixNQUFNLENBQUNDLFFBQVEsQ0FBQztRQUM1QnRJLE1BQU07UUFDTmtGLGVBQWU7UUFDZnFELFdBQVcsRUFBRTtNQUNmLENBQUMsQ0FBQztJQUNKLE9BQU91bEIsaUJBQWlCLENBQUNvSCxXQUFXLEVBQUUxVSxJQUFJLEVBQUV4TCxHQUFHLENBQUM7RUFDbEQ7O0VBRUE7QUFDRjtBQUNBO0VBQ0UsT0FBT3dqQixpQkFBaUJBLENBQUNoWSxJQUFJLEVBQUV4TCxHQUFHLEVBQUVqUSxPQUFPLEdBQUcsRUFBRSxFQUFFO0lBQ2hELE9BQU9ZLFFBQVEsQ0FBQzR5QixpQkFBaUIsQ0FBQy9YLElBQUksRUFBRXhMLEdBQUcsRUFBRWpRLE9BQU8sQ0FBQztFQUN2RDs7RUFFQTs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtFQUNFLFdBQVduSSxVQUFVQSxDQUFBLEVBQUc7SUFDdEIsT0FBT0EsVUFBa0I7RUFDM0I7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7RUFDRSxXQUFXSSxRQUFRQSxDQUFBLEVBQUc7SUFDcEIsT0FBT0EsUUFBZ0I7RUFDekI7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7RUFDRSxXQUFXQyxxQkFBcUJBLENBQUEsRUFBRztJQUNqQyxPQUFPQSxxQkFBNkI7RUFDdEM7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7RUFDRSxXQUFXRSxTQUFTQSxDQUFBLEVBQUc7SUFDckIsT0FBT0EsU0FBaUI7RUFDMUI7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7RUFDRSxXQUFXQyxTQUFTQSxDQUFBLEVBQUc7SUFDckIsT0FBT0EsU0FBaUI7RUFDMUI7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7RUFDRSxXQUFXQyxXQUFXQSxDQUFBLEVBQUc7SUFDdkIsT0FBT0EsV0FBbUI7RUFDNUI7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7RUFDRSxXQUFXRyxpQkFBaUJBLENBQUEsRUFBRztJQUM3QixPQUFPQSxpQkFBeUI7RUFDbEM7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7RUFDRSxXQUFXRSxzQkFBc0JBLENBQUEsRUFBRztJQUNsQyxPQUFPQSxzQkFBOEI7RUFDdkM7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7RUFDRSxXQUFXRSxxQkFBcUJBLENBQUEsRUFBRztJQUNqQyxPQUFPQSxxQkFBNkI7RUFDdEM7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7RUFDRSxXQUFXQyxjQUFjQSxDQUFBLEVBQUc7SUFDMUIsT0FBT0EsY0FBc0I7RUFDL0I7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7RUFDRSxXQUFXRSxvQkFBb0JBLENBQUEsRUFBRztJQUNoQyxPQUFPQSxvQkFBNEI7RUFDckM7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7RUFDRSxXQUFXQyx5QkFBeUJBLENBQUEsRUFBRztJQUNyQyxPQUFPQSx5QkFBaUM7RUFDMUM7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7RUFDRSxXQUFXQyx3QkFBd0JBLENBQUEsRUFBRztJQUNwQyxPQUFPQSx3QkFBZ0M7RUFDekM7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7RUFDRSxXQUFXQyxjQUFjQSxDQUFBLEVBQUc7SUFDMUIsT0FBT0EsY0FBc0I7RUFDL0I7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7RUFDRSxXQUFXQywyQkFBMkJBLENBQUEsRUFBRztJQUN2QyxPQUFPQSwyQkFBbUM7RUFDNUM7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7RUFDRSxXQUFXQyxZQUFZQSxDQUFBLEVBQUc7SUFDeEIsT0FBT0EsWUFBb0I7RUFDN0I7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7RUFDRSxXQUFXQyx5QkFBeUJBLENBQUEsRUFBRztJQUNyQyxPQUFPQSx5QkFBaUM7RUFDMUM7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7RUFDRSxXQUFXQyx5QkFBeUJBLENBQUEsRUFBRztJQUNyQyxPQUFPQSx5QkFBaUM7RUFDMUM7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7RUFDRSxXQUFXQyxhQUFhQSxDQUFBLEVBQUc7SUFDekIsT0FBT0EsYUFBcUI7RUFDOUI7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7RUFDRSxXQUFXQywwQkFBMEJBLENBQUEsRUFBRztJQUN0QyxPQUFPQSwwQkFBa0M7RUFDM0M7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7RUFDRSxXQUFXQyxhQUFhQSxDQUFBLEVBQUc7SUFDekIsT0FBT0EsYUFBcUI7RUFDOUI7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7RUFDRSxXQUFXQywwQkFBMEJBLENBQUEsRUFBRztJQUN0QyxPQUFPQSwwQkFBa0M7RUFDM0M7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDTyxTQUFTZ2xCLGdCQUFnQkEsQ0FBQytVLFdBQVcsRUFBRTtFQUM1QyxJQUFJOXlCLFFBQVEsQ0FBQzB2QixVQUFVLENBQUNvRCxXQUFXLENBQUMsRUFBRTtJQUNwQyxPQUFPQSxXQUFXO0VBQ3BCLENBQUMsTUFBTSxJQUFJQSxXQUFXLElBQUlBLFdBQVcsQ0FBQzlXLE9BQU8sSUFBSXhWLFFBQVEsQ0FBQ3NzQixXQUFXLENBQUM5VyxPQUFPLEVBQUUsQ0FBQyxFQUFFO0lBQ2hGLE9BQU9oYyxRQUFRLENBQUNvdUIsVUFBVSxDQUFDMEUsV0FBVyxDQUFDO0dBQ3hDLE1BQU0sSUFBSUEsV0FBVyxJQUFJLE9BQU9BLFdBQVcsS0FBSyxRQUFRLEVBQUU7SUFDekQsT0FBTzl5QixRQUFRLENBQUNxRCxVQUFVLENBQUN5dkIsV0FBVyxDQUFDO0VBQ3pDLENBQUMsTUFBTTtJQUNMLE1BQU0sSUFBSWw4QixvQkFBb0IsQ0FDM0IsOEJBQTZCazhCLFdBQXdCLG9CQUFPQSxXQUFZLEVBQUMsQ0FDM0U7RUFDSDtBQUNGO0FDNXJFTSxNQUFBQyxPQUFPLEdBQUcifQ==