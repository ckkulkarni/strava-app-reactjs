{"version":3,"names":["applyReviver","reviver","obj","key","val","Array","isArray","i","len","length","v0","v1","String","undefined","Map","k","from","keys","get","delete","set","Set","add","Object","entries","call","exports"],"sources":["applyReviver.js"],"sourcesContent":["'use strict';\n\n/**\n * Applies the JSON.parse reviver algorithm as defined in the ECMA-262 spec,\n * in section 24.5.1.1 \"Runtime Semantics: InternalizeJSONProperty\" of the\n * 2021 edition: https://tc39.es/ecma262/#sec-json.parse\n *\n * Includes extensions for handling Map and Set objects.\n */\nfunction applyReviver(reviver, obj, key, val) {\n    if (val && typeof val === 'object') {\n        if (Array.isArray(val)) {\n            for (let i = 0, len = val.length; i < len; ++i) {\n                const v0 = val[i];\n                const v1 = applyReviver(reviver, val, String(i), v0);\n                if (v1 === undefined)\n                    delete val[i];\n                else if (v1 !== v0)\n                    val[i] = v1;\n            }\n        }\n        else if (val instanceof Map) {\n            for (const k of Array.from(val.keys())) {\n                const v0 = val.get(k);\n                const v1 = applyReviver(reviver, val, k, v0);\n                if (v1 === undefined)\n                    val.delete(k);\n                else if (v1 !== v0)\n                    val.set(k, v1);\n            }\n        }\n        else if (val instanceof Set) {\n            for (const v0 of Array.from(val)) {\n                const v1 = applyReviver(reviver, val, v0, v0);\n                if (v1 === undefined)\n                    val.delete(v0);\n                else if (v1 !== v0) {\n                    val.delete(v0);\n                    val.add(v1);\n                }\n            }\n        }\n        else {\n            for (const [k, v0] of Object.entries(val)) {\n                const v1 = applyReviver(reviver, val, k, v0);\n                if (v1 === undefined)\n                    delete val[k];\n                else if (v1 !== v0)\n                    val[k] = v1;\n            }\n        }\n    }\n    return reviver.call(obj, key, val);\n}\n\nexports.applyReviver = applyReviver;\n"],"mappings":"AAAA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,YAAYA,CAACC,OAAO,EAAEC,GAAG,EAAEC,GAAG,EAAEC,GAAG,EAAE;EAC1C,IAAIA,GAAG,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;IAChC,IAAIC,KAAK,CAACC,OAAO,CAACF,GAAG,CAAC,EAAE;MACpB,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGJ,GAAG,CAACK,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAE,EAAED,CAAC,EAAE;QAC5C,MAAMG,EAAE,GAAGN,GAAG,CAACG,CAAC,CAAC;QACjB,MAAMI,EAAE,GAAGX,YAAY,CAACC,OAAO,EAAEG,GAAG,EAAEQ,MAAM,CAACL,CAAC,CAAC,EAAEG,EAAE,CAAC;QACpD,IAAIC,EAAE,KAAKE,SAAS,EAChB,OAAOT,GAAG,CAACG,CAAC,CAAC,CAAC,KACb,IAAII,EAAE,KAAKD,EAAE,EACdN,GAAG,CAACG,CAAC,CAAC,GAAGI,EAAE;MACnB;IACJ,CAAC,MACI,IAAIP,GAAG,YAAYU,GAAG,EAAE;MACzB,KAAK,MAAMC,CAAC,IAAIV,KAAK,CAACW,IAAI,CAACZ,GAAG,CAACa,IAAI,EAAE,CAAC,EAAE;QACpC,MAAMP,EAAE,GAAGN,GAAG,CAACc,GAAG,CAACH,CAAC,CAAC;QACrB,MAAMJ,EAAE,GAAGX,YAAY,CAACC,OAAO,EAAEG,GAAG,EAAEW,CAAC,EAAEL,EAAE,CAAC;QAC5C,IAAIC,EAAE,KAAKE,SAAS,EAChBT,GAAG,CAACe,MAAM,CAACJ,CAAC,CAAC,CAAC,KACb,IAAIJ,EAAE,KAAKD,EAAE,EACdN,GAAG,CAACgB,GAAG,CAACL,CAAC,EAAEJ,EAAE,CAAC;MACtB;IACJ,CAAC,MACI,IAAIP,GAAG,YAAYiB,GAAG,EAAE;MACzB,KAAK,MAAMX,EAAE,IAAIL,KAAK,CAACW,IAAI,CAACZ,GAAG,CAAC,EAAE;QAC9B,MAAMO,EAAE,GAAGX,YAAY,CAACC,OAAO,EAAEG,GAAG,EAAEM,EAAE,EAAEA,EAAE,CAAC;QAC7C,IAAIC,EAAE,KAAKE,SAAS,EAChBT,GAAG,CAACe,MAAM,CAACT,EAAE,CAAC,CAAC,KACd,IAAIC,EAAE,KAAKD,EAAE,EAAE;UAChBN,GAAG,CAACe,MAAM,CAACT,EAAE,CAAC;UACdN,GAAG,CAACkB,GAAG,CAACX,EAAE,CAAC;QACf;MACJ;IACJ,CAAC,MACI;MACD,KAAK,MAAM,CAACI,CAAC,EAAEL,EAAE,CAAC,IAAIa,MAAM,CAACC,OAAO,CAACpB,GAAG,CAAC,EAAE;QACvC,MAAMO,EAAE,GAAGX,YAAY,CAACC,OAAO,EAAEG,GAAG,EAAEW,CAAC,EAAEL,EAAE,CAAC;QAC5C,IAAIC,EAAE,KAAKE,SAAS,EAChB,OAAOT,GAAG,CAACW,CAAC,CAAC,CAAC,KACb,IAAIJ,EAAE,KAAKD,EAAE,EACdN,GAAG,CAACW,CAAC,CAAC,GAAGJ,EAAE;MACnB;IACJ;EACJ;EACA,OAAOV,OAAO,CAACwB,IAAI,CAACvB,GAAG,EAAEC,GAAG,EAAEC,GAAG,CAAC;AACtC;AAEAsB,OAAO,CAAC1B,YAAY,GAAGA,YAAY"}