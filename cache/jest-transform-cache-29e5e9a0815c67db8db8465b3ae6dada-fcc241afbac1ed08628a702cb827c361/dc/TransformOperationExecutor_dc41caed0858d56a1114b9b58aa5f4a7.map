{"version":3,"names":["storage_1","require","enums_1","utils_1","instantiateArrayType","arrayType","array","Set","TransformOperationExecutor","constructor","transformationType","options","recursionStack","transform","source","value","targetType","isMap","level","Array","isArray","newValue","TransformationType","PLAIN_TO_CLASS","forEach","subValue","index","subSource","undefined","enableCircularCheck","isCircular","realTargetType","discriminator","property","subTypes","find","subType","name","newObject","object","newType","typeFunction","keepDiscriminatorProperty","CLASS_TO_CLASS","CLASS_TO_PLAIN","Map","add","push","String","Number","Boolean","Date","valueOf","getGlobal","Buffer","from","isPromise","Promise","resolve","reject","then","data","Object","keys","getKeys","key","valueKey","newValueKey","propertyName","ignoreDecorators","exposeMetadata","defaultMetadataStorage","findExposeMetadataByCustomName","findExposeMetadata","get","Function","type","isSubValueMap","metadata","findTypeMetadata","reflectedType","targetMaps","filter","map","target","properties","enableImplicitConversion","Reflect","getMetadata","prototype","getReflectedType","descriptor","getOwnPropertyDescriptor","set","transformKey","finalValue","applyCustomTransformations","exposeDefaultValues","exposeUnsetFields","delete","obj","metadatas","findTransformMetadatas","version","checkVersion","since","until","groups","length","checkGroups","transformFn","has","meta","strategy","getStrategy","excludeExtraneousValues","exposedProperties","getExposedProperties","excludedProperties","getExcludedProperties","concat","includes","excludePrefixes","every","prefix","substr","self","indexOf","decision","some","optionGroup","exports"],"sources":["../../src/TransformOperationExecutor.ts"],"sourcesContent":["import { defaultMetadataStorage } from './storage';\nimport { ClassTransformOptions, TypeHelpOptions, TypeMetadata, TypeOptions } from './interfaces';\nimport { TransformationType } from './enums';\nimport { getGlobal, isPromise } from './utils';\n\nfunction instantiateArrayType(arrayType: Function): Array<any> | Set<any> {\n  const array = new (arrayType as any)();\n  if (!(array instanceof Set) && !('push' in array)) {\n    return [];\n  }\n  return array;\n}\n\nexport class TransformOperationExecutor {\n  // -------------------------------------------------------------------------\n  // Private Properties\n  // -------------------------------------------------------------------------\n\n  private recursionStack = new Set<Record<string, any>>();\n\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n\n  constructor(private transformationType: TransformationType, private options: ClassTransformOptions) {}\n\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  transform(\n    source: Record<string, any> | Record<string, any>[] | any,\n    value: Record<string, any> | Record<string, any>[] | any,\n    targetType: Function | TypeMetadata,\n    arrayType: Function,\n    isMap: boolean,\n    level: number = 0\n  ): any {\n    if (Array.isArray(value) || value instanceof Set) {\n      const newValue =\n        arrayType && this.transformationType === TransformationType.PLAIN_TO_CLASS\n          ? instantiateArrayType(arrayType)\n          : [];\n      (value as any[]).forEach((subValue, index) => {\n        const subSource = source ? source[index] : undefined;\n        if (!this.options.enableCircularCheck || !this.isCircular(subValue)) {\n          let realTargetType;\n          if (\n            typeof targetType !== 'function' &&\n            targetType &&\n            targetType.options &&\n            targetType.options.discriminator &&\n            targetType.options.discriminator.property &&\n            targetType.options.discriminator.subTypes\n          ) {\n            if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n              realTargetType = targetType.options.discriminator.subTypes.find(\n                subType =>\n                  subType.name === subValue[(targetType as { options: TypeOptions }).options.discriminator.property]\n              );\n              const options: TypeHelpOptions = { newObject: newValue, object: subValue, property: undefined };\n              const newType = targetType.typeFunction(options);\n              realTargetType === undefined ? (realTargetType = newType) : (realTargetType = realTargetType.value);\n              if (!targetType.options.keepDiscriminatorProperty)\n                delete subValue[targetType.options.discriminator.property];\n            }\n\n            if (this.transformationType === TransformationType.CLASS_TO_CLASS) {\n              realTargetType = subValue.constructor;\n            }\n            if (this.transformationType === TransformationType.CLASS_TO_PLAIN) {\n              subValue[targetType.options.discriminator.property] = targetType.options.discriminator.subTypes.find(\n                subType => subType.value === subValue.constructor\n              ).name;\n            }\n          } else {\n            realTargetType = targetType;\n          }\n          const value = this.transform(\n            subSource,\n            subValue,\n            realTargetType,\n            undefined,\n            subValue instanceof Map,\n            level + 1\n          );\n\n          if (newValue instanceof Set) {\n            newValue.add(value);\n          } else {\n            newValue.push(value);\n          }\n        } else if (this.transformationType === TransformationType.CLASS_TO_CLASS) {\n          if (newValue instanceof Set) {\n            newValue.add(subValue);\n          } else {\n            newValue.push(subValue);\n          }\n        }\n      });\n      return newValue;\n    } else if (targetType === String && !isMap) {\n      if (value === null || value === undefined) return value;\n      return String(value);\n    } else if (targetType === Number && !isMap) {\n      if (value === null || value === undefined) return value;\n      return Number(value);\n    } else if (targetType === Boolean && !isMap) {\n      if (value === null || value === undefined) return value;\n      return Boolean(value);\n    } else if ((targetType === Date || value instanceof Date) && !isMap) {\n      if (value instanceof Date) {\n        return new Date(value.valueOf());\n      }\n      if (value === null || value === undefined) return value;\n      return new Date(value);\n    } else if (!!getGlobal().Buffer && (targetType === Buffer || value instanceof Buffer) && !isMap) {\n      if (value === null || value === undefined) return value;\n      return Buffer.from(value);\n    } else if (isPromise(value) && !isMap) {\n      return new Promise((resolve, reject) => {\n        value.then(\n          (data: any) => resolve(this.transform(undefined, data, targetType, undefined, undefined, level + 1)),\n          reject\n        );\n      });\n    } else if (!isMap && value !== null && typeof value === 'object' && typeof value.then === 'function') {\n      // Note: We should not enter this, as promise has been handled above\n      // This option simply returns the Promise preventing a JS error from happening and should be an inaccessible path.\n      return value; // skip promise transformation\n    } else if (typeof value === 'object' && value !== null) {\n      // try to guess the type\n      if (!targetType && value.constructor !== Object /* && TransformationType === TransformationType.CLASS_TO_PLAIN*/)\n        if (!Array.isArray(value) && value.constructor === Array) {\n          // Somebody attempts to convert special Array like object to Array, eg:\n          // const evilObject = { '100000000': '100000000', __proto__: [] };\n          // This could be used to cause Denial-of-service attack so we don't allow it.\n          // See prevent-array-bomb.spec.ts for more details.\n        } else {\n          // We are good we can use the built-in constructor\n          targetType = value.constructor;\n        }\n      if (!targetType && source) targetType = source.constructor;\n\n      if (this.options.enableCircularCheck) {\n        // add transformed type to prevent circular references\n        this.recursionStack.add(value);\n      }\n\n      const keys = this.getKeys(targetType as Function, value, isMap);\n      let newValue: any = source ? source : {};\n      if (\n        !source &&\n        (this.transformationType === TransformationType.PLAIN_TO_CLASS ||\n          this.transformationType === TransformationType.CLASS_TO_CLASS)\n      ) {\n        if (isMap) {\n          newValue = new Map();\n        } else if (targetType) {\n          newValue = new (targetType as any)();\n        } else {\n          newValue = {};\n        }\n      }\n\n      // traverse over keys\n      for (const key of keys) {\n        if (key === '__proto__' || key === 'constructor') {\n          continue;\n        }\n\n        const valueKey = key;\n        let newValueKey = key,\n          propertyName = key;\n        if (!this.options.ignoreDecorators && targetType) {\n          if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n            const exposeMetadata = defaultMetadataStorage.findExposeMetadataByCustomName(targetType as Function, key);\n            if (exposeMetadata) {\n              propertyName = exposeMetadata.propertyName;\n              newValueKey = exposeMetadata.propertyName;\n            }\n          } else if (\n            this.transformationType === TransformationType.CLASS_TO_PLAIN ||\n            this.transformationType === TransformationType.CLASS_TO_CLASS\n          ) {\n            const exposeMetadata = defaultMetadataStorage.findExposeMetadata(targetType as Function, key);\n            if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {\n              newValueKey = exposeMetadata.options.name;\n            }\n          }\n        }\n\n        // get a subvalue\n        let subValue: any = undefined;\n        if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n          /**\n           * This section is added for the following report:\n           * https://github.com/typestack/class-transformer/issues/596\n           *\n           * We should not call functions or constructors when transforming to class.\n           */\n          subValue = value[valueKey];\n        } else {\n          if (value instanceof Map) {\n            subValue = value.get(valueKey);\n          } else if (value[valueKey] instanceof Function) {\n            subValue = value[valueKey]();\n          } else {\n            subValue = value[valueKey];\n          }\n        }\n\n        // determine a type\n        let type: any = undefined,\n          isSubValueMap = subValue instanceof Map;\n        if (targetType && isMap) {\n          type = targetType;\n        } else if (targetType) {\n          const metadata = defaultMetadataStorage.findTypeMetadata(targetType as Function, propertyName);\n          if (metadata) {\n            const options: TypeHelpOptions = { newObject: newValue, object: value, property: propertyName };\n            const newType = metadata.typeFunction ? metadata.typeFunction(options) : metadata.reflectedType;\n            if (\n              metadata.options &&\n              metadata.options.discriminator &&\n              metadata.options.discriminator.property &&\n              metadata.options.discriminator.subTypes\n            ) {\n              if (!(value[valueKey] instanceof Array)) {\n                if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                  type = metadata.options.discriminator.subTypes.find(subType => {\n                    if (subValue && subValue instanceof Object && metadata.options.discriminator.property in subValue) {\n                      return subType.name === subValue[metadata.options.discriminator.property];\n                    }\n                  });\n                  type === undefined ? (type = newType) : (type = type.value);\n                  if (!metadata.options.keepDiscriminatorProperty) {\n                    if (subValue && subValue instanceof Object && metadata.options.discriminator.property in subValue) {\n                      delete subValue[metadata.options.discriminator.property];\n                    }\n                  }\n                }\n                if (this.transformationType === TransformationType.CLASS_TO_CLASS) {\n                  type = subValue.constructor;\n                }\n                if (this.transformationType === TransformationType.CLASS_TO_PLAIN) {\n                  if (subValue) {\n                    subValue[metadata.options.discriminator.property] = metadata.options.discriminator.subTypes.find(\n                      subType => subType.value === subValue.constructor\n                    ).name;\n                  }\n                }\n              } else {\n                type = metadata;\n              }\n            } else {\n              type = newType;\n            }\n            isSubValueMap = isSubValueMap || metadata.reflectedType === Map;\n          } else if (this.options.targetMaps) {\n            // try to find a type in target maps\n            this.options.targetMaps\n              .filter(map => map.target === targetType && !!map.properties[propertyName])\n              .forEach(map => (type = map.properties[propertyName]));\n          } else if (\n            this.options.enableImplicitConversion &&\n            this.transformationType === TransformationType.PLAIN_TO_CLASS\n          ) {\n            // if we have no registererd type via the @Type() decorator then we check if we have any\n            // type declarations in reflect-metadata (type declaration is emited only if some decorator is added to the property.)\n            const reflectedType = (Reflect as any).getMetadata(\n              'design:type',\n              (targetType as Function).prototype,\n              propertyName\n            );\n\n            if (reflectedType) {\n              type = reflectedType;\n            }\n          }\n        }\n\n        // if value is an array try to get its custom array type\n        const arrayType = Array.isArray(value[valueKey])\n          ? this.getReflectedType(targetType as Function, propertyName)\n          : undefined;\n\n        // const subValueKey = TransformationType === TransformationType.PLAIN_TO_CLASS && newKeyName ? newKeyName : key;\n        const subSource = source ? source[valueKey] : undefined;\n\n        // if its deserialization then type if required\n        // if we uncomment this types like string[] will not work\n        // if (this.transformationType === TransformationType.PLAIN_TO_CLASS && !type && subValue instanceof Object && !(subValue instanceof Date))\n        //     throw new Error(`Cannot determine type for ${(targetType as any).name }.${propertyName}, did you forget to specify a @Type?`);\n\n        // if newValue is a source object that has method that match newKeyName then skip it\n        if (newValue.constructor.prototype) {\n          const descriptor = Object.getOwnPropertyDescriptor(newValue.constructor.prototype, newValueKey);\n          if (\n            (this.transformationType === TransformationType.PLAIN_TO_CLASS ||\n              this.transformationType === TransformationType.CLASS_TO_CLASS) &&\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            ((descriptor && !descriptor.set) || newValue[newValueKey] instanceof Function)\n          )\n            //  || TransformationType === TransformationType.CLASS_TO_CLASS\n            continue;\n        }\n\n        if (!this.options.enableCircularCheck || !this.isCircular(subValue)) {\n          const transformKey = this.transformationType === TransformationType.PLAIN_TO_CLASS ? newValueKey : key;\n          let finalValue;\n\n          if (this.transformationType === TransformationType.CLASS_TO_PLAIN) {\n            // Get original value\n            finalValue = value[transformKey];\n            // Apply custom transformation\n            finalValue = this.applyCustomTransformations(\n              finalValue,\n              targetType as Function,\n              transformKey,\n              value,\n              this.transformationType\n            );\n            // If nothing change, it means no custom transformation was applied, so use the subValue.\n            finalValue = value[transformKey] === finalValue ? subValue : finalValue;\n            // Apply the default transformation\n            finalValue = this.transform(subSource, finalValue, type, arrayType, isSubValueMap, level + 1);\n          } else {\n            if (subValue === undefined && this.options.exposeDefaultValues) {\n              // Set default value if nothing provided\n              finalValue = newValue[newValueKey];\n            } else {\n              finalValue = this.transform(subSource, subValue, type, arrayType, isSubValueMap, level + 1);\n              finalValue = this.applyCustomTransformations(\n                finalValue,\n                targetType as Function,\n                transformKey,\n                value,\n                this.transformationType\n              );\n            }\n          }\n\n          if (finalValue !== undefined || this.options.exposeUnsetFields) {\n            if (newValue instanceof Map) {\n              newValue.set(newValueKey, finalValue);\n            } else {\n              newValue[newValueKey] = finalValue;\n            }\n          }\n        } else if (this.transformationType === TransformationType.CLASS_TO_CLASS) {\n          let finalValue = subValue;\n          finalValue = this.applyCustomTransformations(\n            finalValue,\n            targetType as Function,\n            key,\n            value,\n            this.transformationType\n          );\n          if (finalValue !== undefined || this.options.exposeUnsetFields) {\n            if (newValue instanceof Map) {\n              newValue.set(newValueKey, finalValue);\n            } else {\n              newValue[newValueKey] = finalValue;\n            }\n          }\n        }\n      }\n\n      if (this.options.enableCircularCheck) {\n        this.recursionStack.delete(value);\n      }\n\n      return newValue;\n    } else {\n      return value;\n    }\n  }\n\n  private applyCustomTransformations(\n    value: any,\n    target: Function,\n    key: string,\n    obj: any,\n    transformationType: TransformationType\n  ): boolean {\n    let metadatas = defaultMetadataStorage.findTransformMetadatas(target, key, this.transformationType);\n\n    // apply versioning options\n    if (this.options.version !== undefined) {\n      metadatas = metadatas.filter(metadata => {\n        if (!metadata.options) return true;\n\n        return this.checkVersion(metadata.options.since, metadata.options.until);\n      });\n    }\n\n    // apply grouping options\n    if (this.options.groups && this.options.groups.length) {\n      metadatas = metadatas.filter(metadata => {\n        if (!metadata.options) return true;\n\n        return this.checkGroups(metadata.options.groups);\n      });\n    } else {\n      metadatas = metadatas.filter(metadata => {\n        return !metadata.options || !metadata.options.groups || !metadata.options.groups.length;\n      });\n    }\n\n    metadatas.forEach(metadata => {\n      value = metadata.transformFn({ value, key, obj, type: transformationType, options: this.options });\n    });\n\n    return value;\n  }\n\n  // preventing circular references\n  private isCircular(object: Record<string, any>): boolean {\n    return this.recursionStack.has(object);\n  }\n\n  private getReflectedType(target: Function, propertyName: string): Function | undefined {\n    if (!target) return undefined;\n    const meta = defaultMetadataStorage.findTypeMetadata(target, propertyName);\n    return meta ? meta.reflectedType : undefined;\n  }\n\n  private getKeys(target: Function, object: Record<string, any>, isMap: boolean): string[] {\n    // determine exclusion strategy\n    let strategy = defaultMetadataStorage.getStrategy(target);\n    if (strategy === 'none') strategy = this.options.strategy || 'exposeAll'; // exposeAll is default strategy\n\n    // get all keys that need to expose\n    let keys: any[] = [];\n    if (strategy === 'exposeAll' || isMap) {\n      if (object instanceof Map) {\n        keys = Array.from(object.keys());\n      } else {\n        keys = Object.keys(object);\n      }\n    }\n\n    if (isMap) {\n      // expose & exclude do not apply for map keys only to fields\n      return keys;\n    }\n\n    /**\n     * If decorators are ignored but we don't want the extraneous values, then we use the\n     * metadata to decide which property is needed, but doesn't apply the decorator effect.\n     */\n    if (this.options.ignoreDecorators && this.options.excludeExtraneousValues && target) {\n      const exposedProperties = defaultMetadataStorage.getExposedProperties(target, this.transformationType);\n      const excludedProperties = defaultMetadataStorage.getExcludedProperties(target, this.transformationType);\n      keys = [...exposedProperties, ...excludedProperties];\n    }\n\n    if (!this.options.ignoreDecorators && target) {\n      // add all exposed to list of keys\n      let exposedProperties = defaultMetadataStorage.getExposedProperties(target, this.transformationType);\n      if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n        exposedProperties = exposedProperties.map(key => {\n          const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n          if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {\n            return exposeMetadata.options.name;\n          }\n\n          return key;\n        });\n      }\n      if (this.options.excludeExtraneousValues) {\n        keys = exposedProperties;\n      } else {\n        keys = keys.concat(exposedProperties);\n      }\n\n      // exclude excluded properties\n      const excludedProperties = defaultMetadataStorage.getExcludedProperties(target, this.transformationType);\n      if (excludedProperties.length > 0) {\n        keys = keys.filter(key => {\n          return !excludedProperties.includes(key);\n        });\n      }\n\n      // apply versioning options\n      if (this.options.version !== undefined) {\n        keys = keys.filter(key => {\n          const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n          if (!exposeMetadata || !exposeMetadata.options) return true;\n\n          return this.checkVersion(exposeMetadata.options.since, exposeMetadata.options.until);\n        });\n      }\n\n      // apply grouping options\n      if (this.options.groups && this.options.groups.length) {\n        keys = keys.filter(key => {\n          const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n          if (!exposeMetadata || !exposeMetadata.options) return true;\n\n          return this.checkGroups(exposeMetadata.options.groups);\n        });\n      } else {\n        keys = keys.filter(key => {\n          const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n          return (\n            !exposeMetadata ||\n            !exposeMetadata.options ||\n            !exposeMetadata.options.groups ||\n            !exposeMetadata.options.groups.length\n          );\n        });\n      }\n    }\n\n    // exclude prefixed properties\n    if (this.options.excludePrefixes && this.options.excludePrefixes.length) {\n      keys = keys.filter(key =>\n        this.options.excludePrefixes.every(prefix => {\n          return key.substr(0, prefix.length) !== prefix;\n        })\n      );\n    }\n\n    // make sure we have unique keys\n    keys = keys.filter((key, index, self) => {\n      return self.indexOf(key) === index;\n    });\n\n    return keys;\n  }\n\n  private checkVersion(since: number, until: number): boolean {\n    let decision = true;\n    if (decision && since) decision = this.options.version >= since;\n    if (decision && until) decision = this.options.version < until;\n\n    return decision;\n  }\n\n  private checkGroups(groups: string[]): boolean {\n    if (!groups) return true;\n\n    return this.options.groups.some(optionGroup => groups.includes(optionGroup));\n  }\n}\n"],"mappings":";;;;;;AAAA,MAAAA,SAAA,GAAAC,OAAA;AAEA,MAAAC,OAAA,GAAAD,OAAA;AACA,MAAAE,OAAA,GAAAF,OAAA;AAEA,SAASG,oBAAoBA,CAACC,SAAmB;EAC/C,MAAMC,KAAK,GAAG,IAAKD,SAAiB,EAAE;EACtC,IAAI,EAAEC,KAAK,YAAYC,GAAG,CAAC,IAAI,EAAE,MAAM,IAAID,KAAK,CAAC,EAAE;IACjD,OAAO,EAAE;;EAEX,OAAOA,KAAK;AACd;AAEA,MAAaE,0BAA0B;EAOrC;EACA;EACA;EAEAC,YAAoBC,kBAAsC,EAAUC,OAA8B;IAA9E,KAAAD,kBAAkB,GAAlBA,kBAAkB;IAA8B,KAAAC,OAAO,GAAPA,OAAO;IAV3E;IACA;IACA;IAEQ,KAAAC,cAAc,GAAG,IAAIL,GAAG,EAAuB;EAM8C;EAErG;EACA;EACA;EAEAM,SAASA,CACPC,MAAyD,EACzDC,KAAwD,EACxDC,UAAmC,EACnCX,SAAmB,EACnBY,KAAc,EACdC,KAAA,GAAgB,CAAC;IAEjB,IAAIC,KAAK,CAACC,OAAO,CAACL,KAAK,CAAC,IAAIA,KAAK,YAAYR,GAAG,EAAE;MAChD,MAAMc,QAAQ,GACZhB,SAAS,IAAI,IAAI,CAACK,kBAAkB,KAAKR,OAAA,CAAAoB,kBAAkB,CAACC,cAAc,GACtEnB,oBAAoB,CAACC,SAAS,CAAC,GAC/B,EAAE;MACPU,KAAe,CAACS,OAAO,CAAC,CAACC,QAAQ,EAAEC,KAAK,KAAI;QAC3C,MAAMC,SAAS,GAAGb,MAAM,GAAGA,MAAM,CAACY,KAAK,CAAC,GAAGE,SAAS;QACpD,IAAI,CAAC,IAAI,CAACjB,OAAO,CAACkB,mBAAmB,IAAI,CAAC,IAAI,CAACC,UAAU,CAACL,QAAQ,CAAC,EAAE;UACnE,IAAIM,cAAc;UAClB,IACE,OAAOf,UAAU,KAAK,UAAU,IAChCA,UAAU,IACVA,UAAU,CAACL,OAAO,IAClBK,UAAU,CAACL,OAAO,CAACqB,aAAa,IAChChB,UAAU,CAACL,OAAO,CAACqB,aAAa,CAACC,QAAQ,IACzCjB,UAAU,CAACL,OAAO,CAACqB,aAAa,CAACE,QAAQ,EACzC;YACA,IAAI,IAAI,CAACxB,kBAAkB,KAAKR,OAAA,CAAAoB,kBAAkB,CAACC,cAAc,EAAE;cACjEQ,cAAc,GAAGf,UAAU,CAACL,OAAO,CAACqB,aAAa,CAACE,QAAQ,CAACC,IAAI,CAC7DC,OAAO,IACLA,OAAO,CAACC,IAAI,KAAKZ,QAAQ,CAAET,UAAuC,CAACL,OAAO,CAACqB,aAAa,CAACC,QAAQ,CAAC,CACrG;cACD,MAAMtB,OAAO,GAAoB;gBAAE2B,SAAS,EAAEjB,QAAQ;gBAAEkB,MAAM,EAAEd,QAAQ;gBAAEQ,QAAQ,EAAEL;cAAS,CAAE;cAC/F,MAAMY,OAAO,GAAGxB,UAAU,CAACyB,YAAY,CAAC9B,OAAO,CAAC;cAChDoB,cAAc,KAAKH,SAAS,GAAIG,cAAc,GAAGS,OAAO,GAAKT,cAAc,GAAGA,cAAc,CAAChB,KAAM;cACnG,IAAI,CAACC,UAAU,CAACL,OAAO,CAAC+B,yBAAyB,EAC/C,OAAOjB,QAAQ,CAACT,UAAU,CAACL,OAAO,CAACqB,aAAa,CAACC,QAAQ,CAAC;;YAG9D,IAAI,IAAI,CAACvB,kBAAkB,KAAKR,OAAA,CAAAoB,kBAAkB,CAACqB,cAAc,EAAE;cACjEZ,cAAc,GAAGN,QAAQ,CAAChB,WAAW;;YAEvC,IAAI,IAAI,CAACC,kBAAkB,KAAKR,OAAA,CAAAoB,kBAAkB,CAACsB,cAAc,EAAE;cACjEnB,QAAQ,CAACT,UAAU,CAACL,OAAO,CAACqB,aAAa,CAACC,QAAQ,CAAC,GAAGjB,UAAU,CAACL,OAAO,CAACqB,aAAa,CAACE,QAAQ,CAACC,IAAI,CAClGC,OAAO,IAAIA,OAAO,CAACrB,KAAK,KAAKU,QAAQ,CAAChB,WAAW,CAClD,CAAC4B,IAAI;;WAET,MAAM;YACLN,cAAc,GAAGf,UAAU;;UAE7B,MAAMD,KAAK,GAAG,IAAI,CAACF,SAAS,CAC1Bc,SAAS,EACTF,QAAQ,EACRM,cAAc,EACdH,SAAS,EACTH,QAAQ,YAAYoB,GAAG,EACvB3B,KAAK,GAAG,CAAC,CACV;UAED,IAAIG,QAAQ,YAAYd,GAAG,EAAE;YAC3Bc,QAAQ,CAACyB,GAAG,CAAC/B,KAAK,CAAC;WACpB,MAAM;YACLM,QAAQ,CAAC0B,IAAI,CAAChC,KAAK,CAAC;;SAEvB,MAAM,IAAI,IAAI,CAACL,kBAAkB,KAAKR,OAAA,CAAAoB,kBAAkB,CAACqB,cAAc,EAAE;UACxE,IAAItB,QAAQ,YAAYd,GAAG,EAAE;YAC3Bc,QAAQ,CAACyB,GAAG,CAACrB,QAAQ,CAAC;WACvB,MAAM;YACLJ,QAAQ,CAAC0B,IAAI,CAACtB,QAAQ,CAAC;;;MAG7B,CAAC,CAAC;MACF,OAAOJ,QAAQ;KAChB,MAAM,IAAIL,UAAU,KAAKgC,MAAM,IAAI,CAAC/B,KAAK,EAAE;MAC1C,IAAIF,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAKa,SAAS,EAAE,OAAOb,KAAK;MACvD,OAAOiC,MAAM,CAACjC,KAAK,CAAC;KACrB,MAAM,IAAIC,UAAU,KAAKiC,MAAM,IAAI,CAAChC,KAAK,EAAE;MAC1C,IAAIF,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAKa,SAAS,EAAE,OAAOb,KAAK;MACvD,OAAOkC,MAAM,CAAClC,KAAK,CAAC;KACrB,MAAM,IAAIC,UAAU,KAAKkC,OAAO,IAAI,CAACjC,KAAK,EAAE;MAC3C,IAAIF,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAKa,SAAS,EAAE,OAAOb,KAAK;MACvD,OAAOmC,OAAO,CAACnC,KAAK,CAAC;KACtB,MAAM,IAAI,CAACC,UAAU,KAAKmC,IAAI,IAAIpC,KAAK,YAAYoC,IAAI,KAAK,CAAClC,KAAK,EAAE;MACnE,IAAIF,KAAK,YAAYoC,IAAI,EAAE;QACzB,OAAO,IAAIA,IAAI,CAACpC,KAAK,CAACqC,OAAO,EAAE,CAAC;;MAElC,IAAIrC,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAKa,SAAS,EAAE,OAAOb,KAAK;MACvD,OAAO,IAAIoC,IAAI,CAACpC,KAAK,CAAC;KACvB,MAAM,IAAI,CAAC,CAAC,IAAAZ,OAAA,CAAAkD,SAAS,GAAE,CAACC,MAAM,KAAKtC,UAAU,KAAKsC,MAAM,IAAIvC,KAAK,YAAYuC,MAAM,CAAC,IAAI,CAACrC,KAAK,EAAE;MAC/F,IAAIF,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAKa,SAAS,EAAE,OAAOb,KAAK;MACvD,OAAOuC,MAAM,CAACC,IAAI,CAACxC,KAAK,CAAC;KAC1B,MAAM,IAAI,IAAAZ,OAAA,CAAAqD,SAAS,EAACzC,KAAK,CAAC,IAAI,CAACE,KAAK,EAAE;MACrC,OAAO,IAAIwC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAI;QACrC5C,KAAK,CAAC6C,IAAI,CACPC,IAAS,IAAKH,OAAO,CAAC,IAAI,CAAC7C,SAAS,CAACe,SAAS,EAAEiC,IAAI,EAAE7C,UAAU,EAAEY,SAAS,EAAEA,SAAS,EAAEV,KAAK,GAAG,CAAC,CAAC,CAAC,EACpGyC,MAAM,CACP;MACH,CAAC,CAAC;KACH,MAAM,IAAI,CAAC1C,KAAK,IAAIF,KAAK,KAAK,IAAI,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAI,OAAOA,KAAK,CAAC6C,IAAI,KAAK,UAAU,EAAE;MACpG;MACA;MACA,OAAO7C,KAAK,CAAC,CAAC;KACf,MAAM,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAIA,KAAK,KAAK,IAAI,EAAE;MACtD;MACA,IAAI,CAACC,UAAU,IAAID,KAAK,CAACN,WAAW,KAAKqD,MAAM,CAAC,kEAC9C,IAAI,CAAC3C,KAAK,CAACC,OAAO,CAACL,KAAK,CAAC,IAAIA,KAAK,CAACN,WAAW,KAAKU,KAAK,EAAE;QACxD;QACA;QACA;QACA;MAAA,CACD,MAAM;QACL;QACAH,UAAU,GAAGD,KAAK,CAACN,WAAW;;MAElC,IAAI,CAACO,UAAU,IAAIF,MAAM,EAAEE,UAAU,GAAGF,MAAM,CAACL,WAAW;MAE1D,IAAI,IAAI,CAACE,OAAO,CAACkB,mBAAmB,EAAE;QACpC;QACA,IAAI,CAACjB,cAAc,CAACkC,GAAG,CAAC/B,KAAK,CAAC;;MAGhC,MAAMgD,IAAI,GAAG,IAAI,CAACC,OAAO,CAAChD,UAAsB,EAAED,KAAK,EAAEE,KAAK,CAAC;MAC/D,IAAII,QAAQ,GAAQP,MAAM,GAAGA,MAAM,GAAG,EAAE;MACxC,IACE,CAACA,MAAM,KACN,IAAI,CAACJ,kBAAkB,KAAKR,OAAA,CAAAoB,kBAAkB,CAACC,cAAc,IAC5D,IAAI,CAACb,kBAAkB,KAAKR,OAAA,CAAAoB,kBAAkB,CAACqB,cAAc,CAAC,EAChE;QACA,IAAI1B,KAAK,EAAE;UACTI,QAAQ,GAAG,IAAIwB,GAAG,EAAE;SACrB,MAAM,IAAI7B,UAAU,EAAE;UACrBK,QAAQ,GAAG,IAAKL,UAAkB,EAAE;SACrC,MAAM;UACLK,QAAQ,GAAG,EAAE;;;MAIjB;MACA,KAAK,MAAM4C,GAAG,IAAIF,IAAI,EAAE;QACtB,IAAIE,GAAG,KAAK,WAAW,IAAIA,GAAG,KAAK,aAAa,EAAE;UAChD;;QAGF,MAAMC,QAAQ,GAAGD,GAAG;QACpB,IAAIE,WAAW,GAAGF,GAAG;UACnBG,YAAY,GAAGH,GAAG;QACpB,IAAI,CAAC,IAAI,CAACtD,OAAO,CAAC0D,gBAAgB,IAAIrD,UAAU,EAAE;UAChD,IAAI,IAAI,CAACN,kBAAkB,KAAKR,OAAA,CAAAoB,kBAAkB,CAACC,cAAc,EAAE;YACjE,MAAM+C,cAAc,GAAGtE,SAAA,CAAAuE,sBAAsB,CAACC,8BAA8B,CAACxD,UAAsB,EAAEiD,GAAG,CAAC;YACzG,IAAIK,cAAc,EAAE;cAClBF,YAAY,GAAGE,cAAc,CAACF,YAAY;cAC1CD,WAAW,GAAGG,cAAc,CAACF,YAAY;;WAE5C,MAAM,IACL,IAAI,CAAC1D,kBAAkB,KAAKR,OAAA,CAAAoB,kBAAkB,CAACsB,cAAc,IAC7D,IAAI,CAAClC,kBAAkB,KAAKR,OAAA,CAAAoB,kBAAkB,CAACqB,cAAc,EAC7D;YACA,MAAM2B,cAAc,GAAGtE,SAAA,CAAAuE,sBAAsB,CAACE,kBAAkB,CAACzD,UAAsB,EAAEiD,GAAG,CAAC;YAC7F,IAAIK,cAAc,IAAIA,cAAc,CAAC3D,OAAO,IAAI2D,cAAc,CAAC3D,OAAO,CAAC0B,IAAI,EAAE;cAC3E8B,WAAW,GAAGG,cAAc,CAAC3D,OAAO,CAAC0B,IAAI;;;;QAK/C;QACA,IAAIZ,QAAQ,GAAQG,SAAS;QAC7B,IAAI,IAAI,CAAClB,kBAAkB,KAAKR,OAAA,CAAAoB,kBAAkB,CAACC,cAAc,EAAE;UACjE;;;;;;UAMAE,QAAQ,GAAGV,KAAK,CAACmD,QAAQ,CAAC;SAC3B,MAAM;UACL,IAAInD,KAAK,YAAY8B,GAAG,EAAE;YACxBpB,QAAQ,GAAGV,KAAK,CAAC2D,GAAG,CAACR,QAAQ,CAAC;WAC/B,MAAM,IAAInD,KAAK,CAACmD,QAAQ,CAAC,YAAYS,QAAQ,EAAE;YAC9ClD,QAAQ,GAAGV,KAAK,CAACmD,QAAQ,CAAC,EAAE;WAC7B,MAAM;YACLzC,QAAQ,GAAGV,KAAK,CAACmD,QAAQ,CAAC;;;QAI9B;QACA,IAAIU,IAAI,GAAQhD,SAAS;UACvBiD,aAAa,GAAGpD,QAAQ,YAAYoB,GAAG;QACzC,IAAI7B,UAAU,IAAIC,KAAK,EAAE;UACvB2D,IAAI,GAAG5D,UAAU;SAClB,MAAM,IAAIA,UAAU,EAAE;UACrB,MAAM8D,QAAQ,GAAG9E,SAAA,CAAAuE,sBAAsB,CAACQ,gBAAgB,CAAC/D,UAAsB,EAAEoD,YAAY,CAAC;UAC9F,IAAIU,QAAQ,EAAE;YACZ,MAAMnE,OAAO,GAAoB;cAAE2B,SAAS,EAAEjB,QAAQ;cAAEkB,MAAM,EAAExB,KAAK;cAAEkB,QAAQ,EAAEmC;YAAY,CAAE;YAC/F,MAAM5B,OAAO,GAAGsC,QAAQ,CAACrC,YAAY,GAAGqC,QAAQ,CAACrC,YAAY,CAAC9B,OAAO,CAAC,GAAGmE,QAAQ,CAACE,aAAa;YAC/F,IACEF,QAAQ,CAACnE,OAAO,IAChBmE,QAAQ,CAACnE,OAAO,CAACqB,aAAa,IAC9B8C,QAAQ,CAACnE,OAAO,CAACqB,aAAa,CAACC,QAAQ,IACvC6C,QAAQ,CAACnE,OAAO,CAACqB,aAAa,CAACE,QAAQ,EACvC;cACA,IAAI,EAAEnB,KAAK,CAACmD,QAAQ,CAAC,YAAY/C,KAAK,CAAC,EAAE;gBACvC,IAAI,IAAI,CAACT,kBAAkB,KAAKR,OAAA,CAAAoB,kBAAkB,CAACC,cAAc,EAAE;kBACjEqD,IAAI,GAAGE,QAAQ,CAACnE,OAAO,CAACqB,aAAa,CAACE,QAAQ,CAACC,IAAI,CAACC,OAAO,IAAG;oBAC5D,IAAIX,QAAQ,IAAIA,QAAQ,YAAYqC,MAAM,IAAIgB,QAAQ,CAACnE,OAAO,CAACqB,aAAa,CAACC,QAAQ,IAAIR,QAAQ,EAAE;sBACjG,OAAOW,OAAO,CAACC,IAAI,KAAKZ,QAAQ,CAACqD,QAAQ,CAACnE,OAAO,CAACqB,aAAa,CAACC,QAAQ,CAAC;;kBAE7E,CAAC,CAAC;kBACF2C,IAAI,KAAKhD,SAAS,GAAIgD,IAAI,GAAGpC,OAAO,GAAKoC,IAAI,GAAGA,IAAI,CAAC7D,KAAM;kBAC3D,IAAI,CAAC+D,QAAQ,CAACnE,OAAO,CAAC+B,yBAAyB,EAAE;oBAC/C,IAAIjB,QAAQ,IAAIA,QAAQ,YAAYqC,MAAM,IAAIgB,QAAQ,CAACnE,OAAO,CAACqB,aAAa,CAACC,QAAQ,IAAIR,QAAQ,EAAE;sBACjG,OAAOA,QAAQ,CAACqD,QAAQ,CAACnE,OAAO,CAACqB,aAAa,CAACC,QAAQ,CAAC;;;;gBAI9D,IAAI,IAAI,CAACvB,kBAAkB,KAAKR,OAAA,CAAAoB,kBAAkB,CAACqB,cAAc,EAAE;kBACjEiC,IAAI,GAAGnD,QAAQ,CAAChB,WAAW;;gBAE7B,IAAI,IAAI,CAACC,kBAAkB,KAAKR,OAAA,CAAAoB,kBAAkB,CAACsB,cAAc,EAAE;kBACjE,IAAInB,QAAQ,EAAE;oBACZA,QAAQ,CAACqD,QAAQ,CAACnE,OAAO,CAACqB,aAAa,CAACC,QAAQ,CAAC,GAAG6C,QAAQ,CAACnE,OAAO,CAACqB,aAAa,CAACE,QAAQ,CAACC,IAAI,CAC9FC,OAAO,IAAIA,OAAO,CAACrB,KAAK,KAAKU,QAAQ,CAAChB,WAAW,CAClD,CAAC4B,IAAI;;;eAGX,MAAM;gBACLuC,IAAI,GAAGE,QAAQ;;aAElB,MAAM;cACLF,IAAI,GAAGpC,OAAO;;YAEhBqC,aAAa,GAAGA,aAAa,IAAIC,QAAQ,CAACE,aAAa,KAAKnC,GAAG;WAChE,MAAM,IAAI,IAAI,CAAClC,OAAO,CAACsE,UAAU,EAAE;YAClC;YACA,IAAI,CAACtE,OAAO,CAACsE,UAAU,CACpBC,MAAM,CAACC,GAAG,IAAIA,GAAG,CAACC,MAAM,KAAKpE,UAAU,IAAI,CAAC,CAACmE,GAAG,CAACE,UAAU,CAACjB,YAAY,CAAC,CAAC,CAC1E5C,OAAO,CAAC2D,GAAG,IAAKP,IAAI,GAAGO,GAAG,CAACE,UAAU,CAACjB,YAAY,CAAE,CAAC;WACzD,MAAM,IACL,IAAI,CAACzD,OAAO,CAAC2E,wBAAwB,IACrC,IAAI,CAAC5E,kBAAkB,KAAKR,OAAA,CAAAoB,kBAAkB,CAACC,cAAc,EAC7D;YACA;YACA;YACA,MAAMyD,aAAa,GAAIO,OAAe,CAACC,WAAW,CAChD,aAAa,EACZxE,UAAuB,CAACyE,SAAS,EAClCrB,YAAY,CACb;YAED,IAAIY,aAAa,EAAE;cACjBJ,IAAI,GAAGI,aAAa;;;;QAK1B;QACA,MAAM3E,SAAS,GAAGc,KAAK,CAACC,OAAO,CAACL,KAAK,CAACmD,QAAQ,CAAC,CAAC,GAC5C,IAAI,CAACwB,gBAAgB,CAAC1E,UAAsB,EAAEoD,YAAY,CAAC,GAC3DxC,SAAS;QAEb;QACA,MAAMD,SAAS,GAAGb,MAAM,GAAGA,MAAM,CAACoD,QAAQ,CAAC,GAAGtC,SAAS;QAEvD;QACA;QACA;QACA;QAEA;QACA,IAAIP,QAAQ,CAACZ,WAAW,CAACgF,SAAS,EAAE;UAClC,MAAME,UAAU,GAAG7B,MAAM,CAAC8B,wBAAwB,CAACvE,QAAQ,CAACZ,WAAW,CAACgF,SAAS,EAAEtB,WAAW,CAAC;UAC/F,IACE,CAAC,IAAI,CAACzD,kBAAkB,KAAKR,OAAA,CAAAoB,kBAAkB,CAACC,cAAc,IAC5D,IAAI,CAACb,kBAAkB,KAAKR,OAAA,CAAAoB,kBAAkB,CAACqB,cAAc;UAC/D;UACEgD,UAAU,IAAI,CAACA,UAAU,CAACE,GAAG,IAAKxE,QAAQ,CAAC8C,WAAW,CAAC,YAAYQ,QAAQ,CAAC;YAE9E;YACA;;QAGJ,IAAI,CAAC,IAAI,CAAChE,OAAO,CAACkB,mBAAmB,IAAI,CAAC,IAAI,CAACC,UAAU,CAACL,QAAQ,CAAC,EAAE;UACnE,MAAMqE,YAAY,GAAG,IAAI,CAACpF,kBAAkB,KAAKR,OAAA,CAAAoB,kBAAkB,CAACC,cAAc,GAAG4C,WAAW,GAAGF,GAAG;UACtG,IAAI8B,UAAU;UAEd,IAAI,IAAI,CAACrF,kBAAkB,KAAKR,OAAA,CAAAoB,kBAAkB,CAACsB,cAAc,EAAE;YACjE;YACAmD,UAAU,GAAGhF,KAAK,CAAC+E,YAAY,CAAC;YAChC;YACAC,UAAU,GAAG,IAAI,CAACC,0BAA0B,CAC1CD,UAAU,EACV/E,UAAsB,EACtB8E,YAAY,EACZ/E,KAAK,EACL,IAAI,CAACL,kBAAkB,CACxB;YACD;YACAqF,UAAU,GAAGhF,KAAK,CAAC+E,YAAY,CAAC,KAAKC,UAAU,GAAGtE,QAAQ,GAAGsE,UAAU;YACvE;YACAA,UAAU,GAAG,IAAI,CAAClF,SAAS,CAACc,SAAS,EAAEoE,UAAU,EAAEnB,IAAI,EAAEvE,SAAS,EAAEwE,aAAa,EAAE3D,KAAK,GAAG,CAAC,CAAC;WAC9F,MAAM;YACL,IAAIO,QAAQ,KAAKG,SAAS,IAAI,IAAI,CAACjB,OAAO,CAACsF,mBAAmB,EAAE;cAC9D;cACAF,UAAU,GAAG1E,QAAQ,CAAC8C,WAAW,CAAC;aACnC,MAAM;cACL4B,UAAU,GAAG,IAAI,CAAClF,SAAS,CAACc,SAAS,EAAEF,QAAQ,EAAEmD,IAAI,EAAEvE,SAAS,EAAEwE,aAAa,EAAE3D,KAAK,GAAG,CAAC,CAAC;cAC3F6E,UAAU,GAAG,IAAI,CAACC,0BAA0B,CAC1CD,UAAU,EACV/E,UAAsB,EACtB8E,YAAY,EACZ/E,KAAK,EACL,IAAI,CAACL,kBAAkB,CACxB;;;UAIL,IAAIqF,UAAU,KAAKnE,SAAS,IAAI,IAAI,CAACjB,OAAO,CAACuF,iBAAiB,EAAE;YAC9D,IAAI7E,QAAQ,YAAYwB,GAAG,EAAE;cAC3BxB,QAAQ,CAACwE,GAAG,CAAC1B,WAAW,EAAE4B,UAAU,CAAC;aACtC,MAAM;cACL1E,QAAQ,CAAC8C,WAAW,CAAC,GAAG4B,UAAU;;;SAGvC,MAAM,IAAI,IAAI,CAACrF,kBAAkB,KAAKR,OAAA,CAAAoB,kBAAkB,CAACqB,cAAc,EAAE;UACxE,IAAIoD,UAAU,GAAGtE,QAAQ;UACzBsE,UAAU,GAAG,IAAI,CAACC,0BAA0B,CAC1CD,UAAU,EACV/E,UAAsB,EACtBiD,GAAG,EACHlD,KAAK,EACL,IAAI,CAACL,kBAAkB,CACxB;UACD,IAAIqF,UAAU,KAAKnE,SAAS,IAAI,IAAI,CAACjB,OAAO,CAACuF,iBAAiB,EAAE;YAC9D,IAAI7E,QAAQ,YAAYwB,GAAG,EAAE;cAC3BxB,QAAQ,CAACwE,GAAG,CAAC1B,WAAW,EAAE4B,UAAU,CAAC;aACtC,MAAM;cACL1E,QAAQ,CAAC8C,WAAW,CAAC,GAAG4B,UAAU;;;;;MAM1C,IAAI,IAAI,CAACpF,OAAO,CAACkB,mBAAmB,EAAE;QACpC,IAAI,CAACjB,cAAc,CAACuF,MAAM,CAACpF,KAAK,CAAC;;MAGnC,OAAOM,QAAQ;KAChB,MAAM;MACL,OAAON,KAAK;;EAEhB;EAEQiF,0BAA0BA,CAChCjF,KAAU,EACVqE,MAAgB,EAChBnB,GAAW,EACXmC,GAAQ,EACR1F,kBAAsC;IAEtC,IAAI2F,SAAS,GAAGrG,SAAA,CAAAuE,sBAAsB,CAAC+B,sBAAsB,CAAClB,MAAM,EAAEnB,GAAG,EAAE,IAAI,CAACvD,kBAAkB,CAAC;IAEnG;IACA,IAAI,IAAI,CAACC,OAAO,CAAC4F,OAAO,KAAK3E,SAAS,EAAE;MACtCyE,SAAS,GAAGA,SAAS,CAACnB,MAAM,CAACJ,QAAQ,IAAG;QACtC,IAAI,CAACA,QAAQ,CAACnE,OAAO,EAAE,OAAO,IAAI;QAElC,OAAO,IAAI,CAAC6F,YAAY,CAAC1B,QAAQ,CAACnE,OAAO,CAAC8F,KAAK,EAAE3B,QAAQ,CAACnE,OAAO,CAAC+F,KAAK,CAAC;MAC1E,CAAC,CAAC;;IAGJ;IACA,IAAI,IAAI,CAAC/F,OAAO,CAACgG,MAAM,IAAI,IAAI,CAAChG,OAAO,CAACgG,MAAM,CAACC,MAAM,EAAE;MACrDP,SAAS,GAAGA,SAAS,CAACnB,MAAM,CAACJ,QAAQ,IAAG;QACtC,IAAI,CAACA,QAAQ,CAACnE,OAAO,EAAE,OAAO,IAAI;QAElC,OAAO,IAAI,CAACkG,WAAW,CAAC/B,QAAQ,CAACnE,OAAO,CAACgG,MAAM,CAAC;MAClD,CAAC,CAAC;KACH,MAAM;MACLN,SAAS,GAAGA,SAAS,CAACnB,MAAM,CAACJ,QAAQ,IAAG;QACtC,OAAO,CAACA,QAAQ,CAACnE,OAAO,IAAI,CAACmE,QAAQ,CAACnE,OAAO,CAACgG,MAAM,IAAI,CAAC7B,QAAQ,CAACnE,OAAO,CAACgG,MAAM,CAACC,MAAM;MACzF,CAAC,CAAC;;IAGJP,SAAS,CAAC7E,OAAO,CAACsD,QAAQ,IAAG;MAC3B/D,KAAK,GAAG+D,QAAQ,CAACgC,WAAW,CAAC;QAAE/F,KAAK;QAAEkD,GAAG;QAAEmC,GAAG;QAAExB,IAAI,EAAElE,kBAAkB;QAAEC,OAAO,EAAE,IAAI,CAACA;MAAO,CAAE,CAAC;IACpG,CAAC,CAAC;IAEF,OAAOI,KAAK;EACd;EAEA;EACQe,UAAUA,CAACS,MAA2B;IAC5C,OAAO,IAAI,CAAC3B,cAAc,CAACmG,GAAG,CAACxE,MAAM,CAAC;EACxC;EAEQmD,gBAAgBA,CAACN,MAAgB,EAAEhB,YAAoB;IAC7D,IAAI,CAACgB,MAAM,EAAE,OAAOxD,SAAS;IAC7B,MAAMoF,IAAI,GAAGhH,SAAA,CAAAuE,sBAAsB,CAACQ,gBAAgB,CAACK,MAAM,EAAEhB,YAAY,CAAC;IAC1E,OAAO4C,IAAI,GAAGA,IAAI,CAAChC,aAAa,GAAGpD,SAAS;EAC9C;EAEQoC,OAAOA,CAACoB,MAAgB,EAAE7C,MAA2B,EAAEtB,KAAc;IAC3E;IACA,IAAIgG,QAAQ,GAAGjH,SAAA,CAAAuE,sBAAsB,CAAC2C,WAAW,CAAC9B,MAAM,CAAC;IACzD,IAAI6B,QAAQ,KAAK,MAAM,EAAEA,QAAQ,GAAG,IAAI,CAACtG,OAAO,CAACsG,QAAQ,IAAI,WAAW,CAAC,CAAC;IAE1E;IACA,IAAIlD,IAAI,GAAU,EAAE;IACpB,IAAIkD,QAAQ,KAAK,WAAW,IAAIhG,KAAK,EAAE;MACrC,IAAIsB,MAAM,YAAYM,GAAG,EAAE;QACzBkB,IAAI,GAAG5C,KAAK,CAACoC,IAAI,CAAChB,MAAM,CAACwB,IAAI,EAAE,CAAC;OACjC,MAAM;QACLA,IAAI,GAAGD,MAAM,CAACC,IAAI,CAACxB,MAAM,CAAC;;;IAI9B,IAAItB,KAAK,EAAE;MACT;MACA,OAAO8C,IAAI;;IAGb;;;;IAIA,IAAI,IAAI,CAACpD,OAAO,CAAC0D,gBAAgB,IAAI,IAAI,CAAC1D,OAAO,CAACwG,uBAAuB,IAAI/B,MAAM,EAAE;MACnF,MAAMgC,iBAAiB,GAAGpH,SAAA,CAAAuE,sBAAsB,CAAC8C,oBAAoB,CAACjC,MAAM,EAAE,IAAI,CAAC1E,kBAAkB,CAAC;MACtG,MAAM4G,kBAAkB,GAAGtH,SAAA,CAAAuE,sBAAsB,CAACgD,qBAAqB,CAACnC,MAAM,EAAE,IAAI,CAAC1E,kBAAkB,CAAC;MACxGqD,IAAI,GAAG,CAAC,GAAGqD,iBAAiB,EAAE,GAAGE,kBAAkB,CAAC;;IAGtD,IAAI,CAAC,IAAI,CAAC3G,OAAO,CAAC0D,gBAAgB,IAAIe,MAAM,EAAE;MAC5C;MACA,IAAIgC,iBAAiB,GAAGpH,SAAA,CAAAuE,sBAAsB,CAAC8C,oBAAoB,CAACjC,MAAM,EAAE,IAAI,CAAC1E,kBAAkB,CAAC;MACpG,IAAI,IAAI,CAACA,kBAAkB,KAAKR,OAAA,CAAAoB,kBAAkB,CAACC,cAAc,EAAE;QACjE6F,iBAAiB,GAAGA,iBAAiB,CAACjC,GAAG,CAAClB,GAAG,IAAG;UAC9C,MAAMK,cAAc,GAAGtE,SAAA,CAAAuE,sBAAsB,CAACE,kBAAkB,CAACW,MAAM,EAAEnB,GAAG,CAAC;UAC7E,IAAIK,cAAc,IAAIA,cAAc,CAAC3D,OAAO,IAAI2D,cAAc,CAAC3D,OAAO,CAAC0B,IAAI,EAAE;YAC3E,OAAOiC,cAAc,CAAC3D,OAAO,CAAC0B,IAAI;;UAGpC,OAAO4B,GAAG;QACZ,CAAC,CAAC;;MAEJ,IAAI,IAAI,CAACtD,OAAO,CAACwG,uBAAuB,EAAE;QACxCpD,IAAI,GAAGqD,iBAAiB;OACzB,MAAM;QACLrD,IAAI,GAAGA,IAAI,CAACyD,MAAM,CAACJ,iBAAiB,CAAC;;MAGvC;MACA,MAAME,kBAAkB,GAAGtH,SAAA,CAAAuE,sBAAsB,CAACgD,qBAAqB,CAACnC,MAAM,EAAE,IAAI,CAAC1E,kBAAkB,CAAC;MACxG,IAAI4G,kBAAkB,CAACV,MAAM,GAAG,CAAC,EAAE;QACjC7C,IAAI,GAAGA,IAAI,CAACmB,MAAM,CAACjB,GAAG,IAAG;UACvB,OAAO,CAACqD,kBAAkB,CAACG,QAAQ,CAACxD,GAAG,CAAC;QAC1C,CAAC,CAAC;;MAGJ;MACA,IAAI,IAAI,CAACtD,OAAO,CAAC4F,OAAO,KAAK3E,SAAS,EAAE;QACtCmC,IAAI,GAAGA,IAAI,CAACmB,MAAM,CAACjB,GAAG,IAAG;UACvB,MAAMK,cAAc,GAAGtE,SAAA,CAAAuE,sBAAsB,CAACE,kBAAkB,CAACW,MAAM,EAAEnB,GAAG,CAAC;UAC7E,IAAI,CAACK,cAAc,IAAI,CAACA,cAAc,CAAC3D,OAAO,EAAE,OAAO,IAAI;UAE3D,OAAO,IAAI,CAAC6F,YAAY,CAAClC,cAAc,CAAC3D,OAAO,CAAC8F,KAAK,EAAEnC,cAAc,CAAC3D,OAAO,CAAC+F,KAAK,CAAC;QACtF,CAAC,CAAC;;MAGJ;MACA,IAAI,IAAI,CAAC/F,OAAO,CAACgG,MAAM,IAAI,IAAI,CAAChG,OAAO,CAACgG,MAAM,CAACC,MAAM,EAAE;QACrD7C,IAAI,GAAGA,IAAI,CAACmB,MAAM,CAACjB,GAAG,IAAG;UACvB,MAAMK,cAAc,GAAGtE,SAAA,CAAAuE,sBAAsB,CAACE,kBAAkB,CAACW,MAAM,EAAEnB,GAAG,CAAC;UAC7E,IAAI,CAACK,cAAc,IAAI,CAACA,cAAc,CAAC3D,OAAO,EAAE,OAAO,IAAI;UAE3D,OAAO,IAAI,CAACkG,WAAW,CAACvC,cAAc,CAAC3D,OAAO,CAACgG,MAAM,CAAC;QACxD,CAAC,CAAC;OACH,MAAM;QACL5C,IAAI,GAAGA,IAAI,CAACmB,MAAM,CAACjB,GAAG,IAAG;UACvB,MAAMK,cAAc,GAAGtE,SAAA,CAAAuE,sBAAsB,CAACE,kBAAkB,CAACW,MAAM,EAAEnB,GAAG,CAAC;UAC7E,OACE,CAACK,cAAc,IACf,CAACA,cAAc,CAAC3D,OAAO,IACvB,CAAC2D,cAAc,CAAC3D,OAAO,CAACgG,MAAM,IAC9B,CAACrC,cAAc,CAAC3D,OAAO,CAACgG,MAAM,CAACC,MAAM;QAEzC,CAAC,CAAC;;;IAIN;IACA,IAAI,IAAI,CAACjG,OAAO,CAAC+G,eAAe,IAAI,IAAI,CAAC/G,OAAO,CAAC+G,eAAe,CAACd,MAAM,EAAE;MACvE7C,IAAI,GAAGA,IAAI,CAACmB,MAAM,CAACjB,GAAG,IACpB,IAAI,CAACtD,OAAO,CAAC+G,eAAe,CAACC,KAAK,CAACC,MAAM,IAAG;QAC1C,OAAO3D,GAAG,CAAC4D,MAAM,CAAC,CAAC,EAAED,MAAM,CAAChB,MAAM,CAAC,KAAKgB,MAAM;MAChD,CAAC,CAAC,CACH;;IAGH;IACA7D,IAAI,GAAGA,IAAI,CAACmB,MAAM,CAAC,CAACjB,GAAG,EAAEvC,KAAK,EAAEoG,IAAI,KAAI;MACtC,OAAOA,IAAI,CAACC,OAAO,CAAC9D,GAAG,CAAC,KAAKvC,KAAK;IACpC,CAAC,CAAC;IAEF,OAAOqC,IAAI;EACb;EAEQyC,YAAYA,CAACC,KAAa,EAAEC,KAAa;IAC/C,IAAIsB,QAAQ,GAAG,IAAI;IACnB,IAAIA,QAAQ,IAAIvB,KAAK,EAAEuB,QAAQ,GAAG,IAAI,CAACrH,OAAO,CAAC4F,OAAO,IAAIE,KAAK;IAC/D,IAAIuB,QAAQ,IAAItB,KAAK,EAAEsB,QAAQ,GAAG,IAAI,CAACrH,OAAO,CAAC4F,OAAO,GAAGG,KAAK;IAE9D,OAAOsB,QAAQ;EACjB;EAEQnB,WAAWA,CAACF,MAAgB;IAClC,IAAI,CAACA,MAAM,EAAE,OAAO,IAAI;IAExB,OAAO,IAAI,CAAChG,OAAO,CAACgG,MAAM,CAACsB,IAAI,CAACC,WAAW,IAAIvB,MAAM,CAACc,QAAQ,CAACS,WAAW,CAAC,CAAC;EAC9E;;AAphBFC,OAAA,CAAA3H,0BAAA,GAAAA,0BAAA"}