{"version":3,"names":["compatTranspiler","require","generator","optimizer","parser","_transform","_traverse","fa","_require","RegExpTree","regexpTree","TransformResult","parse","regexp","options","traverse","ast","handlers","transform","generate","toRegExp","compat","compatTranspile","RegExp","getSource","getFlags","optimize","whitelist","_ref","arguments","length","undefined","blacklist","exec","re","string","extra","getExtra","namedCapturingGroups","flags","source","groups","module","exports"],"sources":["regexp-tree.js"],"sourcesContent":["/**\n * The MIT License (MIT)\n * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>\n */\n\n'use strict';\n\nvar compatTranspiler = require('./compat-transpiler');\nvar generator = require('./generator');\nvar optimizer = require('./optimizer');\nvar parser = require('./parser');\nvar _transform = require('./transform');\nvar _traverse = require('./traverse');\nvar fa = require('./interpreter/finite-automaton');\n\nvar _require = require('./compat-transpiler/runtime'),\n    RegExpTree = _require.RegExpTree;\n\n/**\n * An API object for RegExp processing (parsing/transform/generation).\n */\n\n\nvar regexpTree = {\n  /**\n   * Parser module exposed.\n   */\n  parser: parser,\n\n  /**\n   * Expose finite-automaton module.\n   */\n  fa: fa,\n\n  /**\n   * `TransformResult` exposed.\n   */\n  TransformResult: _transform.TransformResult,\n\n  /**\n   * Parses a regexp string, producing an AST.\n   *\n   * @param string regexp\n   *\n   *   a regular expression in different formats: string, AST, RegExp.\n   *\n   * @param Object options\n   *\n   *   parsing options for this parse call. Default are:\n   *\n   *     - captureLocations: boolean\n   *     - any other custom options\n   *\n   * @return Object AST\n   */\n  parse: function parse(regexp, options) {\n    return parser.parse('' + regexp, options);\n  },\n\n\n  /**\n   * Traverses a RegExp AST.\n   *\n   * @param Object ast\n   * @param Object | Array<Object> handlers\n   *\n   * Each `handler` is an object containing handler function for needed\n   * node types. Example:\n   *\n   *   regexpTree.traverse(ast, {\n   *     onChar(node) {\n   *       ...\n   *     },\n   *   });\n   *\n   * The value for a node type may also be an object with functions pre and post.\n   * This enables more context-aware analyses, e.g. measuring star height.\n   */\n  traverse: function traverse(ast, handlers, options) {\n    return _traverse.traverse(ast, handlers, options);\n  },\n\n\n  /**\n   * Transforms a regular expression.\n   *\n   * A regexp can be passed in different formats (string, regexp or AST),\n   * applying a set of transformations. It is a convenient wrapper\n   * on top of \"parse-traverse-generate\" tool chain.\n   *\n   * @param string | AST | RegExp regexp - a regular expression;\n   * @param Object | Array<Object> handlers - a list of handlers.\n   *\n   * @return TransformResult - a transformation result.\n   */\n  transform: function transform(regexp, handlers) {\n    return _transform.transform(regexp, handlers);\n  },\n\n\n  /**\n   * Generates a RegExp string from an AST.\n   *\n   * @param Object ast\n   *\n   * Invariant:\n   *\n   *   regexpTree.generate(regexpTree.parse('/[a-z]+/i')); // '/[a-z]+/i'\n   */\n  generate: function generate(ast) {\n    return generator.generate(ast);\n  },\n\n\n  /**\n   * Creates a RegExp object from a regexp string.\n   *\n   * @param string regexp\n   */\n  toRegExp: function toRegExp(regexp) {\n    var compat = this.compatTranspile(regexp);\n    return new RegExp(compat.getSource(), compat.getFlags());\n  },\n\n\n  /**\n   * Optimizes a regular expression by replacing some\n   * sub-expressions with their idiomatic patterns.\n   *\n   * @param string regexp\n   *\n   * @return TransformResult object\n   */\n  optimize: function optimize(regexp, whitelist) {\n    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        blacklist = _ref.blacklist;\n\n    return optimizer.optimize(regexp, { whitelist: whitelist, blacklist: blacklist });\n  },\n\n\n  /**\n   * Translates a regular expression in new syntax or in new format\n   * into equivalent expressions in old syntax.\n   *\n   * @param string regexp\n   *\n   * @return TransformResult object\n   */\n  compatTranspile: function compatTranspile(regexp, whitelist) {\n    return compatTranspiler.transform(regexp, whitelist);\n  },\n\n\n  /**\n   * Executes a regular expression on a string.\n   *\n   * @param RegExp|string re - a regular expression.\n   * @param string string - a testing string.\n   */\n  exec: function exec(re, string) {\n    if (typeof re === 'string') {\n      var compat = this.compatTranspile(re);\n      var extra = compat.getExtra();\n\n      if (extra.namedCapturingGroups) {\n        re = new RegExpTree(compat.toRegExp(), {\n          flags: compat.getFlags(),\n          source: compat.getSource(),\n          groups: extra.namedCapturingGroups\n        });\n      } else {\n        re = compat.toRegExp();\n      }\n    }\n\n    return re.exec(string);\n  }\n};\n\nmodule.exports = regexpTree;"],"mappings":"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"}