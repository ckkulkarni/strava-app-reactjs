{"version":3,"names":["paths_1","require","messages_1","environment_1","gherkin_1","console_logger_1","loadSources","coordinates","environment","cwd","stderr","debug","mergeEnvironment","logger","ConsoleLogger","newId","IdGenerator","uuid","unexpandedFeaturePaths","featurePaths","resolvePaths","length","plan","errors","filteredPickles","parseErrors","getFilteredPicklesAndErrors","map","location","pickle","name","uri","source","message","exports"],"sources":["../../src/api/load_sources.ts"],"sourcesContent":["import {\n  ILoadSourcesResult,\n  IPlannedPickle,\n  IRunEnvironment,\n  ISourcesCoordinates,\n  ISourcesError,\n} from './types'\nimport { resolvePaths } from './paths'\nimport { IdGenerator } from '@cucumber/messages'\nimport { mergeEnvironment } from './environment'\nimport { getFilteredPicklesAndErrors } from './gherkin'\nimport { ConsoleLogger } from './console_logger'\nimport { ILogger } from '../logger'\n\n/**\n * Load and parse features, produce a filtered and ordered test plan and/or parse errors.\n *\n * @public\n * @param coordinates - Coordinates required to find features\n * @param environment - Project environment.\n */\nexport async function loadSources(\n  coordinates: ISourcesCoordinates,\n  environment: IRunEnvironment = {}\n): Promise<ILoadSourcesResult> {\n  const { cwd, stderr, debug } = mergeEnvironment(environment)\n  const logger: ILogger = new ConsoleLogger(stderr, debug)\n  const newId = IdGenerator.uuid()\n  const { unexpandedFeaturePaths, featurePaths } = await resolvePaths(\n    logger,\n    cwd,\n    coordinates\n  )\n  if (featurePaths.length === 0) {\n    return {\n      plan: [],\n      errors: [],\n    }\n  }\n  const { filteredPickles, parseErrors } = await getFilteredPicklesAndErrors({\n    newId,\n    cwd,\n    logger,\n    unexpandedFeaturePaths,\n    featurePaths,\n    coordinates,\n  })\n  const plan: IPlannedPickle[] = filteredPickles.map(\n    ({ location, pickle }) => ({\n      name: pickle.name,\n      uri: pickle.uri,\n      location,\n    })\n  )\n  const errors: ISourcesError[] = parseErrors.map(({ source, message }) => {\n    return {\n      uri: source.uri,\n      location: source.location,\n      message,\n    }\n  })\n  return {\n    plan,\n    errors,\n  }\n}\n"],"mappings":";;;;;;AAOA,MAAAA,OAAA,GAAAC,OAAA;AACA,MAAAC,UAAA,GAAAD,OAAA;AACA,MAAAE,aAAA,GAAAF,OAAA;AACA,MAAAG,SAAA,GAAAH,OAAA;AACA,MAAAI,gBAAA,GAAAJ,OAAA;AAGA;;;;;;;AAOO,eAAeK,WAAWA,CAC/BC,WAAgC,EAChCC,WAAA,GAA+B,EAAE;EAEjC,MAAM;IAAEC,GAAG;IAAEC,MAAM;IAAEC;EAAK,CAAE,GAAG,IAAAR,aAAA,CAAAS,gBAAgB,EAACJ,WAAW,CAAC;EAC5D,MAAMK,MAAM,GAAY,IAAIR,gBAAA,CAAAS,aAAa,CAACJ,MAAM,EAAEC,KAAK,CAAC;EACxD,MAAMI,KAAK,GAAGb,UAAA,CAAAc,WAAW,CAACC,IAAI,EAAE;EAChC,MAAM;IAAEC,sBAAsB;IAAEC;EAAY,CAAE,GAAG,MAAM,IAAAnB,OAAA,CAAAoB,YAAY,EACjEP,MAAM,EACNJ,GAAG,EACHF,WAAW,CACZ;EACD,IAAIY,YAAY,CAACE,MAAM,KAAK,CAAC,EAAE;IAC7B,OAAO;MACLC,IAAI,EAAE,EAAE;MACRC,MAAM,EAAE;KACT;;EAEH,MAAM;IAAEC,eAAe;IAAEC;EAAW,CAAE,GAAG,MAAM,IAAArB,SAAA,CAAAsB,2BAA2B,EAAC;IACzEX,KAAK;IACLN,GAAG;IACHI,MAAM;IACNK,sBAAsB;IACtBC,YAAY;IACZZ;GACD,CAAC;EACF,MAAMe,IAAI,GAAqBE,eAAe,CAACG,GAAG,CAChD,CAAC;IAAEC,QAAQ;IAAEC;EAAM,CAAE,MAAM;IACzBC,IAAI,EAAED,MAAM,CAACC,IAAI;IACjBC,GAAG,EAAEF,MAAM,CAACE,GAAG;IACfH;GACD,CAAC,CACH;EACD,MAAML,MAAM,GAAoBE,WAAW,CAACE,GAAG,CAAC,CAAC;IAAEK,MAAM;IAAEC;EAAO,CAAE,KAAI;IACtE,OAAO;MACLF,GAAG,EAAEC,MAAM,CAACD,GAAG;MACfH,QAAQ,EAAEI,MAAM,CAACJ,QAAQ;MACzBK;KACD;EACH,CAAC,CAAC;EACF,OAAO;IACLX,IAAI;IACJC;GACD;AACH;AA5CAW,OAAA,CAAA5B,WAAA,GAAAA,WAAA"}