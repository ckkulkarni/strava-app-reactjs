{"version":3,"names":["cst","require","isEmpty","ch","undefined","hexDigits","split","tagChars","invalidFlowScalarChars","invalidAnchorChars","isNotAnchorChar","includes","Lexer","constructor","atEnd","blockScalarIndent","blockScalarKeep","buffer","flowKey","flowLevel","indentNext","indentValue","lineEndPos","next","pos","lex","source","incomplete","hasChars","parseNext","atLineEnd","i","charAt","n","continueScalar","offset","indent","dt","substr","getLine","end","indexOf","substring","length","setNext","state","peek","parseStream","parseLineStart","parseBlockStart","parseDocument","parseFlowCollection","parseQuotedScalar","parseBlockScalar","parsePlainScalar","line","BOM","pushCount","dirEnd","cs","pushSpaces","pushNewline","sp","DOCUMENT","s","ch0","ch1","pushIndicators","pushUntil","parseBlockScalarHeader","nl","startsWith","atFlowEndMarker","FLOW_END","quote","qb","pushToIndex","Number","loop","lastChar","SCALAR","inFlow","Math","max","allowEmpty","slice","pushTag","allowTabs","test","exports"],"sources":["lexer.js"],"sourcesContent":["'use strict';\n\nvar cst = require('./cst.js');\n\n/*\nSTART -> stream\n\nstream\n  directive -> line-end -> stream\n  indent + line-end -> stream\n  [else] -> line-start\n\nline-end\n  comment -> line-end\n  newline -> .\n  input-end -> END\n\nline-start\n  doc-start -> doc\n  doc-end -> stream\n  [else] -> indent -> block-start\n\nblock-start\n  seq-item-start -> block-start\n  explicit-key-start -> block-start\n  map-value-start -> block-start\n  [else] -> doc\n\ndoc\n  line-end -> line-start\n  spaces -> doc\n  anchor -> doc\n  tag -> doc\n  flow-start -> flow -> doc\n  flow-end -> error -> doc\n  seq-item-start -> error -> doc\n  explicit-key-start -> error -> doc\n  map-value-start -> doc\n  alias -> doc\n  quote-start -> quoted-scalar -> doc\n  block-scalar-header -> line-end -> block-scalar(min) -> line-start\n  [else] -> plain-scalar(false, min) -> doc\n\nflow\n  line-end -> flow\n  spaces -> flow\n  anchor -> flow\n  tag -> flow\n  flow-start -> flow -> flow\n  flow-end -> .\n  seq-item-start -> error -> flow\n  explicit-key-start -> flow\n  map-value-start -> flow\n  alias -> flow\n  quote-start -> quoted-scalar -> flow\n  comma -> flow\n  [else] -> plain-scalar(true, 0) -> flow\n\nquoted-scalar\n  quote-end -> .\n  [else] -> quoted-scalar\n\nblock-scalar(min)\n  newline + peek(indent < min) -> .\n  [else] -> block-scalar(min)\n\nplain-scalar(is-flow, min)\n  scalar-end(is-flow) -> .\n  peek(newline + (indent < min)) -> .\n  [else] -> plain-scalar(min)\n*/\nfunction isEmpty(ch) {\n    switch (ch) {\n        case undefined:\n        case ' ':\n        case '\\n':\n        case '\\r':\n        case '\\t':\n            return true;\n        default:\n            return false;\n    }\n}\nconst hexDigits = '0123456789ABCDEFabcdef'.split('');\nconst tagChars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()\".split('');\nconst invalidFlowScalarChars = ',[]{}'.split('');\nconst invalidAnchorChars = ' ,[]{}\\n\\r\\t'.split('');\nconst isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch);\n/**\n * Splits an input string into lexical tokens, i.e. smaller strings that are\n * easily identifiable by `tokens.tokenType()`.\n *\n * Lexing starts always in a \"stream\" context. Incomplete input may be buffered\n * until a complete token can be emitted.\n *\n * In addition to slices of the original input, the following control characters\n * may also be emitted:\n *\n * - `\\x02` (Start of Text): A document starts with the next token\n * - `\\x18` (Cancel): Unexpected end of flow-mode (indicates an error)\n * - `\\x1f` (Unit Separator): Next token is a scalar value\n * - `\\u{FEFF}` (Byte order mark): Emitted separately outside documents\n */\nclass Lexer {\n    constructor() {\n        /**\n         * Flag indicating whether the end of the current buffer marks the end of\n         * all input\n         */\n        this.atEnd = false;\n        /**\n         * Explicit indent set in block scalar header, as an offset from the current\n         * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not\n         * explicitly set.\n         */\n        this.blockScalarIndent = -1;\n        /**\n         * Block scalars that include a + (keep) chomping indicator in their header\n         * include trailing empty lines, which are otherwise excluded from the\n         * scalar's contents.\n         */\n        this.blockScalarKeep = false;\n        /** Current input */\n        this.buffer = '';\n        /**\n         * Flag noting whether the map value indicator : can immediately follow this\n         * node within a flow context.\n         */\n        this.flowKey = false;\n        /** Count of surrounding flow collection levels. */\n        this.flowLevel = 0;\n        /**\n         * Minimum level of indentation required for next lines to be parsed as a\n         * part of the current scalar value.\n         */\n        this.indentNext = 0;\n        /** Indentation level of the current line. */\n        this.indentValue = 0;\n        /** Position of the next \\n character. */\n        this.lineEndPos = null;\n        /** Stores the state of the lexer if reaching the end of incpomplete input */\n        this.next = null;\n        /** A pointer to `buffer`; the current position of the lexer. */\n        this.pos = 0;\n    }\n    /**\n     * Generate YAML tokens from the `source` string. If `incomplete`,\n     * a part of the last line may be left as a buffer for the next call.\n     *\n     * @returns A generator of lexical tokens\n     */\n    *lex(source, incomplete = false) {\n        if (source) {\n            this.buffer = this.buffer ? this.buffer + source : source;\n            this.lineEndPos = null;\n        }\n        this.atEnd = !incomplete;\n        let next = this.next ?? 'stream';\n        while (next && (incomplete || this.hasChars(1)))\n            next = yield* this.parseNext(next);\n    }\n    atLineEnd() {\n        let i = this.pos;\n        let ch = this.buffer[i];\n        while (ch === ' ' || ch === '\\t')\n            ch = this.buffer[++i];\n        if (!ch || ch === '#' || ch === '\\n')\n            return true;\n        if (ch === '\\r')\n            return this.buffer[i + 1] === '\\n';\n        return false;\n    }\n    charAt(n) {\n        return this.buffer[this.pos + n];\n    }\n    continueScalar(offset) {\n        let ch = this.buffer[offset];\n        if (this.indentNext > 0) {\n            let indent = 0;\n            while (ch === ' ')\n                ch = this.buffer[++indent + offset];\n            if (ch === '\\r') {\n                const next = this.buffer[indent + offset + 1];\n                if (next === '\\n' || (!next && !this.atEnd))\n                    return offset + indent + 1;\n            }\n            return ch === '\\n' || indent >= this.indentNext || (!ch && !this.atEnd)\n                ? offset + indent\n                : -1;\n        }\n        if (ch === '-' || ch === '.') {\n            const dt = this.buffer.substr(offset, 3);\n            if ((dt === '---' || dt === '...') && isEmpty(this.buffer[offset + 3]))\n                return -1;\n        }\n        return offset;\n    }\n    getLine() {\n        let end = this.lineEndPos;\n        if (typeof end !== 'number' || (end !== -1 && end < this.pos)) {\n            end = this.buffer.indexOf('\\n', this.pos);\n            this.lineEndPos = end;\n        }\n        if (end === -1)\n            return this.atEnd ? this.buffer.substring(this.pos) : null;\n        if (this.buffer[end - 1] === '\\r')\n            end -= 1;\n        return this.buffer.substring(this.pos, end);\n    }\n    hasChars(n) {\n        return this.pos + n <= this.buffer.length;\n    }\n    setNext(state) {\n        this.buffer = this.buffer.substring(this.pos);\n        this.pos = 0;\n        this.lineEndPos = null;\n        this.next = state;\n        return null;\n    }\n    peek(n) {\n        return this.buffer.substr(this.pos, n);\n    }\n    *parseNext(next) {\n        switch (next) {\n            case 'stream':\n                return yield* this.parseStream();\n            case 'line-start':\n                return yield* this.parseLineStart();\n            case 'block-start':\n                return yield* this.parseBlockStart();\n            case 'doc':\n                return yield* this.parseDocument();\n            case 'flow':\n                return yield* this.parseFlowCollection();\n            case 'quoted-scalar':\n                return yield* this.parseQuotedScalar();\n            case 'block-scalar':\n                return yield* this.parseBlockScalar();\n            case 'plain-scalar':\n                return yield* this.parsePlainScalar();\n        }\n    }\n    *parseStream() {\n        let line = this.getLine();\n        if (line === null)\n            return this.setNext('stream');\n        if (line[0] === cst.BOM) {\n            yield* this.pushCount(1);\n            line = line.substring(1);\n        }\n        if (line[0] === '%') {\n            let dirEnd = line.length;\n            const cs = line.indexOf('#');\n            if (cs !== -1) {\n                const ch = line[cs - 1];\n                if (ch === ' ' || ch === '\\t')\n                    dirEnd = cs - 1;\n            }\n            while (true) {\n                const ch = line[dirEnd - 1];\n                if (ch === ' ' || ch === '\\t')\n                    dirEnd -= 1;\n                else\n                    break;\n            }\n            const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));\n            yield* this.pushCount(line.length - n); // possible comment\n            this.pushNewline();\n            return 'stream';\n        }\n        if (this.atLineEnd()) {\n            const sp = yield* this.pushSpaces(true);\n            yield* this.pushCount(line.length - sp);\n            yield* this.pushNewline();\n            return 'stream';\n        }\n        yield cst.DOCUMENT;\n        return yield* this.parseLineStart();\n    }\n    *parseLineStart() {\n        const ch = this.charAt(0);\n        if (!ch && !this.atEnd)\n            return this.setNext('line-start');\n        if (ch === '-' || ch === '.') {\n            if (!this.atEnd && !this.hasChars(4))\n                return this.setNext('line-start');\n            const s = this.peek(3);\n            if (s === '---' && isEmpty(this.charAt(3))) {\n                yield* this.pushCount(3);\n                this.indentValue = 0;\n                this.indentNext = 0;\n                return 'doc';\n            }\n            else if (s === '...' && isEmpty(this.charAt(3))) {\n                yield* this.pushCount(3);\n                return 'stream';\n            }\n        }\n        this.indentValue = yield* this.pushSpaces(false);\n        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))\n            this.indentNext = this.indentValue;\n        return yield* this.parseBlockStart();\n    }\n    *parseBlockStart() {\n        const [ch0, ch1] = this.peek(2);\n        if (!ch1 && !this.atEnd)\n            return this.setNext('block-start');\n        if ((ch0 === '-' || ch0 === '?' || ch0 === ':') && isEmpty(ch1)) {\n            const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));\n            this.indentNext = this.indentValue + 1;\n            this.indentValue += n;\n            return yield* this.parseBlockStart();\n        }\n        return 'doc';\n    }\n    *parseDocument() {\n        yield* this.pushSpaces(true);\n        const line = this.getLine();\n        if (line === null)\n            return this.setNext('doc');\n        let n = yield* this.pushIndicators();\n        switch (line[n]) {\n            case '#':\n                yield* this.pushCount(line.length - n);\n            // fallthrough\n            case undefined:\n                yield* this.pushNewline();\n                return yield* this.parseLineStart();\n            case '{':\n            case '[':\n                yield* this.pushCount(1);\n                this.flowKey = false;\n                this.flowLevel = 1;\n                return 'flow';\n            case '}':\n            case ']':\n                // this is an error\n                yield* this.pushCount(1);\n                return 'doc';\n            case '*':\n                yield* this.pushUntil(isNotAnchorChar);\n                return 'doc';\n            case '\"':\n            case \"'\":\n                return yield* this.parseQuotedScalar();\n            case '|':\n            case '>':\n                n += yield* this.parseBlockScalarHeader();\n                n += yield* this.pushSpaces(true);\n                yield* this.pushCount(line.length - n);\n                yield* this.pushNewline();\n                return yield* this.parseBlockScalar();\n            default:\n                return yield* this.parsePlainScalar();\n        }\n    }\n    *parseFlowCollection() {\n        let nl, sp;\n        let indent = -1;\n        do {\n            nl = yield* this.pushNewline();\n            if (nl > 0) {\n                sp = yield* this.pushSpaces(false);\n                this.indentValue = indent = sp;\n            }\n            else {\n                sp = 0;\n            }\n            sp += yield* this.pushSpaces(true);\n        } while (nl + sp > 0);\n        const line = this.getLine();\n        if (line === null)\n            return this.setNext('flow');\n        if ((indent !== -1 && indent < this.indentNext && line[0] !== '#') ||\n            (indent === 0 &&\n                (line.startsWith('---') || line.startsWith('...')) &&\n                isEmpty(line[3]))) {\n            // Allowing for the terminal ] or } at the same (rather than greater)\n            // indent level as the initial [ or { is technically invalid, but\n            // failing here would be surprising to users.\n            const atFlowEndMarker = indent === this.indentNext - 1 &&\n                this.flowLevel === 1 &&\n                (line[0] === ']' || line[0] === '}');\n            if (!atFlowEndMarker) {\n                // this is an error\n                this.flowLevel = 0;\n                yield cst.FLOW_END;\n                return yield* this.parseLineStart();\n            }\n        }\n        let n = 0;\n        while (line[n] === ',') {\n            n += yield* this.pushCount(1);\n            n += yield* this.pushSpaces(true);\n            this.flowKey = false;\n        }\n        n += yield* this.pushIndicators();\n        switch (line[n]) {\n            case undefined:\n                return 'flow';\n            case '#':\n                yield* this.pushCount(line.length - n);\n                return 'flow';\n            case '{':\n            case '[':\n                yield* this.pushCount(1);\n                this.flowKey = false;\n                this.flowLevel += 1;\n                return 'flow';\n            case '}':\n            case ']':\n                yield* this.pushCount(1);\n                this.flowKey = true;\n                this.flowLevel -= 1;\n                return this.flowLevel ? 'flow' : 'doc';\n            case '*':\n                yield* this.pushUntil(isNotAnchorChar);\n                return 'flow';\n            case '\"':\n            case \"'\":\n                this.flowKey = true;\n                return yield* this.parseQuotedScalar();\n            case ':': {\n                const next = this.charAt(1);\n                if (this.flowKey || isEmpty(next) || next === ',') {\n                    this.flowKey = false;\n                    yield* this.pushCount(1);\n                    yield* this.pushSpaces(true);\n                    return 'flow';\n                }\n            }\n            // fallthrough\n            default:\n                this.flowKey = false;\n                return yield* this.parsePlainScalar();\n        }\n    }\n    *parseQuotedScalar() {\n        const quote = this.charAt(0);\n        let end = this.buffer.indexOf(quote, this.pos + 1);\n        if (quote === \"'\") {\n            while (end !== -1 && this.buffer[end + 1] === \"'\")\n                end = this.buffer.indexOf(\"'\", end + 2);\n        }\n        else {\n            // double-quote\n            while (end !== -1) {\n                let n = 0;\n                while (this.buffer[end - 1 - n] === '\\\\')\n                    n += 1;\n                if (n % 2 === 0)\n                    break;\n                end = this.buffer.indexOf('\"', end + 1);\n            }\n        }\n        // Only looking for newlines within the quotes\n        const qb = this.buffer.substring(0, end);\n        let nl = qb.indexOf('\\n', this.pos);\n        if (nl !== -1) {\n            while (nl !== -1) {\n                const cs = this.continueScalar(nl + 1);\n                if (cs === -1)\n                    break;\n                nl = qb.indexOf('\\n', cs);\n            }\n            if (nl !== -1) {\n                // this is an error caused by an unexpected unindent\n                end = nl - (qb[nl - 1] === '\\r' ? 2 : 1);\n            }\n        }\n        if (end === -1) {\n            if (!this.atEnd)\n                return this.setNext('quoted-scalar');\n            end = this.buffer.length;\n        }\n        yield* this.pushToIndex(end + 1, false);\n        return this.flowLevel ? 'flow' : 'doc';\n    }\n    *parseBlockScalarHeader() {\n        this.blockScalarIndent = -1;\n        this.blockScalarKeep = false;\n        let i = this.pos;\n        while (true) {\n            const ch = this.buffer[++i];\n            if (ch === '+')\n                this.blockScalarKeep = true;\n            else if (ch > '0' && ch <= '9')\n                this.blockScalarIndent = Number(ch) - 1;\n            else if (ch !== '-')\n                break;\n        }\n        return yield* this.pushUntil(ch => isEmpty(ch) || ch === '#');\n    }\n    *parseBlockScalar() {\n        let nl = this.pos - 1; // may be -1 if this.pos === 0\n        let indent = 0;\n        let ch;\n        loop: for (let i = this.pos; (ch = this.buffer[i]); ++i) {\n            switch (ch) {\n                case ' ':\n                    indent += 1;\n                    break;\n                case '\\n':\n                    nl = i;\n                    indent = 0;\n                    break;\n                case '\\r': {\n                    const next = this.buffer[i + 1];\n                    if (!next && !this.atEnd)\n                        return this.setNext('block-scalar');\n                    if (next === '\\n')\n                        break;\n                } // fallthrough\n                default:\n                    break loop;\n            }\n        }\n        if (!ch && !this.atEnd)\n            return this.setNext('block-scalar');\n        if (indent >= this.indentNext) {\n            if (this.blockScalarIndent === -1)\n                this.indentNext = indent;\n            else\n                this.indentNext += this.blockScalarIndent;\n            do {\n                const cs = this.continueScalar(nl + 1);\n                if (cs === -1)\n                    break;\n                nl = this.buffer.indexOf('\\n', cs);\n            } while (nl !== -1);\n            if (nl === -1) {\n                if (!this.atEnd)\n                    return this.setNext('block-scalar');\n                nl = this.buffer.length;\n            }\n        }\n        if (!this.blockScalarKeep) {\n            do {\n                let i = nl - 1;\n                let ch = this.buffer[i];\n                if (ch === '\\r')\n                    ch = this.buffer[--i];\n                const lastChar = i; // Drop the line if last char not more indented\n                while (ch === ' ' || ch === '\\t')\n                    ch = this.buffer[--i];\n                if (ch === '\\n' && i >= this.pos && i + 1 + indent > lastChar)\n                    nl = i;\n                else\n                    break;\n            } while (true);\n        }\n        yield cst.SCALAR;\n        yield* this.pushToIndex(nl + 1, true);\n        return yield* this.parseLineStart();\n    }\n    *parsePlainScalar() {\n        const inFlow = this.flowLevel > 0;\n        let end = this.pos - 1;\n        let i = this.pos - 1;\n        let ch;\n        while ((ch = this.buffer[++i])) {\n            if (ch === ':') {\n                const next = this.buffer[i + 1];\n                if (isEmpty(next) || (inFlow && next === ','))\n                    break;\n                end = i;\n            }\n            else if (isEmpty(ch)) {\n                let next = this.buffer[i + 1];\n                if (ch === '\\r') {\n                    if (next === '\\n') {\n                        i += 1;\n                        ch = '\\n';\n                        next = this.buffer[i + 1];\n                    }\n                    else\n                        end = i;\n                }\n                if (next === '#' || (inFlow && invalidFlowScalarChars.includes(next)))\n                    break;\n                if (ch === '\\n') {\n                    const cs = this.continueScalar(i + 1);\n                    if (cs === -1)\n                        break;\n                    i = Math.max(i, cs - 2); // to advance, but still account for ' #'\n                }\n            }\n            else {\n                if (inFlow && invalidFlowScalarChars.includes(ch))\n                    break;\n                end = i;\n            }\n        }\n        if (!ch && !this.atEnd)\n            return this.setNext('plain-scalar');\n        yield cst.SCALAR;\n        yield* this.pushToIndex(end + 1, true);\n        return inFlow ? 'flow' : 'doc';\n    }\n    *pushCount(n) {\n        if (n > 0) {\n            yield this.buffer.substr(this.pos, n);\n            this.pos += n;\n            return n;\n        }\n        return 0;\n    }\n    *pushToIndex(i, allowEmpty) {\n        const s = this.buffer.slice(this.pos, i);\n        if (s) {\n            yield s;\n            this.pos += s.length;\n            return s.length;\n        }\n        else if (allowEmpty)\n            yield '';\n        return 0;\n    }\n    *pushIndicators() {\n        switch (this.charAt(0)) {\n            case '!':\n                return ((yield* this.pushTag()) +\n                    (yield* this.pushSpaces(true)) +\n                    (yield* this.pushIndicators()));\n            case '&':\n                return ((yield* this.pushUntil(isNotAnchorChar)) +\n                    (yield* this.pushSpaces(true)) +\n                    (yield* this.pushIndicators()));\n            case '-': // this is an error\n            case '?': // this is an error outside flow collections\n            case ':': {\n                const inFlow = this.flowLevel > 0;\n                const ch1 = this.charAt(1);\n                if (isEmpty(ch1) || (inFlow && invalidFlowScalarChars.includes(ch1))) {\n                    if (!inFlow)\n                        this.indentNext = this.indentValue + 1;\n                    else if (this.flowKey)\n                        this.flowKey = false;\n                    return ((yield* this.pushCount(1)) +\n                        (yield* this.pushSpaces(true)) +\n                        (yield* this.pushIndicators()));\n                }\n            }\n        }\n        return 0;\n    }\n    *pushTag() {\n        if (this.charAt(1) === '<') {\n            let i = this.pos + 2;\n            let ch = this.buffer[i];\n            while (!isEmpty(ch) && ch !== '>')\n                ch = this.buffer[++i];\n            return yield* this.pushToIndex(ch === '>' ? i + 1 : i, false);\n        }\n        else {\n            let i = this.pos + 1;\n            let ch = this.buffer[i];\n            while (ch) {\n                if (tagChars.includes(ch))\n                    ch = this.buffer[++i];\n                else if (ch === '%' &&\n                    hexDigits.includes(this.buffer[i + 1]) &&\n                    hexDigits.includes(this.buffer[i + 2])) {\n                    ch = this.buffer[(i += 3)];\n                }\n                else\n                    break;\n            }\n            return yield* this.pushToIndex(i, false);\n        }\n    }\n    *pushNewline() {\n        const ch = this.buffer[this.pos];\n        if (ch === '\\n')\n            return yield* this.pushCount(1);\n        else if (ch === '\\r' && this.charAt(1) === '\\n')\n            return yield* this.pushCount(2);\n        else\n            return 0;\n    }\n    *pushSpaces(allowTabs) {\n        let i = this.pos - 1;\n        let ch;\n        do {\n            ch = this.buffer[++i];\n        } while (ch === ' ' || (allowTabs && ch === '\\t'));\n        const n = i - this.pos;\n        if (n > 0) {\n            yield this.buffer.substr(this.pos, n);\n            this.pos = i;\n        }\n        return n;\n    }\n    *pushUntil(test) {\n        let i = this.pos;\n        let ch = this.buffer[i];\n        while (!test(ch))\n            ch = this.buffer[++i];\n        return yield* this.pushToIndex(i, false);\n    }\n}\n\nexports.Lexer = Lexer;\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,GAAG,GAAGC,OAAO,CAAC,UAAU,CAAC;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,OAAOA,CAACC,EAAE,EAAE;EACjB,QAAQA,EAAE;IACN,KAAKC,SAAS;IACd,KAAK,GAAG;IACR,KAAK,IAAI;IACT,KAAK,IAAI;IACT,KAAK,IAAI;MACL,OAAO,IAAI;IACf;MACI,OAAO,KAAK;EAAC;AAEzB;AACA,MAAMC,SAAS,GAAG,wBAAwB,CAACC,KAAK,CAAC,EAAE,CAAC;AACpD,MAAMC,QAAQ,GAAG,mFAAmF,CAACD,KAAK,CAAC,EAAE,CAAC;AAC9G,MAAME,sBAAsB,GAAG,OAAO,CAACF,KAAK,CAAC,EAAE,CAAC;AAChD,MAAMG,kBAAkB,GAAG,cAAc,CAACH,KAAK,CAAC,EAAE,CAAC;AACnD,MAAMI,eAAe,GAAIP,EAAE,IAAK,CAACA,EAAE,IAAIM,kBAAkB,CAACE,QAAQ,CAACR,EAAE,CAAC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMS,KAAK,CAAC;EACRC,WAAWA,CAAA,EAAG;IACV;AACR;AACA;AACA;IACQ,IAAI,CAACC,KAAK,GAAG,KAAK;IAClB;AACR;AACA;AACA;AACA;IACQ,IAAI,CAACC,iBAAiB,GAAG,CAAC,CAAC;IAC3B;AACR;AACA;AACA;AACA;IACQ,IAAI,CAACC,eAAe,GAAG,KAAK;IAC5B;IACA,IAAI,CAACC,MAAM,GAAG,EAAE;IAChB;A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"}