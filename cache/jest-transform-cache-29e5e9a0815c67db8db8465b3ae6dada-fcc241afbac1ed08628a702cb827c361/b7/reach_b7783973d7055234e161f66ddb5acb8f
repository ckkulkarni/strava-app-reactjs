0f657b31c97b685111586a82336de972
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.getIn = getIn;
var _propertyExpr = require("property-expr");
let trim = part => part.substr(0, part.length - 1).substr(1);
function getIn(schema, path, value, context = value) {
  let parent, lastPart, lastPartDebug; // root path: ''

  if (!path) return {
    parent,
    parentPath: path,
    schema
  };
  (0, _propertyExpr.forEach)(path, (_part, isBracket, isArray) => {
    let part = isBracket ? trim(_part) : _part;
    schema = schema.resolve({
      context,
      parent,
      value
    });
    if (schema.innerType) {
      let idx = isArray ? parseInt(part, 10) : 0;
      if (value && idx >= value.length) {
        throw new Error(`Yup.reach cannot resolve an array item at index: ${_part}, in the path: ${path}. ` + `because there is no value at that index. `);
      }
      parent = value;
      value = value && value[idx];
      schema = schema.innerType;
    } // sometimes the array index part of a path doesn't exist: "nested.arr.child"
    // in these cases the current part is the next schema and should be processed
    // in this iteration. For cases where the index signature is included this
    // check will fail and we'll handle the `child` part on the next iteration like normal

    if (!isArray) {
      if (!schema.fields || !schema.fields[part]) throw new Error(`The schema does not contain the path: ${path}. ` + `(failed at: ${lastPartDebug} which is a type: "${schema._type}")`);
      parent = value;
      value = value && value[part];
      schema = schema.fields[part];
    }
    lastPart = part;
    lastPartDebug = isBracket ? '[' + _part + ']' : '.' + _part;
  });
  return {
    schema,
    parent,
    parentPath: lastPart
  };
}
const reach = (obj, path, value, context) => getIn(obj, path, value, context).schema;
var _default = reach;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHQiLCJnZXRJbiIsIl9wcm9wZXJ0eUV4cHIiLCJyZXF1aXJlIiwidHJpbSIsInBhcnQiLCJzdWJzdHIiLCJsZW5ndGgiLCJzY2hlbWEiLCJwYXRoIiwiY29udGV4dCIsInBhcmVudCIsImxhc3RQYXJ0IiwibGFzdFBhcnREZWJ1ZyIsInBhcmVudFBhdGgiLCJmb3JFYWNoIiwiX3BhcnQiLCJpc0JyYWNrZXQiLCJpc0FycmF5IiwicmVzb2x2ZSIsImlubmVyVHlwZSIsImlkeCIsInBhcnNlSW50IiwiRXJyb3IiLCJmaWVsZHMiLCJfdHlwZSIsInJlYWNoIiwib2JqIiwiX2RlZmF1bHQiXSwic291cmNlcyI6WyJyZWFjaC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbmV4cG9ydHMuZ2V0SW4gPSBnZXRJbjtcblxudmFyIF9wcm9wZXJ0eUV4cHIgPSByZXF1aXJlKFwicHJvcGVydHktZXhwclwiKTtcblxubGV0IHRyaW0gPSBwYXJ0ID0+IHBhcnQuc3Vic3RyKDAsIHBhcnQubGVuZ3RoIC0gMSkuc3Vic3RyKDEpO1xuXG5mdW5jdGlvbiBnZXRJbihzY2hlbWEsIHBhdGgsIHZhbHVlLCBjb250ZXh0ID0gdmFsdWUpIHtcbiAgbGV0IHBhcmVudCwgbGFzdFBhcnQsIGxhc3RQYXJ0RGVidWc7IC8vIHJvb3QgcGF0aDogJydcblxuICBpZiAoIXBhdGgpIHJldHVybiB7XG4gICAgcGFyZW50LFxuICAgIHBhcmVudFBhdGg6IHBhdGgsXG4gICAgc2NoZW1hXG4gIH07XG4gICgwLCBfcHJvcGVydHlFeHByLmZvckVhY2gpKHBhdGgsIChfcGFydCwgaXNCcmFja2V0LCBpc0FycmF5KSA9PiB7XG4gICAgbGV0IHBhcnQgPSBpc0JyYWNrZXQgPyB0cmltKF9wYXJ0KSA6IF9wYXJ0O1xuICAgIHNjaGVtYSA9IHNjaGVtYS5yZXNvbHZlKHtcbiAgICAgIGNvbnRleHQsXG4gICAgICBwYXJlbnQsXG4gICAgICB2YWx1ZVxuICAgIH0pO1xuXG4gICAgaWYgKHNjaGVtYS5pbm5lclR5cGUpIHtcbiAgICAgIGxldCBpZHggPSBpc0FycmF5ID8gcGFyc2VJbnQocGFydCwgMTApIDogMDtcblxuICAgICAgaWYgKHZhbHVlICYmIGlkeCA+PSB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBZdXAucmVhY2ggY2Fubm90IHJlc29sdmUgYW4gYXJyYXkgaXRlbSBhdCBpbmRleDogJHtfcGFydH0sIGluIHRoZSBwYXRoOiAke3BhdGh9LiBgICsgYGJlY2F1c2UgdGhlcmUgaXMgbm8gdmFsdWUgYXQgdGhhdCBpbmRleC4gYCk7XG4gICAgICB9XG5cbiAgICAgIHBhcmVudCA9IHZhbHVlO1xuICAgICAgdmFsdWUgPSB2YWx1ZSAmJiB2YWx1ZVtpZHhdO1xuICAgICAgc2NoZW1hID0gc2NoZW1hLmlubmVyVHlwZTtcbiAgICB9IC8vIHNvbWV0aW1lcyB0aGUgYXJyYXkgaW5kZXggcGFydCBvZiBhIHBhdGggZG9lc24ndCBleGlzdDogXCJuZXN0ZWQuYXJyLmNoaWxkXCJcbiAgICAvLyBpbiB0aGVzZSBjYXNlcyB0aGUgY3VycmVudCBwYXJ0IGlzIHRoZSBuZXh0IHNjaGVtYSBhbmQgc2hvdWxkIGJlIHByb2Nlc3NlZFxuICAgIC8vIGluIHRoaXMgaXRlcmF0aW9uLiBGb3IgY2FzZXMgd2hlcmUgdGhlIGluZGV4IHNpZ25hdHVyZSBpcyBpbmNsdWRlZCB0aGlzXG4gICAgLy8gY2hlY2sgd2lsbCBmYWlsIGFuZCB3ZSdsbCBoYW5kbGUgdGhlIGBjaGlsZGAgcGFydCBvbiB0aGUgbmV4dCBpdGVyYXRpb24gbGlrZSBub3JtYWxcblxuXG4gICAgaWYgKCFpc0FycmF5KSB7XG4gICAgICBpZiAoIXNjaGVtYS5maWVsZHMgfHwgIXNjaGVtYS5maWVsZHNbcGFydF0pIHRocm93IG5ldyBFcnJvcihgVGhlIHNjaGVtYSBkb2VzIG5vdCBjb250YWluIHRoZSBwYXRoOiAke3BhdGh9LiBgICsgYChmYWlsZWQgYXQ6ICR7bGFzdFBhcnREZWJ1Z30gd2hpY2ggaXMgYSB0eXBlOiBcIiR7c2NoZW1hLl90eXBlfVwiKWApO1xuICAgICAgcGFyZW50ID0gdmFsdWU7XG4gICAgICB2YWx1ZSA9IHZhbHVlICYmIHZhbHVlW3BhcnRdO1xuICAgICAgc2NoZW1hID0gc2NoZW1hLmZpZWxkc1twYXJ0XTtcbiAgICB9XG5cbiAgICBsYXN0UGFydCA9IHBhcnQ7XG4gICAgbGFzdFBhcnREZWJ1ZyA9IGlzQnJhY2tldCA/ICdbJyArIF9wYXJ0ICsgJ10nIDogJy4nICsgX3BhcnQ7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHNjaGVtYSxcbiAgICBwYXJlbnQsXG4gICAgcGFyZW50UGF0aDogbGFzdFBhcnRcbiAgfTtcbn1cblxuY29uc3QgcmVhY2ggPSAob2JqLCBwYXRoLCB2YWx1ZSwgY29udGV4dCkgPT4gZ2V0SW4ob2JqLCBwYXRoLCB2YWx1ZSwgY29udGV4dCkuc2NoZW1hO1xuXG52YXIgX2RlZmF1bHQgPSByZWFjaDtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyJdLCJtYXBwaW5ncyI6IkFBQUEsWUFBWTs7QUFFWkEsTUFBTSxDQUFDQyxjQUFjLENBQUNDLE9BQU8sRUFBRSxZQUFZLEVBQUU7RUFDM0NDLEtBQUssRUFBRTtBQUNULENBQUMsQ0FBQztBQUNGRCxPQUFPLENBQUNFLE9BQU8sR0FBRyxLQUFLLENBQUM7QUFDeEJGLE9BQU8sQ0FBQ0csS0FBSyxHQUFHQSxLQUFLO0FBRXJCLElBQUlDLGFBQWEsR0FBR0MsT0FBTyxDQUFDLGVBQWUsQ0FBQztBQUU1QyxJQUFJQyxJQUFJLEdBQUdDLElBQUksSUFBSUEsSUFBSSxDQUFDQyxNQUFNLENBQUMsQ0FBQyxFQUFFRCxJQUFJLENBQUNFLE1B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