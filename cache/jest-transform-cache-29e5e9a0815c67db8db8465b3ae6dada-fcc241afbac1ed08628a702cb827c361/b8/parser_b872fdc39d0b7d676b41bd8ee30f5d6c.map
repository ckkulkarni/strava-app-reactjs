{"version":3,"names":["cst","require","lexer","includesToken","list","type","i","length","findNonEmptyIndex","isFlowToken","token","getPrevProps","parent","start","it","items","sep","getFirstKeyStartProps","prev","loop","splice","fixFlowSeqItems","fc","value","key","end","Array","prototype","push","apply","Parser","constructor","onNewLine","atNewLine","atScalar","indent","offset","onKeyLine","stack","source","Lexer","parse","incomplete","lexeme","lex","next","process","env","LOG_TOKENS","console","log","prettyToken","step","tokenType","message","pop","sourceToken","st","top","peek","stream","document","scalar","blockScalar","blockMap","blockSequence","flowCollection","documentEnd","n","error","props","Object","assign","last","every","doc","lineEnd","bv","startBlockValue","map","nl","indexOf","undefined","isArray","atIndentedComment","atNextItem","concat","fs","flowScalar","seq","docEnd","exports"],"sources":["parser.js"],"sourcesContent":["'use strict';\n\nvar cst = require('./cst.js');\nvar lexer = require('./lexer.js');\n\nfunction includesToken(list, type) {\n    for (let i = 0; i < list.length; ++i)\n        if (list[i].type === type)\n            return true;\n    return false;\n}\nfunction findNonEmptyIndex(list) {\n    for (let i = 0; i < list.length; ++i) {\n        switch (list[i].type) {\n            case 'space':\n            case 'comment':\n            case 'newline':\n                break;\n            default:\n                return i;\n        }\n    }\n    return -1;\n}\nfunction isFlowToken(token) {\n    switch (token?.type) {\n        case 'alias':\n        case 'scalar':\n        case 'single-quoted-scalar':\n        case 'double-quoted-scalar':\n        case 'flow-collection':\n            return true;\n        default:\n            return false;\n    }\n}\nfunction getPrevProps(parent) {\n    switch (parent.type) {\n        case 'document':\n            return parent.start;\n        case 'block-map': {\n            const it = parent.items[parent.items.length - 1];\n            return it.sep ?? it.start;\n        }\n        case 'block-seq':\n            return parent.items[parent.items.length - 1].start;\n        /* istanbul ignore next should not happen */\n        default:\n            return [];\n    }\n}\n/** Note: May modify input array */\nfunction getFirstKeyStartProps(prev) {\n    if (prev.length === 0)\n        return [];\n    let i = prev.length;\n    loop: while (--i >= 0) {\n        switch (prev[i].type) {\n            case 'doc-start':\n            case 'explicit-key-ind':\n            case 'map-value-ind':\n            case 'seq-item-ind':\n            case 'newline':\n                break loop;\n        }\n    }\n    while (prev[++i]?.type === 'space') {\n        /* loop */\n    }\n    return prev.splice(i, prev.length);\n}\nfunction fixFlowSeqItems(fc) {\n    if (fc.start.type === 'flow-seq-start') {\n        for (const it of fc.items) {\n            if (it.sep &&\n                !it.value &&\n                !includesToken(it.start, 'explicit-key-ind') &&\n                !includesToken(it.sep, 'map-value-ind')) {\n                if (it.key)\n                    it.value = it.key;\n                delete it.key;\n                if (isFlowToken(it.value)) {\n                    if (it.value.end)\n                        Array.prototype.push.apply(it.value.end, it.sep);\n                    else\n                        it.value.end = it.sep;\n                }\n                else\n                    Array.prototype.push.apply(it.start, it.sep);\n                delete it.sep;\n            }\n        }\n    }\n}\n/**\n * A YAML concrete syntax tree (CST) parser\n *\n * ```ts\n * const src: string = ...\n * for (const token of new Parser().parse(src)) {\n *   // token: Token\n * }\n * ```\n *\n * To use the parser with a user-provided lexer:\n *\n * ```ts\n * function* parse(source: string, lexer: Lexer) {\n *   const parser = new Parser()\n *   for (const lexeme of lexer.lex(source))\n *     yield* parser.next(lexeme)\n *   yield* parser.end()\n * }\n *\n * const src: string = ...\n * const lexer = new Lexer()\n * for (const token of parse(src, lexer)) {\n *   // token: Token\n * }\n * ```\n */\nclass Parser {\n    /**\n     * @param onNewLine - If defined, called separately with the start position of\n     *   each new line (in `parse()`, including the start of input).\n     */\n    constructor(onNewLine) {\n        /** If true, space and sequence indicators count as indentation */\n        this.atNewLine = true;\n        /** If true, next token is a scalar value */\n        this.atScalar = false;\n        /** Current indentation level */\n        this.indent = 0;\n        /** Current offset since the start of parsing */\n        this.offset = 0;\n        /** On the same line with a block map key */\n        this.onKeyLine = false;\n        /** Top indicates the node that's currently being built */\n        this.stack = [];\n        /** The source of the current token, set in parse() */\n        this.source = '';\n        /** The type of the current token, set in parse() */\n        this.type = '';\n        // Must be defined after `next()`\n        this.lexer = new lexer.Lexer();\n        this.onNewLine = onNewLine;\n    }\n    /**\n     * Parse `source` as a YAML stream.\n     * If `incomplete`, a part of the last line may be left as a buffer for the next call.\n     *\n     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.\n     *\n     * @returns A generator of tokens representing each directive, document, and other structure.\n     */\n    *parse(source, incomplete = false) {\n        if (this.onNewLine && this.offset === 0)\n            this.onNewLine(0);\n        for (const lexeme of this.lexer.lex(source, incomplete))\n            yield* this.next(lexeme);\n        if (!incomplete)\n            yield* this.end();\n    }\n    /**\n     * Advance the parser by the `source` of one lexical token.\n     */\n    *next(source) {\n        this.source = source;\n        if (process.env.LOG_TOKENS)\n            console.log('|', cst.prettyToken(source));\n        if (this.atScalar) {\n            this.atScalar = false;\n            yield* this.step();\n            this.offset += source.length;\n            return;\n        }\n        const type = cst.tokenType(source);\n        if (!type) {\n            const message = `Not a YAML token: ${source}`;\n            yield* this.pop({ type: 'error', offset: this.offset, message, source });\n            this.offset += source.length;\n        }\n        else if (type === 'scalar') {\n            this.atNewLine = false;\n            this.atScalar = true;\n            this.type = 'scalar';\n        }\n        else {\n            this.type = type;\n            yield* this.step();\n            switch (type) {\n                case 'newline':\n                    this.atNewLine = true;\n                    this.indent = 0;\n                    if (this.onNewLine)\n                        this.onNewLine(this.offset + source.length);\n                    break;\n                case 'space':\n                    if (this.atNewLine && source[0] === ' ')\n                        this.indent += source.length;\n                    break;\n                case 'explicit-key-ind':\n                case 'map-value-ind':\n                case 'seq-item-ind':\n                    if (this.atNewLine)\n                        this.indent += source.length;\n                    break;\n                case 'doc-mode':\n                case 'flow-error-end':\n                    return;\n                default:\n                    this.atNewLine = false;\n            }\n            this.offset += source.length;\n        }\n    }\n    /** Call at end of input to push out any remaining constructions */\n    *end() {\n        while (this.stack.length > 0)\n            yield* this.pop();\n    }\n    get sourceToken() {\n        const st = {\n            type: this.type,\n            offset: this.offset,\n            indent: this.indent,\n            source: this.source\n        };\n        return st;\n    }\n    *step() {\n        const top = this.peek(1);\n        if (this.type === 'doc-end' && (!top || top.type !== 'doc-end')) {\n            while (this.stack.length > 0)\n                yield* this.pop();\n            this.stack.push({\n                type: 'doc-end',\n                offset: this.offset,\n                source: this.source\n            });\n            return;\n        }\n        if (!top)\n            return yield* this.stream();\n        switch (top.type) {\n            case 'document':\n                return yield* this.document(top);\n            case 'alias':\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return yield* this.scalar(top);\n            case 'block-scalar':\n                return yield* this.blockScalar(top);\n            case 'block-map':\n                return yield* this.blockMap(top);\n            case 'block-seq':\n                return yield* this.blockSequence(top);\n            case 'flow-collection':\n                return yield* this.flowCollection(top);\n            case 'doc-end':\n                return yield* this.documentEnd(top);\n        }\n        /* istanbul ignore next should not happen */\n        yield* this.pop();\n    }\n    peek(n) {\n        return this.stack[this.stack.length - n];\n    }\n    *pop(error) {\n        const token = error ?? this.stack.pop();\n        /* istanbul ignore if should not happen */\n        if (!token) {\n            const message = 'Tried to pop an empty stack';\n            yield { type: 'error', offset: this.offset, source: '', message };\n        }\n        else if (this.stack.length === 0) {\n            yield token;\n        }\n        else {\n            const top = this.peek(1);\n            if (token.type === 'block-scalar') {\n                // Block scalars use their parent rather than header indent\n                token.indent = 'indent' in top ? top.indent : 0;\n            }\n            else if (token.type === 'flow-collection' && top.type === 'document') {\n                // Ignore all indent for top-level flow collections\n                token.indent = 0;\n            }\n            if (token.type === 'flow-collection')\n                fixFlowSeqItems(token);\n            switch (top.type) {\n                case 'document':\n                    top.value = token;\n                    break;\n                case 'block-scalar':\n                    top.props.push(token); // error\n                    break;\n                case 'block-map': {\n                    const it = top.items[top.items.length - 1];\n                    if (it.value) {\n                        top.items.push({ start: [], key: token, sep: [] });\n                        this.onKeyLine = true;\n                        return;\n                    }\n                    else if (it.sep) {\n                        it.value = token;\n                    }\n                    else {\n                        Object.assign(it, { key: token, sep: [] });\n                        this.onKeyLine = !includesToken(it.start, 'explicit-key-ind');\n                        return;\n                    }\n                    break;\n                }\n                case 'block-seq': {\n                    const it = top.items[top.items.length - 1];\n                    if (it.value)\n                        top.items.push({ start: [], value: token });\n                    else\n                        it.value = token;\n                    break;\n                }\n                case 'flow-collection': {\n                    const it = top.items[top.items.length - 1];\n                    if (!it || it.value)\n                        top.items.push({ start: [], key: token, sep: [] });\n                    else if (it.sep)\n                        it.value = token;\n                    else\n                        Object.assign(it, { key: token, sep: [] });\n                    return;\n                }\n                /* istanbul ignore next should not happen */\n                default:\n                    yield* this.pop();\n                    yield* this.pop(token);\n            }\n            if ((top.type === 'document' ||\n                top.type === 'block-map' ||\n                top.type === 'block-seq') &&\n                (token.type === 'block-map' || token.type === 'block-seq')) {\n                const last = token.items[token.items.length - 1];\n                if (last &&\n                    !last.sep &&\n                    !last.value &&\n                    last.start.length > 0 &&\n                    findNonEmptyIndex(last.start) === -1 &&\n                    (token.indent === 0 ||\n                        last.start.every(st => st.type !== 'comment' || st.indent < token.indent))) {\n                    if (top.type === 'document')\n                        top.end = last.start;\n                    else\n                        top.items.push({ start: last.start });\n                    token.items.splice(-1, 1);\n                }\n            }\n        }\n    }\n    *stream() {\n        switch (this.type) {\n            case 'directive-line':\n                yield { type: 'directive', offset: this.offset, source: this.source };\n                return;\n            case 'byte-order-mark':\n            case 'space':\n            case 'comment':\n            case 'newline':\n                yield this.sourceToken;\n                return;\n            case 'doc-mode':\n            case 'doc-start': {\n                const doc = {\n                    type: 'document',\n                    offset: this.offset,\n                    start: []\n                };\n                if (this.type === 'doc-start')\n                    doc.start.push(this.sourceToken);\n                this.stack.push(doc);\n                return;\n            }\n        }\n        yield {\n            type: 'error',\n            offset: this.offset,\n            message: `Unexpected ${this.type} token in YAML stream`,\n            source: this.source\n        };\n    }\n    *document(doc) {\n        if (doc.value)\n            return yield* this.lineEnd(doc);\n        switch (this.type) {\n            case 'doc-start': {\n                if (findNonEmptyIndex(doc.start) !== -1) {\n                    yield* this.pop();\n                    yield* this.step();\n                }\n                else\n                    doc.start.push(this.sourceToken);\n                return;\n            }\n            case 'anchor':\n            case 'tag':\n            case 'space':\n            case 'comment':\n            case 'newline':\n                doc.start.push(this.sourceToken);\n                return;\n        }\n        const bv = this.startBlockValue(doc);\n        if (bv)\n            this.stack.push(bv);\n        else {\n            yield {\n                type: 'error',\n                offset: this.offset,\n                message: `Unexpected ${this.type} token in YAML document`,\n                source: this.source\n            };\n        }\n    }\n    *scalar(scalar) {\n        if (this.type === 'map-value-ind') {\n            const prev = getPrevProps(this.peek(2));\n            const start = getFirstKeyStartProps(prev);\n            let sep;\n            if (scalar.end) {\n                sep = scalar.end;\n                sep.push(this.sourceToken);\n                delete scalar.end;\n            }\n            else\n                sep = [this.sourceToken];\n            const map = {\n                type: 'block-map',\n                offset: scalar.offset,\n                indent: scalar.indent,\n                items: [{ start, key: scalar, sep }]\n            };\n            this.onKeyLine = true;\n            this.stack[this.stack.length - 1] = map;\n        }\n        else\n            yield* this.lineEnd(scalar);\n    }\n    *blockScalar(scalar) {\n        switch (this.type) {\n            case 'space':\n            case 'comment':\n            case 'newline':\n                scalar.props.push(this.sourceToken);\n                return;\n            case 'scalar':\n                scalar.source = this.source;\n                // block-scalar source includes trailing newline\n                this.atNewLine = true;\n                this.indent = 0;\n                if (this.onNewLine) {\n                    let nl = this.source.indexOf('\\n') + 1;\n                    while (nl !== 0) {\n                        this.onNewLine(this.offset + nl);\n                        nl = this.source.indexOf('\\n', nl) + 1;\n                    }\n                }\n                yield* this.pop();\n                break;\n            /* istanbul ignore next should not happen */\n            default:\n                yield* this.pop();\n                yield* this.step();\n        }\n    }\n    *blockMap(map) {\n        const it = map.items[map.items.length - 1];\n        // it.sep is true-ish if pair already has key or : separator\n        switch (this.type) {\n            case 'newline':\n                this.onKeyLine = false;\n                if (it.value) {\n                    const end = 'end' in it.value ? it.value.end : undefined;\n                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;\n                    if (last?.type === 'comment')\n                        end?.push(this.sourceToken);\n                    else\n                        map.items.push({ start: [this.sourceToken] });\n                }\n                else if (it.sep) {\n                    it.sep.push(this.sourceToken);\n                }\n                else {\n                    it.start.push(this.sourceToken);\n                }\n                return;\n            case 'space':\n            case 'comment':\n                if (it.value) {\n                    map.items.push({ start: [this.sourceToken] });\n                }\n                else if (it.sep) {\n                    it.sep.push(this.sourceToken);\n                }\n                else {\n                    if (this.atIndentedComment(it.start, map.indent)) {\n                        const prev = map.items[map.items.length - 2];\n                        const end = prev?.value?.end;\n                        if (Array.isArray(end)) {\n                            Array.prototype.push.apply(end, it.start);\n                            end.push(this.sourceToken);\n                            map.items.pop();\n                            return;\n                        }\n                    }\n                    it.start.push(this.sourceToken);\n                }\n                return;\n        }\n        if (this.indent >= map.indent) {\n            const atNextItem = !this.onKeyLine && this.indent === map.indent && it.sep;\n            // For empty nodes, assign newline-separated not indented empty tokens to following node\n            let start = [];\n            if (atNextItem && it.sep && !it.value) {\n                const nl = [];\n                for (let i = 0; i < it.sep.length; ++i) {\n                    const st = it.sep[i];\n                    switch (st.type) {\n                        case 'newline':\n                            nl.push(i);\n                            break;\n                        case 'space':\n                            break;\n                        case 'comment':\n                            if (st.indent > map.indent)\n                                nl.length = 0;\n                            break;\n                        default:\n                            nl.length = 0;\n                    }\n                }\n                if (nl.length >= 2)\n                    start = it.sep.splice(nl[1]);\n            }\n            switch (this.type) {\n                case 'anchor':\n                case 'tag':\n                    if (atNextItem || it.value) {\n                        start.push(this.sourceToken);\n                        map.items.push({ start });\n                        this.onKeyLine = true;\n                    }\n                    else if (it.sep) {\n                        it.sep.push(this.sourceToken);\n                    }\n                    else {\n                        it.start.push(this.sourceToken);\n                    }\n                    return;\n                case 'explicit-key-ind':\n                    if (!it.sep && !includesToken(it.start, 'explicit-key-ind')) {\n                        it.start.push(this.sourceToken);\n                    }\n                    else if (atNextItem || it.value) {\n                        start.push(this.sourceToken);\n                        map.items.push({ start });\n                    }\n                    else {\n                        this.stack.push({\n                            type: 'block-map',\n                            offset: this.offset,\n                            indent: this.indent,\n                            items: [{ start: [this.sourceToken] }]\n                        });\n                    }\n                    this.onKeyLine = true;\n                    return;\n                case 'map-value-ind':\n                    if (includesToken(it.start, 'explicit-key-ind')) {\n                        if (!it.sep) {\n                            if (includesToken(it.start, 'newline')) {\n                                Object.assign(it, { key: null, sep: [this.sourceToken] });\n                            }\n                            else {\n                                const start = getFirstKeyStartProps(it.start);\n                                this.stack.push({\n                                    type: 'block-map',\n                                    offset: this.offset,\n                                    indent: this.indent,\n                                    items: [{ start, key: null, sep: [this.sourceToken] }]\n                                });\n                            }\n                        }\n                        else if (it.value) {\n                            map.items.push({ start: [], key: null, sep: [this.sourceToken] });\n                        }\n                        else if (includesToken(it.sep, 'map-value-ind')) {\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start, key: null, sep: [this.sourceToken] }]\n                            });\n                        }\n                        else if (isFlowToken(it.key) &&\n                            !includesToken(it.sep, 'newline')) {\n                            const start = getFirstKeyStartProps(it.start);\n                            const key = it.key;\n                            const sep = it.sep;\n                            sep.push(this.sourceToken);\n                            // @ts-expect-error type guard is wrong here\n                            delete it.key, delete it.sep;\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start, key, sep }]\n                            });\n                        }\n                        else if (start.length > 0) {\n                            // Not actually at next item\n                            it.sep = it.sep.concat(start, this.sourceToken);\n                        }\n                        else {\n                            it.sep.push(this.sourceToken);\n                        }\n                    }\n                    else {\n                        if (!it.sep) {\n                            Object.assign(it, { key: null, sep: [this.sourceToken] });\n                        }\n                        else if (it.value || atNextItem) {\n                            map.items.push({ start, key: null, sep: [this.sourceToken] });\n                        }\n                        else if (includesToken(it.sep, 'map-value-ind')) {\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start: [], key: null, sep: [this.sourceToken] }]\n                            });\n                        }\n                        else {\n                            it.sep.push(this.sourceToken);\n                        }\n                    }\n                    this.onKeyLine = true;\n                    return;\n                case 'alias':\n                case 'scalar':\n                case 'single-quoted-scalar':\n                case 'double-quoted-scalar': {\n                    const fs = this.flowScalar(this.type);\n                    if (atNextItem || it.value) {\n                        map.items.push({ start, key: fs, sep: [] });\n                        this.onKeyLine = true;\n                    }\n                    else if (it.sep) {\n                        this.stack.push(fs);\n                    }\n                    else {\n                        Object.assign(it, { key: fs, sep: [] });\n                        this.onKeyLine = true;\n                    }\n                    return;\n                }\n                default: {\n                    const bv = this.startBlockValue(map);\n                    if (bv) {\n                        if (atNextItem &&\n                            bv.type !== 'block-seq' &&\n                            includesToken(it.start, 'explicit-key-ind')) {\n                            map.items.push({ start });\n                        }\n                        this.stack.push(bv);\n                        return;\n                    }\n                }\n            }\n        }\n        yield* this.pop();\n        yield* this.step();\n    }\n    *blockSequence(seq) {\n        const it = seq.items[seq.items.length - 1];\n        switch (this.type) {\n            case 'newline':\n                if (it.value) {\n                    const end = 'end' in it.value ? it.value.end : undefined;\n                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;\n                    if (last?.type === 'comment')\n                        end?.push(this.sourceToken);\n                    else\n                        seq.items.push({ start: [this.sourceToken] });\n                }\n                else\n                    it.start.push(this.sourceToken);\n                return;\n            case 'space':\n            case 'comment':\n                if (it.value)\n                    seq.items.push({ start: [this.sourceToken] });\n                else {\n                    if (this.atIndentedComment(it.start, seq.indent)) {\n                        const prev = seq.items[seq.items.length - 2];\n                        const end = prev?.value?.end;\n                        if (Array.isArray(end)) {\n                            Array.prototype.push.apply(end, it.start);\n                            end.push(this.sourceToken);\n                            seq.items.pop();\n                            return;\n                        }\n                    }\n                    it.start.push(this.sourceToken);\n                }\n                return;\n            case 'anchor':\n            case 'tag':\n                if (it.value || this.indent <= seq.indent)\n                    break;\n                it.start.push(this.sourceToken);\n                return;\n            case 'seq-item-ind':\n                if (this.indent !== seq.indent)\n                    break;\n                if (it.value || includesToken(it.start, 'seq-item-ind'))\n                    seq.items.push({ start: [this.sourceToken] });\n                else\n                    it.start.push(this.sourceToken);\n                return;\n        }\n        if (this.indent > seq.indent) {\n            const bv = this.startBlockValue(seq);\n            if (bv) {\n                this.stack.push(bv);\n                return;\n            }\n        }\n        yield* this.pop();\n        yield* this.step();\n    }\n    *flowCollection(fc) {\n        const it = fc.items[fc.items.length - 1];\n        if (this.type === 'flow-error-end') {\n            let top;\n            do {\n                yield* this.pop();\n                top = this.peek(1);\n            } while (top && top.type === 'flow-collection');\n        }\n        else if (fc.end.length === 0) {\n            switch (this.type) {\n                case 'comma':\n                case 'explicit-key-ind':\n                    if (!it || it.sep)\n                        fc.items.push({ start: [this.sourceToken] });\n                    else\n                        it.start.push(this.sourceToken);\n                    return;\n                case 'map-value-ind':\n                    if (!it || it.value)\n                        fc.items.push({ start: [], key: null, sep: [this.sourceToken] });\n                    else if (it.sep)\n                        it.sep.push(this.sourceToken);\n                    else\n                        Object.assign(it, { key: null, sep: [this.sourceToken] });\n                    return;\n                case 'space':\n                case 'comment':\n                case 'newline':\n                case 'anchor':\n                case 'tag':\n                    if (!it || it.value)\n                        fc.items.push({ start: [this.sourceToken] });\n                    else if (it.sep)\n                        it.sep.push(this.sourceToken);\n                    else\n                        it.start.push(this.sourceToken);\n                    return;\n                case 'alias':\n                case 'scalar':\n                case 'single-quoted-scalar':\n                case 'double-quoted-scalar': {\n                    const fs = this.flowScalar(this.type);\n                    if (!it || it.value)\n                        fc.items.push({ start: [], key: fs, sep: [] });\n                    else if (it.sep)\n                        this.stack.push(fs);\n                    else\n                        Object.assign(it, { key: fs, sep: [] });\n                    return;\n                }\n                case 'flow-map-end':\n                case 'flow-seq-end':\n                    fc.end.push(this.sourceToken);\n                    return;\n            }\n            const bv = this.startBlockValue(fc);\n            /* istanbul ignore else should not happen */\n            if (bv)\n                this.stack.push(bv);\n            else {\n                yield* this.pop();\n                yield* this.step();\n            }\n        }\n        else {\n            const parent = this.peek(2);\n            if (parent.type === 'block-map' &&\n                ((this.type === 'map-value-ind' && parent.indent === fc.indent) ||\n                    (this.type === 'newline' &&\n                        !parent.items[parent.items.length - 1].sep))) {\n                yield* this.pop();\n                yield* this.step();\n            }\n            else if (this.type === 'map-value-ind' &&\n                parent.type !== 'flow-collection') {\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                fixFlowSeqItems(fc);\n                const sep = fc.end.splice(1, fc.end.length);\n                sep.push(this.sourceToken);\n                const map = {\n                    type: 'block-map',\n                    offset: fc.offset,\n                    indent: fc.indent,\n                    items: [{ start, key: fc, sep }]\n                };\n                this.onKeyLine = true;\n                this.stack[this.stack.length - 1] = map;\n            }\n            else {\n                yield* this.lineEnd(fc);\n            }\n        }\n    }\n    flowScalar(type) {\n        if (this.onNewLine) {\n            let nl = this.source.indexOf('\\n') + 1;\n            while (nl !== 0) {\n                this.onNewLine(this.offset + nl);\n                nl = this.source.indexOf('\\n', nl) + 1;\n            }\n        }\n        return {\n            type,\n            offset: this.offset,\n            indent: this.indent,\n            source: this.source\n        };\n    }\n    startBlockValue(parent) {\n        switch (this.type) {\n            case 'alias':\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return this.flowScalar(this.type);\n            case 'block-scalar-header':\n                return {\n                    type: 'block-scalar',\n                    offset: this.offset,\n                    indent: this.indent,\n                    props: [this.sourceToken],\n                    source: ''\n                };\n            case 'flow-map-start':\n            case 'flow-seq-start':\n                return {\n                    type: 'flow-collection',\n                    offset: this.offset,\n                    indent: this.indent,\n                    start: this.sourceToken,\n                    items: [],\n                    end: []\n                };\n            case 'seq-item-ind':\n                return {\n                    type: 'block-seq',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start: [this.sourceToken] }]\n                };\n            case 'explicit-key-ind': {\n                this.onKeyLine = true;\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                start.push(this.sourceToken);\n                return {\n                    type: 'block-map',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start }]\n                };\n            }\n            case 'map-value-ind': {\n                this.onKeyLine = true;\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                return {\n                    type: 'block-map',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start, key: null, sep: [this.sourceToken] }]\n                };\n            }\n        }\n        return null;\n    }\n    atIndentedComment(start, indent) {\n        if (this.type !== 'comment')\n            return false;\n        if (this.indent <= indent)\n            return false;\n        return start.every(st => st.type === 'newline' || st.type === 'space');\n    }\n    *documentEnd(docEnd) {\n        if (this.type !== 'doc-mode') {\n            if (docEnd.end)\n                docEnd.end.push(this.sourceToken);\n            else\n                docEnd.end = [this.sourceToken];\n            if (this.type === 'newline')\n                yield* this.pop();\n        }\n    }\n    *lineEnd(token) {\n        switch (this.type) {\n            case 'comma':\n            case 'doc-start':\n            case 'doc-end':\n            case 'flow-seq-end':\n            case 'flow-map-end':\n            case 'map-value-ind':\n                yield* this.pop();\n                yield* this.step();\n                break;\n            case 'newline':\n                this.onKeyLine = false;\n            // fallthrough\n            case 'space':\n            case 'comment':\n            default:\n                // all other values are errors\n                if (token.end)\n                    token.end.push(this.sourceToken);\n                else\n                    token.end = [this.sourceToken];\n                if (this.type === 'newline')\n                    yield* this.pop();\n        }\n    }\n}\n\nexports.Parser = Parser;\n"],"mappings":"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"}