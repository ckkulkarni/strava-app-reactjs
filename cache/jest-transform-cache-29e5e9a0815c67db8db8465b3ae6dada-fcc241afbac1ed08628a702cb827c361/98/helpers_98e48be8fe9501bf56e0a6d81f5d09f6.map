{"version":3,"names":["knuth_shuffle_seeded_1","__importDefault","require","value_checker_1","configuration_1","os_1","messages","__importStar","ci_environment_1","support_code_library_builder_1","version_1","parseGherkinMessageStream","eventBroadcaster","eventDataCollector","gherkinMessageStream","order","pickleFilter","Promise","resolve","reject","result","on","envelope","emit","doesHaveValue","pickle","pickleId","id","gherkinDocument","getGherkinDocument","uri","matches","push","orderPickles","console","exports","pickleIds","logger","type","seed","OptionSplitter","split","newSeed","Math","floor","random","toString","warn","default","Error","emitMetaMessage","env","meta","protocolVersion","version","implementation","name","cpu","arch","os","platform","release","runtime","process","versions","node","ci","emitParameterTypes","supportCodeLibrary","newId","parameterType","parameterTypeRegistry","parameterTypes","builtinParameterTypes","includes","preferForRegularExpressionMatch","preferForRegexpMatch","regularExpressions","regexpStrings","useForSnippets","emitUndefinedParameterTypes","undefinedParameterType","undefinedParameterTypes","emitStepDefinitions","stepDefinitions","forEach","stepDefinition","pattern","source","StepDefinitionPatternType","CUCUMBER_EXPRESSION","REGULAR_EXPRESSION","sourceReference","location","line","emitTestCaseHooks","concat","beforeTestCaseHookDefinitions","afterTestCaseHookDefinitions","testCaseHookDefinition","hook","tagExpression","emitTestRunHooks","beforeTestRunHookDefinitions","afterTestRunHookDefinitions","testRunHookDefinition","emitSupportCodeMessages"],"sources":["../../src/cli/helpers.ts"],"sourcesContent":["import shuffle from 'knuth-shuffle-seeded'\nimport { EventEmitter } from 'events'\nimport PickleFilter from '../pickle_filter'\nimport { EventDataCollector } from '../formatter/helpers'\nimport { doesHaveValue } from '../value_checker'\nimport { OptionSplitter } from '../configuration'\nimport { Readable } from 'stream'\nimport os from 'os'\nimport * as messages from '@cucumber/messages'\nimport { IdGenerator } from '@cucumber/messages'\nimport detectCiEnvironment from '@cucumber/ci-environment'\nimport { ISupportCodeLibrary } from '../support_code_library_builder/types'\nimport TestCaseHookDefinition from '../models/test_case_hook_definition'\nimport TestRunHookDefinition from '../models/test_run_hook_definition'\nimport { PickleOrder } from '../models/pickle_order'\nimport { builtinParameterTypes } from '../support_code_library_builder'\nimport { version } from '../version'\nimport { ILogger } from '../logger'\n\ninterface IParseGherkinMessageStreamRequest {\n  cwd?: string\n  eventBroadcaster: EventEmitter\n  eventDataCollector: EventDataCollector\n  gherkinMessageStream: Readable\n  order: string\n  pickleFilter: PickleFilter\n}\n\n/**\n * Process a stream of envelopes from Gherkin and resolve to an array of filtered, ordered pickle Ids\n *\n * @param eventBroadcaster\n * @param eventDataCollector\n * @param gherkinMessageStream\n * @param order\n * @param pickleFilter\n */\nexport async function parseGherkinMessageStream({\n  eventBroadcaster,\n  eventDataCollector,\n  gherkinMessageStream,\n  order,\n  pickleFilter,\n}: IParseGherkinMessageStreamRequest): Promise<string[]> {\n  return await new Promise<string[]>((resolve, reject) => {\n    const result: string[] = []\n    gherkinMessageStream.on('data', (envelope: messages.Envelope) => {\n      eventBroadcaster.emit('envelope', envelope)\n      if (doesHaveValue(envelope.pickle)) {\n        const pickle = envelope.pickle\n        const pickleId = pickle.id\n        const gherkinDocument = eventDataCollector.getGherkinDocument(\n          pickle.uri\n        )\n        if (pickleFilter.matches({ gherkinDocument, pickle })) {\n          result.push(pickleId)\n        }\n      }\n    })\n    gherkinMessageStream.on('end', () => {\n      orderPickles(result, order, console)\n      resolve(result)\n    })\n    gherkinMessageStream.on('error', reject)\n  })\n}\n\n// Orders the pickleIds in place - morphs input\nexport function orderPickles<T = string>(\n  pickleIds: T[],\n  order: PickleOrder,\n  logger: ILogger\n): void {\n  const [type, seed] = OptionSplitter.split(order)\n  switch (type) {\n    case 'defined':\n      break\n    case 'random':\n      if (seed === '') {\n        const newSeed = Math.floor(Math.random() * 1000 * 1000).toString()\n        logger.warn(`Random order using seed: ${newSeed}`)\n        shuffle(pickleIds, newSeed)\n      } else {\n        shuffle(pickleIds, seed)\n      }\n      break\n    default:\n      throw new Error(\n        'Unrecgonized order type. Should be `defined` or `random`'\n      )\n  }\n}\n\nexport async function emitMetaMessage(\n  eventBroadcaster: EventEmitter,\n  env: NodeJS.ProcessEnv\n): Promise<void> {\n  const meta: messages.Meta = {\n    protocolVersion: messages.version,\n    implementation: {\n      version,\n      name: 'cucumber-js',\n    },\n    cpu: {\n      name: os.arch(),\n    },\n    os: {\n      name: os.platform(),\n      version: os.release(),\n    },\n    runtime: {\n      name: 'node.js',\n      version: process.versions.node,\n    },\n    ci: detectCiEnvironment(env),\n  }\n  eventBroadcaster.emit('envelope', {\n    meta,\n  })\n}\n\nfunction emitParameterTypes(\n  supportCodeLibrary: ISupportCodeLibrary,\n  eventBroadcaster: EventEmitter,\n  newId: IdGenerator.NewId\n): void {\n  for (const parameterType of supportCodeLibrary.parameterTypeRegistry\n    .parameterTypes) {\n    if (builtinParameterTypes.includes(parameterType.name)) {\n      continue\n    }\n    const envelope: messages.Envelope = {\n      parameterType: {\n        id: newId(),\n        name: parameterType.name,\n        preferForRegularExpressionMatch: parameterType.preferForRegexpMatch,\n        regularExpressions: parameterType.regexpStrings,\n        useForSnippets: parameterType.useForSnippets,\n      },\n    }\n    eventBroadcaster.emit('envelope', envelope)\n  }\n}\n\nfunction emitUndefinedParameterTypes(\n  supportCodeLibrary: ISupportCodeLibrary,\n  eventBroadcaster: EventEmitter\n): void {\n  for (const undefinedParameterType of supportCodeLibrary.undefinedParameterTypes) {\n    const envelope: messages.Envelope = {\n      undefinedParameterType,\n    }\n    eventBroadcaster.emit('envelope', envelope)\n  }\n}\n\nfunction emitStepDefinitions(\n  supportCodeLibrary: ISupportCodeLibrary,\n  eventBroadcaster: EventEmitter\n): void {\n  supportCodeLibrary.stepDefinitions.forEach((stepDefinition) => {\n    const envelope: messages.Envelope = {\n      stepDefinition: {\n        id: stepDefinition.id,\n        pattern: {\n          source: stepDefinition.pattern.toString(),\n          type:\n            typeof stepDefinition.pattern === 'string'\n              ? messages.StepDefinitionPatternType.CUCUMBER_EXPRESSION\n              : messages.StepDefinitionPatternType.REGULAR_EXPRESSION,\n        },\n        sourceReference: {\n          uri: stepDefinition.uri,\n          location: {\n            line: stepDefinition.line,\n          },\n        },\n      },\n    }\n    eventBroadcaster.emit('envelope', envelope)\n  })\n}\n\nfunction emitTestCaseHooks(\n  supportCodeLibrary: ISupportCodeLibrary,\n  eventBroadcaster: EventEmitter\n): void {\n  ;[]\n    .concat(\n      supportCodeLibrary.beforeTestCaseHookDefinitions,\n      supportCodeLibrary.afterTestCaseHookDefinitions\n    )\n    .forEach((testCaseHookDefinition: TestCaseHookDefinition) => {\n      const envelope: messages.Envelope = {\n        hook: {\n          id: testCaseHookDefinition.id,\n          name: testCaseHookDefinition.name,\n          tagExpression: testCaseHookDefinition.tagExpression,\n          sourceReference: {\n            uri: testCaseHookDefinition.uri,\n            location: {\n              line: testCaseHookDefinition.line,\n            },\n          },\n        },\n      }\n      eventBroadcaster.emit('envelope', envelope)\n    })\n}\n\nfunction emitTestRunHooks(\n  supportCodeLibrary: ISupportCodeLibrary,\n  eventBroadcaster: EventEmitter\n): void {\n  ;[]\n    .concat(\n      supportCodeLibrary.beforeTestRunHookDefinitions,\n      supportCodeLibrary.afterTestRunHookDefinitions\n    )\n    .forEach((testRunHookDefinition: TestRunHookDefinition) => {\n      const envelope: messages.Envelope = {\n        hook: {\n          id: testRunHookDefinition.id,\n          sourceReference: {\n            uri: testRunHookDefinition.uri,\n            location: {\n              line: testRunHookDefinition.line,\n            },\n          },\n        },\n      }\n      eventBroadcaster.emit('envelope', envelope)\n    })\n}\n\nexport function emitSupportCodeMessages({\n  eventBroadcaster,\n  supportCodeLibrary,\n  newId,\n}: {\n  eventBroadcaster: EventEmitter\n  supportCodeLibrary: ISupportCodeLibrary\n  newId: IdGenerator.NewId\n}): void {\n  emitParameterTypes(supportCodeLibrary, eventBroadcaster, newId)\n  emitUndefinedParameterTypes(supportCodeLibrary, eventBroadcaster)\n  emitStepDefinitions(supportCodeLibrary, eventBroadcaster)\n  emitTestCaseHooks(supportCodeLibrary, eventBroadcaster)\n  emitTestRunHooks(supportCodeLibrary, eventBroadcaster)\n}\n"],"mappings":"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"}