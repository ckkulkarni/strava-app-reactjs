99b72ef50fe152ad01ca26d4c7882ce8
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _rng = _interopRequireDefault(require("./rng.js"));
var _stringify = require("./stringify.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
let _nodeId;
let _clockseq; // Previous uuid creation time

let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng.default)();
    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.

  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval

  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested

  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }
  return buf || (0, _stringify.unsafeStringify)(b);
}
var _default = v1;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHQiLCJfcm5nIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfc3RyaW5naWZ5Iiwib2JqIiwiX19lc01vZHVsZSIsIl9ub2RlSWQiLCJfY2xvY2tzZXEiLCJfbGFzdE1TZWNzIiwiX2xhc3ROU2VjcyIsInYxIiwib3B0aW9ucyIsImJ1ZiIsIm9mZnNldCIsImkiLCJiIiwiQXJyYXkiLCJub2RlIiwiY2xvY2tzZXEiLCJ1bmRlZmluZWQiLCJzZWVkQnl0ZXMiLCJyYW5kb20iLCJybmciLCJtc2VjcyIsIkRhdGUiLCJub3ciLCJuc2VjcyIsImR0IiwiRXJyb3IiLCJ0bCIsInRtaCIsIm4iLCJ1bnNhZmVTdHJpbmdpZnkiLCJfZGVmYXVsdCJdLCJzb3VyY2VzIjpbInYxLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3JuZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcm5nLmpzXCIpKTtcblxudmFyIF9zdHJpbmdpZnkgPSByZXF1aXJlKFwiLi9zdHJpbmdpZnkuanNcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vICoqYHYxKClgIC0gR2VuZXJhdGUgdGltZS1iYXNlZCBVVUlEKipcbi8vXG4vLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vTGlvc0svVVVJRC5qc1xuLy8gYW5kIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS91dWlkLmh0bWxcbmxldCBfbm9kZUlkO1xuXG5sZXQgX2Nsb2Nrc2VxOyAvLyBQcmV2aW91cyB1dWlkIGNyZWF0aW9uIHRpbWVcblxuXG5sZXQgX2xhc3RNU2VjcyA9IDA7XG5sZXQgX2xhc3ROU2VjcyA9IDA7IC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQgZm9yIEFQSSBkZXRhaWxzXG5cbmZ1bmN0aW9uIHYxKG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGxldCBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuICBjb25zdCBiID0gYnVmIHx8IG5ldyBBcnJheSgxNik7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBsZXQgbm9kZSA9IG9wdGlvbnMubm9kZSB8fCBfbm9kZUlkO1xuICBsZXQgY2xvY2tzZXEgPSBvcHRpb25zLmNsb2Nrc2VxICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsb2Nrc2VxIDogX2Nsb2Nrc2VxOyAvLyBub2RlIGFuZCBjbG9ja3NlcSBuZWVkIHRvIGJlIGluaXRpYWxpemVkIHRvIHJhbmRvbSB2YWx1ZXMgaWYgdGhleSdyZSBub3RcbiAgLy8gc3BlY2lmaWVkLiAgV2UgZG8gdGhpcyBsYXppbHkgdG8gbWluaW1pemUgaXNzdWVzIHJlbGF0ZWQgdG8gaW5zdWZmaWNpZW50XG4gIC8vIHN5c3RlbSBlbnRyb3B5LiAgU2VlICMxODlcblxuICBpZiAobm9kZSA9PSBudWxsIHx8IGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICBjb25zdCBzZWVkQnl0ZXMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgX3JuZy5kZWZhdWx0KSgpO1xuXG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuNSwgY3JlYXRlIGFuZCA0OC1iaXQgbm9kZSBpZCwgKDQ3IHJhbmRvbSBiaXRzICsgbXVsdGljYXN0IGJpdCA9IDEpXG4gICAgICBub2RlID0gX25vZGVJZCA9IFtzZWVkQnl0ZXNbMF0gfCAweDAxLCBzZWVkQnl0ZXNbMV0sIHNlZWRCeXRlc1syXSwgc2VlZEJ5dGVzWzNdLCBzZWVkQnl0ZXNbNF0sIHNlZWRCeXRlc1s1XV07XG4gICAgfVxuXG4gICAgaWYgKGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjIuMiwgcmFuZG9taXplICgxNCBiaXQpIGNsb2Nrc2VxXG4gICAgICBjbG9ja3NlcSA9IF9jbG9ja3NlcSA9IChzZWVkQnl0ZXNbNl0gPDwgOCB8IHNlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG4gICAgfVxuICB9IC8vIFVVSUQgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gIC8vICgxNTgyLTEwLTE1IDAwOjAwKS4gIEpTTnVtYmVycyBhcmVuJ3QgcHJlY2lzZSBlbm91Z2ggZm9yIHRoaXMsIHNvXG4gIC8vIHRpbWUgaXMgaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuXG5cbiAgbGV0IG1zZWNzID0gb3B0aW9ucy5tc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tc2VjcyA6IERhdGUubm93KCk7IC8vIFBlciA0LjIuMS4yLCB1c2UgY291bnQgb2YgdXVpZCdzIGdlbmVyYXRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgY2xvY2tcbiAgLy8gY3ljbGUgdG8gc2ltdWxhdGUgaGlnaGVyIHJlc29sdXRpb24gY2xvY2tcblxuICBsZXQgbnNlY3MgPSBvcHRpb25zLm5zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5zZWNzIDogX2xhc3ROU2VjcyArIDE7IC8vIFRpbWUgc2luY2UgbGFzdCB1dWlkIGNyZWF0aW9uIChpbiBtc2VjcylcblxuICBjb25zdCBkdCA9IG1zZWNzIC0gX2xhc3RNU2VjcyArIChuc2VjcyAtIF9sYXN0TlNlY3MpIC8gMTAwMDA7IC8vIFBlciA0LjIuMS4yLCBCdW1wIGNsb2Nrc2VxIG9uIGNsb2NrIHJlZ3Jlc3Npb25cblxuICBpZiAoZHQgPCAwICYmIG9wdGlvbnMuY2xvY2tzZXEgPT09IHVuZGVmaW5lZCkge1xuICAgIGNsb2Nrc2VxID0gY2xvY2tzZXEgKyAxICYgMHgzZmZmO1xuICB9IC8vIFJlc2V0IG5zZWNzIGlmIGNsb2NrIHJlZ3Jlc3NlcyAobmV3IGNsb2Nrc2VxKSBvciB3ZSd2ZSBtb3ZlZCBvbnRvIGEgbmV3XG4gIC8vIHRpbWUgaW50ZXJ2YWxcblxuXG4gIGlmICgoZHQgPCAwIHx8IG1zZWNzID4gX2xhc3RNU2VjcykgJiYgb3B0aW9ucy5uc2VjcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbnNlY3MgPSAwO1xuICB9IC8vIFBlciA0LjIuMS4yIFRocm93IGVycm9yIGlmIHRvbyBtYW55IHV1aWRzIGFyZSByZXF1ZXN0ZWRcblxuXG4gIGlmIChuc2VjcyA+PSAxMDAwMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInV1aWQudjEoKTogQ2FuJ3QgY3JlYXRlIG1vcmUgdGhhbiAxME0gdXVpZHMvc2VjXCIpO1xuICB9XG5cbiAgX2xhc3RNU2VjcyA9IG1zZWNzO1xuICBfbGFzdE5TZWNzID0gbnNlY3M7XG4gIF9jbG9ja3NlcSA9IGNsb2Nrc2VxOyAvLyBQZXIgNC4xLjQgLSBDb252ZXJ0IGZyb20gdW5peCBlcG9jaCB0byBHcmVnb3JpYW4gZXBvY2hcblxuICBtc2VjcyArPSAxMjIxOTI5MjgwMDAwMDsgLy8gYHRpbWVfbG93YFxuXG4gIGNvbnN0IHRsID0gKChtc2VjcyAmIDB4ZmZmZmZmZikgKiAxMDAwMCArIG5zZWNzKSAlIDB4MTAwMDAwMDAwO1xuICBiW2krK10gPSB0bCA+Pj4gMjQgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gMTYgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsICYgMHhmZjsgLy8gYHRpbWVfbWlkYFxuXG4gIGNvbnN0IHRtaCA9IG1zZWNzIC8gMHgxMDAwMDAwMDAgKiAxMDAwMCAmIDB4ZmZmZmZmZjtcbiAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdG1oICYgMHhmZjsgLy8gYHRpbWVfaGlnaF9hbmRfdmVyc2lvbmBcblxuICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG5cbiAgYltpKytdID0gdG1oID4+PiAxNiAmIDB4ZmY7IC8vIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYCAoUGVyIDQuMi4yIC0gaW5jbHVkZSB2YXJpYW50KVxuXG4gIGJbaSsrXSA9IGNsb2Nrc2VxID4+PiA4IHwgMHg4MDsgLy8gYGNsb2NrX3NlcV9sb3dgXG5cbiAgYltpKytdID0gY2xvY2tzZXEgJiAweGZmOyAvLyBgbm9kZWBcblxuICBmb3IgKGxldCBuID0gMDsgbiA8IDY7ICsrbikge1xuICAgIGJbaSArIG5dID0gbm9kZVtuXTtcbiAgfVxuXG4gIHJldHVybiBidWYgfHwgKDAsIF9zdHJpbmdpZnkudW5zYWZlU3RyaW5naWZ5KShiKTtcbn1cblxudmFyIF9kZWZhdWx0ID0gdjE7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiXSwibWFwcGluZ3MiOiJBQUFBLFlBQVk7O0FBRVpBLE1BQU0sQ0FBQ0MsY0FBYyxDQUFDQyxPQUFPLEVBQUUsWUFBWSxFQUFFO0VBQzNDQyxLQUFLLEVBQUU7QUFDVCxDQUFDLENBQUM7QUFDRkQsT0FBTyxDQUFDRSxPQUFPLEdBQUcsS0FBSyxDQUFDO0FBRXhCLElBQUlDLElBQUksR0FBR0Msc0JBQXNCLENBQUNDLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUV0RCxJQUFJQyxVQUFVLEdBQUdELE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQztBQUUxQyxTQUFTRCxzQkFBc0JBLENBQUNHLEdBQUcsRUFBRTtFQUFFLE9BQU9BLEdBQUcsSUFBSUEsR0FBRyxDQUFDQyxVQUFVLEdBQUdELEdBQUcsR0FBRztJQUFFTCxPQUFPLEVBQUVL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