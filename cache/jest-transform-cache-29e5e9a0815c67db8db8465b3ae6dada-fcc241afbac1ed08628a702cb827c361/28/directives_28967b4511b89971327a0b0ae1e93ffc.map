{"version":3,"names":["Node","require","visit","escapeChars","escapeTagName","tn","replace","ch","Directives","constructor","yaml","tags","docStart","docEnd","Object","assign","defaultYaml","defaultTags","clone","copy","atDocument","res","version","atNextDocument","explicit","add","line","onError","parts","trim","split","name","shift","length","handle","prefix","isValid","test","tagName","source","verbatim","slice","suffix","match","decodeURIComponent","tagString","tag","entries","startsWith","substring","toString","doc","lines","tagEntries","tagNames","isNode","contents","_key","node","keys","some","push","join","exports"],"sources":["directives.js"],"sourcesContent":["'use strict';\n\nvar Node = require('../nodes/Node.js');\nvar visit = require('../visit.js');\n\nconst escapeChars = {\n    '!': '%21',\n    ',': '%2C',\n    '[': '%5B',\n    ']': '%5D',\n    '{': '%7B',\n    '}': '%7D'\n};\nconst escapeTagName = (tn) => tn.replace(/[!,[\\]{}]/g, ch => escapeChars[ch]);\nclass Directives {\n    constructor(yaml, tags) {\n        /**\n         * The directives-end/doc-start marker `---`. If `null`, a marker may still be\n         * included in the document's stringified representation.\n         */\n        this.docStart = null;\n        /** The doc-end marker `...`.  */\n        this.docEnd = false;\n        this.yaml = Object.assign({}, Directives.defaultYaml, yaml);\n        this.tags = Object.assign({}, Directives.defaultTags, tags);\n    }\n    clone() {\n        const copy = new Directives(this.yaml, this.tags);\n        copy.docStart = this.docStart;\n        return copy;\n    }\n    /**\n     * During parsing, get a Directives instance for the current document and\n     * update the stream state according to the current version's spec.\n     */\n    atDocument() {\n        const res = new Directives(this.yaml, this.tags);\n        switch (this.yaml.version) {\n            case '1.1':\n                this.atNextDocument = true;\n                break;\n            case '1.2':\n                this.atNextDocument = false;\n                this.yaml = {\n                    explicit: Directives.defaultYaml.explicit,\n                    version: '1.2'\n                };\n                this.tags = Object.assign({}, Directives.defaultTags);\n                break;\n        }\n        return res;\n    }\n    /**\n     * @param onError - May be called even if the action was successful\n     * @returns `true` on success\n     */\n    add(line, onError) {\n        if (this.atNextDocument) {\n            this.yaml = { explicit: Directives.defaultYaml.explicit, version: '1.1' };\n            this.tags = Object.assign({}, Directives.defaultTags);\n            this.atNextDocument = false;\n        }\n        const parts = line.trim().split(/[ \\t]+/);\n        const name = parts.shift();\n        switch (name) {\n            case '%TAG': {\n                if (parts.length !== 2) {\n                    onError(0, '%TAG directive should contain exactly two parts');\n                    if (parts.length < 2)\n                        return false;\n                }\n                const [handle, prefix] = parts;\n                this.tags[handle] = prefix;\n                return true;\n            }\n            case '%YAML': {\n                this.yaml.explicit = true;\n                if (parts.length !== 1) {\n                    onError(0, '%YAML directive should contain exactly one part');\n                    return false;\n                }\n                const [version] = parts;\n                if (version === '1.1' || version === '1.2') {\n                    this.yaml.version = version;\n                    return true;\n                }\n                else {\n                    const isValid = /^\\d+\\.\\d+$/.test(version);\n                    onError(6, `Unsupported YAML version ${version}`, isValid);\n                    return false;\n                }\n            }\n            default:\n                onError(0, `Unknown directive ${name}`, true);\n                return false;\n        }\n    }\n    /**\n     * Resolves a tag, matching handles to those defined in %TAG directives.\n     *\n     * @returns Resolved tag, which may also be the non-specific tag `'!'` or a\n     *   `'!local'` tag, or `null` if unresolvable.\n     */\n    tagName(source, onError) {\n        if (source === '!')\n            return '!'; // non-specific tag\n        if (source[0] !== '!') {\n            onError(`Not a valid tag: ${source}`);\n            return null;\n        }\n        if (source[1] === '<') {\n            const verbatim = source.slice(2, -1);\n            if (verbatim === '!' || verbatim === '!!') {\n                onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);\n                return null;\n            }\n            if (source[source.length - 1] !== '>')\n                onError('Verbatim tags must end with a >');\n            return verbatim;\n        }\n        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/);\n        if (!suffix)\n            onError(`The ${source} tag has no suffix`);\n        const prefix = this.tags[handle];\n        if (prefix)\n            return prefix + decodeURIComponent(suffix);\n        if (handle === '!')\n            return source; // local tag\n        onError(`Could not resolve tag: ${source}`);\n        return null;\n    }\n    /**\n     * Given a fully resolved tag, returns its printable string form,\n     * taking into account current tag prefixes and defaults.\n     */\n    tagString(tag) {\n        for (const [handle, prefix] of Object.entries(this.tags)) {\n            if (tag.startsWith(prefix))\n                return handle + escapeTagName(tag.substring(prefix.length));\n        }\n        return tag[0] === '!' ? tag : `!<${tag}>`;\n    }\n    toString(doc) {\n        const lines = this.yaml.explicit\n            ? [`%YAML ${this.yaml.version || '1.2'}`]\n            : [];\n        const tagEntries = Object.entries(this.tags);\n        let tagNames;\n        if (doc && tagEntries.length > 0 && Node.isNode(doc.contents)) {\n            const tags = {};\n            visit.visit(doc.contents, (_key, node) => {\n                if (Node.isNode(node) && node.tag)\n                    tags[node.tag] = true;\n            });\n            tagNames = Object.keys(tags);\n        }\n        else\n            tagNames = [];\n        for (const [handle, prefix] of tagEntries) {\n            if (handle === '!!' && prefix === 'tag:yaml.org,2002:')\n                continue;\n            if (!doc || tagNames.some(tn => tn.startsWith(prefix)))\n                lines.push(`%TAG ${handle} ${prefix}`);\n        }\n        return lines.join('\\n');\n    }\n}\nDirectives.defaultYaml = { explicit: false, version: '1.2' };\nDirectives.defaultTags = { '!!': 'tag:yaml.org,2002:' };\n\nexports.Directives = Directives;\n"],"mappings":"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"}