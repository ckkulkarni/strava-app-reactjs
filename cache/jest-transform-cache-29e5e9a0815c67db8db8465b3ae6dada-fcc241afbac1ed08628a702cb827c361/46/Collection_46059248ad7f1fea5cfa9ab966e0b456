c8712cdebd08cbed3298de530c01a56d
'use strict';

var createNode = require('../doc/createNode.js');
var Node = require('./Node.js');
function collectionFromPath(schema, path, value) {
  let v = value;
  for (let i = path.length - 1; i >= 0; --i) {
    const k = path[i];
    if (typeof k === 'number' && Number.isInteger(k) && k >= 0) {
      const a = [];
      a[k] = v;
      v = a;
    } else {
      v = new Map([[k, v]]);
    }
  }
  return createNode.createNode(v, undefined, {
    aliasDuplicateObjects: false,
    keepUndefined: false,
    onAnchor: () => {
      throw new Error('This should not happen, please report a bug.');
    },
    schema,
    sourceObjects: new Map()
  });
}
// Type guard is intentionally a little wrong so as to be more useful,
// as it does not cover untypable empty non-string iterables (e.g. []).
const isEmptyPath = path => path == null || typeof path === 'object' && !!path[Symbol.iterator]().next().done;
class Collection extends Node.NodeBase {
  constructor(type, schema) {
    super(type);
    Object.defineProperty(this, 'schema', {
      value: schema,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  /**
   * Create a copy of this collection.
   *
   * @param schema - If defined, overwrites the original's schema
   */
  clone(schema) {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (schema) copy.schema = schema;
    copy.items = copy.items.map(it => Node.isNode(it) || Node.isPair(it) ? it.clone(schema) : it);
    if (this.range) copy.range = this.range.slice();
    return copy;
  }
  /**
   * Adds a value to the collection. For `!!map` and `!!omap` the value must
   * be a Pair instance or a `{ key, value }` object, which may not have a key
   * that already exists in the map.
   */
  addIn(path, value) {
    if (isEmptyPath(path)) this.add(value);else {
      const [key, ...rest] = path;
      const node = this.get(key, true);
      if (Node.isCollection(node)) node.addIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
  /**
   * Removes a value from the collection.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(path) {
    const [key, ...rest] = path;
    if (rest.length === 0) return this.delete(key);
    const node = this.get(key, true);
    if (Node.isCollection(node)) return node.deleteIn(rest);else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(path, keepScalar) {
    const [key, ...rest] = path;
    const node = this.get(key, true);
    if (rest.length === 0) return !keepScalar && Node.isScalar(node) ? node.value : node;else return Node.isCollection(node) ? node.getIn(rest, keepScalar) : undefined;
  }
  hasAllNullValues(allowScalar) {
    return this.items.every(node => {
      if (!Node.isPair(node)) return false;
      const n = node.value;
      return n == null || allowScalar && Node.isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
    });
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   */
  hasIn(path) {
    const [key, ...rest] = path;
    if (rest.length === 0) return this.has(key);
    const node = this.get(key, true);
    return Node.isCollection(node) ? node.hasIn(rest) : false;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(path, value) {
    const [key, ...rest] = path;
    if (rest.length === 0) {
      this.set(key, value);
    } else {
      const node = this.get(key, true);
      if (Node.isCollection(node)) node.setIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
}
Collection.maxFlowStringSingleLineLength = 60;
exports.Collection = Collection;
exports.collectionFromPath = collectionFromPath;
exports.isEmptyPath = isEmptyPath;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJjcmVhdGVOb2RlIiwicmVxdWlyZSIsIk5vZGUiLCJjb2xsZWN0aW9uRnJvbVBhdGgiLCJzY2hlbWEiLCJwYXRoIiwidmFsdWUiLCJ2IiwiaSIsImxlbmd0aCIsImsiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJhIiwiTWFwIiwidW5kZWZpbmVkIiwiYWxpYXNEdXBsaWNhdGVPYmplY3RzIiwia2VlcFVuZGVmaW5lZCIsIm9uQW5jaG9yIiwiRXJyb3IiLCJzb3VyY2VPYmplY3RzIiwiaXNFbXB0eVBhdGgiLCJTeW1ib2wiLCJpdGVyYXRvciIsIm5leHQiLCJkb25lIiwiQ29sbGVjdGlvbiIsIk5vZGVCYXNlIiwiY29uc3RydWN0b3IiLCJ0eXBlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJjbG9uZSIsImNvcHkiLCJjcmVhdGUiLCJnZXRQcm90b3R5cGVPZiIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJpdGVtcyIsIm1hcCIsIml0IiwiaXNOb2RlIiwiaXNQYWlyIiwicmFuZ2UiLCJzbGljZSIsImFkZEluIiwiYWRkIiwia2V5IiwicmVzdCIsIm5vZGUiLCJnZXQiLCJpc0NvbGxlY3Rpb24iLCJzZXQiLCJkZWxldGVJbiIsImRlbGV0ZSIsImdldEluIiwia2VlcFNjYWxhciIsImlzU2NhbGFyIiwiaGFzQWxsTnVsbFZhbHVlcyIsImFsbG93U2NhbGFyIiwiZXZlcnkiLCJuIiwiY29tbWVudEJlZm9yZSIsImNvbW1lbnQiLCJ0YWciLCJoYXNJbiIsImhhcyIsInNldEluIiwibWF4Rmxvd1N0cmluZ1NpbmdsZUxpbmVMZW5ndGgiLCJleHBvcnRzIl0sInNvdXJjZXMiOlsiQ29sbGVjdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBjcmVhdGVOb2RlID0gcmVxdWlyZSgnLi4vZG9jL2NyZWF0ZU5vZGUuanMnKTtcbnZhciBOb2RlID0gcmVxdWlyZSgnLi9Ob2RlLmpzJyk7XG5cbmZ1bmN0aW9uIGNvbGxlY3Rpb25Gcm9tUGF0aChzY2hlbWEsIHBhdGgsIHZhbHVlKSB7XG4gICAgbGV0IHYgPSB2YWx1ZTtcbiAgICBmb3IgKGxldCBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBjb25zdCBrID0gcGF0aFtpXTtcbiAgICAgICAgaWYgKHR5cGVvZiBrID09PSAnbnVtYmVyJyAmJiBOdW1iZXIuaXNJbnRlZ2VyKGspICYmIGsgPj0gMCkge1xuICAgICAgICAgICAgY29uc3QgYSA9IFtdO1xuICAgICAgICAgICAgYVtrXSA9IHY7XG4gICAgICAgICAgICB2ID0gYTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHYgPSBuZXcgTWFwKFtbaywgdl1dKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlTm9kZS5jcmVhdGVOb2RlKHYsIHVuZGVmaW5lZCwge1xuICAgICAgICBhbGlhc0R1cGxpY2F0ZU9iamVjdHM6IGZhbHNlLFxuICAgICAgICBrZWVwVW5kZWZpbmVkOiBmYWxzZSxcbiAgICAgICAgb25BbmNob3I6ICgpID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBzaG91bGQgbm90IGhhcHBlbiwgcGxlYXNlIHJlcG9ydCBhIGJ1Zy4nKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICBzb3VyY2VPYmplY3RzOiBuZXcgTWFwKClcbiAgICB9KTtcbn1cbi8vIFR5cGUgZ3VhcmQgaXMgaW50ZW50aW9uYWxseSBhIGxpdHRsZSB3cm9uZyBzbyBhcyB0byBiZSBtb3JlIHVzZWZ1bCxcbi8vIGFzIGl0IGRvZXMgbm90IGNvdmVyIHVudHlwYWJsZSBlbXB0eSBub24tc3RyaW5nIGl0ZXJhYmxlcyAoZS5nLiBbXSkuXG5jb25zdCBpc0VtcHR5UGF0aCA9IChwYXRoKSA9PiBwYXRoID09IG51bGwgfHxcbiAgICAodHlwZW9mIHBhdGggPT09ICdvYmplY3QnICYmICEhcGF0aFtTeW1ib2wuaXRlcmF0b3JdKCkubmV4dCgpLmRvbmUpO1xuY2xhc3MgQ29sbGVjdGlvbiBleHRlbmRzIE5vZGUuTm9kZUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIHNjaGVtYSkge1xuICAgICAgICBzdXBlcih0eXBlKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzY2hlbWEnLCB7XG4gICAgICAgICAgICB2YWx1ZTogc2NoZW1hLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgY29weSBvZiB0aGlzIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2NoZW1hIC0gSWYgZGVmaW5lZCwgb3ZlcndyaXRlcyB0aGUgb3JpZ2luYWwncyBzY2hlbWFcbiAgICAgKi9cbiAgICBjbG9uZShzY2hlbWEpIHtcbiAgICAgICAgY29uc3QgY29weSA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0aGlzKSk7XG4gICAgICAgIGlmIChzY2hlbWEpXG4gICAgICAgICAgICBjb3B5LnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgY29weS5pdGVtcyA9IGNvcHkuaXRlbXMubWFwKGl0ID0+IE5vZGUuaXNOb2RlKGl0KSB8fCBOb2RlLmlzUGFpcihpdCkgPyBpdC5jbG9uZShzY2hlbWEpIDogaXQpO1xuICAgICAgICBpZiAodGhpcy5yYW5nZSlcbiAgICAgICAgICAgIGNvcHkucmFuZ2UgPSB0aGlzLnJhbmdlLnNsaWNlKCk7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgdmFsdWUgdG8gdGhlIGNvbGxlY3Rpb24uIEZvciBgISFtYXBgIGFuZCBgISFvbWFwYCB0aGUgdmFsdWUgbXVzdFxuICAgICAqIGJlIGEgUGFpciBpbnN0YW5jZSBvciBhIGB7IGtleSwgdmFsdWUgfWAgb2JqZWN0LCB3aGljaCBtYXkgbm90IGhhdmUgYSBrZXlcbiAgICAgKiB0aGF0IGFscmVhZHkgZXhpc3RzIGluIHRoZSBtYXAuXG4gICAgICovXG4gICAgYWRkSW4ocGF0aCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzRW1wdHlQYXRoKHBhdGgpKVxuICAgICAgICAgICAgdGhpcy5hZGQodmFsdWUpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IFtrZXksIC4uLnJlc3RdID0gcGF0aDtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldChrZXksIHRydWUpO1xuICAgICAgICAgICAgaWYgKE5vZGUuaXNDb2xsZWN0aW9uKG5vZGUpKVxuICAgICAgICAgICAgICAgIG5vZGUuYWRkSW4ocmVzdCwgdmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAobm9kZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuc2NoZW1hKVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgY29sbGVjdGlvbkZyb21QYXRoKHRoaXMuc2NoZW1hLCByZXN0LCB2YWx1ZSkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgWUFNTCBjb2xsZWN0aW9uIGF0ICR7a2V5fS4gUmVtYWluaW5nIHBhdGg6ICR7cmVzdH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgdmFsdWUgZnJvbSB0aGUgY29sbGVjdGlvbi5cbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGl0ZW0gd2FzIGZvdW5kIGFuZCByZW1vdmVkLlxuICAgICAqL1xuICAgIGRlbGV0ZUluKHBhdGgpIHtcbiAgICAgICAgY29uc3QgW2tleSwgLi4ucmVzdF0gPSBwYXRoO1xuICAgICAgICBpZiAocmVzdC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWxldGUoa2V5KTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0KGtleSwgdHJ1ZSk7XG4gICAgICAgIGlmIChOb2RlLmlzQ29sbGVjdGlvbihub2RlKSlcbiAgICAgICAgICAgIHJldHVybiBub2RlLmRlbGV0ZUluKHJlc3QpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIFlBTUwgY29sbGVjdGlvbiBhdCAke2tleX0uIFJlbWFpbmluZyBwYXRoOiAke3Jlc3R9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaXRlbSBhdCBga2V5YCwgb3IgYHVuZGVmaW5lZGAgaWYgbm90IGZvdW5kLiBCeSBkZWZhdWx0IHVud3JhcHNcbiAgICAgKiBzY2FsYXIgdmFsdWVzIGZyb20gdGhlaXIgc3Vycm91bmRpbmcgbm9kZTsgdG8gZGlzYWJsZSBzZXQgYGtlZXBTY2FsYXJgIHRvXG4gICAgICogYHRydWVgIChjb2xsZWN0aW9ucyBhcmUgYWx3YXlzIHJldHVybmVkIGludGFjdCkuXG4gICAgICovXG4gICAgZ2V0SW4ocGF0aCwga2VlcFNjYWxhcikge1xuICAgICAgICBjb25zdCBba2V5LCAuLi5yZXN0XSA9IHBhdGg7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldChrZXksIHRydWUpO1xuICAgICAgICBpZiAocmVzdC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gIWtlZXBTY2FsYXIgJiYgTm9kZS5pc1NjYWxhcihub2RlKSA/IG5vZGUudmFsdWUgOiBub2RlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gTm9kZS5pc0NvbGxlY3Rpb24obm9kZSkgPyBub2RlLmdldEluKHJlc3QsIGtlZXBTY2FsYXIpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBoYXNBbGxOdWxsVmFsdWVzKGFsbG93U2NhbGFyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmV2ZXJ5KG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKCFOb2RlLmlzUGFpcihub2RlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBuID0gbm9kZS52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiAobiA9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgKGFsbG93U2NhbGFyICYmXG4gICAgICAgICAgICAgICAgICAgIE5vZGUuaXNTY2FsYXIobikgJiZcbiAgICAgICAgICAgICAgICAgICAgbi52YWx1ZSA9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICFuLmNvbW1lbnRCZWZvcmUgJiZcbiAgICAgICAgICAgICAgICAgICAgIW4uY29tbWVudCAmJlxuICAgICAgICAgICAgICAgICAgICAhbi50YWcpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgY29sbGVjdGlvbiBpbmNsdWRlcyBhIHZhbHVlIHdpdGggdGhlIGtleSBga2V5YC5cbiAgICAgKi9cbiAgICBoYXNJbihwYXRoKSB7XG4gICAgICAgIGNvbnN0IFtrZXksIC4uLnJlc3RdID0gcGF0aDtcbiAgICAgICAgaWYgKHJlc3QubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzKGtleSk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldChrZXksIHRydWUpO1xuICAgICAgICByZXR1cm4gTm9kZS5pc0NvbGxlY3Rpb24obm9kZSkgPyBub2RlLmhhc0luKHJlc3QpIDogZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSB2YWx1ZSBpbiB0aGlzIGNvbGxlY3Rpb24uIEZvciBgISFzZXRgLCBgdmFsdWVgIG5lZWRzIHRvIGJlIGFcbiAgICAgKiBib29sZWFuIHRvIGFkZC9yZW1vdmUgdGhlIGl0ZW0gZnJvbSB0aGUgc2V0LlxuICAgICAqL1xuICAgIHNldEluKHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IFtrZXksIC4uLnJlc3RdID0gcGF0aDtcbiAgICAgICAgaWYgKHJlc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldChrZXksIHRydWUpO1xuICAgICAgICAgICAgaWYgKE5vZGUuaXNDb2xsZWN0aW9uKG5vZGUpKVxuICAgICAgICAgICAgICAgIG5vZGUuc2V0SW4ocmVzdCwgdmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAobm9kZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuc2NoZW1hKVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgY29sbGVjdGlvbkZyb21QYXRoKHRoaXMuc2NoZW1hLCByZXN0LCB2YWx1ZSkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgWUFNTCBjb2xsZWN0aW9uIGF0ICR7a2V5fS4gUmVtYWluaW5nIHBhdGg6ICR7cmVzdH1gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbkNvbGxlY3Rpb24ubWF4Rmxvd1N0cmluZ1NpbmdsZUxpbmVMZW5ndGggPSA2MDtcblxuZXhwb3J0cy5Db2xsZWN0aW9uID0gQ29sbGVjdGlvbjtcbmV4cG9ydHMuY29sbGVjdGlvbkZyb21QYXRoID0gY29sbGVjdGlvbkZyb21QYXRoO1xuZXhwb3J0cy5pc0VtcHR5UGF0aCA9IGlzRW1wdHlQYXRoO1xuIl0sIm1hcHBpbmdzIjoiQUFBQSxZQUFZOztBQUVaLElBQUlBLFVBQVUsR0FBR0MsT0FBTyxDQUFDLHNCQUFzQixDQUFDO0FBQ2hELElBQUlDLElBQUksR0FBR0QsT0FBTyxDQUFDLFdBQVcsQ0FBQztBQUUvQixTQUFTRSxrQkFBa0JBLENBQUNDLE1BQU0s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