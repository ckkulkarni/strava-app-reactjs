fd8a08ea974f18c05b0cda24a7d2e8bf
"use strict";

/**
 * Various utility functions.
 * @namespace
 */
var util = module.exports = require("./util/minimal");
var roots = require("./roots");
var Type,
  // cyclic
  Enum;
util.codegen = require("@protobufjs/codegen");
util.fetch = require("@protobufjs/fetch");
util.path = require("@protobufjs/path");

/**
 * Node's fs module if available.
 * @type {Object.<string,*>}
 */
util.fs = util.inquire("fs");

/**
 * Converts an object's values to an array.
 * @param {Object.<string,*>} object Object to convert
 * @returns {Array.<*>} Converted array
 */
util.toArray = function toArray(object) {
  if (object) {
    var keys = Object.keys(object),
      array = new Array(keys.length),
      index = 0;
    while (index < keys.length) array[index] = object[keys[index++]];
    return array;
  }
  return [];
};

/**
 * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.
 * @param {Array.<*>} array Array to convert
 * @returns {Object.<string,*>} Converted object
 */
util.toObject = function toObject(array) {
  var object = {},
    index = 0;
  while (index < array.length) {
    var key = array[index++],
      val = array[index++];
    if (val !== undefined) object[key] = val;
  }
  return object;
};
var safePropBackslashRe = /\\/g,
  safePropQuoteRe = /"/g;

/**
 * Tests whether the specified name is a reserved word in JS.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
util.isReserved = function isReserved(name) {
  return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);
};

/**
 * Returns a safe property accessor for the specified property name.
 * @param {string} prop Property name
 * @returns {string} Safe accessor
 */
util.safeProp = function safeProp(prop) {
  if (!/^[$\w_]+$/.test(prop) || util.isReserved(prop)) return "[\"" + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, "\\\"") + "\"]";
  return "." + prop;
};

/**
 * Converts the first character of a string to upper case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.ucFirst = function ucFirst(str) {
  return str.charAt(0).toUpperCase() + str.substring(1);
};
var camelCaseRe = /_([a-z])/g;

/**
 * Converts a string to camel case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.camelCase = function camelCase(str) {
  return str.substring(0, 1) + str.substring(1).replace(camelCaseRe, function ($0, $1) {
    return $1.toUpperCase();
  });
};

/**
 * Compares reflected fields by id.
 * @param {Field} a First field
 * @param {Field} b Second field
 * @returns {number} Comparison value
 */
util.compareFieldsById = function compareFieldsById(a, b) {
  return a.id - b.id;
};

/**
 * Decorator helper for types (TypeScript).
 * @param {Constructor<T>} ctor Constructor function
 * @param {string} [typeName] Type name, defaults to the constructor's name
 * @returns {Type} Reflected type
 * @template T extends Message<T>
 * @property {Root} root Decorators root
 */
util.decorateType = function decorateType(ctor, typeName) {
  /* istanbul ignore if */
  if (ctor.$type) {
    if (typeName && ctor.$type.name !== typeName) {
      util.decorateRoot.remove(ctor.$type);
      ctor.$type.name = typeName;
      util.decorateRoot.add(ctor.$type);
    }
    return ctor.$type;
  }

  /* istanbul ignore next */
  if (!Type) Type = require("./type");
  var type = new Type(typeName || ctor.name);
  util.decorateRoot.add(type);
  type.ctor = ctor; // sets up .encode, .decode etc.
  Object.defineProperty(ctor, "$type", {
    value: type,
    enumerable: false
  });
  Object.defineProperty(ctor.prototype, "$type", {
    value: type,
    enumerable: false
  });
  return type;
};
var decorateEnumIndex = 0;

/**
 * Decorator helper for enums (TypeScript).
 * @param {Object} object Enum object
 * @returns {Enum} Reflected enum
 */
util.decorateEnum = function decorateEnum(object) {
  /* istanbul ignore if */
  if (object.$type) return object.$type;

  /* istanbul ignore next */
  if (!Enum) Enum = require("./enum");
  var enm = new Enum("Enum" + decorateEnumIndex++, object);
  util.decorateRoot.add(enm);
  Object.defineProperty(object, "$type", {
    value: enm,
    enumerable: false
  });
  return enm;
};

/**
 * Sets the value of a property by property path. If a value already exists, it is turned to an array
 * @param {Object.<string,*>} dst Destination object
 * @param {string} path dot '.' delimited path of the property to set
 * @param {Object} value the value to set
 * @returns {Object.<string,*>} Destination object
 */
util.setProperty = function setProperty(dst, path, value) {
  function setProp(dst, path, value) {
    var part = path.shift();
    if (part === "__proto__") {
      return dst;
    }
    if (path.length > 0) {
      dst[part] = setProp(dst[part] || {}, path, value);
    } else {
      var prevValue = dst[part];
      if (prevValue) value = [].concat(prevValue).concat(value);
      dst[part] = value;
    }
    return dst;
  }
  if (typeof dst !== "object") throw TypeError("dst must be an object");
  if (!path) throw TypeError("path must be specified");
  path = path.split(".");
  return setProp(dst, path, value);
};

/**
 * Decorator root (TypeScript).
 * @name util.decorateRoot
 * @type {Root}
 * @readonly
 */
Object.defineProperty(util, "decorateRoot", {
  get: function () {
    return roots["decorated"] || (roots["decorated"] = new (require("./root"))());
  }
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJ1dGlsIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiLCJyb290cyIsIlR5cGUiLCJFbnVtIiwiY29kZWdlbiIsImZldGNoIiwicGF0aCIsImZzIiwiaW5xdWlyZSIsInRvQXJyYXkiLCJvYmplY3QiLCJrZXlzIiwiT2JqZWN0IiwiYXJyYXkiLCJBcnJheSIsImxlbmd0aCIsImluZGV4IiwidG9PYmplY3QiLCJrZXkiLCJ2YWwiLCJ1bmRlZmluZWQiLCJzYWZlUHJvcEJhY2tzbGFzaFJlIiwic2FmZVByb3BRdW90ZVJlIiwiaXNSZXNlcnZlZCIsIm5hbWUiLCJ0ZXN0Iiwic2FmZVByb3AiLCJwcm9wIiwicmVwbGFjZSIsInVjRmlyc3QiLCJzdHIiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInN1YnN0cmluZyIsImNhbWVsQ2FzZVJlIiwiY2FtZWxDYXNlIiwiJDAiLCIkMSIsImNvbXBhcmVGaWVsZHNCeUlkIiwiYSIsImIiLCJpZCIsImRlY29yYXRlVHlwZSIsImN0b3IiLCJ0eXBlTmFtZSIsIiR0eXBlIiwiZGVjb3JhdGVSb290IiwicmVtb3ZlIiwiYWRkIiwidHlwZSIsImRlZmluZVByb3BlcnR5IiwidmFsdWUiLCJlbnVtZXJhYmxlIiwicHJvdG90eXBlIiwiZGVjb3JhdGVFbnVtSW5kZXgiLCJkZWNvcmF0ZUVudW0iLCJlbm0iLCJzZXRQcm9wZXJ0eSIsImRzdCIsInNldFByb3AiLCJwYXJ0Iiwic2hpZnQiLCJwcmV2VmFsdWUiLCJjb25jYXQiLCJUeXBlRXJyb3IiLCJzcGxpdCIsImdldCJdLCJzb3VyY2VzIjpbInV0aWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucy5cbiAqIEBuYW1lc3BhY2VcbiAqL1xudmFyIHV0aWwgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcblxudmFyIHJvb3RzID0gcmVxdWlyZShcIi4vcm9vdHNcIik7XG5cbnZhciBUeXBlLCAvLyBjeWNsaWNcbiAgICBFbnVtO1xuXG51dGlsLmNvZGVnZW4gPSByZXF1aXJlKFwiQHByb3RvYnVmanMvY29kZWdlblwiKTtcbnV0aWwuZmV0Y2ggICA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9mZXRjaFwiKTtcbnV0aWwucGF0aCAgICA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9wYXRoXCIpO1xuXG4vKipcbiAqIE5vZGUncyBmcyBtb2R1bGUgaWYgYXZhaWxhYmxlLlxuICogQHR5cGUge09iamVjdC48c3RyaW5nLCo+fVxuICovXG51dGlsLmZzID0gdXRpbC5pbnF1aXJlKFwiZnNcIik7XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0J3MgdmFsdWVzIHRvIGFuIGFycmF5LlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IE9iamVjdCB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7QXJyYXkuPCo+fSBDb252ZXJ0ZWQgYXJyYXlcbiAqL1xudXRpbC50b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheShvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0KSB7XG4gICAgICAgIHZhciBrZXlzICA9IE9iamVjdC5rZXlzKG9iamVjdCksXG4gICAgICAgICAgICBhcnJheSA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCksXG4gICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGtleXMubGVuZ3RoKVxuICAgICAgICAgICAgYXJyYXlbaW5kZXhdID0gb2JqZWN0W2tleXNbaW5kZXgrK11dO1xuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gYXJyYXkgb2Yga2V5cyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSB0aGVpciByZXNwZWN0aXZlIHZhbHVlIHRvIGFuIG9iamVjdCwgb21pdHRpbmcgdW5kZWZpbmVkIHZhbHVlcy5cbiAqIEBwYXJhbSB7QXJyYXkuPCo+fSBhcnJheSBBcnJheSB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IENvbnZlcnRlZCBvYmplY3RcbiAqL1xudXRpbC50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KGFycmF5KSB7XG4gICAgdmFyIG9iamVjdCA9IHt9LFxuICAgICAgICBpbmRleCAgPSAwO1xuICAgIHdoaWxlIChpbmRleCA8IGFycmF5Lmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gYXJyYXlbaW5kZXgrK10sXG4gICAgICAgICAgICB2YWwgPSBhcnJheVtpbmRleCsrXTtcbiAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgb2JqZWN0W2tleV0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG59O1xuXG52YXIgc2FmZVByb3BCYWNrc2xhc2hSZSA9IC9cXFxcL2csXG4gICAgc2FmZVByb3BRdW90ZVJlICAgICA9IC9cIi9nO1xuXG4vKipcbiAqIFRlc3RzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBuYW1lIGlzIGEgcmVzZXJ2ZWQgd29yZCBpbiBKUy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiByZXNlcnZlZCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAqL1xudXRpbC5pc1Jlc2VydmVkID0gZnVuY3Rpb24gaXNSZXNlcnZlZChuYW1lKSB7XG4gICAgcmV0dXJuIC9eKD86ZG98aWZ8aW58Zm9yfGxldHxuZXd8dHJ5fHZhcnxjYXNlfGVsc2V8ZW51bXxldmFsfGZhbHNlfG51bGx8dGhpc3x0cnVlfHZvaWR8d2l0aHxicmVha3xjYXRjaHxjbGFzc3xjb25zdHxzdXBlcnx0aHJvd3x3aGlsZXx5aWVsZHxkZWxldGV8ZXhwb3J0fGltcG9ydHxwdWJsaWN8cmV0dXJufHN0YXRpY3xzd2l0Y2h8dHlwZW9mfGRlZmF1bHR8ZXh0ZW5kc3xmaW5hbGx5fHBhY2thZ2V8cHJpdmF0ZXxjb250aW51ZXxkZWJ1Z2dlcnxmdW5jdGlvbnxhcmd1bWVudHN8aW50ZXJmYWNlfHByb3RlY3RlZHxpbXBsZW1lbnRzfGluc3RhbmNlb2YpJC8udGVzdChuYW1lKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHNhZmUgcHJvcGVydHkgYWNjZXNzb3IgZm9yIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IG5hbWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFNhZmUgYWNjZXNzb3JcbiAqL1xudXRpbC5zYWZlUHJvcCA9IGZ1bmN0aW9uIHNhZmVQcm9wKHByb3ApIHtcbiAgICBpZiAoIS9eWyRcXHdfXSskLy50ZXN0KHByb3ApIHx8IHV0aWwuaXNSZXNlcnZlZChwcm9wKSlcbiAgICAgICAgcmV0dXJuIFwiW1xcXCJcIiArIHByb3AucmVwbGFjZShzYWZlUHJvcEJhY2tzbGFzaFJlLCBcIlxcXFxcXFxcXCIpLnJlcGxhY2Uoc2FmZVByb3BRdW90ZVJlLCBcIlxcXFxcXFwiXCIpICsgXCJcXFwiXVwiO1xuICAgIHJldHVybiBcIi5cIiArIHByb3A7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBzdHJpbmcgdG8gdXBwZXIgY2FzZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IENvbnZlcnRlZCBzdHJpbmdcbiAqL1xudXRpbC51Y0ZpcnN0ID0gZnVuY3Rpb24gdWNGaXJzdChzdHIpIHtcbiAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKTtcbn07XG5cbnZhciBjYW1lbENhc2VSZSA9IC9fKFthLXpdKS9nO1xuXG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIHRvIGNhbWVsIGNhc2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBDb252ZXJ0ZWQgc3RyaW5nXG4gKi9cbnV0aWwuY2FtZWxDYXNlID0gZnVuY3Rpb24gY2FtZWxDYXNlKHN0cikge1xuICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIDEpXG4gICAgICAgICArIHN0ci5zdWJzdHJpbmcoMSlcbiAgICAgICAgICAgICAgIC5yZXBsYWNlKGNhbWVsQ2FzZVJlLCBmdW5jdGlvbigkMCwgJDEpIHsgcmV0dXJuICQxLnRvVXBwZXJDYXNlKCk7IH0pO1xufTtcblxuLyoqXG4gKiBDb21wYXJlcyByZWZsZWN0ZWQgZmllbGRzIGJ5IGlkLlxuICogQHBhcmFtIHtGaWVsZH0gYSBGaXJzdCBmaWVsZFxuICogQHBhcmFtIHtGaWVsZH0gYiBTZWNvbmQgZmllbGRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IENvbXBhcmlzb24gdmFsdWVcbiAqL1xudXRpbC5jb21wYXJlRmllbGRzQnlJZCA9IGZ1bmN0aW9uIGNvbXBhcmVGaWVsZHNCeUlkKGEsIGIpIHtcbiAgICByZXR1cm4gYS5pZCAtIGIuaWQ7XG59O1xuXG4vKipcbiAqIERlY29yYXRvciBoZWxwZXIgZm9yIHR5cGVzIChUeXBlU2NyaXB0KS5cbiAqIEBwYXJhbSB7Q29uc3RydWN0b3I8VD59IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZU5hbWVdIFR5cGUgbmFtZSwgZGVmYXVsdHMgdG8gdGhlIGNvbnN0cnVjdG9yJ3MgbmFtZVxuICogQHJldHVybnMge1R5cGV9IFJlZmxlY3RlZCB0eXBlXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cbiAqIEBwcm9wZXJ0eSB7Um9vdH0gcm9vdCBEZWNvcmF0b3JzIHJvb3RcbiAqL1xudXRpbC5kZWNvcmF0ZVR5cGUgPSBmdW5jdGlvbiBkZWNvcmF0ZVR5cGUoY3RvciwgdHlwZU5hbWUpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChjdG9yLiR0eXBlKSB7XG4gICAgICAgIGlmICh0eXBlTmFtZSAmJiBjdG9yLiR0eXBlLm5hbWUgIT09IHR5cGVOYW1lKSB7XG4gICAgICAgICAgICB1dGlsLmRlY29yYXRlUm9vdC5yZW1vdmUoY3Rvci4kdHlwZSk7XG4gICAgICAgICAgICBjdG9yLiR0eXBlLm5hbWUgPSB0eXBlTmFtZTtcbiAgICAgICAgICAgIHV0aWwuZGVjb3JhdGVSb290LmFkZChjdG9yLiR0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3Rvci4kdHlwZTtcbiAgICB9XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICghVHlwZSlcbiAgICAgICAgVHlwZSA9IHJlcXVpcmUoXCIuL3R5cGVcIik7XG5cbiAgICB2YXIgdHlwZSA9IG5ldyBUeXBlKHR5cGVOYW1lIHx8IGN0b3IubmFtZSk7XG4gICAgdXRpbC5kZWNvcmF0ZVJvb3QuYWRkKHR5cGUpO1xuICAgIHR5cGUuY3RvciA9IGN0b3I7IC8vIHNldHMgdXAgLmVuY29kZSwgLmRlY29kZSBldGMuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0b3IsIFwiJHR5cGVcIiwgeyB2YWx1ZTogdHlwZSwgZW51bWVyYWJsZTogZmFsc2UgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0b3IucHJvdG90eXBlLCBcIiR0eXBlXCIsIHsgdmFsdWU6IHR5cGUsIGVudW1lcmFibGU6IGZhbHNlIH0pO1xuICAgIHJldHVybiB0eXBlO1xufTtcblxudmFyIGRlY29yYXRlRW51bUluZGV4ID0gMDtcblxuLyoqXG4gKiBEZWNvcmF0b3IgaGVscGVyIGZvciBlbnVtcyAoVHlwZVNjcmlwdCkuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IEVudW0gb2JqZWN0XG4gKiBAcmV0dXJucyB7RW51bX0gUmVmbGVjdGVkIGVudW1cbiAqL1xudXRpbC5kZWNvcmF0ZUVudW0gPSBmdW5jdGlvbiBkZWNvcmF0ZUVudW0ob2JqZWN0KSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAob2JqZWN0LiR0eXBlKVxuICAgICAgICByZXR1cm4gb2JqZWN0LiR0eXBlO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAoIUVudW0pXG4gICAgICAgIEVudW0gPSByZXF1aXJlKFwiLi9lbnVtXCIpO1xuXG4gICAgdmFyIGVubSA9IG5ldyBFbnVtKFwiRW51bVwiICsgZGVjb3JhdGVFbnVtSW5kZXgrKywgb2JqZWN0KTtcbiAgICB1dGlsLmRlY29yYXRlUm9vdC5hZGQoZW5tKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBcIiR0eXBlXCIsIHsgdmFsdWU6IGVubSwgZW51bWVyYWJsZTogZmFsc2UgfSk7XG4gICAgcmV0dXJuIGVubTtcbn07XG5cblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IGJ5IHByb3BlcnR5IHBhdGguIElmIGEgdmFsdWUgYWxyZWFkeSBleGlzdHMsIGl0IGlzIHR1cm5lZCB0byBhbiBhcnJheVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gZHN0IERlc3RpbmF0aW9uIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggZG90ICcuJyBkZWxpbWl0ZWQgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0XG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgdGhlIHZhbHVlIHRvIHNldFxuICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBEZXN0aW5hdGlvbiBvYmplY3RcbiAqL1xudXRpbC5zZXRQcm9wZXJ0eSA9IGZ1bmN0aW9uIHNldFByb3BlcnR5KGRzdCwgcGF0aCwgdmFsdWUpIHtcbiAgICBmdW5jdGlvbiBzZXRQcm9wKGRzdCwgcGF0aCwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHBhcnQgPSBwYXRoLnNoaWZ0KCk7XG4gICAgICAgIGlmIChwYXJ0ID09PSBcIl9fcHJvdG9fX1wiKSB7XG4gICAgICAgICAgcmV0dXJuIGRzdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBkc3RbcGFydF0gPSBzZXRQcm9wKGRzdFtwYXJ0XSB8fCB7fSwgcGF0aCwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHByZXZWYWx1ZSA9IGRzdFtwYXJ0XTtcbiAgICAgICAgICAgIGlmIChwcmV2VmFsdWUpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBbXS5jb25jYXQocHJldlZhbHVlKS5jb25jYXQodmFsdWUpO1xuICAgICAgICAgICAgZHN0W3BhcnRdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRzdDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRzdCAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiZHN0IG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICAgIGlmICghcGF0aClcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicGF0aCBtdXN0IGJlIHNwZWNpZmllZFwiKTtcblxuICAgIHBhdGggPSBwYXRoLnNwbGl0KFwiLlwiKTtcbiAgICByZXR1cm4gc2V0UHJvcChkc3QsIHBhdGgsIHZhbHVlKTtcbn07XG5cbi8qKlxuICogRGVjb3JhdG9yIHJvb3QgKFR5cGVTY3JpcHQpLlxuICogQG5hbWUgdXRpbC5kZWNvcmF0ZVJvb3RcbiAqIEB0eXBlIHtSb290fVxuICogQHJlYWRvbmx5XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh1dGlsLCBcImRlY29yYXRlUm9vdFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJvb3RzW1wiZGVjb3JhdGVkXCJdIHx8IChyb290c1tcImRlY29yYXRlZFwiXSA9IG5ldyAocmVxdWlyZShcIi4vcm9vdFwiKSkoKSk7XG4gICAgfVxufSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJQSxJ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