{"version":3,"names":["keyword_type_1","require","gherkin_document_parser_1","pickle_parser_1","messages","__importStar","value_checker_1","messages_1","parseStep","isBeforeHook","gherkinStepMap","keyword","keywordType","pickleStep","pickleUri","snippetBuilder","supportCodeLibrary","testStep","testStepResult","testStepAttachments","out","attachments","doesHaveValue","pickleStepId","result","hookId","hookDefinition","beforeTestCaseHookDefinitions","find","x","id","afterTestCaseHookDefinitions","actionLocation","uri","line","name","stepDefinitionIds","length","stepDefinition","stepDefinitions","sourceLocation","astNodeIds","location","text","argument","status","TestStepResultStatus","UNDEFINED","snippet","build","parseTestCaseAttempt","testCaseAttempt","testCase","pickle","gherkinDocument","getGherkinStepMap","gherkinScenarioLocationMap","getGherkinScenarioLocationMap","pickleStepMap","getPickleStepMap","relativePickleUri","parsedTestCase","attempt","worstTestStepResult","parsedTestSteps","previousKeywordType","KeywordType","Precondition","testSteps","forEach","stepResults","TestStepResult","getStepKeyword","getStepKeywordType","language","feature","parsedStep","valueOrDefault","stepAttachments","push","exports"],"sources":["../../../src/formatter/helpers/test_case_attempt_parser.ts"],"sourcesContent":["import { getStepKeywordType, KeywordType } from './keyword_type'\nimport {\n  getGherkinScenarioLocationMap,\n  getGherkinStepMap,\n} from './gherkin_document_parser'\nimport { getPickleStepMap, getStepKeyword } from './pickle_parser'\nimport * as messages from '@cucumber/messages'\nimport { ITestCaseAttempt } from './event_data_collector'\nimport StepDefinitionSnippetBuilder from '../step_definition_snippet_builder'\nimport { ISupportCodeLibrary } from '../../support_code_library_builder/types'\nimport { doesHaveValue, valueOrDefault } from '../../value_checker'\nimport TestCaseHookDefinition from '../../models/test_case_hook_definition'\nimport { ILineAndUri } from '../../types'\nimport { TestStepResult } from '@cucumber/messages'\n\nexport interface IParsedTestStep {\n  actionLocation?: ILineAndUri\n  argument?: messages.PickleStepArgument\n  attachments: messages.Attachment[]\n  keyword: string\n  name?: string\n  result: messages.TestStepResult\n  snippet?: string\n  sourceLocation?: ILineAndUri\n  text?: string\n}\n\nexport interface IParsedTestCase {\n  attempt: number\n  name: string\n  sourceLocation?: ILineAndUri\n  worstTestStepResult: messages.TestStepResult\n}\n\nexport interface IParsedTestCaseAttempt {\n  testCase: IParsedTestCase\n  testSteps: IParsedTestStep[]\n}\n\ninterface IParseStepRequest {\n  isBeforeHook: boolean\n  gherkinStepMap: Record<string, messages.Step>\n  keyword: string\n  keywordType: KeywordType\n  pickleStep: messages.PickleStep\n  pickleUri: string\n  snippetBuilder: StepDefinitionSnippetBuilder\n  supportCodeLibrary: ISupportCodeLibrary\n  testStep: messages.TestStep\n  testStepResult: messages.TestStepResult\n  testStepAttachments: messages.Attachment[]\n}\n\nfunction parseStep({\n  isBeforeHook,\n  gherkinStepMap,\n  keyword,\n  keywordType,\n  pickleStep,\n  pickleUri,\n  snippetBuilder,\n  supportCodeLibrary,\n  testStep,\n  testStepResult,\n  testStepAttachments,\n}: IParseStepRequest): IParsedTestStep {\n  const out: IParsedTestStep = {\n    attachments: testStepAttachments,\n    keyword: doesHaveValue(testStep.pickleStepId)\n      ? keyword\n      : isBeforeHook\n      ? 'Before'\n      : 'After',\n    result: testStepResult,\n  }\n  if (doesHaveValue(testStep.hookId)) {\n    let hookDefinition: TestCaseHookDefinition\n    if (isBeforeHook) {\n      hookDefinition = supportCodeLibrary.beforeTestCaseHookDefinitions.find(\n        (x) => x.id === testStep.hookId\n      )\n    } else {\n      hookDefinition = supportCodeLibrary.afterTestCaseHookDefinitions.find(\n        (x) => x.id === testStep.hookId\n      )\n    }\n    out.actionLocation = {\n      uri: hookDefinition.uri,\n      line: hookDefinition.line,\n    }\n    out.name = hookDefinition.name\n  }\n  if (\n    doesHaveValue(testStep.stepDefinitionIds) &&\n    testStep.stepDefinitionIds.length === 1\n  ) {\n    const stepDefinition = supportCodeLibrary.stepDefinitions.find(\n      (x) => x.id === testStep.stepDefinitionIds[0]\n    )\n    out.actionLocation = {\n      uri: stepDefinition.uri,\n      line: stepDefinition.line,\n    }\n  }\n  if (doesHaveValue(testStep.pickleStepId)) {\n    out.sourceLocation = {\n      uri: pickleUri,\n      line: gherkinStepMap[pickleStep.astNodeIds[0]].location.line,\n    }\n    out.text = pickleStep.text\n    if (doesHaveValue(pickleStep.argument)) {\n      out.argument = pickleStep.argument\n    }\n  }\n  if (testStepResult.status === messages.TestStepResultStatus.UNDEFINED) {\n    out.snippet = snippetBuilder.build({ keywordType, pickleStep })\n  }\n  return out\n}\n\nexport interface IParseTestCaseAttemptRequest {\n  testCaseAttempt: ITestCaseAttempt\n  snippetBuilder: StepDefinitionSnippetBuilder\n  supportCodeLibrary: ISupportCodeLibrary\n}\n\n// Converts a testCaseAttempt into a json object with all data needed for\n// displaying it in a pretty format\nexport function parseTestCaseAttempt({\n  testCaseAttempt,\n  snippetBuilder,\n  supportCodeLibrary,\n}: IParseTestCaseAttemptRequest): IParsedTestCaseAttempt {\n  const { testCase, pickle, gherkinDocument } = testCaseAttempt\n  const gherkinStepMap = getGherkinStepMap(gherkinDocument)\n  const gherkinScenarioLocationMap =\n    getGherkinScenarioLocationMap(gherkinDocument)\n  const pickleStepMap = getPickleStepMap(pickle)\n  const relativePickleUri = pickle.uri\n  const parsedTestCase: IParsedTestCase = {\n    attempt: testCaseAttempt.attempt,\n    name: pickle.name,\n    sourceLocation: {\n      uri: relativePickleUri,\n      line: gherkinScenarioLocationMap[\n        pickle.astNodeIds[pickle.astNodeIds.length - 1]\n      ].line,\n    },\n    worstTestStepResult: testCaseAttempt.worstTestStepResult,\n  }\n  const parsedTestSteps: IParsedTestStep[] = []\n  let isBeforeHook = true\n  let previousKeywordType = KeywordType.Precondition\n\n  testCase.testSteps.forEach((testStep) => {\n    const testStepResult =\n      testCaseAttempt.stepResults[testStep.id] || new TestStepResult()\n\n    isBeforeHook = isBeforeHook && doesHaveValue(testStep.hookId)\n\n    let keyword, keywordType, pickleStep\n    if (doesHaveValue(testStep.pickleStepId)) {\n      pickleStep = pickleStepMap[testStep.pickleStepId]\n      keyword = getStepKeyword({ pickleStep, gherkinStepMap })\n      keywordType = getStepKeywordType({\n        keyword,\n        language: gherkinDocument.feature.language,\n        previousKeywordType,\n      })\n    }\n    const parsedStep = parseStep({\n      isBeforeHook,\n      gherkinStepMap,\n      keyword,\n      keywordType,\n      pickleStep,\n      pickleUri: relativePickleUri,\n      snippetBuilder,\n      supportCodeLibrary,\n      testStep,\n      testStepResult,\n      testStepAttachments: valueOrDefault(\n        testCaseAttempt.stepAttachments[testStep.id],\n        []\n      ),\n    })\n    parsedTestSteps.push(parsedStep)\n    previousKeywordType = keywordType\n  })\n  return {\n    testCase: parsedTestCase,\n    testSteps: parsedTestSteps,\n  }\n}\n"],"mappings":"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"}