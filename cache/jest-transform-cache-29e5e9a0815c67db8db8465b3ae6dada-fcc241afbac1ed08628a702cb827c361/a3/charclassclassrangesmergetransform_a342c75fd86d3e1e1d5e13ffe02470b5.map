{"version":3,"names":["module","exports","_hasIUFlags","init","ast","flags","includes","CharacterClass","path","node","expressions","metas","forEach","expression","isMeta","push","value","sort","sortCharClass","i","length","fitsInMetas","combinesWithPrecedingClassRange","combinesWithFollowingClassRange","splice","nbMergedChars","charCombinesWithPrecedingChars","a","b","aValue","getSortValue","bValue","type","to","isControl","Infinity","kind","isNaN","codePoint","from","arguments","undefined","test","hasIUFlags","fitsInMeta","meta","fitsInMetaS","fitsInMetaD","fitsInMetaW","classRange","fitsInClassRange","isMetaWCharOrCode","index","currentExpression","precedingExpresion"],"sources":["char-class-classranges-merge-transform.js"],"sourcesContent":["/**\n * The MIT License (MIT)\n * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>\n */\n\n'use strict';\n\n/**\n * A regexp-tree plugin to merge class ranges.\n *\n * [a-ec] -> [a-e]\n * [a-ec-e] -> [a-e]\n * [\\w\\da-f] -> [\\w]\n * [abcdef] -> [a-f]\n */\n\nmodule.exports = {\n  _hasIUFlags: false,\n  init: function init(ast) {\n    this._hasIUFlags = ast.flags.includes('i') && ast.flags.includes('u');\n  },\n  CharacterClass: function CharacterClass(path) {\n    var node = path.node;\n\n    var expressions = node.expressions;\n\n    var metas = [];\n    // Extract metas\n    expressions.forEach(function (expression) {\n      if (isMeta(expression)) {\n        metas.push(expression.value);\n      }\n    });\n\n    expressions.sort(sortCharClass);\n\n    for (var i = 0; i < expressions.length; i++) {\n      var expression = expressions[i];\n      if (fitsInMetas(expression, metas, this._hasIUFlags) || combinesWithPrecedingClassRange(expression, expressions[i - 1]) || combinesWithFollowingClassRange(expression, expressions[i + 1])) {\n        expressions.splice(i, 1);\n        i--;\n      } else {\n        var nbMergedChars = charCombinesWithPrecedingChars(expression, i, expressions);\n        expressions.splice(i - nbMergedChars + 1, nbMergedChars);\n        i -= nbMergedChars;\n      }\n    }\n  }\n};\n\n/**\n * Sorts expressions in char class in the following order:\n * - meta chars, ordered alphabetically by value\n * - chars (except `control` kind) and class ranges, ordered alphabetically (`from` char is used for class ranges)\n * - if ambiguous, class range comes before char\n * - if ambiguous between two class ranges, orders alphabetically by `to` char\n * - control chars, ordered alphabetically by value\n * @param {Object} a - Left Char or ClassRange node\n * @param {Object} b - Right Char or ClassRange node\n * @returns {number}\n */\nfunction sortCharClass(a, b) {\n  var aValue = getSortValue(a);\n  var bValue = getSortValue(b);\n\n  if (aValue === bValue) {\n    // We want ClassRange before Char\n    // [bb-d] -> [b-db]\n    if (a.type === 'ClassRange' && b.type !== 'ClassRange') {\n      return -1;\n    }\n    if (b.type === 'ClassRange' && a.type !== 'ClassRange') {\n      return 1;\n    }\n    if (a.type === 'ClassRange' && b.type === 'ClassRange') {\n      return getSortValue(a.to) - getSortValue(b.to);\n    }\n    if (isMeta(a) && isMeta(b) || isControl(a) && isControl(b)) {\n      return a.value < b.value ? -1 : 1;\n    }\n  }\n  return aValue - bValue;\n}\n\n/**\n * @param {Object} expression - Char or ClassRange node\n * @returns {number}\n */\nfunction getSortValue(expression) {\n  if (expression.type === 'Char') {\n    if (expression.value === '-') {\n      return Infinity;\n    }\n    if (expression.kind === 'control') {\n      return Infinity;\n    }\n    if (expression.kind === 'meta' && isNaN(expression.codePoint)) {\n      return -1;\n    }\n    return expression.codePoint;\n  }\n  // ClassRange\n  return expression.from.codePoint;\n}\n\n/**\n * Checks if a node is a meta char from the set \\d\\w\\s\\D\\W\\S\n * @param {Object} expression - Char or ClassRange node\n * @param {?string} value\n * @returns {boolean}\n */\nfunction isMeta(expression) {\n  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n  return expression.type === 'Char' && expression.kind === 'meta' && (value ? expression.value === value : /^\\\\[dws]$/i.test(expression.value));\n}\n\n/**\n * @param {Object} expression - Char or ClassRange node\n * @returns {boolean}\n */\nfunction isControl(expression) {\n  return expression.type === 'Char' && expression.kind === 'control';\n}\n\n/**\n * @param {Object} expression - Char or ClassRange node\n * @param {string[]} metas - Array of meta chars, e.g. [\"\\\\w\", \"\\\\s\"]\n * @param {boolean} hasIUFlags\n * @returns {boolean}\n */\nfunction fitsInMetas(expression, metas, hasIUFlags) {\n  for (var i = 0; i < metas.length; i++) {\n    if (fitsInMeta(expression, metas[i], hasIUFlags)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * @param {Object} expression - Char or ClassRange node\n * @param {string} meta - e.g. \"\\\\w\"\n * @param {boolean} hasIUFlags\n * @returns {boolean}\n */\nfunction fitsInMeta(expression, meta, hasIUFlags) {\n  if (expression.type === 'ClassRange') {\n    return fitsInMeta(expression.from, meta, hasIUFlags) && fitsInMeta(expression.to, meta, hasIUFlags);\n  }\n\n  // Special cases:\n  // \\S contains \\w and \\d\n  if (meta === '\\\\S' && (isMeta(expression, '\\\\w') || isMeta(expression, '\\\\d'))) {\n    return true;\n  }\n  // \\D contains \\W and \\s\n  if (meta === '\\\\D' && (isMeta(expression, '\\\\W') || isMeta(expression, '\\\\s'))) {\n    return true;\n  }\n  // \\w contains \\d\n  if (meta === '\\\\w' && isMeta(expression, '\\\\d')) {\n    return true;\n  }\n  // \\W contains \\s\n  if (meta === '\\\\W' && isMeta(expression, '\\\\s')) {\n    return true;\n  }\n\n  if (expression.type !== 'Char' || isNaN(expression.codePoint)) {\n    return false;\n  }\n\n  if (meta === '\\\\s') {\n    return fitsInMetaS(expression);\n  }\n  if (meta === '\\\\S') {\n    return !fitsInMetaS(expression);\n  }\n  if (meta === '\\\\d') {\n    return fitsInMetaD(expression);\n  }\n  if (meta === '\\\\D') {\n    return !fitsInMetaD(expression);\n  }\n  if (meta === '\\\\w') {\n    return fitsInMetaW(expression, hasIUFlags);\n  }\n  if (meta === '\\\\W') {\n    return !fitsInMetaW(expression, hasIUFlags);\n  }\n  return false;\n}\n\n/**\n * @param {Object} expression - Char node with codePoint\n * @returns {boolean}\n */\nfunction fitsInMetaS(expression) {\n  return expression.codePoint === 0x0009 || // \\t\n  expression.codePoint === 0x000a || // \\n\n  expression.codePoint === 0x000b || // \\v\n  expression.codePoint === 0x000c || // \\f\n  expression.codePoint === 0x000d || // \\r\n  expression.codePoint === 0x0020 || // space\n  expression.codePoint === 0x00a0 || // nbsp\n  expression.codePoint === 0x1680 || // part of Zs\n  expression.codePoint >= 0x2000 && expression.codePoint <= 0x200a || // part of Zs\n  expression.codePoint === 0x2028 || // line separator\n  expression.codePoint === 0x2029 || // paragraph separator\n  expression.codePoint === 0x202f || // part of Zs\n  expression.codePoint === 0x205f || // part of Zs\n  expression.codePoint === 0x3000 || // part of Zs\n  expression.codePoint === 0xfeff; // zwnbsp\n}\n\n/**\n * @param {Object} expression - Char node with codePoint\n * @returns {boolean}\n */\nfunction fitsInMetaD(expression) {\n  return expression.codePoint >= 0x30 && expression.codePoint <= 0x39; // 0-9\n}\n\n/**\n * @param {Object} expression - Char node with codePoint\n * @param {boolean} hasIUFlags\n * @returns {boolean}\n */\nfunction fitsInMetaW(expression, hasIUFlags) {\n  return fitsInMetaD(expression) || expression.codePoint >= 0x41 && expression.codePoint <= 0x5a || // A-Z\n  expression.codePoint >= 0x61 && expression.codePoint <= 0x7a || // a-z\n  expression.value === '_' || hasIUFlags && (expression.codePoint === 0x017f || expression.codePoint === 0x212a);\n}\n\n/**\n * @param {Object} expression - Char or ClassRange node\n * @param {Object} classRange - Char or ClassRange node\n * @returns {boolean}\n */\nfunction combinesWithPrecedingClassRange(expression, classRange) {\n  if (classRange && classRange.type === 'ClassRange') {\n    if (fitsInClassRange(expression, classRange)) {\n      // [a-gc] -> [a-g]\n      // [a-gc-e] -> [a-g]\n      return true;\n    } else if (\n    // We only want \\w chars or char codes to keep readability\n    isMetaWCharOrCode(expression) && classRange.to.codePoint === expression.codePoint - 1) {\n      // [a-de] -> [a-e]\n      classRange.to = expression;\n      return true;\n    } else if (expression.type === 'ClassRange' && expression.from.codePoint <= classRange.to.codePoint + 1 && expression.to.codePoint >= classRange.from.codePoint - 1) {\n      // [a-db-f] -> [a-f]\n      // [b-fa-d] -> [a-f]\n      // [a-cd-f] -> [a-f]\n      if (expression.from.codePoint < classRange.from.codePoint) {\n        classRange.from = expression.from;\n      }\n      if (expression.to.codePoint > classRange.to.codePoint) {\n        classRange.to = expression.to;\n      }\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * @param {Object} expression - Char or ClassRange node\n * @param {Object} classRange - Char or ClassRange node\n * @returns {boolean}\n */\nfunction combinesWithFollowingClassRange(expression, classRange) {\n  if (classRange && classRange.type === 'ClassRange') {\n    // Considering the elements were ordered alphabetically,\n    // there is only one case to handle\n    // [ab-e] -> [a-e]\n    if (\n    // We only want \\w chars or char codes to keep readability\n    isMetaWCharOrCode(expression) && classRange.from.codePoint === expression.codePoint + 1) {\n      classRange.from = expression;\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * @param {Object} expression - Char or ClassRange node\n * @param {Object} classRange - ClassRange node\n * @returns {boolean}\n */\nfunction fitsInClassRange(expression, classRange) {\n  if (expression.type === 'Char' && isNaN(expression.codePoint)) {\n    return false;\n  }\n  if (expression.type === 'ClassRange') {\n    return fitsInClassRange(expression.from, classRange) && fitsInClassRange(expression.to, classRange);\n  }\n  return expression.codePoint >= classRange.from.codePoint && expression.codePoint <= classRange.to.codePoint;\n}\n\n/**\n * @param {Object} expression - Char or ClassRange node\n * @param {Number} index\n * @param {Object[]} expressions - expressions in CharClass\n * @returns {number} - Number of characters combined with expression\n */\nfunction charCombinesWithPrecedingChars(expression, index, expressions) {\n  // We only want \\w chars or char codes to keep readability\n  if (!isMetaWCharOrCode(expression)) {\n    return 0;\n  }\n  var nbMergedChars = 0;\n  while (index > 0) {\n    var currentExpression = expressions[index];\n    var precedingExpresion = expressions[index - 1];\n    if (isMetaWCharOrCode(precedingExpresion) && precedingExpresion.codePoint === currentExpression.codePoint - 1) {\n      nbMergedChars++;\n      index--;\n    } else {\n      break;\n    }\n  }\n\n  if (nbMergedChars > 1) {\n    expressions[index] = {\n      type: 'ClassRange',\n      from: expressions[index],\n      to: expression\n    };\n    return nbMergedChars;\n  }\n  return 0;\n}\n\nfunction isMetaWCharOrCode(expression) {\n  return expression && expression.type === 'Char' && !isNaN(expression.codePoint) && (fitsInMetaW(expression, false) || expression.kind === 'unicode' || expression.kind === 'hex' || expression.kind === 'oct' || expression.kind === 'decimal');\n}"],"mappings":"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"}