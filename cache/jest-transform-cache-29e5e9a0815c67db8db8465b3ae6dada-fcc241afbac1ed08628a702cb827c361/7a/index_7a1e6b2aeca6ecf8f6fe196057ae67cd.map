{"version":3,"names":["NodePath","require","astTraverse","root","options","arguments","length","undefined","pre","post","skipProperty","visit","node","parent","prop","idx","type","res","isNaN","_prop","hasOwnProperty","child","Array","isArray","index","traversingIndexStack","push","updateTraversingIndex","pop","module","exports","traverse","ast","handlers","asNodes","filter","handler","shouldRun","initRegistry","forEach","init","getPathFor","parentPath","getForNode","nodePath","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","Symbol","iterator","_step","next","done","value","isRemoved","handlerResult","handlerFuncPre","_handlerResult","call","err","return","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","handlerFuncPost"],"sources":["index.js"],"sourcesContent":["/**\n * The MIT License (MIT)\n * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>\n */\n\n'use strict';\n\nvar NodePath = require('./node-path');\n\n/**\n * Does an actual AST traversal, using visitor pattern,\n * and calling set of callbacks.\n *\n * Based on https://github.com/olov/ast-traverse\n *\n * Expects AST in Mozilla Parser API: nodes which are supposed to be\n * handled should have `type` property.\n *\n * @param Object root - a root node to start traversal from.\n *\n * @param Object options - an object with set of callbacks:\n *\n *   - `pre(node, parent, prop, index)` - a hook called on node enter\n *   - `post`(node, parent, prop, index) - a hook called on node exit\n *   - `skipProperty(prop)` - a predicated whether a property should be skipped\n */\nfunction astTraverse(root) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var pre = options.pre;\n  var post = options.post;\n  var skipProperty = options.skipProperty;\n\n  function visit(node, parent, prop, idx) {\n    if (!node || typeof node.type !== 'string') {\n      return;\n    }\n\n    var res = undefined;\n    if (pre) {\n      res = pre(node, parent, prop, idx);\n    }\n\n    if (res !== false) {\n\n      // A node can be replaced during traversal, so we have to\n      // recalculate it from the parent, to avoid traversing \"dead\" nodes.\n      if (parent && parent[prop]) {\n        if (!isNaN(idx)) {\n          node = parent[prop][idx];\n        } else {\n          node = parent[prop];\n        }\n      }\n\n      for (var _prop in node) {\n        if (node.hasOwnProperty(_prop)) {\n          if (skipProperty ? skipProperty(_prop, node) : _prop[0] === '$') {\n            continue;\n          }\n\n          var child = node[_prop];\n\n          // Collection node.\n          //\n          // NOTE: a node (or several nodes) can be removed or inserted\n          // during traversal.\n          //\n          // Current traversing index is stored on top of the\n          // `NodePath.traversingIndexStack`. The stack is used to support\n          // recursive nature of the traversal.\n          //\n          // In this case `NodePath.traversingIndex` (which we use here) is\n          // updated in the NodePath remove/insert methods.\n          //\n          if (Array.isArray(child)) {\n            var index = 0;\n            NodePath.traversingIndexStack.push(index);\n            while (index < child.length) {\n              visit(child[index], node, _prop, index);\n              index = NodePath.updateTraversingIndex(+1);\n            }\n            NodePath.traversingIndexStack.pop();\n          }\n\n          // Simple node.\n          else {\n              visit(child, node, _prop);\n            }\n        }\n      }\n    }\n\n    if (post) {\n      post(node, parent, prop, idx);\n    }\n  }\n\n  visit(root, null);\n}\n\nmodule.exports = {\n  /**\n   * Traverses an AST.\n   *\n   * @param Object ast - an AST node\n   *\n   * @param Object | Array<Object> handlers:\n   *\n   *   an object (or an array of objects)\n   *\n   *   Each such object contains a handler function per node.\n   *   In case of an array of handlers, they are applied in order.\n   *   A handler may return a transformed node (or a different type).\n   *\n   *   The per-node function may instead be an object with functions pre and post.\n   *   pre is called before visiting the node, post after.\n   *   If a handler is a function, it is treated as the pre function, with an empty post.\n   *\n   * @param Object options:\n   *\n   *   a config object, specifying traversal options:\n   *\n   *   `asNodes`: boolean - whether handlers should receives raw AST nodes\n   *   (false by default), instead of a `NodePath` wrapper. Note, by default\n   *   `NodePath` wrapper provides a set of convenient method to manipulate\n   *   a traversing AST, and also has access to all parents list. A raw\n   *   nodes traversal should be used in rare cases, when no `NodePath`\n   *   features are needed.\n   *\n   * Special hooks:\n   *\n   *   - `shouldRun(ast)` - a predicate determining whether the handler\n   *                        should be applied.\n   *\n   * NOTE: Multiple handlers are used as an optimization of applying all of\n   * them in one AST traversal pass.\n   */\n  traverse: function traverse(ast, handlers) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { asNodes: false };\n\n\n    if (!Array.isArray(handlers)) {\n      handlers = [handlers];\n    }\n\n    // Filter out handlers by result of `shouldRun`, if the method is present.\n    handlers = handlers.filter(function (handler) {\n      if (typeof handler.shouldRun !== 'function') {\n        return true;\n      }\n      return handler.shouldRun(ast);\n    });\n\n    NodePath.initRegistry();\n\n    // Allow handlers to initializer themselves.\n    handlers.forEach(function (handler) {\n      if (typeof handler.init === 'function') {\n        handler.init(ast);\n      }\n    });\n\n    function getPathFor(node, parent, prop, index) {\n      var parentPath = NodePath.getForNode(parent);\n      var nodePath = NodePath.getForNode(node, parentPath, prop, index);\n\n      return nodePath;\n    }\n\n    // Handle actual nodes.\n    astTraverse(ast, {\n      /**\n       * Handler on node enter.\n       */\n      pre: function pre(node, parent, prop, index) {\n        var nodePath = void 0;\n        if (!options.asNodes) {\n          nodePath = getPathFor(node, parent, prop, index);\n        }\n\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = handlers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var handler = _step.value;\n\n            // \"Catch-all\" `*` handler.\n            if (typeof handler['*'] === 'function') {\n              if (nodePath) {\n                // A path/node can be removed by some previous handler.\n                if (!nodePath.isRemoved()) {\n                  var handlerResult = handler['*'](nodePath);\n                  // Explicitly stop traversal.\n                  if (handlerResult === false) {\n                    return false;\n                  }\n                }\n              } else {\n                handler['*'](node, parent, prop, index);\n              }\n            }\n\n            // Per-node handler.\n            var handlerFuncPre = void 0;\n            if (typeof handler[node.type] === 'function') {\n              handlerFuncPre = handler[node.type];\n            } else if (typeof handler[node.type] === 'object' && typeof handler[node.type].pre === 'function') {\n              handlerFuncPre = handler[node.type].pre;\n            }\n\n            if (handlerFuncPre) {\n              if (nodePath) {\n                // A path/node can be removed by some previous handler.\n                if (!nodePath.isRemoved()) {\n                  var _handlerResult = handlerFuncPre.call(handler, nodePath);\n                  // Explicitly stop traversal.\n                  if (_handlerResult === false) {\n                    return false;\n                  }\n                }\n              } else {\n                handlerFuncPre.call(handler, node, parent, prop, index);\n              }\n            }\n          } // Loop over handlers\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      },\n      // pre func\n\n      /**\n       * Handler on node exit.\n       */\n      post: function post(node, parent, prop, index) {\n        if (!node) {\n          return;\n        }\n\n        var nodePath = void 0;\n        if (!options.asNodes) {\n          nodePath = getPathFor(node, parent, prop, index);\n        }\n\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = handlers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var handler = _step2.value;\n\n            // Per-node handler.\n            var handlerFuncPost = void 0;\n            if (typeof handler[node.type] === 'object' && typeof handler[node.type].post === 'function') {\n              handlerFuncPost = handler[node.type].post;\n            }\n\n            if (handlerFuncPost) {\n              if (nodePath) {\n                // A path/node can be removed by some previous handler.\n                if (!nodePath.isRemoved()) {\n                  var handlerResult = handlerFuncPost.call(handler, nodePath);\n                  // Explicitly stop traversal.\n                  if (handlerResult === false) {\n                    return false;\n                  }\n                }\n              } else {\n                handlerFuncPost.call(handler, node, parent, prop, index);\n              }\n            }\n          } // Loop over handlers\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      },\n      // post func\n\n      /**\n       * Skip locations by default.\n       */\n      skipProperty: function skipProperty(prop) {\n        return prop === 'loc';\n      }\n    });\n  }\n};"],"mappings":"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"}