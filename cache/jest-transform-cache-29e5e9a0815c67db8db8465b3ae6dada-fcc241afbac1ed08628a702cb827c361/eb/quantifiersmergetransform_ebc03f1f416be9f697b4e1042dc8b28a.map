{"version":3,"names":["_require","require","increaseQuantifierByOne","module","exports","Repetition","path","node","parent","type","index","previousSibling","getPreviousSibling","getChild","hasEqualSource","_extractFromTo","extractFromTo","quantifier","previousSiblingFrom","from","previousSiblingTo","to","_extractFromTo2","nodeFrom","nodeTo","greedy","isGreedyOpenRange","kind","remove"],"sources":["quantifiers-merge-transform.js"],"sourcesContent":["/**\n * The MIT License (MIT)\n * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>\n */\n\n'use strict';\n\nvar _require = require('../../transform/utils'),\n    increaseQuantifierByOne = _require.increaseQuantifierByOne;\n\n/**\n * A regexp-tree plugin to merge quantifiers\n *\n * a+a+ -> a{2,}\n * a{2}a{3} -> a{5}\n * a{1,2}a{2,3} -> a{3,5}\n */\n\n\nmodule.exports = {\n  Repetition: function Repetition(path) {\n    var node = path.node,\n        parent = path.parent;\n\n\n    if (parent.type !== 'Alternative' || !path.index) {\n      return;\n    }\n\n    var previousSibling = path.getPreviousSibling();\n\n    if (!previousSibling) {\n      return;\n    }\n\n    if (previousSibling.node.type === 'Repetition') {\n      if (!previousSibling.getChild().hasEqualSource(path.getChild())) {\n        return;\n      }\n\n      var _extractFromTo = extractFromTo(previousSibling.node.quantifier),\n          previousSiblingFrom = _extractFromTo.from,\n          previousSiblingTo = _extractFromTo.to;\n\n      var _extractFromTo2 = extractFromTo(node.quantifier),\n          nodeFrom = _extractFromTo2.from,\n          nodeTo = _extractFromTo2.to;\n\n      // It's does not seem reliable to merge quantifiers with different greediness\n      // when none of both is a greedy open range\n\n\n      if (previousSibling.node.quantifier.greedy !== node.quantifier.greedy && !isGreedyOpenRange(previousSibling.node.quantifier) && !isGreedyOpenRange(node.quantifier)) {\n        return;\n      }\n\n      // a*a* -> a*\n      // a*a+ -> a+\n      // a+a+ -> a{2,}\n      // a{2}a{4} -> a{6}\n      // a{1,2}a{2,3} -> a{3,5}\n      // a{1,}a{2,} -> a{3,}\n      // a+a{2,} -> a{3,}\n\n      // a??a{2,} -> a{2,}\n      // a*?a{2,} -> a{2,}\n      // a+?a{2,} -> a{3,}\n\n      node.quantifier.kind = 'Range';\n      node.quantifier.from = previousSiblingFrom + nodeFrom;\n      if (previousSiblingTo && nodeTo) {\n        node.quantifier.to = previousSiblingTo + nodeTo;\n      } else {\n        delete node.quantifier.to;\n      }\n      if (isGreedyOpenRange(previousSibling.node.quantifier) || isGreedyOpenRange(node.quantifier)) {\n        node.quantifier.greedy = true;\n      }\n\n      previousSibling.remove();\n    } else {\n      if (!previousSibling.hasEqualSource(path.getChild())) {\n        return;\n      }\n\n      increaseQuantifierByOne(node.quantifier);\n      previousSibling.remove();\n    }\n  }\n};\n\nfunction isGreedyOpenRange(quantifier) {\n  return quantifier.greedy && (quantifier.kind === '+' || quantifier.kind === '*' || quantifier.kind === 'Range' && !quantifier.to);\n}\n\nfunction extractFromTo(quantifier) {\n  var from = void 0,\n      to = void 0;\n  if (quantifier.kind === '*') {\n    from = 0;\n  } else if (quantifier.kind === '+') {\n    from = 1;\n  } else if (quantifier.kind === '?') {\n    from = 0;\n    to = 1;\n  } else {\n    from = quantifier.from;\n    if (quantifier.to) {\n      to = quantifier.to;\n    }\n  }\n  return { from: from, to: to };\n}"],"mappings":"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"}