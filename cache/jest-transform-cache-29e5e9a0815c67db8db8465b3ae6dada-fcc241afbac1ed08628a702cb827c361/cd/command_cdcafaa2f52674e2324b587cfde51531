dad5279b1656d3236aa49b131f966451
"use strict";

const EventEmitter = require('events').EventEmitter;
const childProcess = require('child_process');
const path = require('path');
const fs = require('fs');
const process = require('process');
const {
  Argument,
  humanReadableArgName
} = require('./argument.js');
const {
  CommanderError
} = require('./error.js');
const {
  Help
} = require('./help.js');
const {
  Option,
  splitOptionFlags,
  DualOptions
} = require('./option.js');
const {
  suggestSimilar
} = require('./suggestSimilar');

// @ts-check

class Command extends EventEmitter {
  /**
   * Initialize a new `Command`.
   *
   * @param {string} [name]
   */

  constructor(name) {
    super();
    /** @type {Command[]} */
    this.commands = [];
    /** @type {Option[]} */
    this.options = [];
    this.parent = null;
    this._allowUnknownOption = false;
    this._allowExcessArguments = true;
    /** @type {Argument[]} */
    this._args = [];
    /** @type {string[]} */
    this.args = []; // cli args with options removed
    this.rawArgs = [];
    this.processedArgs = []; // like .args but after custom processing and collecting variadic
    this._scriptPath = null;
    this._name = name || '';
    this._optionValues = {};
    this._optionValueSources = {}; // default, env, cli etc
    this._storeOptionsAsProperties = false;
    this._actionHandler = null;
    this._executableHandler = false;
    this._executableFile = null; // custom name for executable
    this._executableDir = null; // custom search directory for subcommands
    this._defaultCommandName = null;
    this._exitCallback = null;
    this._aliases = [];
    this._combineFlagAndOptionalValue = true;
    this._description = '';
    this._summary = '';
    this._argsDescription = undefined; // legacy
    this._enablePositionalOptions = false;
    this._passThroughOptions = false;
    this._lifeCycleHooks = {}; // a hash of arrays
    /** @type {boolean | string} */
    this._showHelpAfterError = false;
    this._showSuggestionAfterError = true;

    // see .configureOutput() for docs
    this._outputConfiguration = {
      writeOut: str => process.stdout.write(str),
      writeErr: str => process.stderr.write(str),
      getOutHelpWidth: () => process.stdout.isTTY ? process.stdout.columns : undefined,
      getErrHelpWidth: () => process.stderr.isTTY ? process.stderr.columns : undefined,
      outputError: (str, write) => write(str)
    };
    this._hidden = false;
    this._hasHelpOption = true;
    this._helpFlags = '-h, --help';
    this._helpDescription = 'display help for command';
    this._helpShortFlag = '-h';
    this._helpLongFlag = '--help';
    this._addImplicitHelpCommand = undefined; // Deliberately undefined, not decided whether true or false
    this._helpCommandName = 'help';
    this._helpCommandnameAndArgs = 'help [command]';
    this._helpCommandDescription = 'display help for command';
    this._helpConfiguration = {};
  }

  /**
   * Copy settings that are useful to have in common across root command and subcommands.
   *
   * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)
   *
   * @param {Command} sourceCommand
   * @return {Command} `this` command for chaining
   */
  copyInheritedSettings(sourceCommand) {
    this._outputConfiguration = sourceCommand._outputConfiguration;
    this._hasHelpOption = sourceCommand._hasHelpOption;
    this._helpFlags = sourceCommand._helpFlags;
    this._helpDescription = sourceCommand._helpDescription;
    this._helpShortFlag = sourceCommand._helpShortFlag;
    this._helpLongFlag = sourceCommand._helpLongFlag;
    this._helpCommandName = sourceCommand._helpCommandName;
    this._helpCommandnameAndArgs = sourceCommand._helpCommandnameAndArgs;
    this._helpCommandDescription = sourceCommand._helpCommandDescription;
    this._helpConfiguration = sourceCommand._helpConfiguration;
    this._exitCallback = sourceCommand._exitCallback;
    this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
    this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;
    this._allowExcessArguments = sourceCommand._allowExcessArguments;
    this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
    this._showHelpAfterError = sourceCommand._showHelpAfterError;
    this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;
    return this;
  }

  /**
   * Define a command.
   *
   * There are two styles of command: pay attention to where to put the description.
   *
   * @example
   * // Command implemented using action handler (description is supplied separately to `.command`)
   * program
   *   .command('clone <source> [destination]')
   *   .description('clone a repository into a newly created directory')
   *   .action((source, destination) => {
   *     console.log('clone command called');
   *   });
   *
   * // Command implemented using separate executable file (description is second parameter to `.command`)
   * program
   *   .command('start <service>', 'start named service')
   *   .command('stop [service]', 'stop named service, or all if no name supplied');
   *
   * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`
   * @param {Object|string} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)
   * @param {Object} [execOpts] - configuration options (for executable)
   * @return {Command} returns new command for action handler, or `this` for executable command
   */

  command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
    let desc = actionOptsOrExecDesc;
    let opts = execOpts;
    if (typeof desc === 'object' && desc !== null) {
      opts = desc;
      desc = null;
    }
    opts = opts || {};
    const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);
    const cmd = this.createCommand(name);
    if (desc) {
      cmd.description(desc);
      cmd._executableHandler = true;
    }
    if (opts.isDefault) this._defaultCommandName = cmd._name;
    cmd._hidden = !!(opts.noHelp || opts.hidden); // noHelp is deprecated old name for hidden
    cmd._executableFile = opts.executableFile || null; // Custom name for executable file, set missing to null to match constructor
    if (args) cmd.arguments(args);
    this.commands.push(cmd);
    cmd.parent = this;
    cmd.copyInheritedSettings(this);
    if (desc) return this;
    return cmd;
  }

  /**
   * Factory routine to create a new unattached command.
   *
   * See .command() for creating an attached subcommand, which uses this routine to
   * create the command. You can override createCommand to customise subcommands.
   *
   * @param {string} [name]
   * @return {Command} new command
   */

  createCommand(name) {
    return new Command(name);
  }

  /**
   * You can customise the help with a subclass of Help by overriding createHelp,
   * or by overriding Help properties using configureHelp().
   *
   * @return {Help}
   */

  createHelp() {
    return Object.assign(new Help(), this.configureHelp());
  }

  /**
   * You can customise the help by overriding Help properties using configureHelp(),
   * or with a subclass of Help by overriding createHelp().
   *
   * @param {Object} [configuration] - configuration options
   * @return {Command|Object} `this` command for chaining, or stored configuration
   */

  configureHelp(configuration) {
    if (configuration === undefined) return this._helpConfiguration;
    this._helpConfiguration = configuration;
    return this;
  }

  /**
   * The default output goes to stdout and stderr. You can customise this for special
   * applications. You can also customise the display of errors by overriding outputError.
   *
   * The configuration properties are all functions:
   *
   *     // functions to change where being written, stdout and stderr
   *     writeOut(str)
   *     writeErr(str)
   *     // matching functions to specify width for wrapping help
   *     getOutHelpWidth()
   *     getErrHelpWidth()
   *     // functions based on what is being written out
   *     outputError(str, write) // used for displaying errors, and not used for displaying help
   *
   * @param {Object} [configuration] - configuration options
   * @return {Command|Object} `this` command for chaining, or stored configuration
   */

  configureOutput(configuration) {
    if (configuration === undefined) return this._outputConfiguration;
    Object.assign(this._outputConfiguration, configuration);
    return this;
  }

  /**
   * Display the help or a custom message after an error occurs.
   *
   * @param {boolean|string} [displayHelp]
   * @return {Command} `this` command for chaining
   */
  showHelpAfterError(displayHelp = true) {
    if (typeof displayHelp !== 'string') displayHelp = !!displayHelp;
    this._showHelpAfterError = displayHelp;
    return this;
  }

  /**
   * Display suggestion of similar commands for unknown commands, or options for unknown options.
   *
   * @param {boolean} [displaySuggestion]
   * @return {Command} `this` command for chaining
   */
  showSuggestionAfterError(displaySuggestion = true) {
    this._showSuggestionAfterError = !!displaySuggestion;
    return this;
  }

  /**
   * Add a prepared subcommand.
   *
   * See .command() for creating an attached subcommand which inherits settings from its parent.
   *
   * @param {Command} cmd - new subcommand
   * @param {Object} [opts] - configuration options
   * @return {Command} `this` command for chaining
   */

  addCommand(cmd, opts) {
    if (!cmd._name) {
      throw new Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);
    }
    opts = opts || {};
    if (opts.isDefault) this._defaultCommandName = cmd._name;
    if (opts.noHelp || opts.hidden) cmd._hidden = true; // modifying passed command due to existing implementation

    this.commands.push(cmd);
    cmd.parent = this;
    return this;
  }

  /**
   * Factory routine to create a new unattached argument.
   *
   * See .argument() for creating an attached argument, which uses this routine to
   * create the argument. You can override createArgument to return a custom argument.
   *
   * @param {string} name
   * @param {string} [description]
   * @return {Argument} new argument
   */

  createArgument(name, description) {
    return new Argument(name, description);
  }

  /**
   * Define argument syntax for command.
   *
   * The default is that the argument is required, and you can explicitly
   * indicate this with <> around the name. Put [] around the name for an optional argument.
   *
   * @example
   * program.argument('<input-file>');
   * program.argument('[output-file]');
   *
   * @param {string} name
   * @param {string} [description]
   * @param {Function|*} [fn] - custom argument processing function
   * @param {*} [defaultValue]
   * @return {Command} `this` command for chaining
   */
  argument(name, description, fn, defaultValue) {
    const argument = this.createArgument(name, description);
    if (typeof fn === 'function') {
      argument.default(defaultValue).argParser(fn);
    } else {
      argument.default(fn);
    }
    this.addArgument(argument);
    return this;
  }

  /**
   * Define argument syntax for command, adding multiple at once (without descriptions).
   *
   * See also .argument().
   *
   * @example
   * program.arguments('<cmd> [env]');
   *
   * @param {string} names
   * @return {Command} `this` command for chaining
   */

  arguments(names) {
    names.split(/ +/).forEach(detail => {
      this.argument(detail);
    });
    return this;
  }

  /**
   * Define argument syntax for command, adding a prepared argument.
   *
   * @param {Argument} argument
   * @return {Command} `this` command for chaining
   */
  addArgument(argument) {
    const previousArgument = this._args.slice(-1)[0];
    if (previousArgument && previousArgument.variadic) {
      throw new Error(`only the last argument can be variadic '${previousArgument.name()}'`);
    }
    if (argument.required && argument.defaultValue !== undefined && argument.parseArg === undefined) {
      throw new Error(`a default value for a required argument is never used: '${argument.name()}'`);
    }
    this._args.push(argument);
    return this;
  }

  /**
   * Override default decision whether to add implicit help command.
   *
   *    addHelpCommand() // force on
   *    addHelpCommand(false); // force off
   *    addHelpCommand('help [cmd]', 'display help for [cmd]'); // force on with custom details
   *
   * @return {Command} `this` command for chaining
   */

  addHelpCommand(enableOrNameAndArgs, description) {
    if (enableOrNameAndArgs === false) {
      this._addImplicitHelpCommand = false;
    } else {
      this._addImplicitHelpCommand = true;
      if (typeof enableOrNameAndArgs === 'string') {
        this._helpCommandName = enableOrNameAndArgs.split(' ')[0];
        this._helpCommandnameAndArgs = enableOrNameAndArgs;
      }
      this._helpCommandDescription = description || this._helpCommandDescription;
    }
    return this;
  }

  /**
   * @return {boolean}
   * @api private
   */

  _hasImplicitHelpCommand() {
    if (this._addImplicitHelpCommand === undefined) {
      return this.commands.length && !this._actionHandler && !this._findCommand('help');
    }
    return this._addImplicitHelpCommand;
  }

  /**
   * Add hook for life cycle event.
   *
   * @param {string} event
   * @param {Function} listener
   * @return {Command} `this` command for chaining
   */

  hook(event, listener) {
    const allowedValues = ['preSubcommand', 'preAction', 'postAction'];
    if (!allowedValues.includes(event)) {
      throw new Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
    }
    if (this._lifeCycleHooks[event]) {
      this._lifeCycleHooks[event].push(listener);
    } else {
      this._lifeCycleHooks[event] = [listener];
    }
    return this;
  }

  /**
   * Register callback to use as replacement for calling process.exit.
   *
   * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing
   * @return {Command} `this` command for chaining
   */

  exitOverride(fn) {
    if (fn) {
      this._exitCallback = fn;
    } else {
      this._exitCallback = err => {
        if (err.code !== 'commander.executeSubCommandAsync') {
          throw err;
        } else {
          // Async callback from spawn events, not useful to throw.
        }
      };
    }
    return this;
  }

  /**
   * Call process.exit, and _exitCallback if defined.
   *
   * @param {number} exitCode exit code for using with process.exit
   * @param {string} code an id string representing the error
   * @param {string} message human-readable description of the error
   * @return never
   * @api private
   */

  _exit(exitCode, code, message) {
    if (this._exitCallback) {
      this._exitCallback(new CommanderError(exitCode, code, message));
      // Expecting this line is not reached.
    }

    process.exit(exitCode);
  }

  /**
   * Register callback `fn` for the command.
   *
   * @example
   * program
   *   .command('serve')
   *   .description('start service')
   *   .action(function() {
   *      // do work here
   *   });
   *
   * @param {Function} fn
   * @return {Command} `this` command for chaining
   */

  action(fn) {
    const listener = args => {
      // The .action callback takes an extra parameter which is the command or options.
      const expectedArgsCount = this._args.length;
      const actionArgs = args.slice(0, expectedArgsCount);
      if (this._storeOptionsAsProperties) {
        actionArgs[expectedArgsCount] = this; // backwards compatible "options"
      } else {
        actionArgs[expectedArgsCount] = this.opts();
      }
      actionArgs.push(this);
      return fn.apply(this, actionArgs);
    };
    this._actionHandler = listener;
    return this;
  }

  /**
   * Factory routine to create a new unattached option.
   *
   * See .option() for creating an attached option, which uses this routine to
   * create the option. You can override createOption to return a custom option.
   *
   * @param {string} flags
   * @param {string} [description]
   * @return {Option} new option
   */

  createOption(flags, description) {
    return new Option(flags, description);
  }

  /**
   * Add an option.
   *
   * @param {Option} option
   * @return {Command} `this` command for chaining
   */
  addOption(option) {
    const oname = option.name();
    const name = option.attributeName();

    // store default value
    if (option.negate) {
      // --no-foo is special and defaults foo to true, unless a --foo option is already defined
      const positiveLongFlag = option.long.replace(/^--no-/, '--');
      if (!this._findOption(positiveLongFlag)) {
        this.setOptionValueWithSource(name, option.defaultValue === undefined ? true : option.defaultValue, 'default');
      }
    } else if (option.defaultValue !== undefined) {
      this.setOptionValueWithSource(name, option.defaultValue, 'default');
    }

    // register the option
    this.options.push(option);

    // handler for cli and env supplied values
    const handleOptionValue = (val, invalidValueMessage, valueSource) => {
      // val is null for optional option used without an optional-argument.
      // val is undefined for boolean and negated option.
      if (val == null && option.presetArg !== undefined) {
        val = option.presetArg;
      }

      // custom processing
      const oldValue = this.getOptionValue(name);
      if (val !== null && option.parseArg) {
        try {
          val = option.parseArg(val, oldValue);
        } catch (err) {
          if (err.code === 'commander.invalidArgument') {
            const message = `${invalidValueMessage} ${err.message}`;
            this.error(message, {
              exitCode: err.exitCode,
              code: err.code
            });
          }
          throw err;
        }
      } else if (val !== null && option.variadic) {
        val = option._concatValue(val, oldValue);
      }

      // Fill-in appropriate missing values. Long winded but easy to follow.
      if (val == null) {
        if (option.negate) {
          val = false;
        } else if (option.isBoolean() || option.optional) {
          val = true;
        } else {
          val = ''; // not normal, parseArg might have failed or be a mock function for testing
        }
      }

      this.setOptionValueWithSource(name, val, valueSource);
    };
    this.on('option:' + oname, val => {
      const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
      handleOptionValue(val, invalidValueMessage, 'cli');
    });
    if (option.envVar) {
      this.on('optionEnv:' + oname, val => {
        const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
        handleOptionValue(val, invalidValueMessage, 'env');
      });
    }
    return this;
  }

  /**
   * Internal implementation shared by .option() and .requiredOption()
   *
   * @api private
   */
  _optionEx(config, flags, description, fn, defaultValue) {
    if (typeof flags === 'object' && flags instanceof Option) {
      throw new Error('To add an Option object use addOption() instead of option() or requiredOption()');
    }
    const option = this.createOption(flags, description);
    option.makeOptionMandatory(!!config.mandatory);
    if (typeof fn === 'function') {
      option.default(defaultValue).argParser(fn);
    } else if (fn instanceof RegExp) {
      // deprecated
      const regex = fn;
      fn = (val, def) => {
        const m = regex.exec(val);
        return m ? m[0] : def;
      };
      option.default(defaultValue).argParser(fn);
    } else {
      option.default(fn);
    }
    return this.addOption(option);
  }

  /**
   * Define option with `flags`, `description` and optional
   * coercion `fn`.
   *
   * The `flags` string contains the short and/or long flags,
   * separated by comma, a pipe or space. The following are all valid
   * all will output this way when `--help` is used.
   *
   *     "-p, --pepper"
   *     "-p|--pepper"
   *     "-p --pepper"
   *
   * @example
   * // simple boolean defaulting to undefined
   * program.option('-p, --pepper', 'add pepper');
   *
   * program.pepper
   * // => undefined
   *
   * --pepper
   * program.pepper
   * // => true
   *
   * // simple boolean defaulting to true (unless non-negated option is also defined)
   * program.option('-C, --no-cheese', 'remove cheese');
   *
   * program.cheese
   * // => true
   *
   * --no-cheese
   * program.cheese
   * // => false
   *
   * // required argument
   * program.option('-C, --chdir <path>', 'change the working directory');
   *
   * --chdir /tmp
   * program.chdir
   * // => "/tmp"
   *
   * // optional argument
   * program.option('-c, --cheese [type]', 'add cheese [marble]');
   *
   * @param {string} flags
   * @param {string} [description]
   * @param {Function|*} [fn] - custom option processing function or default value
   * @param {*} [defaultValue]
   * @return {Command} `this` command for chaining
   */

  option(flags, description, fn, defaultValue) {
    return this._optionEx({}, flags, description, fn, defaultValue);
  }

  /**
  * Add a required option which must have a value after parsing. This usually means
  * the option must be specified on the command line. (Otherwise the same as .option().)
  *
  * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.
  *
  * @param {string} flags
  * @param {string} [description]
  * @param {Function|*} [fn] - custom option processing function or default value
  * @param {*} [defaultValue]
  * @return {Command} `this` command for chaining
  */

  requiredOption(flags, description, fn, defaultValue) {
    return this._optionEx({
      mandatory: true
    }, flags, description, fn, defaultValue);
  }

  /**
   * Alter parsing of short flags with optional values.
   *
   * @example
   * // for `.option('-f,--flag [value]'):
   * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour
   * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`
   *
   * @param {Boolean} [combine=true] - if `true` or omitted, an optional value can be specified directly after the flag.
   */
  combineFlagAndOptionalValue(combine = true) {
    this._combineFlagAndOptionalValue = !!combine;
    return this;
  }

  /**
   * Allow unknown options on the command line.
   *
   * @param {Boolean} [allowUnknown=true] - if `true` or omitted, no error will be thrown
   * for unknown options.
   */
  allowUnknownOption(allowUnknown = true) {
    this._allowUnknownOption = !!allowUnknown;
    return this;
  }

  /**
   * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.
   *
   * @param {Boolean} [allowExcess=true] - if `true` or omitted, no error will be thrown
   * for excess arguments.
   */
  allowExcessArguments(allowExcess = true) {
    this._allowExcessArguments = !!allowExcess;
    return this;
  }

  /**
   * Enable positional options. Positional means global options are specified before subcommands which lets
   * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.
   * The default behaviour is non-positional and global options may appear anywhere on the command line.
   *
   * @param {Boolean} [positional=true]
   */
  enablePositionalOptions(positional = true) {
    this._enablePositionalOptions = !!positional;
    return this;
  }

  /**
   * Pass through options that come after command-arguments rather than treat them as command-options,
   * so actual command-options come before command-arguments. Turning this on for a subcommand requires
   * positional options to have been enabled on the program (parent commands).
   * The default behaviour is non-positional and options may appear before or after command-arguments.
   *
   * @param {Boolean} [passThrough=true]
   * for unknown options.
   */
  passThroughOptions(passThrough = true) {
    this._passThroughOptions = !!passThrough;
    if (!!this.parent && passThrough && !this.parent._enablePositionalOptions) {
      throw new Error('passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)');
    }
    return this;
  }

  /**
    * Whether to store option values as properties on command object,
    * or store separately (specify false). In both cases the option values can be accessed using .opts().
    *
    * @param {boolean} [storeAsProperties=true]
    * @return {Command} `this` command for chaining
    */

  storeOptionsAsProperties(storeAsProperties = true) {
    this._storeOptionsAsProperties = !!storeAsProperties;
    if (this.options.length) {
      throw new Error('call .storeOptionsAsProperties() before adding options');
    }
    return this;
  }

  /**
   * Retrieve option value.
   *
   * @param {string} key
   * @return {Object} value
   */

  getOptionValue(key) {
    if (this._storeOptionsAsProperties) {
      return this[key];
    }
    return this._optionValues[key];
  }

  /**
   * Store option value.
   *
   * @param {string} key
   * @param {Object} value
   * @return {Command} `this` command for chaining
   */

  setOptionValue(key, value) {
    return this.setOptionValueWithSource(key, value, undefined);
  }

  /**
    * Store option value and where the value came from.
    *
    * @param {string} key
    * @param {Object} value
    * @param {string} source - expected values are default/config/env/cli/implied
    * @return {Command} `this` command for chaining
    */

  setOptionValueWithSource(key, value, source) {
    if (this._storeOptionsAsProperties) {
      this[key] = value;
    } else {
      this._optionValues[key] = value;
    }
    this._optionValueSources[key] = source;
    return this;
  }

  /**
    * Get source of option value.
    * Expected values are default | config | env | cli | implied
    *
    * @param {string} key
    * @return {string}
    */

  getOptionValueSource(key) {
    return this._optionValueSources[key];
  }

  /**
    * Get source of option value. See also .optsWithGlobals().
    * Expected values are default | config | env | cli | implied
    *
    * @param {string} key
    * @return {string}
    */

  getOptionValueSourceWithGlobals(key) {
    // global overwrites local, like optsWithGlobals
    let source;
    getCommandAndParents(this).forEach(cmd => {
      if (cmd.getOptionValueSource(key) !== undefined) {
        source = cmd.getOptionValueSource(key);
      }
    });
    return source;
  }

  /**
   * Get user arguments from implied or explicit arguments.
   * Side-effects: set _scriptPath if args included script. Used for default program name, and subcommand searches.
   *
   * @api private
   */

  _prepareUserArgs(argv, parseOptions) {
    if (argv !== undefined && !Array.isArray(argv)) {
      throw new Error('first parameter to parse must be array or undefined');
    }
    parseOptions = parseOptions || {};

    // Default to using process.argv
    if (argv === undefined) {
      argv = process.argv;
      // @ts-ignore: unknown property
      if (process.versions && process.versions.electron) {
        parseOptions.from = 'electron';
      }
    }
    this.rawArgs = argv.slice();

    // make it a little easier for callers by supporting various argv conventions
    let userArgs;
    switch (parseOptions.from) {
      case undefined:
      case 'node':
        this._scriptPath = argv[1];
        userArgs = argv.slice(2);
        break;
      case 'electron':
        // @ts-ignore: unknown property
        if (process.defaultApp) {
          this._scriptPath = argv[1];
          userArgs = argv.slice(2);
        } else {
          userArgs = argv.slice(1);
        }
        break;
      case 'user':
        userArgs = argv.slice(0);
        break;
      default:
        throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);
    }

    // Find default name for program from arguments.
    if (!this._name && this._scriptPath) this.nameFromFilename(this._scriptPath);
    this._name = this._name || 'program';
    return userArgs;
  }

  /**
   * Parse `argv`, setting options and invoking commands when defined.
   *
   * The default expectation is that the arguments are from node and have the application as argv[0]
   * and the script being run in argv[1], with user parameters after that.
   *
   * @example
   * program.parse(process.argv);
   * program.parse(); // implicitly use process.argv and auto-detect node vs electron conventions
   * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
   *
   * @param {string[]} [argv] - optional, defaults to process.argv
   * @param {Object} [parseOptions] - optionally specify style of options with from: node/user/electron
   * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'
   * @return {Command} `this` command for chaining
   */

  parse(argv, parseOptions) {
    const userArgs = this._prepareUserArgs(argv, parseOptions);
    this._parseCommand([], userArgs);
    return this;
  }

  /**
   * Parse `argv`, setting options and invoking commands when defined.
   *
   * Use parseAsync instead of parse if any of your action handlers are async. Returns a Promise.
   *
   * The default expectation is that the arguments are from node and have the application as argv[0]
   * and the script being run in argv[1], with user parameters after that.
   *
   * @example
   * await program.parseAsync(process.argv);
   * await program.parseAsync(); // implicitly use process.argv and auto-detect node vs electron conventions
   * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
   *
   * @param {string[]} [argv]
   * @param {Object} [parseOptions]
   * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'
   * @return {Promise}
   */

  async parseAsync(argv, parseOptions) {
    const userArgs = this._prepareUserArgs(argv, parseOptions);
    await this._parseCommand([], userArgs);
    return this;
  }

  /**
   * Execute a sub-command executable.
   *
   * @api private
   */

  _executeSubCommand(subcommand, args) {
    args = args.slice();
    let launchWithNode = false; // Use node for source targets so do not need to get permissions correct, and on Windows.
    const sourceExt = ['.js', '.ts', '.tsx', '.mjs', '.cjs'];
    function findFile(baseDir, baseName) {
      // Look for specified file
      const localBin = path.resolve(baseDir, baseName);
      if (fs.existsSync(localBin)) return localBin;

      // Stop looking if candidate already has an expected extension.
      if (sourceExt.includes(path.extname(baseName))) return undefined;

      // Try all the extensions.
      const foundExt = sourceExt.find(ext => fs.existsSync(`${localBin}${ext}`));
      if (foundExt) return `${localBin}${foundExt}`;
      return undefined;
    }

    // Not checking for help first. Unlikely to have mandatory and executable, and can't robustly test for help flags in external command.
    this._checkForMissingMandatoryOptions();
    this._checkForConflictingOptions();

    // executableFile and executableDir might be full path, or just a name
    let executableFile = subcommand._executableFile || `${this._name}-${subcommand._name}`;
    let executableDir = this._executableDir || '';
    if (this._scriptPath) {
      let resolvedScriptPath; // resolve possible symlink for installed npm binary
      try {
        resolvedScriptPath = fs.realpathSync(this._scriptPath);
      } catch (err) {
        resolvedScriptPath = this._scriptPath;
      }
      executableDir = path.resolve(path.dirname(resolvedScriptPath), executableDir);
    }

    // Look for a local file in preference to a command in PATH.
    if (executableDir) {
      let localFile = findFile(executableDir, executableFile);

      // Legacy search using prefix of script name instead of command name
      if (!localFile && !subcommand._executableFile && this._scriptPath) {
        const legacyName = path.basename(this._scriptPath, path.extname(this._scriptPath));
        if (legacyName !== this._name) {
          localFile = findFile(executableDir, `${legacyName}-${subcommand._name}`);
        }
      }
      executableFile = localFile || executableFile;
    }
    launchWithNode = sourceExt.includes(path.extname(executableFile));
    let proc;
    if (process.platform !== 'win32') {
      if (launchWithNode) {
        args.unshift(executableFile);
        // add executable arguments to spawn
        args = incrementNodeInspectorPort(process.execArgv).concat(args);
        proc = childProcess.spawn(process.argv[0], args, {
          stdio: 'inherit'
        });
      } else {
        proc = childProcess.spawn(executableFile, args, {
          stdio: 'inherit'
        });
      }
    } else {
      args.unshift(executableFile);
      // add executable arguments to spawn
      args = incrementNodeInspectorPort(process.execArgv).concat(args);
      proc = childProcess.spawn(process.execPath, args, {
        stdio: 'inherit'
      });
    }
    if (!proc.killed) {
      // testing mainly to avoid leak warnings during unit tests with mocked spawn
      const signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];
      signals.forEach(signal => {
        // @ts-ignore
        process.on(signal, () => {
          if (proc.killed === false && proc.exitCode === null) {
            proc.kill(signal);
          }
        });
      });
    }

    // By default terminate process when spawned process terminates.
    // Suppressing the exit if exitCallback defined is a bit messy and of limited use, but does allow process to stay running!
    const exitCallback = this._exitCallback;
    if (!exitCallback) {
      proc.on('close', process.exit.bind(process));
    } else {
      proc.on('close', () => {
        exitCallback(new CommanderError(process.exitCode || 0, 'commander.executeSubCommandAsync', '(close)'));
      });
    }
    proc.on('error', err => {
      // @ts-ignore
      if (err.code === 'ENOENT') {
        const executableDirMessage = executableDir ? `searched for local subcommand relative to directory '${executableDir}'` : 'no directory for search for local subcommand, use .executableDir() to supply a custom directory';
        const executableMissing = `'${executableFile}' does not exist
 - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${executableDirMessage}`;
        throw new Error(executableMissing);
        // @ts-ignore
      } else if (err.code === 'EACCES') {
        throw new Error(`'${executableFile}' not executable`);
      }
      if (!exitCallback) {
        process.exit(1);
      } else {
        const wrappedError = new CommanderError(1, 'commander.executeSubCommandAsync', '(error)');
        wrappedError.nestedError = err;
        exitCallback(wrappedError);
      }
    });

    // Store the reference to the child process
    this.runningCommand = proc;
  }

  /**
   * @api private
   */

  _dispatchSubcommand(commandName, operands, unknown) {
    const subCommand = this._findCommand(commandName);
    if (!subCommand) this.help({
      error: true
    });
    let hookResult;
    hookResult = this._chainOrCallSubCommandHook(hookResult, subCommand, 'preSubcommand');
    hookResult = this._chainOrCall(hookResult, () => {
      if (subCommand._executableHandler) {
        this._executeSubCommand(subCommand, operands.concat(unknown));
      } else {
        return subCommand._parseCommand(operands, unknown);
      }
    });
    return hookResult;
  }

  /**
   * Check this.args against expected this._args.
   *
   * @api private
   */

  _checkNumberOfArguments() {
    // too few
    this._args.forEach((arg, i) => {
      if (arg.required && this.args[i] == null) {
        this.missingArgument(arg.name());
      }
    });
    // too many
    if (this._args.length > 0 && this._args[this._args.length - 1].variadic) {
      return;
    }
    if (this.args.length > this._args.length) {
      this._excessArguments(this.args);
    }
  }

  /**
   * Process this.args using this._args and save as this.processedArgs!
   *
   * @api private
   */

  _processArguments() {
    const myParseArg = (argument, value, previous) => {
      // Extra processing for nice error message on parsing failure.
      let parsedValue = value;
      if (value !== null && argument.parseArg) {
        try {
          parsedValue = argument.parseArg(value, previous);
        } catch (err) {
          if (err.code === 'commander.invalidArgument') {
            const message = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'. ${err.message}`;
            this.error(message, {
              exitCode: err.exitCode,
              code: err.code
            });
          }
          throw err;
        }
      }
      return parsedValue;
    };
    this._checkNumberOfArguments();
    const processedArgs = [];
    this._args.forEach((declaredArg, index) => {
      let value = declaredArg.defaultValue;
      if (declaredArg.variadic) {
        // Collect together remaining arguments for passing together as an array.
        if (index < this.args.length) {
          value = this.args.slice(index);
          if (declaredArg.parseArg) {
            value = value.reduce((processed, v) => {
              return myParseArg(declaredArg, v, processed);
            }, declaredArg.defaultValue);
          }
        } else if (value === undefined) {
          value = [];
        }
      } else if (index < this.args.length) {
        value = this.args[index];
        if (declaredArg.parseArg) {
          value = myParseArg(declaredArg, value, declaredArg.defaultValue);
        }
      }
      processedArgs[index] = value;
    });
    this.processedArgs = processedArgs;
  }

  /**
   * Once we have a promise we chain, but call synchronously until then.
   *
   * @param {Promise|undefined} promise
   * @param {Function} fn
   * @return {Promise|undefined}
   * @api private
   */

  _chainOrCall(promise, fn) {
    // thenable
    if (promise && promise.then && typeof promise.then === 'function') {
      // already have a promise, chain callback
      return promise.then(() => fn());
    }
    // callback might return a promise
    return fn();
  }

  /**
   *
   * @param {Promise|undefined} promise
   * @param {string} event
   * @return {Promise|undefined}
   * @api private
   */

  _chainOrCallHooks(promise, event) {
    let result = promise;
    const hooks = [];
    getCommandAndParents(this).reverse().filter(cmd => cmd._lifeCycleHooks[event] !== undefined).forEach(hookedCommand => {
      hookedCommand._lifeCycleHooks[event].forEach(callback => {
        hooks.push({
          hookedCommand,
          callback
        });
      });
    });
    if (event === 'postAction') {
      hooks.reverse();
    }
    hooks.forEach(hookDetail => {
      result = this._chainOrCall(result, () => {
        return hookDetail.callback(hookDetail.hookedCommand, this);
      });
    });
    return result;
  }

  /**
   *
   * @param {Promise|undefined} promise
   * @param {Command} subCommand
   * @param {string} event
   * @return {Promise|undefined}
   * @api private
   */

  _chainOrCallSubCommandHook(promise, subCommand, event) {
    let result = promise;
    if (this._lifeCycleHooks[event] !== undefined) {
      this._lifeCycleHooks[event].forEach(hook => {
        result = this._chainOrCall(result, () => {
          return hook(this, subCommand);
        });
      });
    }
    return result;
  }

  /**
   * Process arguments in context of this command.
   * Returns action result, in case it is a promise.
   *
   * @api private
   */

  _parseCommand(operands, unknown) {
    const parsed = this.parseOptions(unknown);
    this._parseOptionsEnv(); // after cli, so parseArg not called on both cli and env
    this._parseOptionsImplied();
    operands = operands.concat(parsed.operands);
    unknown = parsed.unknown;
    this.args = operands.concat(unknown);
    if (operands && this._findCommand(operands[0])) {
      return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
    }
    if (this._hasImplicitHelpCommand() && operands[0] === this._helpCommandName) {
      if (operands.length === 1) {
        this.help();
      }
      return this._dispatchSubcommand(operands[1], [], [this._helpLongFlag]);
    }
    if (this._defaultCommandName) {
      outputHelpIfRequested(this, unknown); // Run the help for default command from parent rather than passing to default command
      return this._dispatchSubcommand(this._defaultCommandName, operands, unknown);
    }
    if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {
      // probably missing subcommand and no handler, user needs help (and exit)
      this.help({
        error: true
      });
    }
    outputHelpIfRequested(this, parsed.unknown);
    this._checkForMissingMandatoryOptions();
    this._checkForConflictingOptions();

    // We do not always call this check to avoid masking a "better" error, like unknown command.
    const checkForUnknownOptions = () => {
      if (parsed.unknown.length > 0) {
        this.unknownOption(parsed.unknown[0]);
      }
    };
    const commandEvent = `command:${this.name()}`;
    if (this._actionHandler) {
      checkForUnknownOptions();
      this._processArguments();
      let actionResult;
      actionResult = this._chainOrCallHooks(actionResult, 'preAction');
      actionResult = this._chainOrCall(actionResult, () => this._actionHandler(this.processedArgs));
      if (this.parent) {
        actionResult = this._chainOrCall(actionResult, () => {
          this.parent.emit(commandEvent, operands, unknown); // legacy
        });
      }

      actionResult = this._chainOrCallHooks(actionResult, 'postAction');
      return actionResult;
    }
    if (this.parent && this.parent.listenerCount(commandEvent)) {
      checkForUnknownOptions();
      this._processArguments();
      this.parent.emit(commandEvent, operands, unknown); // legacy
    } else if (operands.length) {
      if (this._findCommand('*')) {
        // legacy default command
        return this._dispatchSubcommand('*', operands, unknown);
      }
      if (this.listenerCount('command:*')) {
        // skip option check, emit event for possible misspelling suggestion
        this.emit('command:*', operands, unknown);
      } else if (this.commands.length) {
        this.unknownCommand();
      } else {
        checkForUnknownOptions();
        this._processArguments();
      }
    } else if (this.commands.length) {
      checkForUnknownOptions();
      // This command has subcommands and nothing hooked up at this level, so display help (and exit).
      this.help({
        error: true
      });
    } else {
      checkForUnknownOptions();
      this._processArguments();
      // fall through for caller to handle after calling .parse()
    }
  }

  /**
   * Find matching command.
   *
   * @api private
   */
  _findCommand(name) {
    if (!name) return undefined;
    return this.commands.find(cmd => cmd._name === name || cmd._aliases.includes(name));
  }

  /**
   * Return an option matching `arg` if any.
   *
   * @param {string} arg
   * @return {Option}
   * @api private
   */

  _findOption(arg) {
    return this.options.find(option => option.is(arg));
  }

  /**
   * Display an error message if a mandatory option does not have a value.
   * Called after checking for help flags in leaf subcommand.
   *
   * @api private
   */

  _checkForMissingMandatoryOptions() {
    // Walk up hierarchy so can call in subcommand after checking for displaying help.
    for (let cmd = this; cmd; cmd = cmd.parent) {
      cmd.options.forEach(anOption => {
        if (anOption.mandatory && cmd.getOptionValue(anOption.attributeName()) === undefined) {
          cmd.missingMandatoryOptionValue(anOption);
        }
      });
    }
  }

  /**
   * Display an error message if conflicting options are used together in this.
   *
   * @api private
   */
  _checkForConflictingLocalOptions() {
    const definedNonDefaultOptions = this.options.filter(option => {
      const optionKey = option.attributeName();
      if (this.getOptionValue(optionKey) === undefined) {
        return false;
      }
      return this.getOptionValueSource(optionKey) !== 'default';
    });
    const optionsWithConflicting = definedNonDefaultOptions.filter(option => option.conflictsWith.length > 0);
    optionsWithConflicting.forEach(option => {
      const conflictingAndDefined = definedNonDefaultOptions.find(defined => option.conflictsWith.includes(defined.attributeName()));
      if (conflictingAndDefined) {
        this._conflictingOption(option, conflictingAndDefined);
      }
    });
  }

  /**
   * Display an error message if conflicting options are used together.
   * Called after checking for help flags in leaf subcommand.
   *
   * @api private
   */
  _checkForConflictingOptions() {
    // Walk up hierarchy so can call in subcommand after checking for displaying help.
    for (let cmd = this; cmd; cmd = cmd.parent) {
      cmd._checkForConflictingLocalOptions();
    }
  }

  /**
   * Parse options from `argv` removing known options,
   * and return argv split into operands and unknown arguments.
   *
   * Examples:
   *
   *     argv => operands, unknown
   *     --known kkk op => [op], []
   *     op --known kkk => [op], []
   *     sub --unknown uuu op => [sub], [--unknown uuu op]
   *     sub -- --unknown uuu op => [sub --unknown uuu op], []
   *
   * @param {String[]} argv
   * @return {{operands: String[], unknown: String[]}}
   */

  parseOptions(argv) {
    const operands = []; // operands, not options or values
    const unknown = []; // first unknown option and remaining unknown args
    let dest = operands;
    const args = argv.slice();
    function maybeOption(arg) {
      return arg.length > 1 && arg[0] === '-';
    }

    // parse options
    let activeVariadicOption = null;
    while (args.length) {
      const arg = args.shift();

      // literal
      if (arg === '--') {
        if (dest === unknown) dest.push(arg);
        dest.push(...args);
        break;
      }
      if (activeVariadicOption && !maybeOption(arg)) {
        this.emit(`option:${activeVariadicOption.name()}`, arg);
        continue;
      }
      activeVariadicOption = null;
      if (maybeOption(arg)) {
        const option = this._findOption(arg);
        // recognised option, call listener to assign value with possible custom processing
        if (option) {
          if (option.required) {
            const value = args.shift();
            if (value === undefined) this.optionMissingArgument(option);
            this.emit(`option:${option.name()}`, value);
          } else if (option.optional) {
            let value = null;
            // historical behaviour is optional value is following arg unless an option
            if (args.length > 0 && !maybeOption(args[0])) {
              value = args.shift();
            }
            this.emit(`option:${option.name()}`, value);
          } else {
            // boolean flag
            this.emit(`option:${option.name()}`);
          }
          activeVariadicOption = option.variadic ? option : null;
          continue;
        }
      }

      // Look for combo options following single dash, eat first one if known.
      if (arg.length > 2 && arg[0] === '-' && arg[1] !== '-') {
        const option = this._findOption(`-${arg[1]}`);
        if (option) {
          if (option.required || option.optional && this._combineFlagAndOptionalValue) {
            // option with value following in same argument
            this.emit(`option:${option.name()}`, arg.slice(2));
          } else {
            // boolean option, emit and put back remainder of arg for further processing
            this.emit(`option:${option.name()}`);
            args.unshift(`-${arg.slice(2)}`);
          }
          continue;
        }
      }

      // Look for known long flag with value, like --foo=bar
      if (/^--[^=]+=/.test(arg)) {
        const index = arg.indexOf('=');
        const option = this._findOption(arg.slice(0, index));
        if (option && (option.required || option.optional)) {
          this.emit(`option:${option.name()}`, arg.slice(index + 1));
          continue;
        }
      }

      // Not a recognised option by this command.
      // Might be a command-argument, or subcommand option, or unknown option, or help command or option.

      // An unknown option means further arguments also classified as unknown so can be reprocessed by subcommands.
      if (maybeOption(arg)) {
        dest = unknown;
      }

      // If using positionalOptions, stop processing our options at subcommand.
      if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {
        if (this._findCommand(arg)) {
          operands.push(arg);
          if (args.length > 0) unknown.push(...args);
          break;
        } else if (arg === this._helpCommandName && this._hasImplicitHelpCommand()) {
          operands.push(arg);
          if (args.length > 0) operands.push(...args);
          break;
        } else if (this._defaultCommandName) {
          unknown.push(arg);
          if (args.length > 0) unknown.push(...args);
          break;
        }
      }

      // If using passThroughOptions, stop processing options at first command-argument.
      if (this._passThroughOptions) {
        dest.push(arg);
        if (args.length > 0) dest.push(...args);
        break;
      }

      // add arg
      dest.push(arg);
    }
    return {
      operands,
      unknown
    };
  }

  /**
   * Return an object containing local option values as key-value pairs.
   *
   * @return {Object}
   */
  opts() {
    if (this._storeOptionsAsProperties) {
      // Preserve original behaviour so backwards compatible when still using properties
      const result = {};
      const len = this.options.length;
      for (let i = 0; i < len; i++) {
        const key = this.options[i].attributeName();
        result[key] = key === this._versionOptionName ? this._version : this[key];
      }
      return result;
    }
    return this._optionValues;
  }

  /**
   * Return an object containing merged local and global option values as key-value pairs.
   *
   * @return {Object}
   */
  optsWithGlobals() {
    // globals overwrite locals
    return getCommandAndParents(this).reduce((combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()), {});
  }

  /**
   * Display error message and exit (or call exitOverride).
   *
   * @param {string} message
   * @param {Object} [errorOptions]
   * @param {string} [errorOptions.code] - an id string representing the error
   * @param {number} [errorOptions.exitCode] - used with process.exit
   */
  error(message, errorOptions) {
    // output handling
    this._outputConfiguration.outputError(`${message}\n`, this._outputConfiguration.writeErr);
    if (typeof this._showHelpAfterError === 'string') {
      this._outputConfiguration.writeErr(`${this._showHelpAfterError}\n`);
    } else if (this._showHelpAfterError) {
      this._outputConfiguration.writeErr('\n');
      this.outputHelp({
        error: true
      });
    }

    // exit handling
    const config = errorOptions || {};
    const exitCode = config.exitCode || 1;
    const code = config.code || 'commander.error';
    this._exit(exitCode, code, message);
  }

  /**
   * Apply any option related environment variables, if option does
   * not have a value from cli or client code.
   *
   * @api private
   */
  _parseOptionsEnv() {
    this.options.forEach(option => {
      if (option.envVar && option.envVar in process.env) {
        const optionKey = option.attributeName();
        // Priority check. Do not overwrite cli or options from unknown source (client-code).
        if (this.getOptionValue(optionKey) === undefined || ['default', 'config', 'env'].includes(this.getOptionValueSource(optionKey))) {
          if (option.required || option.optional) {
            // option can take a value
            // keep very simple, optional always takes value
            this.emit(`optionEnv:${option.name()}`, process.env[option.envVar]);
          } else {
            // boolean
            // keep very simple, only care that envVar defined and not the value
            this.emit(`optionEnv:${option.name()}`);
          }
        }
      }
    });
  }

  /**
   * Apply any implied option values, if option is undefined or default value.
   *
   * @api private
   */
  _parseOptionsImplied() {
    const dualHelper = new DualOptions(this.options);
    const hasCustomOptionValue = optionKey => {
      return this.getOptionValue(optionKey) !== undefined && !['default', 'implied'].includes(this.getOptionValueSource(optionKey));
    };
    this.options.filter(option => option.implied !== undefined && hasCustomOptionValue(option.attributeName()) && dualHelper.valueFromOption(this.getOptionValue(option.attributeName()), option)).forEach(option => {
      Object.keys(option.implied).filter(impliedKey => !hasCustomOptionValue(impliedKey)).forEach(impliedKey => {
        this.setOptionValueWithSource(impliedKey, option.implied[impliedKey], 'implied');
      });
    });
  }

  /**
   * Argument `name` is missing.
   *
   * @param {string} name
   * @api private
   */

  missingArgument(name) {
    const message = `error: missing required argument '${name}'`;
    this.error(message, {
      code: 'commander.missingArgument'
    });
  }

  /**
   * `Option` is missing an argument.
   *
   * @param {Option} option
   * @api private
   */

  optionMissingArgument(option) {
    const message = `error: option '${option.flags}' argument missing`;
    this.error(message, {
      code: 'commander.optionMissingArgument'
    });
  }

  /**
   * `Option` does not have a value, and is a mandatory option.
   *
   * @param {Option} option
   * @api private
   */

  missingMandatoryOptionValue(option) {
    const message = `error: required option '${option.flags}' not specified`;
    this.error(message, {
      code: 'commander.missingMandatoryOptionValue'
    });
  }

  /**
   * `Option` conflicts with another option.
   *
   * @param {Option} option
   * @param {Option} conflictingOption
   * @api private
   */
  _conflictingOption(option, conflictingOption) {
    // The calling code does not know whether a negated option is the source of the
    // value, so do some work to take an educated guess.
    const findBestOptionFromValue = option => {
      const optionKey = option.attributeName();
      const optionValue = this.getOptionValue(optionKey);
      const negativeOption = this.options.find(target => target.negate && optionKey === target.attributeName());
      const positiveOption = this.options.find(target => !target.negate && optionKey === target.attributeName());
      if (negativeOption && (negativeOption.presetArg === undefined && optionValue === false || negativeOption.presetArg !== undefined && optionValue === negativeOption.presetArg)) {
        return negativeOption;
      }
      return positiveOption || option;
    };
    const getErrorMessage = option => {
      const bestOption = findBestOptionFromValue(option);
      const optionKey = bestOption.attributeName();
      const source = this.getOptionValueSource(optionKey);
      if (source === 'env') {
        return `environment variable '${bestOption.envVar}'`;
      }
      return `option '${bestOption.flags}'`;
    };
    const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;
    this.error(message, {
      code: 'commander.conflictingOption'
    });
  }

  /**
   * Unknown option `flag`.
   *
   * @param {string} flag
   * @api private
   */

  unknownOption(flag) {
    if (this._allowUnknownOption) return;
    let suggestion = '';
    if (flag.startsWith('--') && this._showSuggestionAfterError) {
      // Looping to pick up the global options too
      let candidateFlags = [];
      let command = this;
      do {
        const moreFlags = command.createHelp().visibleOptions(command).filter(option => option.long).map(option => option.long);
        candidateFlags = candidateFlags.concat(moreFlags);
        command = command.parent;
      } while (command && !command._enablePositionalOptions);
      suggestion = suggestSimilar(flag, candidateFlags);
    }
    const message = `error: unknown option '${flag}'${suggestion}`;
    this.error(message, {
      code: 'commander.unknownOption'
    });
  }

  /**
   * Excess arguments, more than expected.
   *
   * @param {string[]} receivedArgs
   * @api private
   */

  _excessArguments(receivedArgs) {
    if (this._allowExcessArguments) return;
    const expected = this._args.length;
    const s = expected === 1 ? '' : 's';
    const forSubcommand = this.parent ? ` for '${this.name()}'` : '';
    const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;
    this.error(message, {
      code: 'commander.excessArguments'
    });
  }

  /**
   * Unknown command.
   *
   * @api private
   */

  unknownCommand() {
    const unknownName = this.args[0];
    let suggestion = '';
    if (this._showSuggestionAfterError) {
      const candidateNames = [];
      this.createHelp().visibleCommands(this).forEach(command => {
        candidateNames.push(command.name());
        // just visible alias
        if (command.alias()) candidateNames.push(command.alias());
      });
      suggestion = suggestSimilar(unknownName, candidateNames);
    }
    const message = `error: unknown command '${unknownName}'${suggestion}`;
    this.error(message, {
      code: 'commander.unknownCommand'
    });
  }

  /**
   * Set the program version to `str`.
   *
   * This method auto-registers the "-V, --version" flag
   * which will print the version number when passed.
   *
   * You can optionally supply the  flags and description to override the defaults.
   *
   * @param {string} str
   * @param {string} [flags]
   * @param {string} [description]
   * @return {this | string} `this` command for chaining, or version string if no arguments
   */

  version(str, flags, description) {
    if (str === undefined) return this._version;
    this._version = str;
    flags = flags || '-V, --version';
    description = description || 'output the version number';
    const versionOption = this.createOption(flags, description);
    this._versionOptionName = versionOption.attributeName();
    this.options.push(versionOption);
    this.on('option:' + versionOption.name(), () => {
      this._outputConfiguration.writeOut(`${str}\n`);
      this._exit(0, 'commander.version', str);
    });
    return this;
  }

  /**
   * Set the description.
   *
   * @param {string} [str]
   * @param {Object} [argsDescription]
   * @return {string|Command}
   */
  description(str, argsDescription) {
    if (str === undefined && argsDescription === undefined) return this._description;
    this._description = str;
    if (argsDescription) {
      this._argsDescription = argsDescription;
    }
    return this;
  }

  /**
   * Set the summary. Used when listed as subcommand of parent.
   *
   * @param {string} [str]
   * @return {string|Command}
   */
  summary(str) {
    if (str === undefined) return this._summary;
    this._summary = str;
    return this;
  }

  /**
   * Set an alias for the command.
   *
   * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.
   *
   * @param {string} [alias]
   * @return {string|Command}
   */

  alias(alias) {
    if (alias === undefined) return this._aliases[0]; // just return first, for backwards compatibility

    /** @type {Command} */
    let command = this;
    if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {
      // assume adding alias for last added executable subcommand, rather than this
      command = this.commands[this.commands.length - 1];
    }
    if (alias === command._name) throw new Error('Command alias can\'t be the same as its name');
    command._aliases.push(alias);
    return this;
  }

  /**
   * Set aliases for the command.
   *
   * Only the first alias is shown in the auto-generated help.
   *
   * @param {string[]} [aliases]
   * @return {string[]|Command}
   */

  aliases(aliases) {
    // Getter for the array of aliases is the main reason for having aliases() in addition to alias().
    if (aliases === undefined) return this._aliases;
    aliases.forEach(alias => this.alias(alias));
    return this;
  }

  /**
   * Set / get the command usage `str`.
   *
   * @param {string} [str]
   * @return {String|Command}
   */

  usage(str) {
    if (str === undefined) {
      if (this._usage) return this._usage;
      const args = this._args.map(arg => {
        return humanReadableArgName(arg);
      });
      return [].concat(this.options.length || this._hasHelpOption ? '[options]' : [], this.commands.length ? '[command]' : [], this._args.length ? args : []).join(' ');
    }
    this._usage = str;
    return this;
  }

  /**
   * Get or set the name of the command.
   *
   * @param {string} [str]
   * @return {string|Command}
   */

  name(str) {
    if (str === undefined) return this._name;
    this._name = str;
    return this;
  }

  /**
   * Set the name of the command from script filename, such as process.argv[1],
   * or require.main.filename, or __filename.
   *
   * (Used internally and public although not documented in README.)
   *
   * @example
   * program.nameFromFilename(require.main.filename);
   *
   * @param {string} filename
   * @return {Command}
   */

  nameFromFilename(filename) {
    this._name = path.basename(filename, path.extname(filename));
    return this;
  }

  /**
   * Get or set the directory for searching for executable subcommands of this command.
   *
   * @example
   * program.executableDir(__dirname);
   * // or
   * program.executableDir('subcommands');
   *
   * @param {string} [path]
   * @return {string|Command}
   */

  executableDir(path) {
    if (path === undefined) return this._executableDir;
    this._executableDir = path;
    return this;
  }

  /**
   * Return program help documentation.
   *
   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout
   * @return {string}
   */

  helpInformation(contextOptions) {
    const helper = this.createHelp();
    if (helper.helpWidth === undefined) {
      helper.helpWidth = contextOptions && contextOptions.error ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();
    }
    return helper.formatHelp(this, helper);
  }

  /**
   * @api private
   */

  _getHelpContext(contextOptions) {
    contextOptions = contextOptions || {};
    const context = {
      error: !!contextOptions.error
    };
    let write;
    if (context.error) {
      write = arg => this._outputConfiguration.writeErr(arg);
    } else {
      write = arg => this._outputConfiguration.writeOut(arg);
    }
    context.write = contextOptions.write || write;
    context.command = this;
    return context;
  }

  /**
   * Output help information for this command.
   *
   * Outputs built-in help, and custom text added using `.addHelpText()`.
   *
   * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout
   */

  outputHelp(contextOptions) {
    let deprecatedCallback;
    if (typeof contextOptions === 'function') {
      deprecatedCallback = contextOptions;
      contextOptions = undefined;
    }
    const context = this._getHelpContext(contextOptions);
    getCommandAndParents(this).reverse().forEach(command => command.emit('beforeAllHelp', context));
    this.emit('beforeHelp', context);
    let helpInformation = this.helpInformation(context);
    if (deprecatedCallback) {
      helpInformation = deprecatedCallback(helpInformation);
      if (typeof helpInformation !== 'string' && !Buffer.isBuffer(helpInformation)) {
        throw new Error('outputHelp callback must return a string or a Buffer');
      }
    }
    context.write(helpInformation);
    this.emit(this._helpLongFlag); // deprecated
    this.emit('afterHelp', context);
    getCommandAndParents(this).forEach(command => command.emit('afterAllHelp', context));
  }

  /**
   * You can pass in flags and a description to override the help
   * flags and help description for your command. Pass in false to
   * disable the built-in help option.
   *
   * @param {string | boolean} [flags]
   * @param {string} [description]
   * @return {Command} `this` command for chaining
   */

  helpOption(flags, description) {
    if (typeof flags === 'boolean') {
      this._hasHelpOption = flags;
      return this;
    }
    this._helpFlags = flags || this._helpFlags;
    this._helpDescription = description || this._helpDescription;
    const helpFlags = splitOptionFlags(this._helpFlags);
    this._helpShortFlag = helpFlags.shortFlag;
    this._helpLongFlag = helpFlags.longFlag;
    return this;
  }

  /**
   * Output help information and exit.
   *
   * Outputs built-in help, and custom text added using `.addHelpText()`.
   *
   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout
   */

  help(contextOptions) {
    this.outputHelp(contextOptions);
    let exitCode = process.exitCode || 0;
    if (exitCode === 0 && contextOptions && typeof contextOptions !== 'function' && contextOptions.error) {
      exitCode = 1;
    }
    // message: do not have all displayed text available so only passing placeholder.
    this._exit(exitCode, 'commander.help', '(outputHelp)');
  }

  /**
   * Add additional text to be displayed with the built-in help.
   *
   * Position is 'before' or 'after' to affect just this command,
   * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.
   *
   * @param {string} position - before or after built-in help
   * @param {string | Function} text - string to add, or a function returning a string
   * @return {Command} `this` command for chaining
   */
  addHelpText(position, text) {
    const allowedValues = ['beforeAll', 'before', 'after', 'afterAll'];
    if (!allowedValues.includes(position)) {
      throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
    }
    const helpEvent = `${position}Help`;
    this.on(helpEvent, context => {
      let helpStr;
      if (typeof text === 'function') {
        helpStr = text({
          error: context.error,
          command: context.command
        });
      } else {
        helpStr = text;
      }
      // Ignore falsy value when nothing to output.
      if (helpStr) {
        context.write(`${helpStr}\n`);
      }
    });
    return this;
  }
}

/**
 * Output help information if help flags specified
 *
 * @param {Command} cmd - command to output help for
 * @param {Array} args - array of options to search for help flags
 * @api private
 */

function outputHelpIfRequested(cmd, args) {
  const helpOption = cmd._hasHelpOption && args.find(arg => arg === cmd._helpLongFlag || arg === cmd._helpShortFlag);
  if (helpOption) {
    cmd.outputHelp();
    // (Do not have all displayed text available so only passing placeholder.)
    cmd._exit(0, 'commander.helpDisplayed', '(outputHelp)');
  }
}

/**
 * Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command).
 *
 * @param {string[]} args - array of arguments from node.execArgv
 * @returns {string[]}
 * @api private
 */

function incrementNodeInspectorPort(args) {
  // Testing for these options:
  //  --inspect[=[host:]port]
  //  --inspect-brk[=[host:]port]
  //  --inspect-port=[host:]port
  return args.map(arg => {
    if (!arg.startsWith('--inspect')) {
      return arg;
    }
    let debugOption;
    let debugHost = '127.0.0.1';
    let debugPort = '9229';
    let match;
    if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
      // e.g. --inspect
      debugOption = match[1];
    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
      debugOption = match[1];
      if (/^\d+$/.test(match[3])) {
        // e.g. --inspect=1234
        debugPort = match[3];
      } else {
        // e.g. --inspect=localhost
        debugHost = match[3];
      }
    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
      // e.g. --inspect=localhost:1234
      debugOption = match[1];
      debugHost = match[3];
      debugPort = match[4];
    }
    if (debugOption && debugPort !== '0') {
      return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
    }
    return arg;
  });
}

/**
 * @param {Command} startCommand
 * @returns {Command[]}
 * @api private
 */

function getCommandAndParents(startCommand) {
  const result = [];
  for (let command = startCommand; command; command = command.parent) {
    result.push(command);
  }
  return result;
}
exports.Command = Command;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJFdmVudEVtaXR0ZXIiLCJyZXF1aXJlIiwiY2hpbGRQcm9jZXNzIiwicGF0aCIsImZzIiwicHJvY2VzcyIsIkFyZ3VtZW50IiwiaHVtYW5SZWFkYWJsZUFyZ05hbWUiLCJDb21tYW5kZXJFcnJvciIsIkhlbHAiLCJPcHRpb24iLCJzcGxpdE9wdGlvbkZsYWdzIiwiRHVhbE9wdGlvbnMiLCJzdWdnZXN0U2ltaWxhciIsIkNvbW1hbmQiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJjb21tYW5kcyIsIm9wdGlvbnMiLCJwYXJlbnQiLCJfYWxsb3dVbmtub3duT3B0aW9uIiwiX2FsbG93RXhjZXNzQXJndW1lbnRzIiwiX2FyZ3MiLCJhcmdzIiwicmF3QXJncyIsInByb2Nlc3NlZEFyZ3MiLCJfc2NyaXB0UGF0aCIsIl9uYW1lIiwiX29wdGlvblZhbHVlcyIsIl9vcHRpb25WYWx1ZVNvdXJjZXMiLCJfc3RvcmVPcHRpb25zQXNQcm9wZXJ0aWVzIiwiX2FjdGlvbkhhbmRsZXIiLCJfZXhlY3V0YWJsZUhhbmRsZXIiLCJfZXhlY3V0YWJsZUZpbGUiLCJfZXhlY3V0YWJsZURpciIsIl9kZWZhdWx0Q29tbWFuZE5hbWUiLCJfZXhpdENhbGxiYWNrIiwiX2FsaWFzZXMiLCJfY29tYmluZUZsYWdBbmRPcHRpb25hbFZhbHVlIiwiX2Rlc2NyaXB0aW9uIiwiX3N1bW1hcnkiLCJfYXJnc0Rlc2NyaXB0aW9uIiwidW5kZWZpbmVkIiwiX2VuYWJsZVBvc2l0aW9uYWxPcHRpb25zIiwiX3Bhc3NUaHJvdWdoT3B0aW9ucyIsIl9saWZlQ3ljbGVIb29rcyIsIl9zaG93SGVscEFmdGVyRXJyb3IiLCJfc2hvd1N1Z2dlc3Rpb25BZnRlckVycm9yIiwiX291dHB1dENvbmZpZ3VyYXRpb24iLCJ3cml0ZU91dCIsInN0ciIsInN0ZG91dCIsIndyaXRlIiwid3JpdGVFcnIiLCJzdGRlcnIiLCJnZXRPdXRIZWxwV2lkdGgiLCJpc1RUWSIsImNvbHVtbnMiLCJnZXRFcnJIZWxwV2lkdGgiLCJvdXRwdXRFcnJvciIsIl9oaWRkZW4iLCJfaGFzSGVscE9wdGlvbiIsIl9oZWxwRmxhZ3MiLCJfaGVscERlc2NyaXB0aW9uIiwiX2hlbHBTaG9ydEZsYWciLCJfaGVscExvbmdGbGFnIiwiX2FkZEltcGxpY2l0SGVscENvbW1hbmQiLCJfaGVscENvbW1hbmROYW1lIiwiX2hlbHBDb21tYW5kbmFtZUFuZEFyZ3MiLCJfaGVscENvbW1hbmREZXNjcmlwdGlvbiIsIl9oZWxwQ29uZmlndXJhdGlvbiIsImNvcHlJbmhlcml0ZWRTZXR0aW5ncyIsInNvdXJjZUNvbW1hbmQiLCJjb21tYW5kIiwibmFtZUFuZEFyZ3MiLCJhY3Rpb25PcHRzT3JFeGVjRGVzYyIsImV4ZWNPcHRzIiwiZGVzYyIsIm9wdHMiLCJtYXRjaCIsImNtZCIsImNyZWF0ZUNvbW1hbmQiLCJkZXNjcmlwdGlvbiIsImlzRGVmYXVsdCIsIm5vSGVscCIsImhpZGRlbiIsImV4ZWN1dGFibGVGaWxlIiwiYXJndW1lbnRzIiwicHVzaCIsImNyZWF0ZUhlbHAiLCJPYmplY3QiLCJhc3NpZ24iLCJjb25maWd1cmVIZWxwIiwiY29uZmlndXJhdGlvbiIsImNvbmZpZ3VyZU91dHB1dCIsInNob3dIZWxwQWZ0ZXJFcnJvciIsImRpc3BsYXlIZWxwIiwic2hvd1N1Z2dlc3Rpb25BZnRlckVycm9yIiwiZGlzcGxheVN1Z2dlc3Rpb24iLCJhZGRDb21tYW5kIiwiRXJyb3IiLCJjcmVhdGVBcmd1bWVudCIsImFyZ3VtZW50IiwiZm4iLCJkZWZhdWx0VmFsdWUiLCJkZWZhdWx0IiwiYXJnUGFyc2VyIiwiYWRkQXJndW1lbnQiLCJuYW1lcyIsInNwbGl0IiwiZm9yRWFjaCIsImRldGFpbCIsInByZXZpb3VzQXJndW1lbnQiLCJzbGljZSIsInZhcmlhZGljIiwicmVxdWlyZWQiLCJwYXJzZUFyZyIsImFkZEhlbHBDb21tYW5kIiwiZW5hYmxlT3JOYW1lQW5kQXJncyIsIl9oYXNJbXBsaWNpdEhlbHBDb21tYW5kIiwibGVuZ3RoIiwiX2ZpbmRDb21tYW5kIiwiaG9vayIsImV2ZW50IiwibGlzdGVuZXIiLCJhbGxvd2VkVmFsdWVzIiwiaW5jbHVkZXMiLCJqb2luIiwiZXhpdE92ZXJyaWRlIiwiZXJyIiwiY29kZSIsIl9leGl0IiwiZXhpdENvZGUiLCJtZXNzYWdlIiwiZXhpdCIsImFjdGlvbiIsImV4cGVjdGVkQXJnc0NvdW50IiwiYWN0aW9uQXJncyIsImFwcGx5IiwiY3JlYXRlT3B0aW9uIiwiZmxhZ3MiLCJhZGRPcHRpb24iLCJvcHRpb24iLCJvbmFtZSIsImF0dHJpYnV0ZU5hbWUiLCJuZWdhdGUiLCJwb3NpdGl2ZUxvbmdGbGFnIiwibG9uZyIsInJlcGxhY2UiLCJfZmluZE9wdGlvbiIsInNldE9wdGlvblZhbHVlV2l0aFNvdXJjZSIsImhhbmRsZU9wdGlvblZhbHVlIiwidmFsIiwiaW52YWxpZFZhbHVlTWVzc2FnZSIsInZhbHVlU291cmNlIiwicHJlc2V0QXJnIiwib2xkVmFsdWUiLCJnZXRPcHRpb25WYWx1ZSIsImVycm9yIiwiX2NvbmNhdFZhbHVlIiwiaXNCb29sZWFuIiwib3B0aW9uYWwiLCJvbiIsImVudlZhciIsIl9vcHRpb25FeCIsImNvbmZpZyIsIm1ha2VPcHRpb25NYW5kYXRvcnkiLCJtYW5kYXRvcnkiLCJSZWdFeHAiLCJyZWdleCIsImRlZiIsIm0iLCJleGVjIiwicmVxdWlyZWRPcHRpb24iLCJjb21iaW5lRmxhZ0FuZE9wdGlvbmFsVmFsdWUiLCJjb21iaW5lIiwiYWxsb3dVbmtub3duT3B0aW9uIiwiYWxsb3dVbmtub3duIiwiYWxsb3dFeGNlc3NBcmd1bWVudHMiLCJhbGxvd0V4Y2VzcyIsImVuYWJsZVBvc2l0aW9uYWxPcHRpb25zIiwicG9zaXRpb25hbCIsInBhc3NUaHJvdWdoT3B0aW9ucyIsInBhc3NUaHJvdWdoIiwic3RvcmVPcHRpb25zQXNQcm9wZXJ0aWVzIiwic3RvcmVBc1Byb3BlcnRpZXMiLCJrZXkiLCJzZXRPcHRpb25WYWx1ZSIsInZhbHVlIiwic291cmNlIiwiZ2V0T3B0aW9uVmFsdWVTb3VyY2UiLCJnZXRPcHRpb25WYWx1ZVNvdXJjZVdpdGhHbG9iYWxzIiwiZ2V0Q29tbWFuZEFuZFBhcmVudHMiLCJfcHJlcGFyZVVzZXJBcmdzIiwiYXJndiIsInBhcnNlT3B0aW9ucyIsIkFycmF5IiwiaXNBcnJheSIsInZlcnNpb25zIiwiZWxlY3Ryb24iLCJmcm9tIiwidXNlckFyZ3MiLCJkZWZhdWx0QXBwIiwibmFtZUZyb21GaWxlbmFtZSIsInBhcnNlIiwiX3BhcnNlQ29tbWFuZCIsInBhcnNlQXN5bmMiLCJfZXhlY3V0ZVN1YkNvbW1hbmQiLCJzdWJjb21tYW5kIiwibGF1bmNoV2l0aE5vZGUiLCJzb3VyY2VFeHQiLCJmaW5kRmlsZSIsImJhc2VEaXIiLCJiYXNlTmFtZSIsImxvY2FsQmluIiwicmVzb2x2ZSIsImV4aXN0c1N5bmMiLCJleHRuYW1lIiwiZm91bmRFeHQiLCJmaW5kIiwiZXh0IiwiX2NoZWNrRm9yTWlzc2luZ01hbmRhdG9yeU9wdGlvbnMiLCJfY2hlY2tGb3JDb25mbGljdGluZ09wdGlvbnMiLCJleGVjdXRhYmxlRGlyIiwicmVzb2x2ZWRTY3JpcHRQYXRoIiwicmVhbHBhdGhTeW5jIiwiZGlybmFtZSIsImxvY2FsRmlsZSIsImxlZ2FjeU5hbWUiLCJiYXNlbmFtZSIsInByb2MiLCJwbGF0Zm9ybSIsInVuc2hpZnQiLCJpbmNyZW1lbnROb2RlSW5zcGVjdG9yUG9ydCIsImV4ZWNBcmd2IiwiY29uY2F0Iiwic3Bhd24iLCJzdGRpbyIsImV4ZWNQYXRoIiwia2lsbGVkIiwic2lnbmFscyIsInNpZ25hbCIsImtpbGwiLCJleGl0Q2FsbGJhY2siLCJiaW5kIiwiZXhlY3V0YWJsZURpck1lc3NhZ2UiLCJleGVjdXRhYmxlTWlzc2luZyIsIndyYXBwZWRFcnJvciIsIm5lc3RlZEVycm9yIiwicnVubmluZ0NvbW1hbmQiLCJfZGlzcGF0Y2hTdWJjb21tYW5kIiwiY29tbWFuZE5hbWUiLCJvcGVyYW5kcyIsInVua25vd24iLCJzdWJDb21tYW5kIiwiaGVscCIsImhvb2tSZXN1bHQiLCJfY2hhaW5PckNhbGxTdWJDb21tYW5kSG9vayIsIl9jaGFpbk9yQ2FsbCIsIl9jaGVja051bWJlck9mQXJndW1lbnRzIiwiYXJnIiwiaSIsIm1pc3NpbmdBcmd1bWVudCIsIl9leGNlc3NBcmd1bWVudHMiLCJfcHJvY2Vzc0FyZ3VtZW50cyIsIm15UGFyc2VBcmciLCJwcmV2aW91cyIsInBhcnNlZFZhbHVlIiwiZGVjbGFyZWRBcmciLCJpbmRleCIsInJlZHVjZSIsInByb2Nlc3NlZCIsInYiLCJwcm9taXNlIiwidGhlbiIsIl9jaGFpbk9yQ2FsbEhvb2tzIiwicmVzdWx0IiwiaG9va3MiLCJyZXZlcnNlIiwiZmlsdGVyIiwiaG9va2VkQ29tbWFuZCIsImNhbGxiYWNrIiwiaG9va0RldGFpbCIsInBhcnNlZCIsIl9wYXJzZU9wdGlvbnNFbnYiLCJfcGFyc2VPcHRpb25zSW1wbGllZCIsIm91dHB1dEhlbHBJZlJlcXVlc3RlZCIsImNoZWNrRm9yVW5rbm93bk9wdGlvbnMiLCJ1bmtub3duT3B0aW9uIiwiY29tbWFuZEV2ZW50IiwiYWN0aW9uUmVzdWx0IiwiZW1pdCIsImxpc3RlbmVyQ291bnQiLCJ1bmtub3duQ29tbWFuZCIsImlzIiwiYW5PcHRpb24iLCJtaXNzaW5nTWFuZGF0b3J5T3B0aW9uVmFsdWUiLCJfY2hlY2tGb3JDb25mbGljdGluZ0xvY2FsT3B0aW9ucyIsImRlZmluZWROb25EZWZhdWx0T3B0aW9ucyIsIm9wdGlvbktleSIsIm9wdGlvbnNXaXRoQ29uZmxpY3RpbmciLCJjb25mbGljdHNXaXRoIiwiY29uZmxpY3RpbmdBbmREZWZpbmVkIiwiZGVmaW5lZCIsIl9jb25mbGljdGluZ09wdGlvbiIsImRlc3QiLCJtYXliZU9wdGlvbiIsImFjdGl2ZVZhcmlhZGljT3B0aW9uIiwic2hpZnQiLCJvcHRpb25NaXNzaW5nQXJndW1lbnQiLCJ0ZXN0IiwiaW5kZXhPZiIsImxlbiIsIl92ZXJzaW9uT3B0aW9uTmFtZSIsIl92ZXJzaW9uIiwib3B0c1dpdGhHbG9iYWxzIiwiY29tYmluZWRPcHRpb25zIiwiZXJyb3JPcHRpb25zIiwib3V0cHV0SGVscCIsImVudiIsImR1YWxIZWxwZXIiLCJoYXNDdXN0b21PcHRpb25WYWx1ZSIsImltcGxpZWQiLCJ2YWx1ZUZyb21PcHRpb24iLCJrZXlzIiwiaW1wbGllZEtleSIsImNvbmZsaWN0aW5nT3B0aW9uIiwiZmluZEJlc3RPcHRpb25Gcm9tVmFsdWUiLCJvcHRpb25WYWx1ZSIsIm5lZ2F0aXZlT3B0aW9uIiwidGFyZ2V0IiwicG9zaXRpdmVPcHRpb24iLCJnZXRFcnJvck1lc3NhZ2UiLCJiZXN0T3B0aW9uIiwiZmxhZyIsInN1Z2dlc3Rpb24iLCJzdGFydHNXaXRoIiwiY2FuZGlkYXRlRmxhZ3MiLCJtb3JlRmxhZ3MiLCJ2aXNpYmxlT3B0aW9ucyIsIm1hcCIsInJlY2VpdmVkQXJncyIsImV4cGVjdGVkIiwicyIsImZvclN1YmNvbW1hbmQiLCJ1bmtub3duTmFtZSIsImNhbmRpZGF0ZU5hbWVzIiwidmlzaWJsZUNvbW1hbmRzIiwiYWxpYXMiLCJ2ZXJzaW9uIiwidmVyc2lvbk9wdGlvbiIsImFyZ3NEZXNjcmlwdGlvbiIsInN1bW1hcnkiLCJhbGlhc2VzIiwidXNhZ2UiLCJfdXNhZ2UiLCJmaWxlbmFtZSIsImhlbHBJbmZvcm1hdGlvbiIsImNvbnRleHRPcHRpb25zIiwiaGVscGVyIiwiaGVscFdpZHRoIiwiZm9ybWF0SGVscCIsIl9nZXRIZWxwQ29udGV4dCIsImNvbnRleHQiLCJkZXByZWNhdGVkQ2FsbGJhY2siLCJCdWZmZXIiLCJpc0J1ZmZlciIsImhlbHBPcHRpb24iLCJoZWxwRmxhZ3MiLCJzaG9ydEZsYWciLCJsb25nRmxhZyIsImFkZEhlbHBUZXh0IiwicG9zaXRpb24iLCJ0ZXh0IiwiaGVscEV2ZW50IiwiaGVscFN0ciIsImRlYnVnT3B0aW9uIiwiZGVidWdIb3N0IiwiZGVidWdQb3J0IiwicGFyc2VJbnQiLCJzdGFydENvbW1hbmQiLCJleHBvcnRzIl0sInNvdXJjZXMiOlsiY29tbWFuZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5jb25zdCBjaGlsZFByb2Nlc3MgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgcHJvY2VzcyA9IHJlcXVpcmUoJ3Byb2Nlc3MnKTtcblxuY29uc3QgeyBBcmd1bWVudCwgaHVtYW5SZWFkYWJsZUFyZ05hbWUgfSA9IHJlcXVpcmUoJy4vYXJndW1lbnQuanMnKTtcbmNvbnN0IHsgQ29tbWFuZGVyRXJyb3IgfSA9IHJlcXVpcmUoJy4vZXJyb3IuanMnKTtcbmNvbnN0IHsgSGVscCB9ID0gcmVxdWlyZSgnLi9oZWxwLmpzJyk7XG5jb25zdCB7IE9wdGlvbiwgc3BsaXRPcHRpb25GbGFncywgRHVhbE9wdGlvbnMgfSA9IHJlcXVpcmUoJy4vb3B0aW9uLmpzJyk7XG5jb25zdCB7IHN1Z2dlc3RTaW1pbGFyIH0gPSByZXF1aXJlKCcuL3N1Z2dlc3RTaW1pbGFyJyk7XG5cbi8vIEB0cy1jaGVja1xuXG5jbGFzcyBDb21tYW5kIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemUgYSBuZXcgYENvbW1hbmRgLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKiBAdHlwZSB7Q29tbWFuZFtdfSAqL1xuICAgIHRoaXMuY29tbWFuZHMgPSBbXTtcbiAgICAvKiogQHR5cGUge09wdGlvbltdfSAqL1xuICAgIHRoaXMub3B0aW9ucyA9IFtdO1xuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICB0aGlzLl9hbGxvd1Vua25vd25PcHRpb24gPSBmYWxzZTtcbiAgICB0aGlzLl9hbGxvd0V4Y2Vzc0FyZ3VtZW50cyA9IHRydWU7XG4gICAgLyoqIEB0eXBlIHtBcmd1bWVudFtdfSAqL1xuICAgIHRoaXMuX2FyZ3MgPSBbXTtcbiAgICAvKiogQHR5cGUge3N0cmluZ1tdfSAqL1xuICAgIHRoaXMuYXJncyA9IFtdOyAvLyBjbGkgYXJncyB3aXRoIG9wdGlvbnMgcmVtb3ZlZFxuICAgIHRoaXMucmF3QXJncyA9IFtdO1xuICAgIHRoaXMucHJvY2Vzc2VkQXJncyA9IFtdOyAvLyBsaWtlIC5hcmdzIGJ1dCBhZnRlciBjdXN0b20gcHJvY2Vzc2luZyBhbmQgY29sbGVjdGluZyB2YXJpYWRpY1xuICAgIHRoaXMuX3NjcmlwdFBhdGggPSBudWxsO1xuICAgIHRoaXMuX25hbWUgPSBuYW1lIHx8ICcnO1xuICAgIHRoaXMuX29wdGlvblZhbHVlcyA9IHt9O1xuICAgIHRoaXMuX29wdGlvblZhbHVlU291cmNlcyA9IHt9OyAvLyBkZWZhdWx0LCBlbnYsIGNsaSBldGNcbiAgICB0aGlzLl9zdG9yZU9wdGlvbnNBc1Byb3BlcnRpZXMgPSBmYWxzZTtcbiAgICB0aGlzLl9hY3Rpb25IYW5kbGVyID0gbnVsbDtcbiAgICB0aGlzLl9leGVjdXRhYmxlSGFuZGxlciA9IGZhbHNlO1xuICAgIHRoaXMuX2V4ZWN1dGFibGVGaWxlID0gbnVsbDsgLy8gY3VzdG9tIG5hbWUgZm9yIGV4ZWN1dGFibGVcbiAgICB0aGlzLl9leGVjdXRhYmxlRGlyID0gbnVsbDsgLy8gY3VzdG9tIHNlYXJjaCBkaXJlY3RvcnkgZm9yIHN1YmNvbW1hbmRzXG4gICAgdGhpcy5fZGVmYXVsdENvbW1hbmROYW1lID0gbnVsbDtcbiAgICB0aGlzLl9leGl0Q2FsbGJhY2sgPSBudWxsO1xuICAgIHRoaXMuX2FsaWFzZXMgPSBbXTtcbiAgICB0aGlzLl9jb21iaW5lRmxhZ0FuZE9wdGlvbmFsVmFsdWUgPSB0cnVlO1xuICAgIHRoaXMuX2Rlc2NyaXB0aW9uID0gJyc7XG4gICAgdGhpcy5fc3VtbWFyeSA9ICcnO1xuICAgIHRoaXMuX2FyZ3NEZXNjcmlwdGlvbiA9IHVuZGVmaW5lZDsgLy8gbGVnYWN5XG4gICAgdGhpcy5fZW5hYmxlUG9zaXRpb25hbE9wdGlvbnMgPSBmYWxzZTtcbiAgICB0aGlzLl9wYXNzVGhyb3VnaE9wdGlvbnMgPSBmYWxzZTtcbiAgICB0aGlzLl9saWZlQ3ljbGVIb29rcyA9IHt9OyAvLyBhIGhhc2ggb2YgYXJyYXlzXG4gICAgLyoqIEB0eXBlIHtib29sZWFuIHwgc3RyaW5nfSAqL1xuICAgIHRoaXMuX3Nob3dIZWxwQWZ0ZXJFcnJvciA9IGZhbHNlO1xuICAgIHRoaXMuX3Nob3dTdWdnZXN0aW9uQWZ0ZXJFcnJvciA9IHRydWU7XG5cbiAgICAvLyBzZWUgLmNvbmZpZ3VyZU91dHB1dCgpIGZvciBkb2NzXG4gICAgdGhpcy5fb3V0cHV0Q29uZmlndXJhdGlvbiA9IHtcbiAgICAgIHdyaXRlT3V0OiAoc3RyKSA9PiBwcm9jZXNzLnN0ZG91dC53cml0ZShzdHIpLFxuICAgICAgd3JpdGVFcnI6IChzdHIpID0+IHByb2Nlc3Muc3RkZXJyLndyaXRlKHN0ciksXG4gICAgICBnZXRPdXRIZWxwV2lkdGg6ICgpID0+IHByb2Nlc3Muc3Rkb3V0LmlzVFRZID8gcHJvY2Vzcy5zdGRvdXQuY29sdW1ucyA6IHVuZGVmaW5lZCxcbiAgICAgIGdldEVyckhlbHBXaWR0aDogKCkgPT4gcHJvY2Vzcy5zdGRlcnIuaXNUVFkgPyBwcm9jZXNzLnN0ZGVyci5jb2x1bW5zIDogdW5kZWZpbmVkLFxuICAgICAgb3V0cHV0RXJyb3I6IChzdHIsIHdyaXRlKSA9PiB3cml0ZShzdHIpXG4gICAgfTtcblxuICAgIHRoaXMuX2hpZGRlbiA9IGZhbHNlO1xuICAgIHRoaXMuX2hhc0hlbHBPcHRpb24gPSB0cnVlO1xuICAgIHRoaXMuX2hlbHBGbGFncyA9ICctaCwgLS1oZWxwJztcbiAgICB0aGlzLl9oZWxwRGVzY3JpcHRpb24gPSAnZGlzcGxheSBoZWxwIGZvciBjb21tYW5kJztcbiAgICB0aGlzLl9oZWxwU2hvcnRGbGFnID0gJy1oJztcbiAgICB0aGlzLl9oZWxwTG9uZ0ZsYWcgPSAnLS1oZWxwJztcbiAgICB0aGlzLl9hZGRJbXBsaWNpdEhlbHBDb21tYW5kID0gdW5kZWZpbmVkOyAvLyBEZWxpYmVyYXRlbHkgdW5kZWZpbmVkLCBub3QgZGVjaWRlZCB3aGV0aGVyIHRydWUgb3IgZmFsc2VcbiAgICB0aGlzLl9oZWxwQ29tbWFuZE5hbWUgPSAnaGVscCc7XG4gICAgdGhpcy5faGVscENvbW1hbmRuYW1lQW5kQXJncyA9ICdoZWxwIFtjb21tYW5kXSc7XG4gICAgdGhpcy5faGVscENvbW1hbmREZXNjcmlwdGlvbiA9ICdkaXNwbGF5IGhlbHAgZm9yIGNvbW1hbmQnO1xuICAgIHRoaXMuX2hlbHBDb25maWd1cmF0aW9uID0ge307XG4gIH1cblxuICAvKipcbiAgICogQ29weSBzZXR0aW5ncyB0aGF0IGFyZSB1c2VmdWwgdG8gaGF2ZSBpbiBjb21tb24gYWNyb3NzIHJvb3QgY29tbWFuZCBhbmQgc3ViY29tbWFuZHMuXG4gICAqXG4gICAqIChVc2VkIGludGVybmFsbHkgd2hlbiBhZGRpbmcgYSBjb21tYW5kIHVzaW5nIGAuY29tbWFuZCgpYCBzbyBzdWJjb21tYW5kcyBpbmhlcml0IHBhcmVudCBzZXR0aW5ncy4pXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tbWFuZH0gc291cmNlQ29tbWFuZFxuICAgKiBAcmV0dXJuIHtDb21tYW5kfSBgdGhpc2AgY29tbWFuZCBmb3IgY2hhaW5pbmdcbiAgICovXG4gIGNvcHlJbmhlcml0ZWRTZXR0aW5ncyhzb3VyY2VDb21tYW5kKSB7XG4gICAgdGhpcy5fb3V0cHV0Q29uZmlndXJhdGlvbiA9IHNvdXJjZUNvbW1hbmQuX291dHB1dENvbmZpZ3VyYXRpb247XG4gICAgdGhpcy5faGFzSGVscE9wdGlvbiA9IHNvdXJjZUNvbW1hbmQuX2hhc0hlbHBPcHRpb247XG4gICAgdGhpcy5faGVscEZsYWdzID0gc291cmNlQ29tbWFuZC5faGVscEZsYWdzO1xuICAgIHRoaXMuX2hlbHBEZXNjcmlwdGlvbiA9IHNvdXJjZUNvbW1hbmQuX2hlbHBEZXNjcmlwdGlvbjtcbiAgICB0aGlzLl9oZWxwU2hvcnRGbGFnID0gc291cmNlQ29tbWFuZC5faGVscFNob3J0RmxhZztcbiAgICB0aGlzLl9oZWxwTG9uZ0ZsYWcgPSBzb3VyY2VDb21tYW5kLl9oZWxwTG9uZ0ZsYWc7XG4gICAgdGhpcy5faGVscENvbW1hbmROYW1lID0gc291cmNlQ29tbWFuZC5faGVscENvbW1hbmROYW1lO1xuICAgIHRoaXMuX2hlbHBDb21tYW5kbmFtZUFuZEFyZ3MgPSBzb3VyY2VDb21tYW5kLl9oZWxwQ29tbWFuZG5hbWVBbmRBcmdzO1xuICAgIHRoaXMuX2hlbHBDb21tYW5kRGVzY3JpcHRpb24gPSBzb3VyY2VDb21tYW5kLl9oZWxwQ29tbWFuZERlc2NyaXB0aW9uO1xuICAgIHRoaXMuX2hlbHBDb25maWd1cmF0aW9uID0gc291cmNlQ29tbWFuZC5faGVscENvbmZpZ3VyYXRpb247XG4gICAgdGhpcy5fZXhpdENhbGxiYWNrID0gc291cmNlQ29tbWFuZC5fZXhpdENhbGxiYWNrO1xuICAgIHRoaXMuX3N0b3JlT3B0aW9uc0FzUHJvcGVydGllcyA9IHNvdXJjZUNvbW1hbmQuX3N0b3JlT3B0aW9uc0FzUHJvcGVydGllcztcbiAgICB0aGlzLl9jb21iaW5lRmxhZ0FuZE9wdGlvbmFsVmFsdWUgPSBzb3VyY2VDb21tYW5kLl9jb21iaW5lRmxhZ0FuZE9wdGlvbmFsVmFsdWU7XG4gICAgdGhpcy5fYWxsb3dFeGNlc3NBcmd1bWVudHMgPSBzb3VyY2VDb21tYW5kLl9hbGxvd0V4Y2Vzc0FyZ3VtZW50cztcbiAgICB0aGlzLl9lbmFibGVQb3NpdGlvbmFsT3B0aW9ucyA9IHNvdXJjZUNvbW1hbmQuX2VuYWJsZVBvc2l0aW9uYWxPcHRpb25zO1xuICAgIHRoaXMuX3Nob3dIZWxwQWZ0ZXJFcnJvciA9IHNvdXJjZUNvbW1hbmQuX3Nob3dIZWxwQWZ0ZXJFcnJvcjtcbiAgICB0aGlzLl9zaG93U3VnZ2VzdGlvbkFmdGVyRXJyb3IgPSBzb3VyY2VDb21tYW5kLl9zaG93U3VnZ2VzdGlvbkFmdGVyRXJyb3I7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmUgYSBjb21tYW5kLlxuICAgKlxuICAgKiBUaGVyZSBhcmUgdHdvIHN0eWxlcyBvZiBjb21tYW5kOiBwYXkgYXR0ZW50aW9uIHRvIHdoZXJlIHRvIHB1dCB0aGUgZGVzY3JpcHRpb24uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIENvbW1hbmQgaW1wbGVtZW50ZWQgdXNpbmcgYWN0aW9uIGhhbmRsZXIgKGRlc2NyaXB0aW9uIGlzIHN1cHBsaWVkIHNlcGFyYXRlbHkgdG8gYC5jb21tYW5kYClcbiAgICogcHJvZ3JhbVxuICAgKiAgIC5jb21tYW5kKCdjbG9uZSA8c291cmNlPiBbZGVzdGluYXRpb25dJylcbiAgICogICAuZGVzY3JpcHRpb24oJ2Nsb25lIGEgcmVwb3NpdG9yeSBpbnRvIGEgbmV3bHkgY3JlYXRlZCBkaXJlY3RvcnknKVxuICAgKiAgIC5hY3Rpb24oKHNvdXJjZSwgZGVzdGluYXRpb24pID0+IHtcbiAgICogICAgIGNvbnNvbGUubG9nKCdjbG9uZSBjb21tYW5kIGNhbGxlZCcpO1xuICAgKiAgIH0pO1xuICAgKlxuICAgKiAvLyBDb21tYW5kIGltcGxlbWVudGVkIHVzaW5nIHNlcGFyYXRlIGV4ZWN1dGFibGUgZmlsZSAoZGVzY3JpcHRpb24gaXMgc2Vjb25kIHBhcmFtZXRlciB0byBgLmNvbW1hbmRgKVxuICAgKiBwcm9ncmFtXG4gICAqICAgLmNvbW1hbmQoJ3N0YXJ0IDxzZXJ2aWNlPicsICdzdGFydCBuYW1lZCBzZXJ2aWNlJylcbiAgICogICAuY29tbWFuZCgnc3RvcCBbc2VydmljZV0nLCAnc3RvcCBuYW1lZCBzZXJ2aWNlLCBvciBhbGwgaWYgbm8gbmFtZSBzdXBwbGllZCcpO1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZUFuZEFyZ3MgLSBjb21tYW5kIG5hbWUgYW5kIGFyZ3VtZW50cywgYXJncyBhcmUgYDxyZXF1aXJlZD5gIG9yIGBbb3B0aW9uYWxdYCBhbmQgbGFzdCBtYXkgYWxzbyBiZSBgdmFyaWFkaWMuLi5gXG4gICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gW2FjdGlvbk9wdHNPckV4ZWNEZXNjXSAtIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyAoZm9yIGFjdGlvbiksIG9yIGRlc2NyaXB0aW9uIChmb3IgZXhlY3V0YWJsZSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtleGVjT3B0c10gLSBjb25maWd1cmF0aW9uIG9wdGlvbnMgKGZvciBleGVjdXRhYmxlKVxuICAgKiBAcmV0dXJuIHtDb21tYW5kfSByZXR1cm5zIG5ldyBjb21tYW5kIGZvciBhY3Rpb24gaGFuZGxlciwgb3IgYHRoaXNgIGZvciBleGVjdXRhYmxlIGNvbW1hbmRcbiAgICovXG5cbiAgY29tbWFuZChuYW1lQW5kQXJncywgYWN0aW9uT3B0c09yRXhlY0Rlc2MsIGV4ZWNPcHRzKSB7XG4gICAgbGV0IGRlc2MgPSBhY3Rpb25PcHRzT3JFeGVjRGVzYztcbiAgICBsZXQgb3B0cyA9IGV4ZWNPcHRzO1xuICAgIGlmICh0eXBlb2YgZGVzYyA9PT0gJ29iamVjdCcgJiYgZGVzYyAhPT0gbnVsbCkge1xuICAgICAgb3B0cyA9IGRlc2M7XG4gICAgICBkZXNjID0gbnVsbDtcbiAgICB9XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgY29uc3QgWywgbmFtZSwgYXJnc10gPSBuYW1lQW5kQXJncy5tYXRjaCgvKFteIF0rKSAqKC4qKS8pO1xuXG4gICAgY29uc3QgY21kID0gdGhpcy5jcmVhdGVDb21tYW5kKG5hbWUpO1xuICAgIGlmIChkZXNjKSB7XG4gICAgICBjbWQuZGVzY3JpcHRpb24oZGVzYyk7XG4gICAgICBjbWQuX2V4ZWN1dGFibGVIYW5kbGVyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG9wdHMuaXNEZWZhdWx0KSB0aGlzLl9kZWZhdWx0Q29tbWFuZE5hbWUgPSBjbWQuX25hbWU7XG4gICAgY21kLl9oaWRkZW4gPSAhIShvcHRzLm5vSGVscCB8fCBvcHRzLmhpZGRlbik7IC8vIG5vSGVscCBpcyBkZXByZWNhdGVkIG9sZCBuYW1lIGZvciBoaWRkZW5cbiAgICBjbWQuX2V4ZWN1dGFibGVGaWxlID0gb3B0cy5leGVjdXRhYmxlRmlsZSB8fCBudWxsOyAvLyBDdXN0b20gbmFtZSBmb3IgZXhlY3V0YWJsZSBmaWxlLCBzZXQgbWlzc2luZyB0byBudWxsIHRvIG1hdGNoIGNvbnN0cnVjdG9yXG4gICAgaWYgKGFyZ3MpIGNtZC5hcmd1bWVudHMoYXJncyk7XG4gICAgdGhpcy5jb21tYW5kcy5wdXNoKGNtZCk7XG4gICAgY21kLnBhcmVudCA9IHRoaXM7XG4gICAgY21kLmNvcHlJbmhlcml0ZWRTZXR0aW5ncyh0aGlzKTtcblxuICAgIGlmIChkZXNjKSByZXR1cm4gdGhpcztcbiAgICByZXR1cm4gY21kO1xuICB9XG5cbiAgLyoqXG4gICAqIEZhY3Rvcnkgcm91dGluZSB0byBjcmVhdGUgYSBuZXcgdW5hdHRhY2hlZCBjb21tYW5kLlxuICAgKlxuICAgKiBTZWUgLmNvbW1hbmQoKSBmb3IgY3JlYXRpbmcgYW4gYXR0YWNoZWQgc3ViY29tbWFuZCwgd2hpY2ggdXNlcyB0aGlzIHJvdXRpbmUgdG9cbiAgICogY3JlYXRlIHRoZSBjb21tYW5kLiBZb3UgY2FuIG92ZXJyaWRlIGNyZWF0ZUNvbW1hbmQgdG8gY3VzdG9taXNlIHN1YmNvbW1hbmRzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdXG4gICAqIEByZXR1cm4ge0NvbW1hbmR9IG5ldyBjb21tYW5kXG4gICAqL1xuXG4gIGNyZWF0ZUNvbW1hbmQobmFtZSkge1xuICAgIHJldHVybiBuZXcgQ29tbWFuZChuYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBZb3UgY2FuIGN1c3RvbWlzZSB0aGUgaGVscCB3aXRoIGEgc3ViY2xhc3Mgb2YgSGVscCBieSBvdmVycmlkaW5nIGNyZWF0ZUhlbHAsXG4gICAqIG9yIGJ5IG92ZXJyaWRpbmcgSGVscCBwcm9wZXJ0aWVzIHVzaW5nIGNvbmZpZ3VyZUhlbHAoKS5cbiAgICpcbiAgICogQHJldHVybiB7SGVscH1cbiAgICovXG5cbiAgY3JlYXRlSGVscCgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgSGVscCgpLCB0aGlzLmNvbmZpZ3VyZUhlbHAoKSk7XG4gIH1cblxuICAvKipcbiAgICogWW91IGNhbiBjdXN0b21pc2UgdGhlIGhlbHAgYnkgb3ZlcnJpZGluZyBIZWxwIHByb3BlcnRpZXMgdXNpbmcgY29uZmlndXJlSGVscCgpLFxuICAgKiBvciB3aXRoIGEgc3ViY2xhc3Mgb2YgSGVscCBieSBvdmVycmlkaW5nIGNyZWF0ZUhlbHAoKS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWd1cmF0aW9uXSAtIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtDb21tYW5kfE9iamVjdH0gYHRoaXNgIGNvbW1hbmQgZm9yIGNoYWluaW5nLCBvciBzdG9yZWQgY29uZmlndXJhdGlvblxuICAgKi9cblxuICBjb25maWd1cmVIZWxwKGNvbmZpZ3VyYXRpb24pIHtcbiAgICBpZiAoY29uZmlndXJhdGlvbiA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5faGVscENvbmZpZ3VyYXRpb247XG5cbiAgICB0aGlzLl9oZWxwQ29uZmlndXJhdGlvbiA9IGNvbmZpZ3VyYXRpb247XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgb3V0cHV0IGdvZXMgdG8gc3Rkb3V0IGFuZCBzdGRlcnIuIFlvdSBjYW4gY3VzdG9taXNlIHRoaXMgZm9yIHNwZWNpYWxcbiAgICogYXBwbGljYXRpb25zLiBZb3UgY2FuIGFsc28gY3VzdG9taXNlIHRoZSBkaXNwbGF5IG9mIGVycm9ycyBieSBvdmVycmlkaW5nIG91dHB1dEVycm9yLlxuICAgKlxuICAgKiBUaGUgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzIGFyZSBhbGwgZnVuY3Rpb25zOlxuICAgKlxuICAgKiAgICAgLy8gZnVuY3Rpb25zIHRvIGNoYW5nZSB3aGVyZSBiZWluZyB3cml0dGVuLCBzdGRvdXQgYW5kIHN0ZGVyclxuICAgKiAgICAgd3JpdGVPdXQoc3RyKVxuICAgKiAgICAgd3JpdGVFcnIoc3RyKVxuICAgKiAgICAgLy8gbWF0Y2hpbmcgZnVuY3Rpb25zIHRvIHNwZWNpZnkgd2lkdGggZm9yIHdyYXBwaW5nIGhlbHBcbiAgICogICAgIGdldE91dEhlbHBXaWR0aCgpXG4gICAqICAgICBnZXRFcnJIZWxwV2lkdGgoKVxuICAgKiAgICAgLy8gZnVuY3Rpb25zIGJhc2VkIG9uIHdoYXQgaXMgYmVpbmcgd3JpdHRlbiBvdXRcbiAgICogICAgIG91dHB1dEVycm9yKHN0ciwgd3JpdGUpIC8vIHVzZWQgZm9yIGRpc3BsYXlpbmcgZXJyb3JzLCBhbmQgbm90IHVzZWQgZm9yIGRpc3BsYXlpbmcgaGVscFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ3VyYXRpb25dIC0gY29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEByZXR1cm4ge0NvbW1hbmR8T2JqZWN0fSBgdGhpc2AgY29tbWFuZCBmb3IgY2hhaW5pbmcsIG9yIHN0b3JlZCBjb25maWd1cmF0aW9uXG4gICAqL1xuXG4gIGNvbmZpZ3VyZU91dHB1dChjb25maWd1cmF0aW9uKSB7XG4gICAgaWYgKGNvbmZpZ3VyYXRpb24gPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXMuX291dHB1dENvbmZpZ3VyYXRpb247XG5cbiAgICBPYmplY3QuYXNzaWduKHRoaXMuX291dHB1dENvbmZpZ3VyYXRpb24sIGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3BsYXkgdGhlIGhlbHAgb3IgYSBjdXN0b20gbWVzc2FnZSBhZnRlciBhbiBlcnJvciBvY2N1cnMuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbnxzdHJpbmd9IFtkaXNwbGF5SGVscF1cbiAgICogQHJldHVybiB7Q29tbWFuZH0gYHRoaXNgIGNvbW1hbmQgZm9yIGNoYWluaW5nXG4gICAqL1xuICBzaG93SGVscEFmdGVyRXJyb3IoZGlzcGxheUhlbHAgPSB0cnVlKSB7XG4gICAgaWYgKHR5cGVvZiBkaXNwbGF5SGVscCAhPT0gJ3N0cmluZycpIGRpc3BsYXlIZWxwID0gISFkaXNwbGF5SGVscDtcbiAgICB0aGlzLl9zaG93SGVscEFmdGVyRXJyb3IgPSBkaXNwbGF5SGVscDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwbGF5IHN1Z2dlc3Rpb24gb2Ygc2ltaWxhciBjb21tYW5kcyBmb3IgdW5rbm93biBjb21tYW5kcywgb3Igb3B0aW9ucyBmb3IgdW5rbm93biBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkaXNwbGF5U3VnZ2VzdGlvbl1cbiAgICogQHJldHVybiB7Q29tbWFuZH0gYHRoaXNgIGNvbW1hbmQgZm9yIGNoYWluaW5nXG4gICAqL1xuICBzaG93U3VnZ2VzdGlvbkFmdGVyRXJyb3IoZGlzcGxheVN1Z2dlc3Rpb24gPSB0cnVlKSB7XG4gICAgdGhpcy5fc2hvd1N1Z2dlc3Rpb25BZnRlckVycm9yID0gISFkaXNwbGF5U3VnZ2VzdGlvbjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBwcmVwYXJlZCBzdWJjb21tYW5kLlxuICAgKlxuICAgKiBTZWUgLmNvbW1hbmQoKSBmb3IgY3JlYXRpbmcgYW4gYXR0YWNoZWQgc3ViY29tbWFuZCB3aGljaCBpbmhlcml0cyBzZXR0aW5ncyBmcm9tIGl0cyBwYXJlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tbWFuZH0gY21kIC0gbmV3IHN1YmNvbW1hbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSAtIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtDb21tYW5kfSBgdGhpc2AgY29tbWFuZCBmb3IgY2hhaW5pbmdcbiAgICovXG5cbiAgYWRkQ29tbWFuZChjbWQsIG9wdHMpIHtcbiAgICBpZiAoIWNtZC5fbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb21tYW5kIHBhc3NlZCB0byAuYWRkQ29tbWFuZCgpIG11c3QgaGF2ZSBhIG5hbWVcbi0gc3BlY2lmeSB0aGUgbmFtZSBpbiBDb21tYW5kIGNvbnN0cnVjdG9yIG9yIHVzaW5nIC5uYW1lKClgKTtcbiAgICB9XG5cbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICBpZiAob3B0cy5pc0RlZmF1bHQpIHRoaXMuX2RlZmF1bHRDb21tYW5kTmFtZSA9IGNtZC5fbmFtZTtcbiAgICBpZiAob3B0cy5ub0hlbHAgfHwgb3B0cy5oaWRkZW4pIGNtZC5faGlkZGVuID0gdHJ1ZTsgLy8gbW9kaWZ5aW5nIHBhc3NlZCBjb21tYW5kIGR1ZSB0byBleGlzdGluZyBpbXBsZW1lbnRhdGlvblxuXG4gICAgdGhpcy5jb21tYW5kcy5wdXNoKGNtZCk7XG4gICAgY21kLnBhcmVudCA9IHRoaXM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogRmFjdG9yeSByb3V0aW5lIHRvIGNyZWF0ZSBhIG5ldyB1bmF0dGFjaGVkIGFyZ3VtZW50LlxuICAgKlxuICAgKiBTZWUgLmFyZ3VtZW50KCkgZm9yIGNyZWF0aW5nIGFuIGF0dGFjaGVkIGFyZ3VtZW50LCB3aGljaCB1c2VzIHRoaXMgcm91dGluZSB0b1xuICAgKiBjcmVhdGUgdGhlIGFyZ3VtZW50LiBZb3UgY2FuIG92ZXJyaWRlIGNyZWF0ZUFyZ3VtZW50IHRvIHJldHVybiBhIGN1c3RvbSBhcmd1bWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtkZXNjcmlwdGlvbl1cbiAgICogQHJldHVybiB7QXJndW1lbnR9IG5ldyBhcmd1bWVudFxuICAgKi9cblxuICBjcmVhdGVBcmd1bWVudChuYW1lLCBkZXNjcmlwdGlvbikge1xuICAgIHJldHVybiBuZXcgQXJndW1lbnQobmFtZSwgZGVzY3JpcHRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZSBhcmd1bWVudCBzeW50YXggZm9yIGNvbW1hbmQuXG4gICAqXG4gICAqIFRoZSBkZWZhdWx0IGlzIHRoYXQgdGhlIGFyZ3VtZW50IGlzIHJlcXVpcmVkLCBhbmQgeW91IGNhbiBleHBsaWNpdGx5XG4gICAqIGluZGljYXRlIHRoaXMgd2l0aCA8PiBhcm91bmQgdGhlIG5hbWUuIFB1dCBbXSBhcm91bmQgdGhlIG5hbWUgZm9yIGFuIG9wdGlvbmFsIGFyZ3VtZW50LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBwcm9ncmFtLmFyZ3VtZW50KCc8aW5wdXQtZmlsZT4nKTtcbiAgICogcHJvZ3JhbS5hcmd1bWVudCgnW291dHB1dC1maWxlXScpO1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufCp9IFtmbl0gLSBjdXN0b20gYXJndW1lbnQgcHJvY2Vzc2luZyBmdW5jdGlvblxuICAgKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdXG4gICAqIEByZXR1cm4ge0NvbW1hbmR9IGB0aGlzYCBjb21tYW5kIGZvciBjaGFpbmluZ1xuICAgKi9cbiAgYXJndW1lbnQobmFtZSwgZGVzY3JpcHRpb24sIGZuLCBkZWZhdWx0VmFsdWUpIHtcbiAgICBjb25zdCBhcmd1bWVudCA9IHRoaXMuY3JlYXRlQXJndW1lbnQobmFtZSwgZGVzY3JpcHRpb24pO1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFyZ3VtZW50LmRlZmF1bHQoZGVmYXVsdFZhbHVlKS5hcmdQYXJzZXIoZm4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcmd1bWVudC5kZWZhdWx0KGZuKTtcbiAgICB9XG4gICAgdGhpcy5hZGRBcmd1bWVudChhcmd1bWVudCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lIGFyZ3VtZW50IHN5bnRheCBmb3IgY29tbWFuZCwgYWRkaW5nIG11bHRpcGxlIGF0IG9uY2UgKHdpdGhvdXQgZGVzY3JpcHRpb25zKS5cbiAgICpcbiAgICogU2VlIGFsc28gLmFyZ3VtZW50KCkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHByb2dyYW0uYXJndW1lbnRzKCc8Y21kPiBbZW52XScpO1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZXNcbiAgICogQHJldHVybiB7Q29tbWFuZH0gYHRoaXNgIGNvbW1hbmQgZm9yIGNoYWluaW5nXG4gICAqL1xuXG4gIGFyZ3VtZW50cyhuYW1lcykge1xuICAgIG5hbWVzLnNwbGl0KC8gKy8pLmZvckVhY2goKGRldGFpbCkgPT4ge1xuICAgICAgdGhpcy5hcmd1bWVudChkZXRhaWwpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZSBhcmd1bWVudCBzeW50YXggZm9yIGNvbW1hbmQsIGFkZGluZyBhIHByZXBhcmVkIGFyZ3VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0FyZ3VtZW50fSBhcmd1bWVudFxuICAgKiBAcmV0dXJuIHtDb21tYW5kfSBgdGhpc2AgY29tbWFuZCBmb3IgY2hhaW5pbmdcbiAgICovXG4gIGFkZEFyZ3VtZW50KGFyZ3VtZW50KSB7XG4gICAgY29uc3QgcHJldmlvdXNBcmd1bWVudCA9IHRoaXMuX2FyZ3Muc2xpY2UoLTEpWzBdO1xuICAgIGlmIChwcmV2aW91c0FyZ3VtZW50ICYmIHByZXZpb3VzQXJndW1lbnQudmFyaWFkaWMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgb25seSB0aGUgbGFzdCBhcmd1bWVudCBjYW4gYmUgdmFyaWFkaWMgJyR7cHJldmlvdXNBcmd1bWVudC5uYW1lKCl9J2ApO1xuICAgIH1cbiAgICBpZiAoYXJndW1lbnQucmVxdWlyZWQgJiYgYXJndW1lbnQuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgYXJndW1lbnQucGFyc2VBcmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBhIGRlZmF1bHQgdmFsdWUgZm9yIGEgcmVxdWlyZWQgYXJndW1lbnQgaXMgbmV2ZXIgdXNlZDogJyR7YXJndW1lbnQubmFtZSgpfSdgKTtcbiAgICB9XG4gICAgdGhpcy5fYXJncy5wdXNoKGFyZ3VtZW50KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBkZWZhdWx0IGRlY2lzaW9uIHdoZXRoZXIgdG8gYWRkIGltcGxpY2l0IGhlbHAgY29tbWFuZC5cbiAgICpcbiAgICogICAgYWRkSGVscENvbW1hbmQoKSAvLyBmb3JjZSBvblxuICAgKiAgICBhZGRIZWxwQ29tbWFuZChmYWxzZSk7IC8vIGZvcmNlIG9mZlxuICAgKiAgICBhZGRIZWxwQ29tbWFuZCgnaGVscCBbY21kXScsICdkaXNwbGF5IGhlbHAgZm9yIFtjbWRdJyk7IC8vIGZvcmNlIG9uIHdpdGggY3VzdG9tIGRldGFpbHNcbiAgICpcbiAgICogQHJldHVybiB7Q29tbWFuZH0gYHRoaXNgIGNvbW1hbmQgZm9yIGNoYWluaW5nXG4gICAqL1xuXG4gIGFkZEhlbHBDb21tYW5kKGVuYWJsZU9yTmFtZUFuZEFyZ3MsIGRlc2NyaXB0aW9uKSB7XG4gICAgaWYgKGVuYWJsZU9yTmFtZUFuZEFyZ3MgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLl9hZGRJbXBsaWNpdEhlbHBDb21tYW5kID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2FkZEltcGxpY2l0SGVscENvbW1hbmQgPSB0cnVlO1xuICAgICAgaWYgKHR5cGVvZiBlbmFibGVPck5hbWVBbmRBcmdzID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLl9oZWxwQ29tbWFuZE5hbWUgPSBlbmFibGVPck5hbWVBbmRBcmdzLnNwbGl0KCcgJylbMF07XG4gICAgICAgIHRoaXMuX2hlbHBDb21tYW5kbmFtZUFuZEFyZ3MgPSBlbmFibGVPck5hbWVBbmRBcmdzO1xuICAgICAgfVxuICAgICAgdGhpcy5faGVscENvbW1hbmREZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uIHx8IHRoaXMuX2hlbHBDb21tYW5kRGVzY3JpcHRpb247XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBfaGFzSW1wbGljaXRIZWxwQ29tbWFuZCgpIHtcbiAgICBpZiAodGhpcy5fYWRkSW1wbGljaXRIZWxwQ29tbWFuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21tYW5kcy5sZW5ndGggJiYgIXRoaXMuX2FjdGlvbkhhbmRsZXIgJiYgIXRoaXMuX2ZpbmRDb21tYW5kKCdoZWxwJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9hZGRJbXBsaWNpdEhlbHBDb21tYW5kO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBob29rIGZvciBsaWZlIGN5Y2xlIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAgICogQHJldHVybiB7Q29tbWFuZH0gYHRoaXNgIGNvbW1hbmQgZm9yIGNoYWluaW5nXG4gICAqL1xuXG4gIGhvb2soZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgY29uc3QgYWxsb3dlZFZhbHVlcyA9IFsncHJlU3ViY29tbWFuZCcsICdwcmVBY3Rpb24nLCAncG9zdEFjdGlvbiddO1xuICAgIGlmICghYWxsb3dlZFZhbHVlcy5pbmNsdWRlcyhldmVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCB2YWx1ZSBmb3IgZXZlbnQgcGFzc2VkIHRvIGhvb2sgOiAnJHtldmVudH0nLlxuRXhwZWN0aW5nIG9uZSBvZiAnJHthbGxvd2VkVmFsdWVzLmpvaW4oXCInLCAnXCIpfSdgKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2xpZmVDeWNsZUhvb2tzW2V2ZW50XSkge1xuICAgICAgdGhpcy5fbGlmZUN5Y2xlSG9va3NbZXZlbnRdLnB1c2gobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9saWZlQ3ljbGVIb29rc1tldmVudF0gPSBbbGlzdGVuZXJdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBjYWxsYmFjayB0byB1c2UgYXMgcmVwbGFjZW1lbnQgZm9yIGNhbGxpbmcgcHJvY2Vzcy5leGl0LlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dIG9wdGlvbmFsIGNhbGxiYWNrIHdoaWNoIHdpbGwgYmUgcGFzc2VkIGEgQ29tbWFuZGVyRXJyb3IsIGRlZmF1bHRzIHRvIHRocm93aW5nXG4gICAqIEByZXR1cm4ge0NvbW1hbmR9IGB0aGlzYCBjb21tYW5kIGZvciBjaGFpbmluZ1xuICAgKi9cblxuICBleGl0T3ZlcnJpZGUoZm4pIHtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHRoaXMuX2V4aXRDYWxsYmFjayA9IGZuO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9leGl0Q2FsbGJhY2sgPSAoZXJyKSA9PiB7XG4gICAgICAgIGlmIChlcnIuY29kZSAhPT0gJ2NvbW1hbmRlci5leGVjdXRlU3ViQ29tbWFuZEFzeW5jJykge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBBc3luYyBjYWxsYmFjayBmcm9tIHNwYXduIGV2ZW50cywgbm90IHVzZWZ1bCB0byB0aHJvdy5cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbCBwcm9jZXNzLmV4aXQsIGFuZCBfZXhpdENhbGxiYWNrIGlmIGRlZmluZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBleGl0Q29kZSBleGl0IGNvZGUgZm9yIHVzaW5nIHdpdGggcHJvY2Vzcy5leGl0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIGFuIGlkIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGVycm9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIGh1bWFuLXJlYWRhYmxlIGRlc2NyaXB0aW9uIG9mIHRoZSBlcnJvclxuICAgKiBAcmV0dXJuIG5ldmVyXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBfZXhpdChleGl0Q29kZSwgY29kZSwgbWVzc2FnZSkge1xuICAgIGlmICh0aGlzLl9leGl0Q2FsbGJhY2spIHtcbiAgICAgIHRoaXMuX2V4aXRDYWxsYmFjayhuZXcgQ29tbWFuZGVyRXJyb3IoZXhpdENvZGUsIGNvZGUsIG1lc3NhZ2UpKTtcbiAgICAgIC8vIEV4cGVjdGluZyB0aGlzIGxpbmUgaXMgbm90IHJlYWNoZWQuXG4gICAgfVxuICAgIHByb2Nlc3MuZXhpdChleGl0Q29kZSk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgY2FsbGJhY2sgYGZuYCBmb3IgdGhlIGNvbW1hbmQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHByb2dyYW1cbiAgICogICAuY29tbWFuZCgnc2VydmUnKVxuICAgKiAgIC5kZXNjcmlwdGlvbignc3RhcnQgc2VydmljZScpXG4gICAqICAgLmFjdGlvbihmdW5jdGlvbigpIHtcbiAgICogICAgICAvLyBkbyB3b3JrIGhlcmVcbiAgICogICB9KTtcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICogQHJldHVybiB7Q29tbWFuZH0gYHRoaXNgIGNvbW1hbmQgZm9yIGNoYWluaW5nXG4gICAqL1xuXG4gIGFjdGlvbihmbikge1xuICAgIGNvbnN0IGxpc3RlbmVyID0gKGFyZ3MpID0+IHtcbiAgICAgIC8vIFRoZSAuYWN0aW9uIGNhbGxiYWNrIHRha2VzIGFuIGV4dHJhIHBhcmFtZXRlciB3aGljaCBpcyB0aGUgY29tbWFuZCBvciBvcHRpb25zLlxuICAgICAgY29uc3QgZXhwZWN0ZWRBcmdzQ291bnQgPSB0aGlzLl9hcmdzLmxlbmd0aDtcbiAgICAgIGNvbnN0IGFjdGlvbkFyZ3MgPSBhcmdzLnNsaWNlKDAsIGV4cGVjdGVkQXJnc0NvdW50KTtcbiAgICAgIGlmICh0aGlzLl9zdG9yZU9wdGlvbnNBc1Byb3BlcnRpZXMpIHtcbiAgICAgICAgYWN0aW9uQXJnc1tleHBlY3RlZEFyZ3NDb3VudF0gPSB0aGlzOyAvLyBiYWNrd2FyZHMgY29tcGF0aWJsZSBcIm9wdGlvbnNcIlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aW9uQXJnc1tleHBlY3RlZEFyZ3NDb3VudF0gPSB0aGlzLm9wdHMoKTtcbiAgICAgIH1cbiAgICAgIGFjdGlvbkFyZ3MucHVzaCh0aGlzKTtcblxuICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFjdGlvbkFyZ3MpO1xuICAgIH07XG4gICAgdGhpcy5fYWN0aW9uSGFuZGxlciA9IGxpc3RlbmVyO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEZhY3Rvcnkgcm91dGluZSB0byBjcmVhdGUgYSBuZXcgdW5hdHRhY2hlZCBvcHRpb24uXG4gICAqXG4gICAqIFNlZSAub3B0aW9uKCkgZm9yIGNyZWF0aW5nIGFuIGF0dGFjaGVkIG9wdGlvbiwgd2hpY2ggdXNlcyB0aGlzIHJvdXRpbmUgdG9cbiAgICogY3JlYXRlIHRoZSBvcHRpb24uIFlvdSBjYW4gb3ZlcnJpZGUgY3JlYXRlT3B0aW9uIHRvIHJldHVybiBhIGN1c3RvbSBvcHRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmbGFnc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW2Rlc2NyaXB0aW9uXVxuICAgKiBAcmV0dXJuIHtPcHRpb259IG5ldyBvcHRpb25cbiAgICovXG5cbiAgY3JlYXRlT3B0aW9uKGZsYWdzLCBkZXNjcmlwdGlvbikge1xuICAgIHJldHVybiBuZXcgT3B0aW9uKGZsYWdzLCBkZXNjcmlwdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGFuIG9wdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtPcHRpb259IG9wdGlvblxuICAgKiBAcmV0dXJuIHtDb21tYW5kfSBgdGhpc2AgY29tbWFuZCBmb3IgY2hhaW5pbmdcbiAgICovXG4gIGFkZE9wdGlvbihvcHRpb24pIHtcbiAgICBjb25zdCBvbmFtZSA9IG9wdGlvbi5uYW1lKCk7XG4gICAgY29uc3QgbmFtZSA9IG9wdGlvbi5hdHRyaWJ1dGVOYW1lKCk7XG5cbiAgICAvLyBzdG9yZSBkZWZhdWx0IHZhbHVlXG4gICAgaWYgKG9wdGlvbi5uZWdhdGUpIHtcbiAgICAgIC8vIC0tbm8tZm9vIGlzIHNwZWNpYWwgYW5kIGRlZmF1bHRzIGZvbyB0byB0cnVlLCB1bmxlc3MgYSAtLWZvbyBvcHRpb24gaXMgYWxyZWFkeSBkZWZpbmVkXG4gICAgICBjb25zdCBwb3NpdGl2ZUxvbmdGbGFnID0gb3B0aW9uLmxvbmcucmVwbGFjZSgvXi0tbm8tLywgJy0tJyk7XG4gICAgICBpZiAoIXRoaXMuX2ZpbmRPcHRpb24ocG9zaXRpdmVMb25nRmxhZykpIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb25WYWx1ZVdpdGhTb3VyY2UobmFtZSwgb3B0aW9uLmRlZmF1bHRWYWx1ZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbi5kZWZhdWx0VmFsdWUsICdkZWZhdWx0Jyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvcHRpb24uZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc2V0T3B0aW9uVmFsdWVXaXRoU291cmNlKG5hbWUsIG9wdGlvbi5kZWZhdWx0VmFsdWUsICdkZWZhdWx0Jyk7XG4gICAgfVxuXG4gICAgLy8gcmVnaXN0ZXIgdGhlIG9wdGlvblxuICAgIHRoaXMub3B0aW9ucy5wdXNoKG9wdGlvbik7XG5cbiAgICAvLyBoYW5kbGVyIGZvciBjbGkgYW5kIGVudiBzdXBwbGllZCB2YWx1ZXNcbiAgICBjb25zdCBoYW5kbGVPcHRpb25WYWx1ZSA9ICh2YWwsIGludmFsaWRWYWx1ZU1lc3NhZ2UsIHZhbHVlU291cmNlKSA9PiB7XG4gICAgICAvLyB2YWwgaXMgbnVsbCBmb3Igb3B0aW9uYWwgb3B0aW9uIHVzZWQgd2l0aG91dCBhbiBvcHRpb25hbC1hcmd1bWVudC5cbiAgICAgIC8vIHZhbCBpcyB1bmRlZmluZWQgZm9yIGJvb2xlYW4gYW5kIG5lZ2F0ZWQgb3B0aW9uLlxuICAgICAgaWYgKHZhbCA9PSBudWxsICYmIG9wdGlvbi5wcmVzZXRBcmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWwgPSBvcHRpb24ucHJlc2V0QXJnO1xuICAgICAgfVxuXG4gICAgICAvLyBjdXN0b20gcHJvY2Vzc2luZ1xuICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLmdldE9wdGlvblZhbHVlKG5hbWUpO1xuICAgICAgaWYgKHZhbCAhPT0gbnVsbCAmJiBvcHRpb24ucGFyc2VBcmcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YWwgPSBvcHRpb24ucGFyc2VBcmcodmFsLCBvbGRWYWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gJ2NvbW1hbmRlci5pbnZhbGlkQXJndW1lbnQnKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYCR7aW52YWxpZFZhbHVlTWVzc2FnZX0gJHtlcnIubWVzc2FnZX1gO1xuICAgICAgICAgICAgdGhpcy5lcnJvcihtZXNzYWdlLCB7IGV4aXRDb2RlOiBlcnIuZXhpdENvZGUsIGNvZGU6IGVyci5jb2RlIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodmFsICE9PSBudWxsICYmIG9wdGlvbi52YXJpYWRpYykge1xuICAgICAgICB2YWwgPSBvcHRpb24uX2NvbmNhdFZhbHVlKHZhbCwgb2xkVmFsdWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBGaWxsLWluIGFwcHJvcHJpYXRlIG1pc3NpbmcgdmFsdWVzLiBMb25nIHdpbmRlZCBidXQgZWFzeSB0byBmb2xsb3cuXG4gICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgaWYgKG9wdGlvbi5uZWdhdGUpIHtcbiAgICAgICAgICB2YWwgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb24uaXNCb29sZWFuKCkgfHwgb3B0aW9uLm9wdGlvbmFsKSB7XG4gICAgICAgICAgdmFsID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSAnJzsgLy8gbm90IG5vcm1hbCwgcGFyc2VBcmcgbWlnaHQgaGF2ZSBmYWlsZWQgb3IgYmUgYSBtb2NrIGZ1bmN0aW9uIGZvciB0ZXN0aW5nXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0T3B0aW9uVmFsdWVXaXRoU291cmNlKG5hbWUsIHZhbCwgdmFsdWVTb3VyY2UpO1xuICAgIH07XG5cbiAgICB0aGlzLm9uKCdvcHRpb246JyArIG9uYW1lLCAodmFsKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkVmFsdWVNZXNzYWdlID0gYGVycm9yOiBvcHRpb24gJyR7b3B0aW9uLmZsYWdzfScgYXJndW1lbnQgJyR7dmFsfScgaXMgaW52YWxpZC5gO1xuICAgICAgaGFuZGxlT3B0aW9uVmFsdWUodmFsLCBpbnZhbGlkVmFsdWVNZXNzYWdlLCAnY2xpJyk7XG4gICAgfSk7XG5cbiAgICBpZiAob3B0aW9uLmVudlZhcikge1xuICAgICAgdGhpcy5vbignb3B0aW9uRW52OicgKyBvbmFtZSwgKHZhbCkgPT4ge1xuICAgICAgICBjb25zdCBpbnZhbGlkVmFsdWVNZXNzYWdlID0gYGVycm9yOiBvcHRpb24gJyR7b3B0aW9uLmZsYWdzfScgdmFsdWUgJyR7dmFsfScgZnJvbSBlbnYgJyR7b3B0aW9uLmVudlZhcn0nIGlzIGludmFsaWQuYDtcbiAgICAgICAgaGFuZGxlT3B0aW9uVmFsdWUodmFsLCBpbnZhbGlkVmFsdWVNZXNzYWdlLCAnZW52Jyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBzaGFyZWQgYnkgLm9wdGlvbigpIGFuZCAucmVxdWlyZWRPcHRpb24oKVxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIF9vcHRpb25FeChjb25maWcsIGZsYWdzLCBkZXNjcmlwdGlvbiwgZm4sIGRlZmF1bHRWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgZmxhZ3MgPT09ICdvYmplY3QnICYmIGZsYWdzIGluc3RhbmNlb2YgT3B0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvIGFkZCBhbiBPcHRpb24gb2JqZWN0IHVzZSBhZGRPcHRpb24oKSBpbnN0ZWFkIG9mIG9wdGlvbigpIG9yIHJlcXVpcmVkT3B0aW9uKCknKTtcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9uID0gdGhpcy5jcmVhdGVPcHRpb24oZmxhZ3MsIGRlc2NyaXB0aW9uKTtcbiAgICBvcHRpb24ubWFrZU9wdGlvbk1hbmRhdG9yeSghIWNvbmZpZy5tYW5kYXRvcnkpO1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9wdGlvbi5kZWZhdWx0KGRlZmF1bHRWYWx1ZSkuYXJnUGFyc2VyKGZuKTtcbiAgICB9IGVsc2UgaWYgKGZuIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAvLyBkZXByZWNhdGVkXG4gICAgICBjb25zdCByZWdleCA9IGZuO1xuICAgICAgZm4gPSAodmFsLCBkZWYpID0+IHtcbiAgICAgICAgY29uc3QgbSA9IHJlZ2V4LmV4ZWModmFsKTtcbiAgICAgICAgcmV0dXJuIG0gPyBtWzBdIDogZGVmO1xuICAgICAgfTtcbiAgICAgIG9wdGlvbi5kZWZhdWx0KGRlZmF1bHRWYWx1ZSkuYXJnUGFyc2VyKGZuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9uLmRlZmF1bHQoZm4pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmFkZE9wdGlvbihvcHRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZSBvcHRpb24gd2l0aCBgZmxhZ3NgLCBgZGVzY3JpcHRpb25gIGFuZCBvcHRpb25hbFxuICAgKiBjb2VyY2lvbiBgZm5gLlxuICAgKlxuICAgKiBUaGUgYGZsYWdzYCBzdHJpbmcgY29udGFpbnMgdGhlIHNob3J0IGFuZC9vciBsb25nIGZsYWdzLFxuICAgKiBzZXBhcmF0ZWQgYnkgY29tbWEsIGEgcGlwZSBvciBzcGFjZS4gVGhlIGZvbGxvd2luZyBhcmUgYWxsIHZhbGlkXG4gICAqIGFsbCB3aWxsIG91dHB1dCB0aGlzIHdheSB3aGVuIGAtLWhlbHBgIGlzIHVzZWQuXG4gICAqXG4gICAqICAgICBcIi1wLCAtLXBlcHBlclwiXG4gICAqICAgICBcIi1wfC0tcGVwcGVyXCJcbiAgICogICAgIFwiLXAgLS1wZXBwZXJcIlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBzaW1wbGUgYm9vbGVhbiBkZWZhdWx0aW5nIHRvIHVuZGVmaW5lZFxuICAgKiBwcm9ncmFtLm9wdGlvbignLXAsIC0tcGVwcGVyJywgJ2FkZCBwZXBwZXInKTtcbiAgICpcbiAgICogcHJvZ3JhbS5wZXBwZXJcbiAgICogLy8gPT4gdW5kZWZpbmVkXG4gICAqXG4gICAqIC0tcGVwcGVyXG4gICAqIHByb2dyYW0ucGVwcGVyXG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogLy8gc2ltcGxlIGJvb2xlYW4gZGVmYXVsdGluZyB0byB0cnVlICh1bmxlc3Mgbm9uLW5lZ2F0ZWQgb3B0aW9uIGlzIGFsc28gZGVmaW5lZClcbiAgICogcHJvZ3JhbS5vcHRpb24oJy1DLCAtLW5vLWNoZWVzZScsICdyZW1vdmUgY2hlZXNlJyk7XG4gICAqXG4gICAqIHByb2dyYW0uY2hlZXNlXG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogLS1uby1jaGVlc2VcbiAgICogcHJvZ3JhbS5jaGVlc2VcbiAgICogLy8gPT4gZmFsc2VcbiAgICpcbiAgICogLy8gcmVxdWlyZWQgYXJndW1lbnRcbiAgICogcHJvZ3JhbS5vcHRpb24oJy1DLCAtLWNoZGlyIDxwYXRoPicsICdjaGFuZ2UgdGhlIHdvcmtpbmcgZGlyZWN0b3J5Jyk7XG4gICAqXG4gICAqIC0tY2hkaXIgL3RtcFxuICAgKiBwcm9ncmFtLmNoZGlyXG4gICAqIC8vID0+IFwiL3RtcFwiXG4gICAqXG4gICAqIC8vIG9wdGlvbmFsIGFyZ3VtZW50XG4gICAqIHByb2dyYW0ub3B0aW9uKCctYywgLS1jaGVlc2UgW3R5cGVdJywgJ2FkZCBjaGVlc2UgW21hcmJsZV0nKTtcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZsYWdzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSB7RnVuY3Rpb258Kn0gW2ZuXSAtIGN1c3RvbSBvcHRpb24gcHJvY2Vzc2luZyBmdW5jdGlvbiBvciBkZWZhdWx0IHZhbHVlXG4gICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV1cbiAgICogQHJldHVybiB7Q29tbWFuZH0gYHRoaXNgIGNvbW1hbmQgZm9yIGNoYWluaW5nXG4gICAqL1xuXG4gIG9wdGlvbihmbGFncywgZGVzY3JpcHRpb24sIGZuLCBkZWZhdWx0VmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9uRXgoe30sIGZsYWdzLCBkZXNjcmlwdGlvbiwgZm4sIGRlZmF1bHRWYWx1ZSk7XG4gIH1cblxuICAvKipcbiAgKiBBZGQgYSByZXF1aXJlZCBvcHRpb24gd2hpY2ggbXVzdCBoYXZlIGEgdmFsdWUgYWZ0ZXIgcGFyc2luZy4gVGhpcyB1c3VhbGx5IG1lYW5zXG4gICogdGhlIG9wdGlvbiBtdXN0IGJlIHNwZWNpZmllZCBvbiB0aGUgY29tbWFuZCBsaW5lLiAoT3RoZXJ3aXNlIHRoZSBzYW1lIGFzIC5vcHRpb24oKS4pXG4gICpcbiAgKiBUaGUgYGZsYWdzYCBzdHJpbmcgY29udGFpbnMgdGhlIHNob3J0IGFuZC9vciBsb25nIGZsYWdzLCBzZXBhcmF0ZWQgYnkgY29tbWEsIGEgcGlwZSBvciBzcGFjZS5cbiAgKlxuICAqIEBwYXJhbSB7c3RyaW5nfSBmbGFnc1xuICAqIEBwYXJhbSB7c3RyaW5nfSBbZGVzY3JpcHRpb25dXG4gICogQHBhcmFtIHtGdW5jdGlvbnwqfSBbZm5dIC0gY3VzdG9tIG9wdGlvbiBwcm9jZXNzaW5nIGZ1bmN0aW9uIG9yIGRlZmF1bHQgdmFsdWVcbiAgKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdXG4gICogQHJldHVybiB7Q29tbWFuZH0gYHRoaXNgIGNvbW1hbmQgZm9yIGNoYWluaW5nXG4gICovXG5cbiAgcmVxdWlyZWRPcHRpb24oZmxhZ3MsIGRlc2NyaXB0aW9uLCBmbiwgZGVmYXVsdFZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbkV4KHsgbWFuZGF0b3J5OiB0cnVlIH0sIGZsYWdzLCBkZXNjcmlwdGlvbiwgZm4sIGRlZmF1bHRWYWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQWx0ZXIgcGFyc2luZyBvZiBzaG9ydCBmbGFncyB3aXRoIG9wdGlvbmFsIHZhbHVlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogLy8gZm9yIGAub3B0aW9uKCctZiwtLWZsYWcgW3ZhbHVlXScpOlxuICAgKiBwcm9ncmFtLmNvbWJpbmVGbGFnQW5kT3B0aW9uYWxWYWx1ZSh0cnVlKTsgIC8vIGAtZjgwYCBpcyB0cmVhdGVkIGxpa2UgYC0tZmxhZz04MGAsIHRoaXMgaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3VyXG4gICAqIHByb2dyYW0uY29tYmluZUZsYWdBbmRPcHRpb25hbFZhbHVlKGZhbHNlKSAvLyBgLWZiYCBpcyB0cmVhdGVkIGxpa2UgYC1mIC1iYFxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb21iaW5lPXRydWVdIC0gaWYgYHRydWVgIG9yIG9taXR0ZWQsIGFuIG9wdGlvbmFsIHZhbHVlIGNhbiBiZSBzcGVjaWZpZWQgZGlyZWN0bHkgYWZ0ZXIgdGhlIGZsYWcuXG4gICAqL1xuICBjb21iaW5lRmxhZ0FuZE9wdGlvbmFsVmFsdWUoY29tYmluZSA9IHRydWUpIHtcbiAgICB0aGlzLl9jb21iaW5lRmxhZ0FuZE9wdGlvbmFsVmFsdWUgPSAhIWNvbWJpbmU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQWxsb3cgdW5rbm93biBvcHRpb25zIG9uIHRoZSBjb21tYW5kIGxpbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FsbG93VW5rbm93bj10cnVlXSAtIGlmIGB0cnVlYCBvciBvbWl0dGVkLCBubyBlcnJvciB3aWxsIGJlIHRocm93blxuICAgKiBmb3IgdW5rbm93biBvcHRpb25zLlxuICAgKi9cbiAgYWxsb3dVbmtub3duT3B0aW9uKGFsbG93VW5rbm93biA9IHRydWUpIHtcbiAgICB0aGlzLl9hbGxvd1Vua25vd25PcHRpb24gPSAhIWFsbG93VW5rbm93bjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGxvdyBleGNlc3MgY29tbWFuZC1hcmd1bWVudHMgb24gdGhlIGNvbW1hbmQgbGluZS4gUGFzcyBmYWxzZSB0byBtYWtlIGV4Y2VzcyBhcmd1bWVudHMgYW4gZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FsbG93RXhjZXNzPXRydWVdIC0gaWYgYHRydWVgIG9yIG9taXR0ZWQsIG5vIGVycm9yIHdpbGwgYmUgdGhyb3duXG4gICAqIGZvciBleGNlc3MgYXJndW1lbnRzLlxuICAgKi9cbiAgYWxsb3dFeGNlc3NBcmd1bWVudHMoYWxsb3dFeGNlc3MgPSB0cnVlKSB7XG4gICAgdGhpcy5fYWxsb3dFeGNlc3NBcmd1bWVudHMgPSAhIWFsbG93RXhjZXNzO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuYWJsZSBwb3NpdGlvbmFsIG9wdGlvbnMuIFBvc2l0aW9uYWwgbWVhbnMgZ2xvYmFsIG9wdGlvbnMgYXJlIHNwZWNpZmllZCBiZWZvcmUgc3ViY29tbWFuZHMgd2hpY2ggbGV0c1xuICAgKiBzdWJjb21tYW5kcyByZXVzZSB0aGUgc2FtZSBvcHRpb24gbmFtZXMsIGFuZCBhbHNvIGVuYWJsZXMgc3ViY29tbWFuZHMgdG8gdHVybiBvbiBwYXNzVGhyb3VnaE9wdGlvbnMuXG4gICAqIFRoZSBkZWZhdWx0IGJlaGF2aW91ciBpcyBub24tcG9zaXRpb25hbCBhbmQgZ2xvYmFsIG9wdGlvbnMgbWF5IGFwcGVhciBhbnl3aGVyZSBvbiB0aGUgY29tbWFuZCBsaW5lLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwb3NpdGlvbmFsPXRydWVdXG4gICAqL1xuICBlbmFibGVQb3NpdGlvbmFsT3B0aW9ucyhwb3NpdGlvbmFsID0gdHJ1ZSkge1xuICAgIHRoaXMuX2VuYWJsZVBvc2l0aW9uYWxPcHRpb25zID0gISFwb3NpdGlvbmFsO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhc3MgdGhyb3VnaCBvcHRpb25zIHRoYXQgY29tZSBhZnRlciBjb21tYW5kLWFyZ3VtZW50cyByYXRoZXIgdGhhbiB0cmVhdCB0aGVtIGFzIGNvbW1hbmQtb3B0aW9ucyxcbiAgICogc28gYWN0dWFsIGNvbW1hbmQtb3B0aW9ucyBjb21lIGJlZm9yZSBjb21tYW5kLWFyZ3VtZW50cy4gVHVybmluZyB0aGlzIG9uIGZvciBhIHN1YmNvbW1hbmQgcmVxdWlyZXNcbiAgICogcG9zaXRpb25hbCBvcHRpb25zIHRvIGhhdmUgYmVlbiBlbmFibGVkIG9uIHRoZSBwcm9ncmFtIChwYXJlbnQgY29tbWFuZHMpLlxuICAgKiBUaGUgZGVmYXVsdCBiZWhhdmlvdXIgaXMgbm9uLXBvc2l0aW9uYWwgYW5kIG9wdGlvbnMgbWF5IGFwcGVhciBiZWZvcmUgb3IgYWZ0ZXIgY29tbWFuZC1hcmd1bWVudHMuXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Bhc3NUaHJvdWdoPXRydWVdXG4gICAqIGZvciB1bmtub3duIG9wdGlvbnMuXG4gICAqL1xuICBwYXNzVGhyb3VnaE9wdGlvbnMocGFzc1Rocm91Z2ggPSB0cnVlKSB7XG4gICAgdGhpcy5fcGFzc1Rocm91Z2hPcHRpb25zID0gISFwYXNzVGhyb3VnaDtcbiAgICBpZiAoISF0aGlzLnBhcmVudCAmJiBwYXNzVGhyb3VnaCAmJiAhdGhpcy5wYXJlbnQuX2VuYWJsZVBvc2l0aW9uYWxPcHRpb25zKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Bhc3NUaHJvdWdoT3B0aW9ucyBjYW4gbm90IGJlIHVzZWQgd2l0aG91dCB0dXJuaW5nIG9uIGVuYWJsZVBvc2l0aW9uYWxPcHRpb25zIGZvciBwYXJlbnQgY29tbWFuZChzKScpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgICogV2hldGhlciB0byBzdG9yZSBvcHRpb24gdmFsdWVzIGFzIHByb3BlcnRpZXMgb24gY29tbWFuZCBvYmplY3QsXG4gICAgKiBvciBzdG9yZSBzZXBhcmF0ZWx5IChzcGVjaWZ5IGZhbHNlKS4gSW4gYm90aCBjYXNlcyB0aGUgb3B0aW9uIHZhbHVlcyBjYW4gYmUgYWNjZXNzZWQgdXNpbmcgLm9wdHMoKS5cbiAgICAqXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzdG9yZUFzUHJvcGVydGllcz10cnVlXVxuICAgICogQHJldHVybiB7Q29tbWFuZH0gYHRoaXNgIGNvbW1hbmQgZm9yIGNoYWluaW5nXG4gICAgKi9cblxuICBzdG9yZU9wdGlvbnNBc1Byb3BlcnRpZXMoc3RvcmVBc1Byb3BlcnRpZXMgPSB0cnVlKSB7XG4gICAgdGhpcy5fc3RvcmVPcHRpb25zQXNQcm9wZXJ0aWVzID0gISFzdG9yZUFzUHJvcGVydGllcztcbiAgICBpZiAodGhpcy5vcHRpb25zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsIC5zdG9yZU9wdGlvbnNBc1Byb3BlcnRpZXMoKSBiZWZvcmUgYWRkaW5nIG9wdGlvbnMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmUgb3B0aW9uIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEByZXR1cm4ge09iamVjdH0gdmFsdWVcbiAgICovXG5cbiAgZ2V0T3B0aW9uVmFsdWUoa2V5KSB7XG4gICAgaWYgKHRoaXMuX3N0b3JlT3B0aW9uc0FzUHJvcGVydGllcykge1xuICAgICAgcmV0dXJuIHRoaXNba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvblZhbHVlc1trZXldO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlIG9wdGlvbiB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICogQHJldHVybiB7Q29tbWFuZH0gYHRoaXNgIGNvbW1hbmQgZm9yIGNoYWluaW5nXG4gICAqL1xuXG4gIHNldE9wdGlvblZhbHVlKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRPcHRpb25WYWx1ZVdpdGhTb3VyY2Uoa2V5LCB2YWx1ZSwgdW5kZWZpbmVkKTtcbiAgfVxuXG4gIC8qKlxuICAgICogU3RvcmUgb3B0aW9uIHZhbHVlIGFuZCB3aGVyZSB0aGUgdmFsdWUgY2FtZSBmcm9tLlxuICAgICpcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSAtIGV4cGVjdGVkIHZhbHVlcyBhcmUgZGVmYXVsdC9jb25maWcvZW52L2NsaS9pbXBsaWVkXG4gICAgKiBAcmV0dXJuIHtDb21tYW5kfSBgdGhpc2AgY29tbWFuZCBmb3IgY2hhaW5pbmdcbiAgICAqL1xuXG4gIHNldE9wdGlvblZhbHVlV2l0aFNvdXJjZShrZXksIHZhbHVlLCBzb3VyY2UpIHtcbiAgICBpZiAodGhpcy5fc3RvcmVPcHRpb25zQXNQcm9wZXJ0aWVzKSB7XG4gICAgICB0aGlzW2tleV0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fb3B0aW9uVmFsdWVzW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgdGhpcy5fb3B0aW9uVmFsdWVTb3VyY2VzW2tleV0gPSBzb3VyY2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICAqIEdldCBzb3VyY2Ugb2Ygb3B0aW9uIHZhbHVlLlxuICAgICogRXhwZWN0ZWQgdmFsdWVzIGFyZSBkZWZhdWx0IHwgY29uZmlnIHwgZW52IHwgY2xpIHwgaW1wbGllZFxuICAgICpcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAqL1xuXG4gIGdldE9wdGlvblZhbHVlU291cmNlKGtleSkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25WYWx1ZVNvdXJjZXNba2V5XTtcbiAgfVxuXG4gIC8qKlxuICAgICogR2V0IHNvdXJjZSBvZiBvcHRpb24gdmFsdWUuIFNlZSBhbHNvIC5vcHRzV2l0aEdsb2JhbHMoKS5cbiAgICAqIEV4cGVjdGVkIHZhbHVlcyBhcmUgZGVmYXVsdCB8IGNvbmZpZyB8IGVudiB8IGNsaSB8IGltcGxpZWRcbiAgICAqXG4gICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgKi9cblxuICBnZXRPcHRpb25WYWx1ZVNvdXJjZVdpdGhHbG9iYWxzKGtleSkge1xuICAgIC8vIGdsb2JhbCBvdmVyd3JpdGVzIGxvY2FsLCBsaWtlIG9wdHNXaXRoR2xvYmFsc1xuICAgIGxldCBzb3VyY2U7XG4gICAgZ2V0Q29tbWFuZEFuZFBhcmVudHModGhpcykuZm9yRWFjaCgoY21kKSA9PiB7XG4gICAgICBpZiAoY21kLmdldE9wdGlvblZhbHVlU291cmNlKGtleSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzb3VyY2UgPSBjbWQuZ2V0T3B0aW9uVmFsdWVTb3VyY2Uoa2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB1c2VyIGFyZ3VtZW50cyBmcm9tIGltcGxpZWQgb3IgZXhwbGljaXQgYXJndW1lbnRzLlxuICAgKiBTaWRlLWVmZmVjdHM6IHNldCBfc2NyaXB0UGF0aCBpZiBhcmdzIGluY2x1ZGVkIHNjcmlwdC4gVXNlZCBmb3IgZGVmYXVsdCBwcm9ncmFtIG5hbWUsIGFuZCBzdWJjb21tYW5kIHNlYXJjaGVzLlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgX3ByZXBhcmVVc2VyQXJncyhhcmd2LCBwYXJzZU9wdGlvbnMpIHtcbiAgICBpZiAoYXJndiAhPT0gdW5kZWZpbmVkICYmICFBcnJheS5pc0FycmF5KGFyZ3YpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IHBhcmFtZXRlciB0byBwYXJzZSBtdXN0IGJlIGFycmF5IG9yIHVuZGVmaW5lZCcpO1xuICAgIH1cbiAgICBwYXJzZU9wdGlvbnMgPSBwYXJzZU9wdGlvbnMgfHwge307XG5cbiAgICAvLyBEZWZhdWx0IHRvIHVzaW5nIHByb2Nlc3MuYXJndlxuICAgIGlmIChhcmd2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGFyZ3YgPSBwcm9jZXNzLmFyZ3Y7XG4gICAgICAvLyBAdHMtaWdub3JlOiB1bmtub3duIHByb3BlcnR5XG4gICAgICBpZiAocHJvY2Vzcy52ZXJzaW9ucyAmJiBwcm9jZXNzLnZlcnNpb25zLmVsZWN0cm9uKSB7XG4gICAgICAgIHBhcnNlT3B0aW9ucy5mcm9tID0gJ2VsZWN0cm9uJztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5yYXdBcmdzID0gYXJndi5zbGljZSgpO1xuXG4gICAgLy8gbWFrZSBpdCBhIGxpdHRsZSBlYXNpZXIgZm9yIGNhbGxlcnMgYnkgc3VwcG9ydGluZyB2YXJpb3VzIGFyZ3YgY29udmVudGlvbnNcbiAgICBsZXQgdXNlckFyZ3M7XG4gICAgc3dpdGNoIChwYXJzZU9wdGlvbnMuZnJvbSkge1xuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICBjYXNlICdub2RlJzpcbiAgICAgICAgdGhpcy5fc2NyaXB0UGF0aCA9IGFyZ3ZbMV07XG4gICAgICAgIHVzZXJBcmdzID0gYXJndi5zbGljZSgyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdlbGVjdHJvbic6XG4gICAgICAgIC8vIEB0cy1pZ25vcmU6IHVua25vd24gcHJvcGVydHlcbiAgICAgICAgaWYgKHByb2Nlc3MuZGVmYXVsdEFwcCkge1xuICAgICAgICAgIHRoaXMuX3NjcmlwdFBhdGggPSBhcmd2WzFdO1xuICAgICAgICAgIHVzZXJBcmdzID0gYXJndi5zbGljZSgyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1c2VyQXJncyA9IGFyZ3Yuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd1c2VyJzpcbiAgICAgICAgdXNlckFyZ3MgPSBhcmd2LnNsaWNlKDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5leHBlY3RlZCBwYXJzZSBvcHRpb24geyBmcm9tOiAnJHtwYXJzZU9wdGlvbnMuZnJvbX0nIH1gKTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIGRlZmF1bHQgbmFtZSBmb3IgcHJvZ3JhbSBmcm9tIGFyZ3VtZW50cy5cbiAgICBpZiAoIXRoaXMuX25hbWUgJiYgdGhpcy5fc2NyaXB0UGF0aCkgdGhpcy5uYW1lRnJvbUZpbGVuYW1lKHRoaXMuX3NjcmlwdFBhdGgpO1xuICAgIHRoaXMuX25hbWUgPSB0aGlzLl9uYW1lIHx8ICdwcm9ncmFtJztcblxuICAgIHJldHVybiB1c2VyQXJncztcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBgYXJndmAsIHNldHRpbmcgb3B0aW9ucyBhbmQgaW52b2tpbmcgY29tbWFuZHMgd2hlbiBkZWZpbmVkLlxuICAgKlxuICAgKiBUaGUgZGVmYXVsdCBleHBlY3RhdGlvbiBpcyB0aGF0IHRoZSBhcmd1bWVudHMgYXJlIGZyb20gbm9kZSBhbmQgaGF2ZSB0aGUgYXBwbGljYXRpb24gYXMgYXJndlswXVxuICAgKiBhbmQgdGhlIHNjcmlwdCBiZWluZyBydW4gaW4gYXJndlsxXSwgd2l0aCB1c2VyIHBhcmFtZXRlcnMgYWZ0ZXIgdGhhdC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogcHJvZ3JhbS5wYXJzZShwcm9jZXNzLmFyZ3YpO1xuICAgKiBwcm9ncmFtLnBhcnNlKCk7IC8vIGltcGxpY2l0bHkgdXNlIHByb2Nlc3MuYXJndiBhbmQgYXV0by1kZXRlY3Qgbm9kZSB2cyBlbGVjdHJvbiBjb252ZW50aW9uc1xuICAgKiBwcm9ncmFtLnBhcnNlKG15LWFyZ3MsIHsgZnJvbTogJ3VzZXInIH0pOyAvLyBqdXN0IHVzZXIgc3VwcGxpZWQgYXJndW1lbnRzLCBub3RoaW5nIHNwZWNpYWwgYWJvdXQgYXJndlswXVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBbYXJndl0gLSBvcHRpb25hbCwgZGVmYXVsdHMgdG8gcHJvY2Vzcy5hcmd2XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyc2VPcHRpb25zXSAtIG9wdGlvbmFsbHkgc3BlY2lmeSBzdHlsZSBvZiBvcHRpb25zIHdpdGggZnJvbTogbm9kZS91c2VyL2VsZWN0cm9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyc2VPcHRpb25zLmZyb21dIC0gd2hlcmUgdGhlIGFyZ3MgYXJlIGZyb206ICdub2RlJywgJ3VzZXInLCAnZWxlY3Ryb24nXG4gICAqIEByZXR1cm4ge0NvbW1hbmR9IGB0aGlzYCBjb21tYW5kIGZvciBjaGFpbmluZ1xuICAgKi9cblxuICBwYXJzZShhcmd2LCBwYXJzZU9wdGlvbnMpIHtcbiAgICBjb25zdCB1c2VyQXJncyA9IHRoaXMuX3ByZXBhcmVVc2VyQXJncyhhcmd2LCBwYXJzZU9wdGlvbnMpO1xuICAgIHRoaXMuX3BhcnNlQ29tbWFuZChbXSwgdXNlckFyZ3MpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgYGFyZ3ZgLCBzZXR0aW5nIG9wdGlvbnMgYW5kIGludm9raW5nIGNvbW1hbmRzIHdoZW4gZGVmaW5lZC5cbiAgICpcbiAgICogVXNlIHBhcnNlQXN5bmMgaW5zdGVhZCBvZiBwYXJzZSBpZiBhbnkgb2YgeW91ciBhY3Rpb24gaGFuZGxlcnMgYXJlIGFzeW5jLiBSZXR1cm5zIGEgUHJvbWlzZS5cbiAgICpcbiAgICogVGhlIGRlZmF1bHQgZXhwZWN0YXRpb24gaXMgdGhhdCB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIG5vZGUgYW5kIGhhdmUgdGhlIGFwcGxpY2F0aW9uIGFzIGFyZ3ZbMF1cbiAgICogYW5kIHRoZSBzY3JpcHQgYmVpbmcgcnVuIGluIGFyZ3ZbMV0sIHdpdGggdXNlciBwYXJhbWV0ZXJzIGFmdGVyIHRoYXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGF3YWl0IHByb2dyYW0ucGFyc2VBc3luYyhwcm9jZXNzLmFyZ3YpO1xuICAgKiBhd2FpdCBwcm9ncmFtLnBhcnNlQXN5bmMoKTsgLy8gaW1wbGljaXRseSB1c2UgcHJvY2Vzcy5hcmd2IGFuZCBhdXRvLWRldGVjdCBub2RlIHZzIGVsZWN0cm9uIGNvbnZlbnRpb25zXG4gICAqIGF3YWl0IHByb2dyYW0ucGFyc2VBc3luYyhteS1hcmdzLCB7IGZyb206ICd1c2VyJyB9KTsgLy8ganVzdCB1c2VyIHN1cHBsaWVkIGFyZ3VtZW50cywgbm90aGluZyBzcGVjaWFsIGFib3V0IGFyZ3ZbMF1cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gW2FyZ3ZdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyc2VPcHRpb25zXVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyc2VPcHRpb25zLmZyb20gLSB3aGVyZSB0aGUgYXJncyBhcmUgZnJvbTogJ25vZGUnLCAndXNlcicsICdlbGVjdHJvbidcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG5cbiAgYXN5bmMgcGFyc2VBc3luYyhhcmd2LCBwYXJzZU9wdGlvbnMpIHtcbiAgICBjb25zdCB1c2VyQXJncyA9IHRoaXMuX3ByZXBhcmVVc2VyQXJncyhhcmd2LCBwYXJzZU9wdGlvbnMpO1xuICAgIGF3YWl0IHRoaXMuX3BhcnNlQ29tbWFuZChbXSwgdXNlckFyZ3MpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZSBhIHN1Yi1jb21tYW5kIGV4ZWN1dGFibGUuXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBfZXhlY3V0ZVN1YkNvbW1hbmQoc3ViY29tbWFuZCwgYXJncykge1xuICAgIGFyZ3MgPSBhcmdzLnNsaWNlKCk7XG4gICAgbGV0IGxhdW5jaFdpdGhOb2RlID0gZmFsc2U7IC8vIFVzZSBub2RlIGZvciBzb3VyY2UgdGFyZ2V0cyBzbyBkbyBub3QgbmVlZCB0byBnZXQgcGVybWlzc2lvbnMgY29ycmVjdCwgYW5kIG9uIFdpbmRvd3MuXG4gICAgY29uc3Qgc291cmNlRXh0ID0gWycuanMnLCAnLnRzJywgJy50c3gnLCAnLm1qcycsICcuY2pzJ107XG5cbiAgICBmdW5jdGlvbiBmaW5kRmlsZShiYXNlRGlyLCBiYXNlTmFtZSkge1xuICAgICAgLy8gTG9vayBmb3Igc3BlY2lmaWVkIGZpbGVcbiAgICAgIGNvbnN0IGxvY2FsQmluID0gcGF0aC5yZXNvbHZlKGJhc2VEaXIsIGJhc2VOYW1lKTtcbiAgICAgIGlmIChmcy5leGlzdHNTeW5jKGxvY2FsQmluKSkgcmV0dXJuIGxvY2FsQmluO1xuXG4gICAgICAvLyBTdG9wIGxvb2tpbmcgaWYgY2FuZGlkYXRlIGFscmVhZHkgaGFzIGFuIGV4cGVjdGVkIGV4dGVuc2lvbi5cbiAgICAgIGlmIChzb3VyY2VFeHQuaW5jbHVkZXMocGF0aC5leHRuYW1lKGJhc2VOYW1lKSkpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICAgIC8vIFRyeSBhbGwgdGhlIGV4dGVuc2lvbnMuXG4gICAgICBjb25zdCBmb3VuZEV4dCA9IHNvdXJjZUV4dC5maW5kKGV4dCA9PiBmcy5leGlzdHNTeW5jKGAke2xvY2FsQmlufSR7ZXh0fWApKTtcbiAgICAgIGlmIChmb3VuZEV4dCkgcmV0dXJuIGAke2xvY2FsQmlufSR7Zm91bmRFeHR9YDtcblxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBOb3QgY2hlY2tpbmcgZm9yIGhlbHAgZmlyc3QuIFVubGlrZWx5IHRvIGhhdmUgbWFuZGF0b3J5IGFuZCBleGVjdXRhYmxlLCBhbmQgY2FuJ3Qgcm9idXN0bHkgdGVzdCBmb3IgaGVscCBmbGFncyBpbiBleHRlcm5hbCBjb21tYW5kLlxuICAgIHRoaXMuX2NoZWNrRm9yTWlzc2luZ01hbmRhdG9yeU9wdGlvbnMoKTtcbiAgICB0aGlzLl9jaGVja0ZvckNvbmZsaWN0aW5nT3B0aW9ucygpO1xuXG4gICAgLy8gZXhlY3V0YWJsZUZpbGUgYW5kIGV4ZWN1dGFibGVEaXIgbWlnaHQgYmUgZnVsbCBwYXRoLCBvciBqdXN0IGEgbmFtZVxuICAgIGxldCBleGVjdXRhYmxlRmlsZSA9IHN1YmNvbW1hbmQuX2V4ZWN1dGFibGVGaWxlIHx8IGAke3RoaXMuX25hbWV9LSR7c3ViY29tbWFuZC5fbmFtZX1gO1xuICAgIGxldCBleGVjdXRhYmxlRGlyID0gdGhpcy5fZXhlY3V0YWJsZURpciB8fCAnJztcbiAgICBpZiAodGhpcy5fc2NyaXB0UGF0aCkge1xuICAgICAgbGV0IHJlc29sdmVkU2NyaXB0UGF0aDsgLy8gcmVzb2x2ZSBwb3NzaWJsZSBzeW1saW5rIGZvciBpbnN0YWxsZWQgbnBtIGJpbmFyeVxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzb2x2ZWRTY3JpcHRQYXRoID0gZnMucmVhbHBhdGhTeW5jKHRoaXMuX3NjcmlwdFBhdGgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlc29sdmVkU2NyaXB0UGF0aCA9IHRoaXMuX3NjcmlwdFBhdGg7XG4gICAgICB9XG4gICAgICBleGVjdXRhYmxlRGlyID0gcGF0aC5yZXNvbHZlKHBhdGguZGlybmFtZShyZXNvbHZlZFNjcmlwdFBhdGgpLCBleGVjdXRhYmxlRGlyKTtcbiAgICB9XG5cbiAgICAvLyBMb29rIGZvciBhIGxvY2FsIGZpbGUgaW4gcHJlZmVyZW5jZSB0byBhIGNvbW1hbmQgaW4gUEFUSC5cbiAgICBpZiAoZXhlY3V0YWJsZURpcikge1xuICAgICAgbGV0IGxvY2FsRmlsZSA9IGZpbmRGaWxlKGV4ZWN1dGFibGVEaXIsIGV4ZWN1dGFibGVGaWxlKTtcblxuICAgICAgLy8gTGVnYWN5IHNlYXJjaCB1c2luZyBwcmVmaXggb2Ygc2NyaXB0IG5hbWUgaW5zdGVhZCBvZiBjb21tYW5kIG5hbWVcbiAgICAgIGlmICghbG9jYWxGaWxlICYmICFzdWJjb21tYW5kLl9leGVjdXRhYmxlRmlsZSAmJiB0aGlzLl9zY3JpcHRQYXRoKSB7XG4gICAgICAgIGNvbnN0IGxlZ2FjeU5hbWUgPSBwYXRoLmJhc2VuYW1lKHRoaXMuX3NjcmlwdFBhdGgsIHBhdGguZXh0bmFtZSh0aGlzLl9zY3JpcHRQYXRoKSk7XG4gICAgICAgIGlmIChsZWdhY3lOYW1lICE9PSB0aGlzLl9uYW1lKSB7XG4gICAgICAgICAgbG9jYWxGaWxlID0gZmluZEZpbGUoZXhlY3V0YWJsZURpciwgYCR7bGVnYWN5TmFtZX0tJHtzdWJjb21tYW5kLl9uYW1lfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBleGVjdXRhYmxlRmlsZSA9IGxvY2FsRmlsZSB8fCBleGVjdXRhYmxlRmlsZTtcbiAgICB9XG5cbiAgICBsYXVuY2hXaXRoTm9kZSA9IHNvdXJjZUV4dC5pbmNsdWRlcyhwYXRoLmV4dG5hbWUoZXhlY3V0YWJsZUZpbGUpKTtcblxuICAgIGxldCBwcm9jO1xuICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtICE9PSAnd2luMzInKSB7XG4gICAgICBpZiAobGF1bmNoV2l0aE5vZGUpIHtcbiAgICAgICAgYXJncy51bnNoaWZ0KGV4ZWN1dGFibGVGaWxlKTtcbiAgICAgICAgLy8gYWRkIGV4ZWN1dGFibGUgYXJndW1lbnRzIHRvIHNwYXduXG4gICAgICAgIGFyZ3MgPSBpbmNyZW1lbnROb2RlSW5zcGVjdG9yUG9ydChwcm9jZXNzLmV4ZWNBcmd2KS5jb25jYXQoYXJncyk7XG5cbiAgICAgICAgcHJvYyA9IGNoaWxkUHJvY2Vzcy5zcGF3bihwcm9jZXNzLmFyZ3ZbMF0sIGFyZ3MsIHsgc3RkaW86ICdpbmhlcml0JyB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2MgPSBjaGlsZFByb2Nlc3Muc3Bhd24oZXhlY3V0YWJsZUZpbGUsIGFyZ3MsIHsgc3RkaW86ICdpbmhlcml0JyB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXJncy51bnNoaWZ0KGV4ZWN1dGFibGVGaWxlKTtcbiAgICAgIC8vIGFkZCBleGVjdXRhYmxlIGFyZ3VtZW50cyB0byBzcGF3blxuICAgICAgYXJncyA9IGluY3JlbWVudE5vZGVJbnNwZWN0b3JQb3J0KHByb2Nlc3MuZXhlY0FyZ3YpLmNvbmNhdChhcmdzKTtcbiAgICAgIHByb2MgPSBjaGlsZFByb2Nlc3Muc3Bhd24ocHJvY2Vzcy5leGVjUGF0aCwgYXJncywgeyBzdGRpbzogJ2luaGVyaXQnIH0pO1xuICAgIH1cblxuICAgIGlmICghcHJvYy5raWxsZWQpIHsgLy8gdGVzdGluZyBtYWlubHkgdG8gYXZvaWQgbGVhayB3YXJuaW5ncyBkdXJpbmcgdW5pdCB0ZXN0cyB3aXRoIG1vY2tlZCBzcGF3blxuICAgICAgY29uc3Qgc2lnbmFscyA9IFsnU0lHVVNSMScsICdTSUdVU1IyJywgJ1NJR1RFUk0nLCAnU0lHSU5UJywgJ1NJR0hVUCddO1xuICAgICAgc2lnbmFscy5mb3JFYWNoKChzaWduYWwpID0+IHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBwcm9jZXNzLm9uKHNpZ25hbCwgKCkgPT4ge1xuICAgICAgICAgIGlmIChwcm9jLmtpbGxlZCA9PT0gZmFsc2UgJiYgcHJvYy5leGl0Q29kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvYy5raWxsKHNpZ25hbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEJ5IGRlZmF1bHQgdGVybWluYXRlIHByb2Nlc3Mgd2hlbiBzcGF3bmVkIHByb2Nlc3MgdGVybWluYXRlcy5cbiAgICAvLyBTdXBwcmVzc2luZyB0aGUgZXhpdCBpZiBleGl0Q2FsbGJhY2sgZGVmaW5lZCBpcyBhIGJpdCBtZXNzeSBhbmQgb2YgbGltaXRlZCB1c2UsIGJ1dCBkb2VzIGFsbG93IHByb2Nlc3MgdG8gc3RheSBydW5uaW5nIVxuICAgIGNvbnN0IGV4aXRDYWxsYmFjayA9IHRoaXMuX2V4aXRDYWxsYmFjaztcbiAgICBpZiAoIWV4aXRDYWxsYmFjaykge1xuICAgICAgcHJvYy5vbignY2xvc2UnLCBwcm9jZXNzLmV4aXQuYmluZChwcm9jZXNzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Mub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICBleGl0Q2FsbGJhY2sobmV3IENvbW1hbmRlckVycm9yKHByb2Nlc3MuZXhpdENvZGUgfHwgMCwgJ2NvbW1hbmRlci5leGVjdXRlU3ViQ29tbWFuZEFzeW5jJywgJyhjbG9zZSknKSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcHJvYy5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBpZiAoZXJyLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICAgIGNvbnN0IGV4ZWN1dGFibGVEaXJNZXNzYWdlID0gZXhlY3V0YWJsZURpclxuICAgICAgICAgID8gYHNlYXJjaGVkIGZvciBsb2NhbCBzdWJjb21tYW5kIHJlbGF0aXZlIHRvIGRpcmVjdG9yeSAnJHtleGVjdXRhYmxlRGlyfSdgXG4gICAgICAgICAgOiAnbm8gZGlyZWN0b3J5IGZvciBzZWFyY2ggZm9yIGxvY2FsIHN1YmNvbW1hbmQsIHVzZSAuZXhlY3V0YWJsZURpcigpIHRvIHN1cHBseSBhIGN1c3RvbSBkaXJlY3RvcnknO1xuICAgICAgICBjb25zdCBleGVjdXRhYmxlTWlzc2luZyA9IGAnJHtleGVjdXRhYmxlRmlsZX0nIGRvZXMgbm90IGV4aXN0XG4gLSBpZiAnJHtzdWJjb21tYW5kLl9uYW1lfScgaXMgbm90IG1lYW50IHRvIGJlIGFuIGV4ZWN1dGFibGUgY29tbWFuZCwgcmVtb3ZlIGRlc2NyaXB0aW9uIHBhcmFtZXRlciBmcm9tICcuY29tbWFuZCgpJyBhbmQgdXNlICcuZGVzY3JpcHRpb24oKScgaW5zdGVhZFxuIC0gaWYgdGhlIGRlZmF1bHQgZXhlY3V0YWJsZSBuYW1lIGlzIG5vdCBzdWl0YWJsZSwgdXNlIHRoZSBleGVjdXRhYmxlRmlsZSBvcHRpb24gdG8gc3VwcGx5IGEgY3VzdG9tIG5hbWUgb3IgcGF0aFxuIC0gJHtleGVjdXRhYmxlRGlyTWVzc2FnZX1gO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXhlY3V0YWJsZU1pc3NpbmcpO1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgfSBlbHNlIGlmIChlcnIuY29kZSA9PT0gJ0VBQ0NFUycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAnJHtleGVjdXRhYmxlRmlsZX0nIG5vdCBleGVjdXRhYmxlYCk7XG4gICAgICB9XG4gICAgICBpZiAoIWV4aXRDYWxsYmFjaykge1xuICAgICAgICBwcm9jZXNzLmV4aXQoMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB3cmFwcGVkRXJyb3IgPSBuZXcgQ29tbWFuZGVyRXJyb3IoMSwgJ2NvbW1hbmRlci5leGVjdXRlU3ViQ29tbWFuZEFzeW5jJywgJyhlcnJvciknKTtcbiAgICAgICAgd3JhcHBlZEVycm9yLm5lc3RlZEVycm9yID0gZXJyO1xuICAgICAgICBleGl0Q2FsbGJhY2sod3JhcHBlZEVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFN0b3JlIHRoZSByZWZlcmVuY2UgdG8gdGhlIGNoaWxkIHByb2Nlc3NcbiAgICB0aGlzLnJ1bm5pbmdDb21tYW5kID0gcHJvYztcbiAgfVxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgX2Rpc3BhdGNoU3ViY29tbWFuZChjb21tYW5kTmFtZSwgb3BlcmFuZHMsIHVua25vd24pIHtcbiAgICBjb25zdCBzdWJDb21tYW5kID0gdGhpcy5fZmluZENvbW1hbmQoY29tbWFuZE5hbWUpO1xuICAgIGlmICghc3ViQ29tbWFuZCkgdGhpcy5oZWxwKHsgZXJyb3I6IHRydWUgfSk7XG5cbiAgICBsZXQgaG9va1Jlc3VsdDtcbiAgICBob29rUmVzdWx0ID0gdGhpcy5fY2hhaW5PckNhbGxTdWJDb21tYW5kSG9vayhob29rUmVzdWx0LCBzdWJDb21tYW5kLCAncHJlU3ViY29tbWFuZCcpO1xuICAgIGhvb2tSZXN1bHQgPSB0aGlzLl9jaGFpbk9yQ2FsbChob29rUmVzdWx0LCAoKSA9PiB7XG4gICAgICBpZiAoc3ViQ29tbWFuZC5fZXhlY3V0YWJsZUhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fZXhlY3V0ZVN1YkNvbW1hbmQoc3ViQ29tbWFuZCwgb3BlcmFuZHMuY29uY2F0KHVua25vd24pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzdWJDb21tYW5kLl9wYXJzZUNvbW1hbmQob3BlcmFuZHMsIHVua25vd24pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBob29rUmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHRoaXMuYXJncyBhZ2FpbnN0IGV4cGVjdGVkIHRoaXMuX2FyZ3MuXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBfY2hlY2tOdW1iZXJPZkFyZ3VtZW50cygpIHtcbiAgICAvLyB0b28gZmV3XG4gICAgdGhpcy5fYXJncy5mb3JFYWNoKChhcmcsIGkpID0+IHtcbiAgICAgIGlmIChhcmcucmVxdWlyZWQgJiYgdGhpcy5hcmdzW2ldID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5taXNzaW5nQXJndW1lbnQoYXJnLm5hbWUoKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gdG9vIG1hbnlcbiAgICBpZiAodGhpcy5fYXJncy5sZW5ndGggPiAwICYmIHRoaXMuX2FyZ3NbdGhpcy5fYXJncy5sZW5ndGggLSAxXS52YXJpYWRpYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5hcmdzLmxlbmd0aCA+IHRoaXMuX2FyZ3MubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9leGNlc3NBcmd1bWVudHModGhpcy5hcmdzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyB0aGlzLmFyZ3MgdXNpbmcgdGhpcy5fYXJncyBhbmQgc2F2ZSBhcyB0aGlzLnByb2Nlc3NlZEFyZ3MhXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBfcHJvY2Vzc0FyZ3VtZW50cygpIHtcbiAgICBjb25zdCBteVBhcnNlQXJnID0gKGFyZ3VtZW50LCB2YWx1ZSwgcHJldmlvdXMpID0+IHtcbiAgICAgIC8vIEV4dHJhIHByb2Nlc3NpbmcgZm9yIG5pY2UgZXJyb3IgbWVzc2FnZSBvbiBwYXJzaW5nIGZhaWx1cmUuXG4gICAgICBsZXQgcGFyc2VkVmFsdWUgPSB2YWx1ZTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiBhcmd1bWVudC5wYXJzZUFyZykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHBhcnNlZFZhbHVlID0gYXJndW1lbnQucGFyc2VBcmcodmFsdWUsIHByZXZpb3VzKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaWYgKGVyci5jb2RlID09PSAnY29tbWFuZGVyLmludmFsaWRBcmd1bWVudCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgZXJyb3I6IGNvbW1hbmQtYXJndW1lbnQgdmFsdWUgJyR7dmFsdWV9JyBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCAnJHthcmd1bWVudC5uYW1lKCl9Jy4gJHtlcnIubWVzc2FnZX1gO1xuICAgICAgICAgICAgdGhpcy5lcnJvcihtZXNzYWdlLCB7IGV4aXRDb2RlOiBlcnIuZXhpdENvZGUsIGNvZGU6IGVyci5jb2RlIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZWRWYWx1ZTtcbiAgICB9O1xuXG4gICAgdGhpcy5fY2hlY2tOdW1iZXJPZkFyZ3VtZW50cygpO1xuXG4gICAgY29uc3QgcHJvY2Vzc2VkQXJncyA9IFtdO1xuICAgIHRoaXMuX2FyZ3MuZm9yRWFjaCgoZGVjbGFyZWRBcmcsIGluZGV4KSA9PiB7XG4gICAgICBsZXQgdmFsdWUgPSBkZWNsYXJlZEFyZy5kZWZhdWx0VmFsdWU7XG4gICAgICBpZiAoZGVjbGFyZWRBcmcudmFyaWFkaWMpIHtcbiAgICAgICAgLy8gQ29sbGVjdCB0b2dldGhlciByZW1haW5pbmcgYXJndW1lbnRzIGZvciBwYXNzaW5nIHRvZ2V0aGVyIGFzIGFuIGFycmF5LlxuICAgICAgICBpZiAoaW5kZXggPCB0aGlzLmFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsdWUgPSB0aGlzLmFyZ3Muc2xpY2UoaW5kZXgpO1xuICAgICAgICAgIGlmIChkZWNsYXJlZEFyZy5wYXJzZUFyZykge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZWR1Y2UoKHByb2Nlc3NlZCwgdikgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gbXlQYXJzZUFyZyhkZWNsYXJlZEFyZywgdiwgcHJvY2Vzc2VkKTtcbiAgICAgICAgICAgIH0sIGRlY2xhcmVkQXJnLmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YWx1ZSA9IFtdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGluZGV4IDwgdGhpcy5hcmdzLmxlbmd0aCkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuYXJnc1tpbmRleF07XG4gICAgICAgIGlmIChkZWNsYXJlZEFyZy5wYXJzZUFyZykge1xuICAgICAgICAgIHZhbHVlID0gbXlQYXJzZUFyZyhkZWNsYXJlZEFyZywgdmFsdWUsIGRlY2xhcmVkQXJnLmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHByb2Nlc3NlZEFyZ3NbaW5kZXhdID0gdmFsdWU7XG4gICAgfSk7XG4gICAgdGhpcy5wcm9jZXNzZWRBcmdzID0gcHJvY2Vzc2VkQXJncztcbiAgfVxuXG4gIC8qKlxuICAgKiBPbmNlIHdlIGhhdmUgYSBwcm9taXNlIHdlIGNoYWluLCBidXQgY2FsbCBzeW5jaHJvbm91c2x5IHVudGlsIHRoZW4uXG4gICAqXG4gICAqIEBwYXJhbSB7UHJvbWlzZXx1bmRlZmluZWR9IHByb21pc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICogQHJldHVybiB7UHJvbWlzZXx1bmRlZmluZWR9XG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBfY2hhaW5PckNhbGwocHJvbWlzZSwgZm4pIHtcbiAgICAvLyB0aGVuYWJsZVxuICAgIGlmIChwcm9taXNlICYmIHByb21pc2UudGhlbiAmJiB0eXBlb2YgcHJvbWlzZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBhbHJlYWR5IGhhdmUgYSBwcm9taXNlLCBjaGFpbiBjYWxsYmFja1xuICAgICAgcmV0dXJuIHByb21pc2UudGhlbigoKSA9PiBmbigpKTtcbiAgICB9XG4gICAgLy8gY2FsbGJhY2sgbWlnaHQgcmV0dXJuIGEgcHJvbWlzZVxuICAgIHJldHVybiBmbigpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7UHJvbWlzZXx1bmRlZmluZWR9IHByb21pc2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICAqIEByZXR1cm4ge1Byb21pc2V8dW5kZWZpbmVkfVxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgX2NoYWluT3JDYWxsSG9va3MocHJvbWlzZSwgZXZlbnQpIHtcbiAgICBsZXQgcmVzdWx0ID0gcHJvbWlzZTtcbiAgICBjb25zdCBob29rcyA9IFtdO1xuICAgIGdldENvbW1hbmRBbmRQYXJlbnRzKHRoaXMpXG4gICAgICAucmV2ZXJzZSgpXG4gICAgICAuZmlsdGVyKGNtZCA9PiBjbWQuX2xpZmVDeWNsZUhvb2tzW2V2ZW50XSAhPT0gdW5kZWZpbmVkKVxuICAgICAgLmZvckVhY2goaG9va2VkQ29tbWFuZCA9PiB7XG4gICAgICAgIGhvb2tlZENvbW1hbmQuX2xpZmVDeWNsZUhvb2tzW2V2ZW50XS5mb3JFYWNoKChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgIGhvb2tzLnB1c2goeyBob29rZWRDb21tYW5kLCBjYWxsYmFjayB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICBpZiAoZXZlbnQgPT09ICdwb3N0QWN0aW9uJykge1xuICAgICAgaG9va3MucmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIGhvb2tzLmZvckVhY2goKGhvb2tEZXRhaWwpID0+IHtcbiAgICAgIHJlc3VsdCA9IHRoaXMuX2NoYWluT3JDYWxsKHJlc3VsdCwgKCkgPT4ge1xuICAgICAgICByZXR1cm4gaG9va0RldGFpbC5jYWxsYmFjayhob29rRGV0YWlsLmhvb2tlZENvbW1hbmQsIHRoaXMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge1Byb21pc2V8dW5kZWZpbmVkfSBwcm9taXNlXG4gICAqIEBwYXJhbSB7Q29tbWFuZH0gc3ViQ29tbWFuZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICogQHJldHVybiB7UHJvbWlzZXx1bmRlZmluZWR9XG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBfY2hhaW5PckNhbGxTdWJDb21tYW5kSG9vayhwcm9taXNlLCBzdWJDb21tYW5kLCBldmVudCkge1xuICAgIGxldCByZXN1bHQgPSBwcm9taXNlO1xuICAgIGlmICh0aGlzLl9saWZlQ3ljbGVIb29rc1tldmVudF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fbGlmZUN5Y2xlSG9va3NbZXZlbnRdLmZvckVhY2goKGhvb2spID0+IHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5fY2hhaW5PckNhbGwocmVzdWx0LCAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGhvb2sodGhpcywgc3ViQ29tbWFuZCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyBhcmd1bWVudHMgaW4gY29udGV4dCBvZiB0aGlzIGNvbW1hbmQuXG4gICAqIFJldHVybnMgYWN0aW9uIHJlc3VsdCwgaW4gY2FzZSBpdCBpcyBhIHByb21pc2UuXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBfcGFyc2VDb21tYW5kKG9wZXJhbmRzLCB1bmtub3duKSB7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5wYXJzZU9wdGlvbnModW5rbm93bik7XG4gICAgdGhpcy5fcGFyc2VPcHRpb25zRW52KCk7IC8vIGFmdGVyIGNsaSwgc28gcGFyc2VBcmcgbm90IGNhbGxlZCBvbiBib3RoIGNsaSBhbmQgZW52XG4gICAgdGhpcy5fcGFyc2VPcHRpb25zSW1wbGllZCgpO1xuICAgIG9wZXJhbmRzID0gb3BlcmFuZHMuY29uY2F0KHBhcnNlZC5vcGVyYW5kcyk7XG4gICAgdW5rbm93biA9IHBhcnNlZC51bmtub3duO1xuICAgIHRoaXMuYXJncyA9IG9wZXJhbmRzLmNvbmNhdCh1bmtub3duKTtcblxuICAgIGlmIChvcGVyYW5kcyAmJiB0aGlzLl9maW5kQ29tbWFuZChvcGVyYW5kc1swXSkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kaXNwYXRjaFN1YmNvbW1hbmQob3BlcmFuZHNbMF0sIG9wZXJhbmRzLnNsaWNlKDEpLCB1bmtub3duKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2hhc0ltcGxpY2l0SGVscENvbW1hbmQoKSAmJiBvcGVyYW5kc1swXSA9PT0gdGhpcy5faGVscENvbW1hbmROYW1lKSB7XG4gICAgICBpZiAob3BlcmFuZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRoaXMuaGVscCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3BhdGNoU3ViY29tbWFuZChvcGVyYW5kc1sxXSwgW10sIFt0aGlzLl9oZWxwTG9uZ0ZsYWddKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RlZmF1bHRDb21tYW5kTmFtZSkge1xuICAgICAgb3V0cHV0SGVscElmUmVxdWVzdGVkKHRoaXMsIHVua25vd24pOyAvLyBSdW4gdGhlIGhlbHAgZm9yIGRlZmF1bHQgY29tbWFuZCBmcm9tIHBhcmVudCByYXRoZXIgdGhhbiBwYXNzaW5nIHRvIGRlZmF1bHQgY29tbWFuZFxuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3BhdGNoU3ViY29tbWFuZCh0aGlzLl9kZWZhdWx0Q29tbWFuZE5hbWUsIG9wZXJhbmRzLCB1bmtub3duKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29tbWFuZHMubGVuZ3RoICYmIHRoaXMuYXJncy5sZW5ndGggPT09IDAgJiYgIXRoaXMuX2FjdGlvbkhhbmRsZXIgJiYgIXRoaXMuX2RlZmF1bHRDb21tYW5kTmFtZSkge1xuICAgICAgLy8gcHJvYmFibHkgbWlzc2luZyBzdWJjb21tYW5kIGFuZCBubyBoYW5kbGVyLCB1c2VyIG5lZWRzIGhlbHAgKGFuZCBleGl0KVxuICAgICAgdGhpcy5oZWxwKHsgZXJyb3I6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgb3V0cHV0SGVscElmUmVxdWVzdGVkKHRoaXMsIHBhcnNlZC51bmtub3duKTtcbiAgICB0aGlzLl9jaGVja0Zvck1pc3NpbmdNYW5kYXRvcnlPcHRpb25zKCk7XG4gICAgdGhpcy5fY2hlY2tGb3JDb25mbGljdGluZ09wdGlvbnMoKTtcblxuICAgIC8vIFdlIGRvIG5vdCBhbHdheXMgY2FsbCB0aGlzIGNoZWNrIHRvIGF2b2lkIG1hc2tpbmcgYSBcImJldHRlclwiIGVycm9yLCBsaWtlIHVua25vd24gY29tbWFuZC5cbiAgICBjb25zdCBjaGVja0ZvclVua25vd25PcHRpb25zID0gKCkgPT4ge1xuICAgICAgaWYgKHBhcnNlZC51bmtub3duLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy51bmtub3duT3B0aW9uKHBhcnNlZC51bmtub3duWzBdKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgY29tbWFuZEV2ZW50ID0gYGNvbW1hbmQ6JHt0aGlzLm5hbWUoKX1gO1xuICAgIGlmICh0aGlzLl9hY3Rpb25IYW5kbGVyKSB7XG4gICAgICBjaGVja0ZvclVua25vd25PcHRpb25zKCk7XG4gICAgICB0aGlzLl9wcm9jZXNzQXJndW1lbnRzKCk7XG5cbiAgICAgIGxldCBhY3Rpb25SZXN1bHQ7XG4gICAgICBhY3Rpb25SZXN1bHQgPSB0aGlzLl9jaGFpbk9yQ2FsbEhvb2tzKGFjdGlvblJlc3VsdCwgJ3ByZUFjdGlvbicpO1xuICAgICAgYWN0aW9uUmVzdWx0ID0gdGhpcy5fY2hhaW5PckNhbGwoYWN0aW9uUmVzdWx0LCAoKSA9PiB0aGlzLl9hY3Rpb25IYW5kbGVyKHRoaXMucHJvY2Vzc2VkQXJncykpO1xuICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgIGFjdGlvblJlc3VsdCA9IHRoaXMuX2NoYWluT3JDYWxsKGFjdGlvblJlc3VsdCwgKCkgPT4ge1xuICAgICAgICAgIHRoaXMucGFyZW50LmVtaXQoY29tbWFuZEV2ZW50LCBvcGVyYW5kcywgdW5rbm93bik7IC8vIGxlZ2FjeVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGFjdGlvblJlc3VsdCA9IHRoaXMuX2NoYWluT3JDYWxsSG9va3MoYWN0aW9uUmVzdWx0LCAncG9zdEFjdGlvbicpO1xuICAgICAgcmV0dXJuIGFjdGlvblJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50Lmxpc3RlbmVyQ291bnQoY29tbWFuZEV2ZW50KSkge1xuICAgICAgY2hlY2tGb3JVbmtub3duT3B0aW9ucygpO1xuICAgICAgdGhpcy5fcHJvY2Vzc0FyZ3VtZW50cygpO1xuICAgICAgdGhpcy5wYXJlbnQuZW1pdChjb21tYW5kRXZlbnQsIG9wZXJhbmRzLCB1bmtub3duKTsgLy8gbGVnYWN5XG4gICAgfSBlbHNlIGlmIChvcGVyYW5kcy5sZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLl9maW5kQ29tbWFuZCgnKicpKSB7IC8vIGxlZ2FjeSBkZWZhdWx0IGNvbW1hbmRcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3BhdGNoU3ViY29tbWFuZCgnKicsIG9wZXJhbmRzLCB1bmtub3duKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmxpc3RlbmVyQ291bnQoJ2NvbW1hbmQ6KicpKSB7XG4gICAgICAgIC8vIHNraXAgb3B0aW9uIGNoZWNrLCBlbWl0IGV2ZW50IGZvciBwb3NzaWJsZSBtaXNzcGVsbGluZyBzdWdnZXN0aW9uXG4gICAgICAgIHRoaXMuZW1pdCgnY29tbWFuZDoqJywgb3BlcmFuZHMsIHVua25vd24pO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmNvbW1hbmRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnVua25vd25Db21tYW5kKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGVja0ZvclVua25vd25PcHRpb25zKCk7XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NBcmd1bWVudHMoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuY29tbWFuZHMubGVuZ3RoKSB7XG4gICAgICBjaGVja0ZvclVua25vd25PcHRpb25zKCk7XG4gICAgICAvLyBUaGlzIGNvbW1hbmQgaGFzIHN1YmNvbW1hbmRzIGFuZCBub3RoaW5nIGhvb2tlZCB1cCBhdCB0aGlzIGxldmVsLCBzbyBkaXNwbGF5IGhlbHAgKGFuZCBleGl0KS5cbiAgICAgIHRoaXMuaGVscCh7IGVycm9yOiB0cnVlIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGVja0ZvclVua25vd25PcHRpb25zKCk7XG4gICAgICB0aGlzLl9wcm9jZXNzQXJndW1lbnRzKCk7XG4gICAgICAvLyBmYWxsIHRocm91Z2ggZm9yIGNhbGxlciB0byBoYW5kbGUgYWZ0ZXIgY2FsbGluZyAucGFyc2UoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIG1hdGNoaW5nIGNvbW1hbmQuXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgX2ZpbmRDb21tYW5kKG5hbWUpIHtcbiAgICBpZiAoIW5hbWUpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHRoaXMuY29tbWFuZHMuZmluZChjbWQgPT4gY21kLl9uYW1lID09PSBuYW1lIHx8IGNtZC5fYWxpYXNlcy5pbmNsdWRlcyhuYW1lKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIG9wdGlvbiBtYXRjaGluZyBgYXJnYCBpZiBhbnkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhcmdcbiAgICogQHJldHVybiB7T3B0aW9ufVxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgX2ZpbmRPcHRpb24oYXJnKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5maW5kKG9wdGlvbiA9PiBvcHRpb24uaXMoYXJnKSk7XG4gIH1cblxuICAvKipcbiAgICogRGlzcGxheSBhbiBlcnJvciBtZXNzYWdlIGlmIGEgbWFuZGF0b3J5IG9wdGlvbiBkb2VzIG5vdCBoYXZlIGEgdmFsdWUuXG4gICAqIENhbGxlZCBhZnRlciBjaGVja2luZyBmb3IgaGVscCBmbGFncyBpbiBsZWFmIHN1YmNvbW1hbmQuXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBfY2hlY2tGb3JNaXNzaW5nTWFuZGF0b3J5T3B0aW9ucygpIHtcbiAgICAvLyBXYWxrIHVwIGhpZXJhcmNoeSBzbyBjYW4gY2FsbCBpbiBzdWJjb21tYW5kIGFmdGVyIGNoZWNraW5nIGZvciBkaXNwbGF5aW5nIGhlbHAuXG4gICAgZm9yIChsZXQgY21kID0gdGhpczsgY21kOyBjbWQgPSBjbWQucGFyZW50KSB7XG4gICAgICBjbWQub3B0aW9ucy5mb3JFYWNoKChhbk9wdGlvbikgPT4ge1xuICAgICAgICBpZiAoYW5PcHRpb24ubWFuZGF0b3J5ICYmIChjbWQuZ2V0T3B0aW9uVmFsdWUoYW5PcHRpb24uYXR0cmlidXRlTmFtZSgpKSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgIGNtZC5taXNzaW5nTWFuZGF0b3J5T3B0aW9uVmFsdWUoYW5PcHRpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGlzcGxheSBhbiBlcnJvciBtZXNzYWdlIGlmIGNvbmZsaWN0aW5nIG9wdGlvbnMgYXJlIHVzZWQgdG9nZXRoZXIgaW4gdGhpcy5cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBfY2hlY2tGb3JDb25mbGljdGluZ0xvY2FsT3B0aW9ucygpIHtcbiAgICBjb25zdCBkZWZpbmVkTm9uRGVmYXVsdE9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuZmlsdGVyKFxuICAgICAgKG9wdGlvbikgPT4ge1xuICAgICAgICBjb25zdCBvcHRpb25LZXkgPSBvcHRpb24uYXR0cmlidXRlTmFtZSgpO1xuICAgICAgICBpZiAodGhpcy5nZXRPcHRpb25WYWx1ZShvcHRpb25LZXkpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9uVmFsdWVTb3VyY2Uob3B0aW9uS2V5KSAhPT0gJ2RlZmF1bHQnO1xuICAgICAgfVxuICAgICk7XG5cbiAgICBjb25zdCBvcHRpb25zV2l0aENvbmZsaWN0aW5nID0gZGVmaW5lZE5vbkRlZmF1bHRPcHRpb25zLmZpbHRlcihcbiAgICAgIChvcHRpb24pID0+IG9wdGlvbi5jb25mbGljdHNXaXRoLmxlbmd0aCA+IDBcbiAgICApO1xuXG4gICAgb3B0aW9uc1dpdGhDb25mbGljdGluZy5mb3JFYWNoKChvcHRpb24pID0+IHtcbiAgICAgIGNvbnN0IGNvbmZsaWN0aW5nQW5kRGVmaW5lZCA9IGRlZmluZWROb25EZWZhdWx0T3B0aW9ucy5maW5kKChkZWZpbmVkKSA9PlxuICAgICAgICBvcHRpb24uY29uZmxpY3RzV2l0aC5pbmNsdWRlcyhkZWZpbmVkLmF0dHJpYnV0ZU5hbWUoKSlcbiAgICAgICk7XG4gICAgICBpZiAoY29uZmxpY3RpbmdBbmREZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX2NvbmZsaWN0aW5nT3B0aW9uKG9wdGlvbiwgY29uZmxpY3RpbmdBbmREZWZpbmVkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwbGF5IGFuIGVycm9yIG1lc3NhZ2UgaWYgY29uZmxpY3Rpbmcgb3B0aW9ucyBhcmUgdXNlZCB0b2dldGhlci5cbiAgICogQ2FsbGVkIGFmdGVyIGNoZWNraW5nIGZvciBoZWxwIGZsYWdzIGluIGxlYWYgc3ViY29tbWFuZC5cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBfY2hlY2tGb3JDb25mbGljdGluZ09wdGlvbnMoKSB7XG4gICAgLy8gV2FsayB1cCBoaWVyYXJjaHkgc28gY2FuIGNhbGwgaW4gc3ViY29tbWFuZCBhZnRlciBjaGVja2luZyBmb3IgZGlzcGxheWluZyBoZWxwLlxuICAgIGZvciAobGV0IGNtZCA9IHRoaXM7IGNtZDsgY21kID0gY21kLnBhcmVudCkge1xuICAgICAgY21kLl9jaGVja0ZvckNvbmZsaWN0aW5nTG9jYWxPcHRpb25zKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIG9wdGlvbnMgZnJvbSBgYXJndmAgcmVtb3Zpbmcga25vd24gb3B0aW9ucyxcbiAgICogYW5kIHJldHVybiBhcmd2IHNwbGl0IGludG8gb3BlcmFuZHMgYW5kIHVua25vd24gYXJndW1lbnRzLlxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogICAgIGFyZ3YgPT4gb3BlcmFuZHMsIHVua25vd25cbiAgICogICAgIC0ta25vd24ga2trIG9wID0+IFtvcF0sIFtdXG4gICAqICAgICBvcCAtLWtub3duIGtrayA9PiBbb3BdLCBbXVxuICAgKiAgICAgc3ViIC0tdW5rbm93biB1dXUgb3AgPT4gW3N1Yl0sIFstLXVua25vd24gdXV1IG9wXVxuICAgKiAgICAgc3ViIC0tIC0tdW5rbm93biB1dXUgb3AgPT4gW3N1YiAtLXVua25vd24gdXV1IG9wXSwgW11cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmdbXX0gYXJndlxuICAgKiBAcmV0dXJuIHt7b3BlcmFuZHM6IFN0cmluZ1tdLCB1bmtub3duOiBTdHJpbmdbXX19XG4gICAqL1xuXG4gIHBhcnNlT3B0aW9ucyhhcmd2KSB7XG4gICAgY29uc3Qgb3BlcmFuZHMgPSBbXTsgLy8gb3BlcmFuZHMsIG5vdCBvcHRpb25zIG9yIHZhbHVlc1xuICAgIGNvbnN0IHVua25vd24gPSBbXTsgLy8gZmlyc3QgdW5rbm93biBvcHRpb24gYW5kIHJlbWFpbmluZyB1bmtub3duIGFyZ3NcbiAgICBsZXQgZGVzdCA9IG9wZXJhbmRzO1xuICAgIGNvbnN0IGFyZ3MgPSBhcmd2LnNsaWNlKCk7XG5cbiAgICBmdW5jdGlvbiBtYXliZU9wdGlvbihhcmcpIHtcbiAgICAgIHJldHVybiBhcmcubGVuZ3RoID4gMSAmJiBhcmdbMF0gPT09ICctJztcbiAgICB9XG5cbiAgICAvLyBwYXJzZSBvcHRpb25zXG4gICAgbGV0IGFjdGl2ZVZhcmlhZGljT3B0aW9uID0gbnVsbDtcbiAgICB3aGlsZSAoYXJncy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGFyZyA9IGFyZ3Muc2hpZnQoKTtcblxuICAgICAgLy8gbGl0ZXJhbFxuICAgICAgaWYgKGFyZyA9PT0gJy0tJykge1xuICAgICAgICBpZiAoZGVzdCA9PT0gdW5rbm93bikgZGVzdC5wdXNoKGFyZyk7XG4gICAgICAgIGRlc3QucHVzaCguLi5hcmdzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChhY3RpdmVWYXJpYWRpY09wdGlvbiAmJiAhbWF5YmVPcHRpb24oYXJnKSkge1xuICAgICAgICB0aGlzLmVtaXQoYG9wdGlvbjoke2FjdGl2ZVZhcmlhZGljT3B0aW9uLm5hbWUoKX1gLCBhcmcpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGFjdGl2ZVZhcmlhZGljT3B0aW9uID0gbnVsbDtcblxuICAgICAgaWYgKG1heWJlT3B0aW9uKGFyZykpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gdGhpcy5fZmluZE9wdGlvbihhcmcpO1xuICAgICAgICAvLyByZWNvZ25pc2VkIG9wdGlvbiwgY2FsbCBsaXN0ZW5lciB0byBhc3NpZ24gdmFsdWUgd2l0aCBwb3NzaWJsZSBjdXN0b20gcHJvY2Vzc2luZ1xuICAgICAgICBpZiAob3B0aW9uKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbi5yZXF1aXJlZCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhcmdzLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgdGhpcy5vcHRpb25NaXNzaW5nQXJndW1lbnQob3B0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChgb3B0aW9uOiR7b3B0aW9uLm5hbWUoKX1gLCB2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChvcHRpb24ub3B0aW9uYWwpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAvLyBoaXN0b3JpY2FsIGJlaGF2aW91ciBpcyBvcHRpb25hbCB2YWx1ZSBpcyBmb2xsb3dpbmcgYXJnIHVubGVzcyBhbiBvcHRpb25cbiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDAgJiYgIW1heWJlT3B0aW9uKGFyZ3NbMF0pKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gYXJncy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KGBvcHRpb246JHtvcHRpb24ubmFtZSgpfWAsIHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2UgeyAvLyBib29sZWFuIGZsYWdcbiAgICAgICAgICAgIHRoaXMuZW1pdChgb3B0aW9uOiR7b3B0aW9uLm5hbWUoKX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWN0aXZlVmFyaWFkaWNPcHRpb24gPSBvcHRpb24udmFyaWFkaWMgPyBvcHRpb24gOiBudWxsO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIExvb2sgZm9yIGNvbWJvIG9wdGlvbnMgZm9sbG93aW5nIHNpbmdsZSBkYXNoLCBlYXQgZmlyc3Qgb25lIGlmIGtub3duLlxuICAgICAgaWYgKGFyZy5sZW5ndGggPiAyICYmIGFyZ1swXSA9PT0gJy0nICYmIGFyZ1sxXSAhPT0gJy0nKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IHRoaXMuX2ZpbmRPcHRpb24oYC0ke2FyZ1sxXX1gKTtcbiAgICAgICAgaWYgKG9wdGlvbikge1xuICAgICAgICAgIGlmIChvcHRpb24ucmVxdWlyZWQgfHwgKG9wdGlvbi5vcHRpb25hbCAmJiB0aGlzLl9jb21iaW5lRmxhZ0FuZE9wdGlvbmFsVmFsdWUpKSB7XG4gICAgICAgICAgICAvLyBvcHRpb24gd2l0aCB2YWx1ZSBmb2xsb3dpbmcgaW4gc2FtZSBhcmd1bWVudFxuICAgICAgICAgICAgdGhpcy5lbWl0KGBvcHRpb246JHtvcHRpb24ubmFtZSgpfWAsIGFyZy5zbGljZSgyKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGJvb2xlYW4gb3B0aW9uLCBlbWl0IGFuZCBwdXQgYmFjayByZW1haW5kZXIgb2YgYXJnIGZvciBmdXJ0aGVyIHByb2Nlc3NpbmdcbiAgICAgICAgICAgIHRoaXMuZW1pdChgb3B0aW9uOiR7b3B0aW9uLm5hbWUoKX1gKTtcbiAgICAgICAgICAgIGFyZ3MudW5zaGlmdChgLSR7YXJnLnNsaWNlKDIpfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBMb29rIGZvciBrbm93biBsb25nIGZsYWcgd2l0aCB2YWx1ZSwgbGlrZSAtLWZvbz1iYXJcbiAgICAgIGlmICgvXi0tW149XSs9Ly50ZXN0KGFyZykpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBhcmcuaW5kZXhPZignPScpO1xuICAgICAgICBjb25zdCBvcHRpb24gPSB0aGlzLl9maW5kT3B0aW9uKGFyZy5zbGljZSgwLCBpbmRleCkpO1xuICAgICAgICBpZiAob3B0aW9uICYmIChvcHRpb24ucmVxdWlyZWQgfHwgb3B0aW9uLm9wdGlvbmFsKSkge1xuICAgICAgICAgIHRoaXMuZW1pdChgb3B0aW9uOiR7b3B0aW9uLm5hbWUoKX1gLCBhcmcuc2xpY2UoaW5kZXggKyAxKSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gTm90IGEgcmVjb2duaXNlZCBvcHRpb24gYnkgdGhpcyBjb21tYW5kLlxuICAgICAgLy8gTWlnaHQgYmUgYSBjb21tYW5kLWFyZ3VtZW50LCBvciBzdWJjb21tYW5kIG9wdGlvbiwgb3IgdW5rbm93biBvcHRpb24sIG9yIGhlbHAgY29tbWFuZCBvciBvcHRpb24uXG5cbiAgICAgIC8vIEFuIHVua25vd24gb3B0aW9uIG1lYW5zIGZ1cnRoZXIgYXJndW1lbnRzIGFsc28gY2xhc3NpZmllZCBhcyB1bmtub3duIHNvIGNhbiBiZSByZXByb2Nlc3NlZCBieSBzdWJjb21tYW5kcy5cbiAgICAgIGlmIChtYXliZU9wdGlvbihhcmcpKSB7XG4gICAgICAgIGRlc3QgPSB1bmtub3duO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB1c2luZyBwb3NpdGlvbmFsT3B0aW9ucywgc3RvcCBwcm9jZXNzaW5nIG91ciBvcHRpb25zIGF0IHN1YmNvbW1hbmQuXG4gICAgICBpZiAoKHRoaXMuX2VuYWJsZVBvc2l0aW9uYWxPcHRpb25zIHx8IHRoaXMuX3Bhc3NUaHJvdWdoT3B0aW9ucykgJiYgb3BlcmFuZHMubGVuZ3RoID09PSAwICYmIHVua25vd24ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlmICh0aGlzLl9maW5kQ29tbWFuZChhcmcpKSB7XG4gICAgICAgICAgb3BlcmFuZHMucHVzaChhcmcpO1xuICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIHVua25vd24ucHVzaCguLi5hcmdzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmIChhcmcgPT09IHRoaXMuX2hlbHBDb21tYW5kTmFtZSAmJiB0aGlzLl9oYXNJbXBsaWNpdEhlbHBDb21tYW5kKCkpIHtcbiAgICAgICAgICBvcGVyYW5kcy5wdXNoKGFyZyk7XG4gICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkgb3BlcmFuZHMucHVzaCguLi5hcmdzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9kZWZhdWx0Q29tbWFuZE5hbWUpIHtcbiAgICAgICAgICB1bmtub3duLnB1c2goYXJnKTtcbiAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPiAwKSB1bmtub3duLnB1c2goLi4uYXJncyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgdXNpbmcgcGFzc1Rocm91Z2hPcHRpb25zLCBzdG9wIHByb2Nlc3Npbmcgb3B0aW9ucyBhdCBmaXJzdCBjb21tYW5kLWFyZ3VtZW50LlxuICAgICAgaWYgKHRoaXMuX3Bhc3NUaHJvdWdoT3B0aW9ucykge1xuICAgICAgICBkZXN0LnB1c2goYXJnKTtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkgZGVzdC5wdXNoKC4uLmFyZ3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gYWRkIGFyZ1xuICAgICAgZGVzdC5wdXNoKGFyZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgb3BlcmFuZHMsIHVua25vd24gfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gb2JqZWN0IGNvbnRhaW5pbmcgbG9jYWwgb3B0aW9uIHZhbHVlcyBhcyBrZXktdmFsdWUgcGFpcnMuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIG9wdHMoKSB7XG4gICAgaWYgKHRoaXMuX3N0b3JlT3B0aW9uc0FzUHJvcGVydGllcykge1xuICAgICAgLy8gUHJlc2VydmUgb3JpZ2luYWwgYmVoYXZpb3VyIHNvIGJhY2t3YXJkcyBjb21wYXRpYmxlIHdoZW4gc3RpbGwgdXNpbmcgcHJvcGVydGllc1xuICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICBjb25zdCBsZW4gPSB0aGlzLm9wdGlvbnMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMub3B0aW9uc1tpXS5hdHRyaWJ1dGVOYW1lKCk7XG4gICAgICAgIHJlc3VsdFtrZXldID0ga2V5ID09PSB0aGlzLl92ZXJzaW9uT3B0aW9uTmFtZSA/IHRoaXMuX3ZlcnNpb24gOiB0aGlzW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9vcHRpb25WYWx1ZXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIG9iamVjdCBjb250YWluaW5nIG1lcmdlZCBsb2NhbCBhbmQgZ2xvYmFsIG9wdGlvbiB2YWx1ZXMgYXMga2V5LXZhbHVlIHBhaXJzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBvcHRzV2l0aEdsb2JhbHMoKSB7XG4gICAgLy8gZ2xvYmFscyBvdmVyd3JpdGUgbG9jYWxzXG4gICAgcmV0dXJuIGdldENvbW1hbmRBbmRQYXJlbnRzKHRoaXMpLnJlZHVjZShcbiAgICAgIChjb21iaW5lZE9wdGlvbnMsIGNtZCkgPT4gT2JqZWN0LmFzc2lnbihjb21iaW5lZE9wdGlvbnMsIGNtZC5vcHRzKCkpLFxuICAgICAge31cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3BsYXkgZXJyb3IgbWVzc2FnZSBhbmQgZXhpdCAob3IgY2FsbCBleGl0T3ZlcnJpZGUpLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2Vycm9yT3B0aW9uc11cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtlcnJvck9wdGlvbnMuY29kZV0gLSBhbiBpZCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBlcnJvclxuICAgKiBAcGFyYW0ge251bWJlcn0gW2Vycm9yT3B0aW9ucy5leGl0Q29kZV0gLSB1c2VkIHdpdGggcHJvY2Vzcy5leGl0XG4gICAqL1xuICBlcnJvcihtZXNzYWdlLCBlcnJvck9wdGlvbnMpIHtcbiAgICAvLyBvdXRwdXQgaGFuZGxpbmdcbiAgICB0aGlzLl9vdXRwdXRDb25maWd1cmF0aW9uLm91dHB1dEVycm9yKGAke21lc3NhZ2V9XFxuYCwgdGhpcy5fb3V0cHV0Q29uZmlndXJhdGlvbi53cml0ZUVycik7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9zaG93SGVscEFmdGVyRXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl9vdXRwdXRDb25maWd1cmF0aW9uLndyaXRlRXJyKGAke3RoaXMuX3Nob3dIZWxwQWZ0ZXJFcnJvcn1cXG5gKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3Nob3dIZWxwQWZ0ZXJFcnJvcikge1xuICAgICAgdGhpcy5fb3V0cHV0Q29uZmlndXJhdGlvbi53cml0ZUVycignXFxuJyk7XG4gICAgICB0aGlzLm91dHB1dEhlbHAoeyBlcnJvcjogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICAvLyBleGl0IGhhbmRsaW5nXG4gICAgY29uc3QgY29uZmlnID0gZXJyb3JPcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IGV4aXRDb2RlID0gY29uZmlnLmV4aXRDb2RlIHx8IDE7XG4gICAgY29uc3QgY29kZSA9IGNvbmZpZy5jb2RlIHx8ICdjb21tYW5kZXIuZXJyb3InO1xuICAgIHRoaXMuX2V4aXQoZXhpdENvZGUsIGNvZGUsIG1lc3NhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGx5IGFueSBvcHRpb24gcmVsYXRlZCBlbnZpcm9ubWVudCB2YXJpYWJsZXMsIGlmIG9wdGlvbiBkb2VzXG4gICAqIG5vdCBoYXZlIGEgdmFsdWUgZnJvbSBjbGkgb3IgY2xpZW50IGNvZGUuXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgX3BhcnNlT3B0aW9uc0VudigpIHtcbiAgICB0aGlzLm9wdGlvbnMuZm9yRWFjaCgob3B0aW9uKSA9PiB7XG4gICAgICBpZiAob3B0aW9uLmVudlZhciAmJiBvcHRpb24uZW52VmFyIGluIHByb2Nlc3MuZW52KSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbktleSA9IG9wdGlvbi5hdHRyaWJ1dGVOYW1lKCk7XG4gICAgICAgIC8vIFByaW9yaXR5IGNoZWNrLiBEbyBub3Qgb3ZlcndyaXRlIGNsaSBvciBvcHRpb25zIGZyb20gdW5rbm93biBzb3VyY2UgKGNsaWVudC1jb2RlKS5cbiAgICAgICAgaWYgKHRoaXMuZ2V0T3B0aW9uVmFsdWUob3B0aW9uS2V5KSA9PT0gdW5kZWZpbmVkIHx8IFsnZGVmYXVsdCcsICdjb25maWcnLCAnZW52J10uaW5jbHVkZXModGhpcy5nZXRPcHRpb25WYWx1ZVNvdXJjZShvcHRpb25LZXkpKSkge1xuICAgICAgICAgIGlmIChvcHRpb24ucmVxdWlyZWQgfHwgb3B0aW9uLm9wdGlvbmFsKSB7IC8vIG9wdGlvbiBjYW4gdGFrZSBhIHZhbHVlXG4gICAgICAgICAgICAvLyBrZWVwIHZlcnkgc2ltcGxlLCBvcHRpb25hbCBhbHdheXMgdGFrZXMgdmFsdWVcbiAgICAgICAgICAgIHRoaXMuZW1pdChgb3B0aW9uRW52OiR7b3B0aW9uLm5hbWUoKX1gLCBwcm9jZXNzLmVudltvcHRpb24uZW52VmFyXSk7XG4gICAgICAgICAgfSBlbHNlIHsgLy8gYm9vbGVhblxuICAgICAgICAgICAgLy8ga2VlcCB2ZXJ5IHNpbXBsZSwgb25seSBjYXJlIHRoYXQgZW52VmFyIGRlZmluZWQgYW5kIG5vdCB0aGUgdmFsdWVcbiAgICAgICAgICAgIHRoaXMuZW1pdChgb3B0aW9uRW52OiR7b3B0aW9uLm5hbWUoKX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBseSBhbnkgaW1wbGllZCBvcHRpb24gdmFsdWVzLCBpZiBvcHRpb24gaXMgdW5kZWZpbmVkIG9yIGRlZmF1bHQgdmFsdWUuXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgX3BhcnNlT3B0aW9uc0ltcGxpZWQoKSB7XG4gICAgY29uc3QgZHVhbEhlbHBlciA9IG5ldyBEdWFsT3B0aW9ucyh0aGlzLm9wdGlvbnMpO1xuICAgIGNvbnN0IGhhc0N1c3RvbU9wdGlvblZhbHVlID0gKG9wdGlvbktleSkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9uVmFsdWUob3B0aW9uS2V5KSAhPT0gdW5kZWZpbmVkICYmICFbJ2RlZmF1bHQnLCAnaW1wbGllZCddLmluY2x1ZGVzKHRoaXMuZ2V0T3B0aW9uVmFsdWVTb3VyY2Uob3B0aW9uS2V5KSk7XG4gICAgfTtcbiAgICB0aGlzLm9wdGlvbnNcbiAgICAgIC5maWx0ZXIob3B0aW9uID0+IChvcHRpb24uaW1wbGllZCAhPT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICBoYXNDdXN0b21PcHRpb25WYWx1ZShvcHRpb24uYXR0cmlidXRlTmFtZSgpKSAmJlxuICAgICAgICBkdWFsSGVscGVyLnZhbHVlRnJvbU9wdGlvbih0aGlzLmdldE9wdGlvblZhbHVlKG9wdGlvbi5hdHRyaWJ1dGVOYW1lKCkpLCBvcHRpb24pKVxuICAgICAgLmZvckVhY2goKG9wdGlvbikgPT4ge1xuICAgICAgICBPYmplY3Qua2V5cyhvcHRpb24uaW1wbGllZClcbiAgICAgICAgICAuZmlsdGVyKGltcGxpZWRLZXkgPT4gIWhhc0N1c3RvbU9wdGlvblZhbHVlKGltcGxpZWRLZXkpKVxuICAgICAgICAgIC5mb3JFYWNoKGltcGxpZWRLZXkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRPcHRpb25WYWx1ZVdpdGhTb3VyY2UoaW1wbGllZEtleSwgb3B0aW9uLmltcGxpZWRbaW1wbGllZEtleV0sICdpbXBsaWVkJyk7XG4gICAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcmd1bWVudCBgbmFtZWAgaXMgbWlzc2luZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIG1pc3NpbmdBcmd1bWVudChuYW1lKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGBlcnJvcjogbWlzc2luZyByZXF1aXJlZCBhcmd1bWVudCAnJHtuYW1lfSdgO1xuICAgIHRoaXMuZXJyb3IobWVzc2FnZSwgeyBjb2RlOiAnY29tbWFuZGVyLm1pc3NpbmdBcmd1bWVudCcgfSk7XG4gIH1cblxuICAvKipcbiAgICogYE9wdGlvbmAgaXMgbWlzc2luZyBhbiBhcmd1bWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtPcHRpb259IG9wdGlvblxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgb3B0aW9uTWlzc2luZ0FyZ3VtZW50KG9wdGlvbikge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBgZXJyb3I6IG9wdGlvbiAnJHtvcHRpb24uZmxhZ3N9JyBhcmd1bWVudCBtaXNzaW5nYDtcbiAgICB0aGlzLmVycm9yKG1lc3NhZ2UsIHsgY29kZTogJ2NvbW1hbmRlci5vcHRpb25NaXNzaW5nQXJndW1lbnQnIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIGBPcHRpb25gIGRvZXMgbm90IGhhdmUgYSB2YWx1ZSwgYW5kIGlzIGEgbWFuZGF0b3J5IG9wdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtPcHRpb259IG9wdGlvblxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgbWlzc2luZ01hbmRhdG9yeU9wdGlvblZhbHVlKG9wdGlvbikge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBgZXJyb3I6IHJlcXVpcmVkIG9wdGlvbiAnJHtvcHRpb24uZmxhZ3N9JyBub3Qgc3BlY2lmaWVkYDtcbiAgICB0aGlzLmVycm9yKG1lc3NhZ2UsIHsgY29kZTogJ2NvbW1hbmRlci5taXNzaW5nTWFuZGF0b3J5T3B0aW9uVmFsdWUnIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIGBPcHRpb25gIGNvbmZsaWN0cyB3aXRoIGFub3RoZXIgb3B0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge09wdGlvbn0gb3B0aW9uXG4gICAqIEBwYXJhbSB7T3B0aW9ufSBjb25mbGljdGluZ09wdGlvblxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIF9jb25mbGljdGluZ09wdGlvbihvcHRpb24sIGNvbmZsaWN0aW5nT3B0aW9uKSB7XG4gICAgLy8gVGhlIGNhbGxpbmcgY29kZSBkb2VzIG5vdCBrbm93IHdoZXRoZXIgYSBuZWdhdGVkIG9wdGlvbiBpcyB0aGUgc291cmNlIG9mIHRoZVxuICAgIC8vIHZhbHVlLCBzbyBkbyBzb21lIHdvcmsgdG8gdGFrZSBhbiBlZHVjYXRlZCBndWVzcy5cbiAgICBjb25zdCBmaW5kQmVzdE9wdGlvbkZyb21WYWx1ZSA9IChvcHRpb24pID0+IHtcbiAgICAgIGNvbnN0IG9wdGlvbktleSA9IG9wdGlvbi5hdHRyaWJ1dGVOYW1lKCk7XG4gICAgICBjb25zdCBvcHRpb25WYWx1ZSA9IHRoaXMuZ2V0T3B0aW9uVmFsdWUob3B0aW9uS2V5KTtcbiAgICAgIGNvbnN0IG5lZ2F0aXZlT3B0aW9uID0gdGhpcy5vcHRpb25zLmZpbmQodGFyZ2V0ID0+IHRhcmdldC5uZWdhdGUgJiYgb3B0aW9uS2V5ID09PSB0YXJnZXQuYXR0cmlidXRlTmFtZSgpKTtcbiAgICAgIGNvbnN0IHBvc2l0aXZlT3B0aW9uID0gdGhpcy5vcHRpb25zLmZpbmQodGFyZ2V0ID0+ICF0YXJnZXQubmVnYXRlICYmIG9wdGlvbktleSA9PT0gdGFyZ2V0LmF0dHJpYnV0ZU5hbWUoKSk7XG4gICAgICBpZiAobmVnYXRpdmVPcHRpb24gJiYgKFxuICAgICAgICAobmVnYXRpdmVPcHRpb24ucHJlc2V0QXJnID09PSB1bmRlZmluZWQgJiYgb3B0aW9uVmFsdWUgPT09IGZhbHNlKSB8fFxuICAgICAgICAobmVnYXRpdmVPcHRpb24ucHJlc2V0QXJnICE9PSB1bmRlZmluZWQgJiYgb3B0aW9uVmFsdWUgPT09IG5lZ2F0aXZlT3B0aW9uLnByZXNldEFyZylcbiAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIG5lZ2F0aXZlT3B0aW9uO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBvc2l0aXZlT3B0aW9uIHx8IG9wdGlvbjtcbiAgICB9O1xuXG4gICAgY29uc3QgZ2V0RXJyb3JNZXNzYWdlID0gKG9wdGlvbikgPT4ge1xuICAgICAgY29uc3QgYmVzdE9wdGlvbiA9IGZpbmRCZXN0T3B0aW9uRnJvbVZhbHVlKG9wdGlvbik7XG4gICAgICBjb25zdCBvcHRpb25LZXkgPSBiZXN0T3B0aW9uLmF0dHJpYnV0ZU5hbWUoKTtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuZ2V0T3B0aW9uVmFsdWVTb3VyY2Uob3B0aW9uS2V5KTtcbiAgICAgIGlmIChzb3VyY2UgPT09ICdlbnYnKSB7XG4gICAgICAgIHJldHVybiBgZW52aXJvbm1lbnQgdmFyaWFibGUgJyR7YmVzdE9wdGlvbi5lbnZWYXJ9J2A7XG4gICAgICB9XG4gICAgICByZXR1cm4gYG9wdGlvbiAnJHtiZXN0T3B0aW9uLmZsYWdzfSdgO1xuICAgIH07XG5cbiAgICBjb25zdCBtZXNzYWdlID0gYGVycm9yOiAke2dldEVycm9yTWVzc2FnZShvcHRpb24pfSBjYW5ub3QgYmUgdXNlZCB3aXRoICR7Z2V0RXJyb3JNZXNzYWdlKGNvbmZsaWN0aW5nT3B0aW9uKX1gO1xuICAgIHRoaXMuZXJyb3IobWVzc2FnZSwgeyBjb2RlOiAnY29tbWFuZGVyLmNvbmZsaWN0aW5nT3B0aW9uJyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbmtub3duIG9wdGlvbiBgZmxhZ2AuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmbGFnXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICB1bmtub3duT3B0aW9uKGZsYWcpIHtcbiAgICBpZiAodGhpcy5fYWxsb3dVbmtub3duT3B0aW9uKSByZXR1cm47XG4gICAgbGV0IHN1Z2dlc3Rpb24gPSAnJztcblxuICAgIGlmIChmbGFnLnN0YXJ0c1dpdGgoJy0tJykgJiYgdGhpcy5fc2hvd1N1Z2dlc3Rpb25BZnRlckVycm9yKSB7XG4gICAgICAvLyBMb29waW5nIHRvIHBpY2sgdXAgdGhlIGdsb2JhbCBvcHRpb25zIHRvb1xuICAgICAgbGV0IGNhbmRpZGF0ZUZsYWdzID0gW107XG4gICAgICBsZXQgY29tbWFuZCA9IHRoaXM7XG4gICAgICBkbyB7XG4gICAgICAgIGNvbnN0IG1vcmVGbGFncyA9IGNvbW1hbmQuY3JlYXRlSGVscCgpLnZpc2libGVPcHRpb25zKGNvbW1hbmQpXG4gICAgICAgICAgLmZpbHRlcihvcHRpb24gPT4gb3B0aW9uLmxvbmcpXG4gICAgICAgICAgLm1hcChvcHRpb24gPT4gb3B0aW9uLmxvbmcpO1xuICAgICAgICBjYW5kaWRhdGVGbGFncyA9IGNhbmRpZGF0ZUZsYWdzLmNvbmNhdChtb3JlRmxhZ3MpO1xuICAgICAgICBjb21tYW5kID0gY29tbWFuZC5wYXJlbnQ7XG4gICAgICB9IHdoaWxlIChjb21tYW5kICYmICFjb21tYW5kLl9lbmFibGVQb3NpdGlvbmFsT3B0aW9ucyk7XG4gICAgICBzdWdnZXN0aW9uID0gc3VnZ2VzdFNpbWlsYXIoZmxhZywgY2FuZGlkYXRlRmxhZ3MpO1xuICAgIH1cblxuICAgIGNvbnN0IG1lc3NhZ2UgPSBgZXJyb3I6IHVua25vd24gb3B0aW9uICcke2ZsYWd9JyR7c3VnZ2VzdGlvbn1gO1xuICAgIHRoaXMuZXJyb3IobWVzc2FnZSwgeyBjb2RlOiAnY29tbWFuZGVyLnVua25vd25PcHRpb24nIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4Y2VzcyBhcmd1bWVudHMsIG1vcmUgdGhhbiBleHBlY3RlZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gcmVjZWl2ZWRBcmdzXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBfZXhjZXNzQXJndW1lbnRzKHJlY2VpdmVkQXJncykge1xuICAgIGlmICh0aGlzLl9hbGxvd0V4Y2Vzc0FyZ3VtZW50cykgcmV0dXJuO1xuXG4gICAgY29uc3QgZXhwZWN0ZWQgPSB0aGlzLl9hcmdzLmxlbmd0aDtcbiAgICBjb25zdCBzID0gKGV4cGVjdGVkID09PSAxKSA/ICcnIDogJ3MnO1xuICAgIGNvbnN0IGZvclN1YmNvbW1hbmQgPSB0aGlzLnBhcmVudCA/IGAgZm9yICcke3RoaXMubmFtZSgpfSdgIDogJyc7XG4gICAgY29uc3QgbWVzc2FnZSA9IGBlcnJvcjogdG9vIG1hbnkgYXJndW1lbnRzJHtmb3JTdWJjb21tYW5kfS4gRXhwZWN0ZWQgJHtleHBlY3RlZH0gYXJndW1lbnQke3N9IGJ1dCBnb3QgJHtyZWNlaXZlZEFyZ3MubGVuZ3RofS5gO1xuICAgIHRoaXMuZXJyb3IobWVzc2FnZSwgeyBjb2RlOiAnY29tbWFuZGVyLmV4Y2Vzc0FyZ3VtZW50cycgfSk7XG4gIH1cblxuICAvKipcbiAgICogVW5rbm93biBjb21tYW5kLlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgdW5rbm93bkNvbW1hbmQoKSB7XG4gICAgY29uc3QgdW5rbm93bk5hbWUgPSB0aGlzLmFyZ3NbMF07XG4gICAgbGV0IHN1Z2dlc3Rpb24gPSAnJztcblxuICAgIGlmICh0aGlzLl9zaG93U3VnZ2VzdGlvbkFmdGVyRXJyb3IpIHtcbiAgICAgIGNvbnN0IGNhbmRpZGF0ZU5hbWVzID0gW107XG4gICAgICB0aGlzLmNyZWF0ZUhlbHAoKS52aXNpYmxlQ29tbWFuZHModGhpcykuZm9yRWFjaCgoY29tbWFuZCkgPT4ge1xuICAgICAgICBjYW5kaWRhdGVOYW1lcy5wdXNoKGNvbW1hbmQubmFtZSgpKTtcbiAgICAgICAgLy8ganVzdCB2aXNpYmxlIGFsaWFzXG4gICAgICAgIGlmIChjb21tYW5kLmFsaWFzKCkpIGNhbmRpZGF0ZU5hbWVzLnB1c2goY29tbWFuZC5hbGlhcygpKTtcbiAgICAgIH0pO1xuICAgICAgc3VnZ2VzdGlvbiA9IHN1Z2dlc3RTaW1pbGFyKHVua25vd25OYW1lLCBjYW5kaWRhdGVOYW1lcyk7XG4gICAgfVxuXG4gICAgY29uc3QgbWVzc2FnZSA9IGBlcnJvcjogdW5rbm93biBjb21tYW5kICcke3Vua25vd25OYW1lfScke3N1Z2dlc3Rpb259YDtcbiAgICB0aGlzLmVycm9yKG1lc3NhZ2UsIHsgY29kZTogJ2NvbW1hbmRlci51bmtub3duQ29tbWFuZCcgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBwcm9ncmFtIHZlcnNpb24gdG8gYHN0cmAuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGF1dG8tcmVnaXN0ZXJzIHRoZSBcIi1WLCAtLXZlcnNpb25cIiBmbGFnXG4gICAqIHdoaWNoIHdpbGwgcHJpbnQgdGhlIHZlcnNpb24gbnVtYmVyIHdoZW4gcGFzc2VkLlxuICAgKlxuICAgKiBZb3UgY2FuIG9wdGlvbmFsbHkgc3VwcGx5IHRoZSAgZmxhZ3MgYW5kIGRlc2NyaXB0aW9uIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0cy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2ZsYWdzXVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2Rlc2NyaXB0aW9uXVxuICAgKiBAcmV0dXJuIHt0aGlzIHwgc3RyaW5nfSBgdGhpc2AgY29tbWFuZCBmb3IgY2hhaW5pbmcsIG9yIHZlcnNpb24gc3RyaW5nIGlmIG5vIGFyZ3VtZW50c1xuICAgKi9cblxuICB2ZXJzaW9uKHN0ciwgZmxhZ3MsIGRlc2NyaXB0aW9uKSB7XG4gICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5fdmVyc2lvbjtcbiAgICB0aGlzLl92ZXJzaW9uID0gc3RyO1xuICAgIGZsYWdzID0gZmxhZ3MgfHwgJy1WLCAtLXZlcnNpb24nO1xuICAgIGRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb24gfHwgJ291dHB1dCB0aGUgdmVyc2lvbiBudW1iZXInO1xuICAgIGNvbnN0IHZlcnNpb25PcHRpb24gPSB0aGlzLmNyZWF0ZU9wdGlvbihmbGFncywgZGVzY3JpcHRpb24pO1xuICAgIHRoaXMuX3ZlcnNpb25PcHRpb25OYW1lID0gdmVyc2lvbk9wdGlvbi5hdHRyaWJ1dGVOYW1lKCk7XG4gICAgdGhpcy5vcHRpb25zLnB1c2godmVyc2lvbk9wdGlvbik7XG4gICAgdGhpcy5vbignb3B0aW9uOicgKyB2ZXJzaW9uT3B0aW9uLm5hbWUoKSwgKCkgPT4ge1xuICAgICAgdGhpcy5fb3V0cHV0Q29uZmlndXJhdGlvbi53cml0ZU91dChgJHtzdHJ9XFxuYCk7XG4gICAgICB0aGlzLl9leGl0KDAsICdjb21tYW5kZXIudmVyc2lvbicsIHN0cik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBkZXNjcmlwdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnc0Rlc2NyaXB0aW9uXVxuICAgKiBAcmV0dXJuIHtzdHJpbmd8Q29tbWFuZH1cbiAgICovXG4gIGRlc2NyaXB0aW9uKHN0ciwgYXJnc0Rlc2NyaXB0aW9uKSB7XG4gICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkICYmIGFyZ3NEZXNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5fZGVzY3JpcHRpb247XG4gICAgdGhpcy5fZGVzY3JpcHRpb24gPSBzdHI7XG4gICAgaWYgKGFyZ3NEZXNjcmlwdGlvbikge1xuICAgICAgdGhpcy5fYXJnc0Rlc2NyaXB0aW9uID0gYXJnc0Rlc2NyaXB0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHN1bW1hcnkuIFVzZWQgd2hlbiBsaXN0ZWQgYXMgc3ViY29tbWFuZCBvZiBwYXJlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyXVxuICAgKiBAcmV0dXJuIHtzdHJpbmd8Q29tbWFuZH1cbiAgICovXG4gIHN1bW1hcnkoc3RyKSB7XG4gICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5fc3VtbWFyeTtcbiAgICB0aGlzLl9zdW1tYXJ5ID0gc3RyO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBhbiBhbGlhcyBmb3IgdGhlIGNvbW1hbmQuXG4gICAqXG4gICAqIFlvdSBtYXkgY2FsbCBtb3JlIHRoYW4gb25jZSB0byBhZGQgbXVsdGlwbGUgYWxpYXNlcy4gT25seSB0aGUgZmlyc3QgYWxpYXMgaXMgc2hvd24gaW4gdGhlIGF1dG8tZ2VuZXJhdGVkIGhlbHAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbYWxpYXNdXG4gICAqIEByZXR1cm4ge3N0cmluZ3xDb21tYW5kfVxuICAgKi9cblxuICBhbGlhcyhhbGlhcykge1xuICAgIGlmIChhbGlhcyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5fYWxpYXNlc1swXTsgLy8ganVzdCByZXR1cm4gZmlyc3QsIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXG4gICAgLyoqIEB0eXBlIHtDb21tYW5kfSAqL1xuICAgIGxldCBjb21tYW5kID0gdGhpcztcbiAgICBpZiAodGhpcy5jb21tYW5kcy5sZW5ndGggIT09IDAgJiYgdGhpcy5jb21tYW5kc1t0aGlzLmNvbW1hbmRzLmxlbmd0aCAtIDFdLl9leGVjdXRhYmxlSGFuZGxlcikge1xuICAgICAgLy8gYXNzdW1lIGFkZGluZyBhbGlhcyBmb3IgbGFzdCBhZGRlZCBleGVjdXRhYmxlIHN1YmNvbW1hbmQsIHJhdGhlciB0aGFuIHRoaXNcbiAgICAgIGNvbW1hbmQgPSB0aGlzLmNvbW1hbmRzW3RoaXMuY29tbWFuZHMubGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgaWYgKGFsaWFzID09PSBjb21tYW5kLl9uYW1lKSB0aHJvdyBuZXcgRXJyb3IoJ0NvbW1hbmQgYWxpYXMgY2FuXFwndCBiZSB0aGUgc2FtZSBhcyBpdHMgbmFtZScpO1xuXG4gICAgY29tbWFuZC5fYWxpYXNlcy5wdXNoKGFsaWFzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYWxpYXNlcyBmb3IgdGhlIGNvbW1hbmQuXG4gICAqXG4gICAqIE9ubHkgdGhlIGZpcnN0IGFsaWFzIGlzIHNob3duIGluIHRoZSBhdXRvLWdlbmVyYXRlZCBoZWxwLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBbYWxpYXNlc11cbiAgICogQHJldHVybiB7c3RyaW5nW118Q29tbWFuZH1cbiAgICovXG5cbiAgYWxpYXNlcyhhbGlhc2VzKSB7XG4gICAgLy8gR2V0dGVyIGZvciB0aGUgYXJyYXkgb2YgYWxpYXNlcyBpcyB0aGUgbWFpbiByZWFzb24gZm9yIGhhdmluZyBhbGlhc2VzKCkgaW4gYWRkaXRpb24gdG8gYWxpYXMoKS5cbiAgICBpZiAoYWxpYXNlcyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5fYWxpYXNlcztcblxuICAgIGFsaWFzZXMuZm9yRWFjaCgoYWxpYXMpID0+IHRoaXMuYWxpYXMoYWxpYXMpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgLyBnZXQgdGhlIGNvbW1hbmQgdXNhZ2UgYHN0cmAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyXVxuICAgKiBAcmV0dXJuIHtTdHJpbmd8Q29tbWFuZH1cbiAgICovXG5cbiAgdXNhZ2Uoc3RyKSB7XG4gICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodGhpcy5fdXNhZ2UpIHJldHVybiB0aGlzLl91c2FnZTtcblxuICAgICAgY29uc3QgYXJncyA9IHRoaXMuX2FyZ3MubWFwKChhcmcpID0+IHtcbiAgICAgICAgcmV0dXJuIGh1bWFuUmVhZGFibGVBcmdOYW1lKGFyZyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBbXS5jb25jYXQoXG4gICAgICAgICh0aGlzLm9wdGlvbnMubGVuZ3RoIHx8IHRoaXMuX2hhc0hlbHBPcHRpb24gPyAnW29wdGlvbnNdJyA6IFtdKSxcbiAgICAgICAgKHRoaXMuY29tbWFuZHMubGVuZ3RoID8gJ1tjb21tYW5kXScgOiBbXSksXG4gICAgICAgICh0aGlzLl9hcmdzLmxlbmd0aCA/IGFyZ3MgOiBbXSlcbiAgICAgICkuam9pbignICcpO1xuICAgIH1cblxuICAgIHRoaXMuX3VzYWdlID0gc3RyO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgdGhlIG5hbWUgb2YgdGhlIGNvbW1hbmQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyXVxuICAgKiBAcmV0dXJuIHtzdHJpbmd8Q29tbWFuZH1cbiAgICovXG5cbiAgbmFtZShzdHIpIHtcbiAgICBpZiAoc3RyID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIHRoaXMuX25hbWUgPSBzdHI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBuYW1lIG9mIHRoZSBjb21tYW5kIGZyb20gc2NyaXB0IGZpbGVuYW1lLCBzdWNoIGFzIHByb2Nlc3MuYXJndlsxXSxcbiAgICogb3IgcmVxdWlyZS5tYWluLmZpbGVuYW1lLCBvciBfX2ZpbGVuYW1lLlxuICAgKlxuICAgKiAoVXNlZCBpbnRlcm5hbGx5IGFuZCBwdWJsaWMgYWx0aG91Z2ggbm90IGRvY3VtZW50ZWQgaW4gUkVBRE1FLilcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogcHJvZ3JhbS5uYW1lRnJvbUZpbGVuYW1lKHJlcXVpcmUubWFpbi5maWxlbmFtZSk7XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlbmFtZVxuICAgKiBAcmV0dXJuIHtDb21tYW5kfVxuICAgKi9cblxuICBuYW1lRnJvbUZpbGVuYW1lKGZpbGVuYW1lKSB7XG4gICAgdGhpcy5fbmFtZSA9IHBhdGguYmFzZW5hbWUoZmlsZW5hbWUsIHBhdGguZXh0bmFtZShmaWxlbmFtZSkpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IG9yIHNldCB0aGUgZGlyZWN0b3J5IGZvciBzZWFyY2hpbmcgZm9yIGV4ZWN1dGFibGUgc3ViY29tbWFuZHMgb2YgdGhpcyBjb21tYW5kLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBwcm9ncmFtLmV4ZWN1dGFibGVEaXIoX19kaXJuYW1lKTtcbiAgICogLy8gb3JcbiAgICogcHJvZ3JhbS5leGVjdXRhYmxlRGlyKCdzdWJjb21tYW5kcycpO1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhdGhdXG4gICAqIEByZXR1cm4ge3N0cmluZ3xDb21tYW5kfVxuICAgKi9cblxuICBleGVjdXRhYmxlRGlyKHBhdGgpIHtcbiAgICBpZiAocGF0aCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5fZXhlY3V0YWJsZURpcjtcbiAgICB0aGlzLl9leGVjdXRhYmxlRGlyID0gcGF0aDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gcHJvZ3JhbSBoZWxwIGRvY3VtZW50YXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7eyBlcnJvcjogYm9vbGVhbiB9fSBbY29udGV4dE9wdGlvbnNdIC0gcGFzcyB7ZXJyb3I6dHJ1ZX0gdG8gd3JhcCBmb3Igc3RkZXJyIGluc3RlYWQgb2Ygc3Rkb3V0XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG5cbiAgaGVscEluZm9ybWF0aW9uKGNvbnRleHRPcHRpb25zKSB7XG4gICAgY29uc3QgaGVscGVyID0gdGhpcy5jcmVhdGVIZWxwKCk7XG4gICAgaWYgKGhlbHBlci5oZWxwV2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgaGVscGVyLmhlbHBXaWR0aCA9IChjb250ZXh0T3B0aW9ucyAmJiBjb250ZXh0T3B0aW9ucy5lcnJvcikgPyB0aGlzLl9vdXRwdXRDb25maWd1cmF0aW9uLmdldEVyckhlbHBXaWR0aCgpIDogdGhpcy5fb3V0cHV0Q29uZmlndXJhdGlvbi5nZXRPdXRIZWxwV2lkdGgoKTtcbiAgICB9XG4gICAgcmV0dXJuIGhlbHBlci5mb3JtYXRIZWxwKHRoaXMsIGhlbHBlcik7XG4gIH1cblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIF9nZXRIZWxwQ29udGV4dChjb250ZXh0T3B0aW9ucykge1xuICAgIGNvbnRleHRPcHRpb25zID0gY29udGV4dE9wdGlvbnMgfHwge307XG4gICAgY29uc3QgY29udGV4dCA9IHsgZXJyb3I6ICEhY29udGV4dE9wdGlvbnMuZXJyb3IgfTtcbiAgICBsZXQgd3JpdGU7XG4gICAgaWYgKGNvbnRleHQuZXJyb3IpIHtcbiAgICAgIHdyaXRlID0gKGFyZykgPT4gdGhpcy5fb3V0cHV0Q29uZmlndXJhdGlvbi53cml0ZUVycihhcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3cml0ZSA9IChhcmcpID0+IHRoaXMuX291dHB1dENvbmZpZ3VyYXRpb24ud3JpdGVPdXQoYXJnKTtcbiAgICB9XG4gICAgY29udGV4dC53cml0ZSA9IGNvbnRleHRPcHRpb25zLndyaXRlIHx8IHdyaXRlO1xuICAgIGNvbnRleHQuY29tbWFuZCA9IHRoaXM7XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH1cblxuICAvKipcbiAgICogT3V0cHV0IGhlbHAgaW5mb3JtYXRpb24gZm9yIHRoaXMgY29tbWFuZC5cbiAgICpcbiAgICogT3V0cHV0cyBidWlsdC1pbiBoZWxwLCBhbmQgY3VzdG9tIHRleHQgYWRkZWQgdXNpbmcgYC5hZGRIZWxwVGV4dCgpYC5cbiAgICpcbiAgICogQHBhcmFtIHt7IGVycm9yOiBib29sZWFuIH0gfCBGdW5jdGlvbn0gW2NvbnRleHRPcHRpb25zXSAtIHBhc3Mge2Vycm9yOnRydWV9IHRvIHdyaXRlIHRvIHN0ZGVyciBpbnN0ZWFkIG9mIHN0ZG91dFxuICAgKi9cblxuICBvdXRwdXRIZWxwKGNvbnRleHRPcHRpb25zKSB7XG4gICAgbGV0IGRlcHJlY2F0ZWRDYWxsYmFjaztcbiAgICBpZiAodHlwZW9mIGNvbnRleHRPcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBkZXByZWNhdGVkQ2FsbGJhY2sgPSBjb250ZXh0T3B0aW9ucztcbiAgICAgIGNvbnRleHRPcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5fZ2V0SGVscENvbnRleHQoY29udGV4dE9wdGlvbnMpO1xuXG4gICAgZ2V0Q29tbWFuZEFuZFBhcmVudHModGhpcykucmV2ZXJzZSgpLmZvckVhY2goY29tbWFuZCA9PiBjb21tYW5kLmVtaXQoJ2JlZm9yZUFsbEhlbHAnLCBjb250ZXh0KSk7XG4gICAgdGhpcy5lbWl0KCdiZWZvcmVIZWxwJywgY29udGV4dCk7XG5cbiAgICBsZXQgaGVscEluZm9ybWF0aW9uID0gdGhpcy5oZWxwSW5mb3JtYXRpb24oY29udGV4dCk7XG4gICAgaWYgKGRlcHJlY2F0ZWRDYWxsYmFjaykge1xuICAgICAgaGVscEluZm9ybWF0aW9uID0gZGVwcmVjYXRlZENhbGxiYWNrKGhlbHBJbmZvcm1hdGlvbik7XG4gICAgICBpZiAodHlwZW9mIGhlbHBJbmZvcm1hdGlvbiAhPT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0J1ZmZlcihoZWxwSW5mb3JtYXRpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3V0cHV0SGVscCBjYWxsYmFjayBtdXN0IHJldHVybiBhIHN0cmluZyBvciBhIEJ1ZmZlcicpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb250ZXh0LndyaXRlKGhlbHBJbmZvcm1hdGlvbik7XG5cbiAgICB0aGlzLmVtaXQodGhpcy5faGVscExvbmdGbGFnKTsgLy8gZGVwcmVjYXRlZFxuICAgIHRoaXMuZW1pdCgnYWZ0ZXJIZWxwJywgY29udGV4dCk7XG4gICAgZ2V0Q29tbWFuZEFuZFBhcmVudHModGhpcykuZm9yRWFjaChjb21tYW5kID0+IGNvbW1hbmQuZW1pdCgnYWZ0ZXJBbGxIZWxwJywgY29udGV4dCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFlvdSBjYW4gcGFzcyBpbiBmbGFncyBhbmQgYSBkZXNjcmlwdGlvbiB0byBvdmVycmlkZSB0aGUgaGVscFxuICAgKiBmbGFncyBhbmQgaGVscCBkZXNjcmlwdGlvbiBmb3IgeW91ciBjb21tYW5kLiBQYXNzIGluIGZhbHNlIHRvXG4gICAqIGRpc2FibGUgdGhlIGJ1aWx0LWluIGhlbHAgb3B0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IGJvb2xlYW59IFtmbGFnc11cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtkZXNjcmlwdGlvbl1cbiAgICogQHJldHVybiB7Q29tbWFuZH0gYHRoaXNgIGNvbW1hbmQgZm9yIGNoYWluaW5nXG4gICAqL1xuXG4gIGhlbHBPcHRpb24oZmxhZ3MsIGRlc2NyaXB0aW9uKSB7XG4gICAgaWYgKHR5cGVvZiBmbGFncyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aGlzLl9oYXNIZWxwT3B0aW9uID0gZmxhZ3M7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5faGVscEZsYWdzID0gZmxhZ3MgfHwgdGhpcy5faGVscEZsYWdzO1xuICAgIHRoaXMuX2hlbHBEZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uIHx8IHRoaXMuX2hlbHBEZXNjcmlwdGlvbjtcblxuICAgIGNvbnN0IGhlbHBGbGFncyA9IHNwbGl0T3B0aW9uRmxhZ3ModGhpcy5faGVscEZsYWdzKTtcbiAgICB0aGlzLl9oZWxwU2hvcnRGbGFnID0gaGVscEZsYWdzLnNob3J0RmxhZztcbiAgICB0aGlzLl9oZWxwTG9uZ0ZsYWcgPSBoZWxwRmxhZ3MubG9uZ0ZsYWc7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBPdXRwdXQgaGVscCBpbmZvcm1hdGlvbiBhbmQgZXhpdC5cbiAgICpcbiAgICogT3V0cHV0cyBidWlsdC1pbiBoZWxwLCBhbmQgY3VzdG9tIHRleHQgYWRkZWQgdXNpbmcgYC5hZGRIZWxwVGV4dCgpYC5cbiAgICpcbiAgICogQHBhcmFtIHt7IGVycm9yOiBib29sZWFuIH19IFtjb250ZXh0T3B0aW9uc10gLSBwYXNzIHtlcnJvcjp0cnVlfSB0byB3cml0ZSB0byBzdGRlcnIgaW5zdGVhZCBvZiBzdGRvdXRcbiAgICovXG5cbiAgaGVscChjb250ZXh0T3B0aW9ucykge1xuICAgIHRoaXMub3V0cHV0SGVscChjb250ZXh0T3B0aW9ucyk7XG4gICAgbGV0IGV4aXRDb2RlID0gcHJvY2Vzcy5leGl0Q29kZSB8fCAwO1xuICAgIGlmIChleGl0Q29kZSA9PT0gMCAmJiBjb250ZXh0T3B0aW9ucyAmJiB0eXBlb2YgY29udGV4dE9wdGlvbnMgIT09ICdmdW5jdGlvbicgJiYgY29udGV4dE9wdGlvbnMuZXJyb3IpIHtcbiAgICAgIGV4aXRDb2RlID0gMTtcbiAgICB9XG4gICAgLy8gbWVzc2FnZTogZG8gbm90IGhhdmUgYWxsIGRpc3BsYXllZCB0ZXh0IGF2YWlsYWJsZSBzbyBvbmx5IHBhc3NpbmcgcGxhY2Vob2xkZXIuXG4gICAgdGhpcy5fZXhpdChleGl0Q29kZSwgJ2NvbW1hbmRlci5oZWxwJywgJyhvdXRwdXRIZWxwKScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhZGRpdGlvbmFsIHRleHQgdG8gYmUgZGlzcGxheWVkIHdpdGggdGhlIGJ1aWx0LWluIGhlbHAuXG4gICAqXG4gICAqIFBvc2l0aW9uIGlzICdiZWZvcmUnIG9yICdhZnRlcicgdG8gYWZmZWN0IGp1c3QgdGhpcyBjb21tYW5kLFxuICAgKiBhbmQgJ2JlZm9yZUFsbCcgb3IgJ2FmdGVyQWxsJyB0byBhZmZlY3QgdGhpcyBjb21tYW5kIGFuZCBhbGwgaXRzIHN1YmNvbW1hbmRzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcG9zaXRpb24gLSBiZWZvcmUgb3IgYWZ0ZXIgYnVpbHQtaW4gaGVscFxuICAgKiBAcGFyYW0ge3N0cmluZyB8IEZ1bmN0aW9ufSB0ZXh0IC0gc3RyaW5nIHRvIGFkZCwgb3IgYSBmdW5jdGlvbiByZXR1cm5pbmcgYSBzdHJpbmdcbiAgICogQHJldHVybiB7Q29tbWFuZH0gYHRoaXNgIGNvbW1hbmQgZm9yIGNoYWluaW5nXG4gICAqL1xuICBhZGRIZWxwVGV4dChwb3NpdGlvbiwgdGV4dCkge1xuICAgIGNvbnN0IGFsbG93ZWRWYWx1ZXMgPSBbJ2JlZm9yZUFsbCcsICdiZWZvcmUnLCAnYWZ0ZXInLCAnYWZ0ZXJBbGwnXTtcbiAgICBpZiAoIWFsbG93ZWRWYWx1ZXMuaW5jbHVkZXMocG9zaXRpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgdmFsdWUgZm9yIHBvc2l0aW9uIHRvIGFkZEhlbHBUZXh0LlxuRXhwZWN0aW5nIG9uZSBvZiAnJHthbGxvd2VkVmFsdWVzLmpvaW4oXCInLCAnXCIpfSdgKTtcbiAgICB9XG4gICAgY29uc3QgaGVscEV2ZW50ID0gYCR7cG9zaXRpb259SGVscGA7XG4gICAgdGhpcy5vbihoZWxwRXZlbnQsIChjb250ZXh0KSA9PiB7XG4gICAgICBsZXQgaGVscFN0cjtcbiAgICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBoZWxwU3RyID0gdGV4dCh7IGVycm9yOiBjb250ZXh0LmVycm9yLCBjb21tYW5kOiBjb250ZXh0LmNvbW1hbmQgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoZWxwU3RyID0gdGV4dDtcbiAgICAgIH1cbiAgICAgIC8vIElnbm9yZSBmYWxzeSB2YWx1ZSB3aGVuIG5vdGhpbmcgdG8gb3V0cHV0LlxuICAgICAgaWYgKGhlbHBTdHIpIHtcbiAgICAgICAgY29udGV4dC53cml0ZShgJHtoZWxwU3RyfVxcbmApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbi8qKlxuICogT3V0cHV0IGhlbHAgaW5mb3JtYXRpb24gaWYgaGVscCBmbGFncyBzcGVjaWZpZWRcbiAqXG4gKiBAcGFyYW0ge0NvbW1hbmR9IGNtZCAtIGNvbW1hbmQgdG8gb3V0cHV0IGhlbHAgZm9yXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIC0gYXJyYXkgb2Ygb3B0aW9ucyB0byBzZWFyY2ggZm9yIGhlbHAgZmxhZ3NcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG91dHB1dEhlbHBJZlJlcXVlc3RlZChjbWQsIGFyZ3MpIHtcbiAgY29uc3QgaGVscE9wdGlvbiA9IGNtZC5faGFzSGVscE9wdGlvbiAmJiBhcmdzLmZpbmQoYXJnID0+IGFyZyA9PT0gY21kLl9oZWxwTG9uZ0ZsYWcgfHwgYXJnID09PSBjbWQuX2hlbHBTaG9ydEZsYWcpO1xuICBpZiAoaGVscE9wdGlvbikge1xuICAgIGNtZC5vdXRwdXRIZWxwKCk7XG4gICAgLy8gKERvIG5vdCBoYXZlIGFsbCBkaXNwbGF5ZWQgdGV4dCBhdmFpbGFibGUgc28gb25seSBwYXNzaW5nIHBsYWNlaG9sZGVyLilcbiAgICBjbWQuX2V4aXQoMCwgJ2NvbW1hbmRlci5oZWxwRGlzcGxheWVkJywgJyhvdXRwdXRIZWxwKScpO1xuICB9XG59XG5cbi8qKlxuICogU2NhbiBhcmd1bWVudHMgYW5kIGluY3JlbWVudCBwb3J0IG51bWJlciBmb3IgaW5zcGVjdCBjYWxscyAodG8gYXZvaWQgY29uZmxpY3RzIHdoZW4gc3Bhd25pbmcgbmV3IGNvbW1hbmQpLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nW119IGFyZ3MgLSBhcnJheSBvZiBhcmd1bWVudHMgZnJvbSBub2RlLmV4ZWNBcmd2XG4gKiBAcmV0dXJucyB7c3RyaW5nW119XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpbmNyZW1lbnROb2RlSW5zcGVjdG9yUG9ydChhcmdzKSB7XG4gIC8vIFRlc3RpbmcgZm9yIHRoZXNlIG9wdGlvbnM6XG4gIC8vICAtLWluc3BlY3RbPVtob3N0Ol1wb3J0XVxuICAvLyAgLS1pbnNwZWN0LWJya1s9W2hvc3Q6XXBvcnRdXG4gIC8vICAtLWluc3BlY3QtcG9ydD1baG9zdDpdcG9ydFxuICByZXR1cm4gYXJncy5tYXAoKGFyZykgPT4ge1xuICAgIGlmICghYXJnLnN0YXJ0c1dpdGgoJy0taW5zcGVjdCcpKSB7XG4gICAgICByZXR1cm4gYXJnO1xuICAgIH1cbiAgICBsZXQgZGVidWdPcHRpb247XG4gICAgbGV0IGRlYnVnSG9zdCA9ICcxMjcuMC4wLjEnO1xuICAgIGxldCBkZWJ1Z1BvcnQgPSAnOTIyOSc7XG4gICAgbGV0IG1hdGNoO1xuICAgIGlmICgobWF0Y2ggPSBhcmcubWF0Y2goL14oLS1pbnNwZWN0KC1icmspPykkLykpICE9PSBudWxsKSB7XG4gICAgICAvLyBlLmcuIC0taW5zcGVjdFxuICAgICAgZGVidWdPcHRpb24gPSBtYXRjaFsxXTtcbiAgICB9IGVsc2UgaWYgKChtYXRjaCA9IGFyZy5tYXRjaCgvXigtLWluc3BlY3QoLWJya3wtcG9ydCk/KT0oW146XSspJC8pKSAhPT0gbnVsbCkge1xuICAgICAgZGVidWdPcHRpb24gPSBtYXRjaFsxXTtcbiAgICAgIGlmICgvXlxcZCskLy50ZXN0KG1hdGNoWzNdKSkge1xuICAgICAgICAvLyBlLmcuIC0taW5zcGVjdD0xMjM0XG4gICAgICAgIGRlYnVnUG9ydCA9IG1hdGNoWzNdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZS5nLiAtLWluc3BlY3Q9bG9jYWxob3N0XG4gICAgICAgIGRlYnVnSG9zdCA9IG1hdGNoWzNdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKG1hdGNoID0gYXJnLm1hdGNoKC9eKC0taW5zcGVjdCgtYnJrfC1wb3J0KT8pPShbXjpdKyk6KFxcZCspJC8pKSAhPT0gbnVsbCkge1xuICAgICAgLy8gZS5nLiAtLWluc3BlY3Q9bG9jYWxob3N0OjEyMzRcbiAgICAgIGRlYnVnT3B0aW9uID0gbWF0Y2hbMV07XG4gICAgICBkZWJ1Z0hvc3QgPSBtYXRjaFszXTtcbiAgICAgIGRlYnVnUG9ydCA9IG1hdGNoWzRdO1xuICAgIH1cblxuICAgIGlmIChkZWJ1Z09wdGlvbiAmJiBkZWJ1Z1BvcnQgIT09ICcwJykge1xuICAgICAgcmV0dXJuIGAke2RlYnVnT3B0aW9ufT0ke2RlYnVnSG9zdH06JHtwYXJzZUludChkZWJ1Z1BvcnQpICsgMX1gO1xuICAgIH1cbiAgICByZXR1cm4gYXJnO1xuICB9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NvbW1hbmR9IHN0YXJ0Q29tbWFuZFxuICogQHJldHVybnMge0NvbW1hbmRbXX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGdldENvbW1hbmRBbmRQYXJlbnRzKHN0YXJ0Q29tbWFuZCkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgY29tbWFuZCA9IHN0YXJ0Q29tbWFuZDsgY29tbWFuZDsgY29tbWFuZCA9IGNvbW1hbmQucGFyZW50KSB7XG4gICAgcmVzdWx0LnB1c2goY29tbWFuZCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0cy5Db21tYW5kID0gQ29tbWFuZDtcbiJdLCJtYXBwaW5ncyI6Ijs7QUFBQSxNQUFNQSxZQUFZLEdBQUdDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQ0QsWUFBWTtBQUNuRCxNQUFNRSxZQUFZLEdBQUdELE9BQU8sQ0FBQyxlQUFlLENBQUM7QUFDN0MsTUFBTUUsSUFBSSxHQUFHRixPQUFPLENBQUMsTUFBTSxDQUFDO0FBQzVCLE1BQU1HLEVBQUUsR0FBR0gsT0FBTyxDQUFDLElBQUksQ0FBQztBQUN4QixNQUFNSSxPQUFPLEdBQUdKLE9BQU8sQ0FBQyxTQUFTLENBQUM7QUFFbEMsTUFBTTtFQUFFSyxRQUFRO0VBQUVDO0FBQXFCLENBQUMsR0FBR04sT0FBTyxDQUFDLGVBQWUsQ0FBQztBQUNuRSxNQUFNO0VBQUVPO0FBQWUsQ0FBQyxHQUFHUCxPQUFPLENBQUMsWUFBWSxDQUFDO0FBQ2hELE1BQU07RUFBRVE7QUFBSyxDQUFDLEdBQUdSLE9BQU8sQ0FBQyxXQUFXLENBQUM7QUFDckMsTUFBTTtFQUFFUyxNQUFNO0VBQUVDLGdCQUFnQjtFQUFFQztBQUFZLENBQUMsR0FBR1gsT0FBTyxDQUFDLGFBQWEsQ0FBQztBQUN4RSxNQUFNO0VBQUVZO0FBQWUsQ0FBQyxHQUFHWixPQUFPLENBQUMsa0JBQWtCLENBQUM7O0FBRXREOztBQUVBLE1BQU1hLE9BQU8sU0FBU2QsWUFBWSxDQUFDO0VBQ2pDO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0VBRUVlLFdBQVdBLENBQUNDLElBQUksRUFBRTtJQUNoQixLQUFLLEVBQUU7SUFDUDtJQUNBLElBQUksQ0FBQ0MsUUFB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