8ce1d0e99c1a977d94f34b553be11751
'use strict';

const ansiStyles = require('ansi-styles');
const {
  stdout: stdoutColor,
  stderr: stderrColor
} = require('supports-color');
const {
  stringReplaceAll,
  stringEncaseCRLFWithFirstIndex
} = require('./util');

// `supportsColor.level` â†’ `ansiStyles.color[name]` mapping
const levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m'];
const styles = Object.create(null);
const applyOptions = (object, options = {}) => {
  if (options.level > 3 || options.level < 0) {
    throw new Error('The `level` option should be an integer from 0 to 3');
  }

  // Detect level if not set manually
  const colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options.level === undefined ? colorLevel : options.level;
};
class ChalkClass {
  constructor(options) {
    return chalkFactory(options);
  }
}
const chalkFactory = options => {
  const chalk = {};
  applyOptions(chalk, options);
  chalk.template = (...arguments_) => chalkTag(chalk.template, ...arguments_);
  Object.setPrototypeOf(chalk, Chalk.prototype);
  Object.setPrototypeOf(chalk.template, chalk);
  chalk.template.constructor = () => {
    throw new Error('`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.');
  };
  chalk.template.Instance = ChalkClass;
  return chalk.template;
};
function Chalk(options) {
  return chalkFactory(options);
}
for (const [styleName, style] of Object.entries(ansiStyles)) {
  styles[styleName] = {
    get() {
      const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
      Object.defineProperty(this, styleName, {
        value: builder
      });
      return builder;
    }
  };
}
styles.visible = {
  get() {
    const builder = createBuilder(this, this._styler, true);
    Object.defineProperty(this, 'visible', {
      value: builder
    });
    return builder;
  }
};
const usedModels = ['rgb', 'hex', 'keyword', 'hsl', 'hsv', 'hwb', 'ansi', 'ansi256'];
for (const model of usedModels) {
  styles[model] = {
    get() {
      const {
        level
      } = this;
      return function (...arguments_) {
        const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
        return createBuilder(this, styler, this._isEmpty);
      };
    }
  };
}
for (const model of usedModels) {
  const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
  styles[bgModel] = {
    get() {
      const {
        level
      } = this;
      return function (...arguments_) {
        const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
        return createBuilder(this, styler, this._isEmpty);
      };
    }
  };
}
const proto = Object.defineProperties(() => {}, {
  ...styles,
  level: {
    enumerable: true,
    get() {
      return this._generator.level;
    },
    set(level) {
      this._generator.level = level;
    }
  }
});
const createStyler = (open, close, parent) => {
  let openAll;
  let closeAll;
  if (parent === undefined) {
    openAll = open;
    closeAll = close;
  } else {
    openAll = parent.openAll + open;
    closeAll = close + parent.closeAll;
  }
  return {
    open,
    close,
    openAll,
    closeAll,
    parent
  };
};
const createBuilder = (self, _styler, _isEmpty) => {
  const builder = (...arguments_) => {
    // Single argument is hot path, implicit coercion is faster than anything
    // eslint-disable-next-line no-implicit-coercion
    return applyStyle(builder, arguments_.length === 1 ? '' + arguments_[0] : arguments_.join(' '));
  };

  // `__proto__` is used because we must return a function, but there is
  // no way to create a function with a different prototype
  builder.__proto__ = proto; // eslint-disable-line no-proto

  builder._generator = self;
  builder._styler = _styler;
  builder._isEmpty = _isEmpty;
  return builder;
};
const applyStyle = (self, string) => {
  if (self.level <= 0 || !string) {
    return self._isEmpty ? '' : string;
  }
  let styler = self._styler;
  if (styler === undefined) {
    return string;
  }
  const {
    openAll,
    closeAll
  } = styler;
  if (string.indexOf('\u001B') !== -1) {
    while (styler !== undefined) {
      // Replace any instances already present with a re-opening code
      // otherwise only the part of the string until said closing code
      // will be colored, and the rest will simply be 'plain'.
      string = stringReplaceAll(string, styler.close, styler.open);
      styler = styler.parent;
    }
  }

  // We can move both next actions out of loop, because remaining actions in loop won't have
  // any/visible effect on parts we add here. Close the styling before a linebreak and reopen
  // after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
  const lfIndex = string.indexOf('\n');
  if (lfIndex !== -1) {
    string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
  }
  return openAll + string + closeAll;
};
let template;
const chalkTag = (chalk, ...strings) => {
  const [firstString] = strings;
  if (!Array.isArray(firstString)) {
    // If chalk() was called by itself or with a string,
    // return the string itself as a string.
    return strings.join(' ');
  }
  const arguments_ = strings.slice(1);
  const parts = [firstString.raw[0]];
  for (let i = 1; i < firstString.length; i++) {
    parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, '\\$&'), String(firstString.raw[i]));
  }
  if (template === undefined) {
    template = require('./templates');
  }
  return template(chalk, parts.join(''));
};
Object.defineProperties(Chalk.prototype, styles);
const chalk = Chalk(); // eslint-disable-line new-cap
chalk.supportsColor = stdoutColor;
chalk.stderr = Chalk({
  level: stderrColor ? stderrColor.level : 0
}); // eslint-disable-line new-cap
chalk.stderr.supportsColor = stderrColor;

// For TypeScript
chalk.Level = {
  None: 0,
  Basic: 1,
  Ansi256: 2,
  TrueColor: 3,
  0: 'None',
  1: 'Basic',
  2: 'Ansi256',
  3: 'TrueColor'
};
module.exports = chalk;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJhbnNpU3R5bGVzIiwicmVxdWlyZSIsInN0ZG91dCIsInN0ZG91dENvbG9yIiwic3RkZXJyIiwic3RkZXJyQ29sb3IiLCJzdHJpbmdSZXBsYWNlQWxsIiwic3RyaW5nRW5jYXNlQ1JMRldpdGhGaXJzdEluZGV4IiwibGV2ZWxNYXBwaW5nIiwic3R5bGVzIiwiT2JqZWN0IiwiY3JlYXRlIiwiYXBwbHlPcHRpb25zIiwib2JqZWN0Iiwib3B0aW9ucyIsImxldmVsIiwiRXJyb3IiLCJjb2xvckxldmVsIiwidW5kZWZpbmVkIiwiQ2hhbGtDbGFzcyIsImNvbnN0cnVjdG9yIiwiY2hhbGtGYWN0b3J5IiwiY2hhbGsiLCJ0ZW1wbGF0ZSIsImFyZ3VtZW50c18iLCJjaGFsa1RhZyIsInNldFByb3RvdHlwZU9mIiwiQ2hhbGsiLCJwcm90b3R5cGUiLCJJbnN0YW5jZSIsInN0eWxlTmFtZSIsInN0eWxlIiwiZW50cmllcyIsImdldCIsImJ1aWxkZXIiLCJjcmVhdGVCdWlsZGVyIiwiY3JlYXRlU3R5bGVyIiwib3BlbiIsImNsb3NlIiwiX3N0eWxlciIsIl9pc0VtcHR5IiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsInZpc2libGUiLCJ1c2VkTW9kZWxzIiwibW9kZWwiLCJzdHlsZXIiLCJjb2xvciIsImJnTW9kZWwiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIiwiYmdDb2xvciIsInByb3RvIiwiZGVmaW5lUHJvcGVydGllcyIsImVudW1lcmFibGUiLCJfZ2VuZXJhdG9yIiwic2V0IiwicGFyZW50Iiwib3BlbkFsbCIsImNsb3NlQWxsIiwic2VsZiIsImFwcGx5U3R5bGUiLCJsZW5ndGgiLCJqb2luIiwiX19wcm90b19fIiwic3RyaW5nIiwiaW5kZXhPZiIsImxmSW5kZXgiLCJzdHJpbmdzIiwiZmlyc3RTdHJpbmciLCJBcnJheSIsImlzQXJyYXkiLCJwYXJ0cyIsInJhdyIsImkiLCJwdXNoIiwiU3RyaW5nIiwicmVwbGFjZSIsInN1cHBvcnRzQ29sb3IiLCJMZXZlbCIsIk5vbmUiLCJCYXNpYyIsIkFuc2kyNTYiLCJUcnVlQ29sb3IiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZXMiOlsiaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuY29uc3QgYW5zaVN0eWxlcyA9IHJlcXVpcmUoJ2Fuc2ktc3R5bGVzJyk7XG5jb25zdCB7c3Rkb3V0OiBzdGRvdXRDb2xvciwgc3RkZXJyOiBzdGRlcnJDb2xvcn0gPSByZXF1aXJlKCdzdXBwb3J0cy1jb2xvcicpO1xuY29uc3Qge1xuXHRzdHJpbmdSZXBsYWNlQWxsLFxuXHRzdHJpbmdFbmNhc2VDUkxGV2l0aEZpcnN0SW5kZXhcbn0gPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuLy8gYHN1cHBvcnRzQ29sb3IubGV2ZWxgIOKGkiBgYW5zaVN0eWxlcy5jb2xvcltuYW1lXWAgbWFwcGluZ1xuY29uc3QgbGV2ZWxNYXBwaW5nID0gW1xuXHQnYW5zaScsXG5cdCdhbnNpJyxcblx0J2Fuc2kyNTYnLFxuXHQnYW5zaTE2bSdcbl07XG5cbmNvbnN0IHN0eWxlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmNvbnN0IGFwcGx5T3B0aW9ucyA9IChvYmplY3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuXHRpZiAob3B0aW9ucy5sZXZlbCA+IDMgfHwgb3B0aW9ucy5sZXZlbCA8IDApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgbGV2ZWxgIG9wdGlvbiBzaG91bGQgYmUgYW4gaW50ZWdlciBmcm9tIDAgdG8gMycpO1xuXHR9XG5cblx0Ly8gRGV0ZWN0IGxldmVsIGlmIG5vdCBzZXQgbWFudWFsbHlcblx0Y29uc3QgY29sb3JMZXZlbCA9IHN0ZG91dENvbG9yID8gc3Rkb3V0Q29sb3IubGV2ZWwgOiAwO1xuXHRvYmplY3QubGV2ZWwgPSBvcHRpb25zLmxldmVsID09PSB1bmRlZmluZWQgPyBjb2xvckxldmVsIDogb3B0aW9ucy5sZXZlbDtcbn07XG5cbmNsYXNzIENoYWxrQ2xhc3Mge1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdFx0cmV0dXJuIGNoYWxrRmFjdG9yeShvcHRpb25zKTtcblx0fVxufVxuXG5jb25zdCBjaGFsa0ZhY3RvcnkgPSBvcHRpb25zID0+IHtcblx0Y29uc3QgY2hhbGsgPSB7fTtcblx0YXBwbHlPcHRpb25zKGNoYWxrLCBvcHRpb25zKTtcblxuXHRjaGFsay50ZW1wbGF0ZSA9ICguLi5hcmd1bWVudHNfKSA9PiBjaGFsa1RhZyhjaGFsay50ZW1wbGF0ZSwgLi4uYXJndW1lbnRzXyk7XG5cblx0T2JqZWN0LnNldFByb3RvdHlwZU9mKGNoYWxrLCBDaGFsay5wcm90b3R5cGUpO1xuXHRPYmplY3Quc2V0UHJvdG90eXBlT2YoY2hhbGsudGVtcGxhdGUsIGNoYWxrKTtcblxuXHRjaGFsay50ZW1wbGF0ZS5jb25zdHJ1Y3RvciA9ICgpID0+IHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ2BjaGFsay5jb25zdHJ1Y3RvcigpYCBpcyBkZXByZWNhdGVkLiBVc2UgYG5ldyBjaGFsay5JbnN0YW5jZSgpYCBpbnN0ZWFkLicpO1xuXHR9O1xuXG5cdGNoYWxrLnRlbXBsYXRlLkluc3RhbmNlID0gQ2hhbGtDbGFzcztcblxuXHRyZXR1cm4gY2hhbGsudGVtcGxhdGU7XG59O1xuXG5mdW5jdGlvbiBDaGFsayhvcHRpb25zKSB7XG5cdHJldHVybiBjaGFsa0ZhY3Rvcnkob3B0aW9ucyk7XG59XG5cbmZvciAoY29uc3QgW3N0eWxlTmFtZSwgc3R5bGVdIG9mIE9iamVjdC5lbnRyaWVzKGFuc2lTdHlsZXMpKSB7XG5cdHN0eWxlc1tzdHlsZU5hbWVdID0ge1xuXHRcdGdldCgpIHtcblx0XHRcdGNvbnN0IGJ1aWxkZXIgPSBjcmVhdGVCdWlsZGVyKHRoaXMsIGNyZWF0ZVN0eWxlcihzdHlsZS5vcGVuLCBzdHlsZS5jbG9zZSwgdGhpcy5fc3R5bGVyKSwgdGhpcy5faXNFbXB0eSk7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgc3R5bGVOYW1lLCB7dmFsdWU6IGJ1aWxkZXJ9KTtcblx0XHRcdHJldHVybiBidWlsZGVyO1xuXHRcdH1cblx0fTtcbn1cblxuc3R5bGVzLnZpc2libGUgPSB7XG5cdGdldCgpIHtcblx0XHRjb25zdCBidWlsZGVyID0gY3JlYXRlQnVpbGRlcih0aGlzLCB0aGlzLl9zdHlsZXIsIHRydWUpO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndmlzaWJsZScsIHt2YWx1ZTogYnVpbGRlcn0pO1xuXHRcdHJldHVybiBidWlsZGVyO1xuXHR9XG59O1xuXG5jb25zdCB1c2VkTW9kZWxzID0gWydyZ2InLCAnaGV4JywgJ2tleXdvcmQnLCAnaHNsJywgJ2hzdicsICdod2InLCAnYW5zaScsICdhbnNpMjU2J107XG5cbmZvciAoY29uc3QgbW9kZWwgb2YgdXNlZE1vZGVscykge1xuXHRzdHlsZXNbbW9kZWxdID0ge1xuXHRcdGdldCgpIHtcblx0XHRcdGNvbnN0IHtsZXZlbH0gPSB0aGlzO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICguLi5hcmd1bWVudHNfKSB7XG5cdFx0XHRcdGNvbnN0IHN0eWxlciA9IGNyZWF0ZVN0eWxlcihhbnNpU3R5bGVzLmNvbG9yW2xldmVsTWFwcGluZ1tsZXZlbF1dW21vZGVsXSguLi5hcmd1bWVudHNfKSwgYW5zaVN0eWxlcy5jb2xvci5jbG9zZSwgdGhpcy5fc3R5bGVyKTtcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZUJ1aWxkZXIodGhpcywgc3R5bGVyLCB0aGlzLl9pc0VtcHR5KTtcblx0XHRcdH07XG5cdFx0fVxuXHR9O1xufVxuXG5mb3IgKGNvbnN0IG1vZGVsIG9mIHVzZWRNb2RlbHMpIHtcblx0Y29uc3QgYmdNb2RlbCA9ICdiZycgKyBtb2RlbFswXS50b1VwcGVyQ2FzZSgpICsgbW9kZWwuc2xpY2UoMSk7XG5cdHN0eWxlc1tiZ01vZGVsXSA9IHtcblx0XHRnZXQoKSB7XG5cdFx0XHRjb25zdCB7bGV2ZWx9ID0gdGhpcztcblx0XHRcdHJldHVybiBmdW5jdGlvbiAoLi4uYXJndW1lbnRzXykge1xuXHRcdFx0XHRjb25zdCBzdHlsZXIgPSBjcmVhdGVTdHlsZXIoYW5zaVN0eWxlcy5iZ0NvbG9yW2xldmVsTWFwcGluZ1tsZXZlbF1dW21vZGVsXSguLi5hcmd1bWVudHNfKSwgYW5zaVN0eWxlcy5iZ0NvbG9yLmNsb3NlLCB0aGlzLl9zdHlsZXIpO1xuXHRcdFx0XHRyZXR1cm4gY3JlYXRlQnVpbGRlcih0aGlzLCBzdHlsZXIsIHRoaXMuX2lzRW1wdHkpO1xuXHRcdFx0fTtcblx0XHR9XG5cdH07XG59XG5cbmNvbnN0IHByb3RvID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoKCkgPT4ge30sIHtcblx0Li4uc3R5bGVzLFxuXHRsZXZlbDoge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Z2V0KCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2dlbmVyYXRvci5sZXZlbDtcblx0XHR9LFxuXHRcdHNldChsZXZlbCkge1xuXHRcdFx0dGhpcy5fZ2VuZXJhdG9yLmxldmVsID0gbGV2ZWw7XG5cdFx0fVxuXHR9XG59KTtcblxuY29uc3QgY3JlYXRlU3R5bGVyID0gKG9wZW4sIGNsb3NlLCBwYXJlbnQpID0+IHtcblx0bGV0IG9wZW5BbGw7XG5cdGxldCBjbG9zZUFsbDtcblx0aWYgKHBhcmVudCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0b3BlbkFsbCA9IG9wZW47XG5cdFx0Y2xvc2VBbGwgPSBjbG9zZTtcblx0fSBlbHNlIHtcblx0XHRvcGVuQWxsID0gcGFyZW50Lm9wZW5BbGwgKyBvcGVuO1xuXHRcdGNsb3NlQWxsID0gY2xvc2UgKyBwYXJlbnQuY2xvc2VBbGw7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdG9wZW4sXG5cdFx0Y2xvc2UsXG5cdFx0b3BlbkFsbCxcblx0XHRjbG9zZUFsbCxcblx0XHRwYXJlbnRcblx0fTtcbn07XG5cbmNvbnN0IGNyZWF0ZUJ1aWxkZXIgPSAoc2VsZiwgX3N0eWxlciwgX2lzRW1wdHkpID0+IHtcblx0Y29uc3QgYnVpbGRlciA9ICguLi5hcmd1bWVudHNfKSA9PiB7XG5cdFx0Ly8gU2luZ2xlIGFyZ3VtZW50IGlzIGhvdCBwYXRoLCBpbXBsaWNpdCBjb2VyY2lvbiBpcyBmYXN0ZXIgdGhhbiBhbnl0aGluZ1xuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbXBsaWNpdC1jb2VyY2lvblxuXHRcdHJldHVybiBhcHBseVN0eWxlKGJ1aWxkZXIsIChhcmd1bWVudHNfLmxlbmd0aCA9PT0gMSkgPyAoJycgKyBhcmd1bWVudHNfWzBdKSA6IGFyZ3VtZW50c18uam9pbignICcpKTtcblx0fTtcblxuXHQvLyBgX19wcm90b19fYCBpcyB1c2VkIGJlY2F1c2Ugd2UgbXVzdCByZXR1cm4gYSBmdW5jdGlvbiwgYnV0IHRoZXJlIGlzXG5cdC8vIG5vIHdheSB0byBjcmVhdGUgYSBmdW5jdGlvbiB3aXRoIGEgZGlmZmVyZW50IHByb3RvdHlwZVxuXHRidWlsZGVyLl9fcHJvdG9fXyA9IHByb3RvOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvXG5cblx0YnVpbGRlci5fZ2VuZXJhdG9yID0gc2VsZjtcblx0YnVpbGRlci5fc3R5bGVyID0gX3N0eWxlcjtcblx0YnVpbGRlci5faXNFbXB0eSA9IF9pc0VtcHR5O1xuXG5cdHJldHVybiBidWlsZGVyO1xufTtcblxuY29uc3QgYXBwbHlTdHlsZSA9IChzZWxmLCBzdHJpbmcpID0+IHtcblx0aWYgKHNlbGYubGV2ZWwgPD0gMCB8fCAhc3RyaW5nKSB7XG5cdFx0cmV0dXJuIHNlbGYuX2lzRW1wdHkgPyAnJyA6IHN0cmluZztcblx0fVxuXG5cdGxldCBzdHlsZXIgPSBzZWxmLl9zdHlsZXI7XG5cblx0aWYgKHN0eWxlciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIHN0cmluZztcblx0fVxuXG5cdGNvbnN0IHtvcGVuQWxsLCBjbG9zZUFsbH0gPSBzdHlsZXI7XG5cdGlmIChzdHJpbmcuaW5kZXhPZignXFx1MDAxQicpICE9PSAtMSkge1xuXHRcdHdoaWxlIChzdHlsZXIgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Ly8gUmVwbGFjZSBhbnkgaW5zdGFuY2VzIGFscmVhZHkgcHJlc2VudCB3aXRoIGEgcmUtb3BlbmluZyBjb2RlXG5cdFx0XHQvLyBvdGhlcndpc2Ugb25seSB0aGUgcGFydCBvZiB0aGUgc3RyaW5nIHVudGlsIHNhaWQgY2xvc2luZyBjb2RlXG5cdFx0XHQvLyB3aWxsIGJlIGNvbG9yZWQsIGFuZCB0aGUgcmVzdCB3aWxsIHNpbXBseSBiZSAncGxhaW4nLlxuXHRcdFx0c3RyaW5nID0gc3RyaW5nUmVwbGFjZUFsbChzdHJpbmcsIHN0eWxlci5jbG9zZSwgc3R5bGVyLm9wZW4pO1xuXG5cdFx0XHRzdHlsZXIgPSBzdHlsZXIucGFyZW50O1xuXHRcdH1cblx0fVxuXG5cdC8vIFdlIGNhbiBtb3ZlIGJvdGggbmV4dCBhY3Rpb25zIG91dCBvZiBsb29wLCBiZWNhdXNlIHJlbWFpbmluZyBhY3Rpb25zIGluIGxvb3Agd29uJ3QgaGF2ZVxuXHQvLyBhbnkvdmlzaWJsZSBlZmZlY3Qgb24gcGFydHMgd2UgYWRkIGhlcmUuIENsb3NlIHRoZSBzdHlsaW5nIGJlZm9yZSBhIGxpbmVicmVhayBhbmQgcmVvcGVuXG5cdC8vIGFmdGVyIG5leHQgbGluZSB0byBmaXggYSBibGVlZCBpc3N1ZSBvbiBtYWNPUzogaHR0cHM6Ly9naXRodWIuY29tL2NoYWxrL2NoYWxrL3B1bGwvOTJcblx0Y29uc3QgbGZJbmRleCA9IHN0cmluZy5pbmRleE9mKCdcXG4nKTtcblx0aWYgKGxmSW5kZXggIT09IC0xKSB7XG5cdFx0c3RyaW5nID0gc3RyaW5nRW5jYXNlQ1JMRldpdGhGaXJzdEluZGV4KHN0cmluZywgY2xvc2VBbGwsIG9wZW5BbGwsIGxmSW5kZXgpO1xuXHR9XG5cblx0cmV0dXJuIG9wZW5BbGwgKyBzdHJpbmcgKyBjbG9zZUFsbDtcbn07XG5cbmxldCB0ZW1wbGF0ZTtcbmNvbnN0IGNoYWxrVGFnID0gKGNoYWxrLCAuLi5zdHJpbmdzKSA9PiB7XG5cdGNvbnN0IFtmaXJzdFN0cmluZ10gPSBzdHJpbmdzO1xuXG5cdGlmICghQXJyYXkuaXNBcnJheShmaXJzdFN0cmluZykpIHtcblx0XHQvLyBJZiBjaGFsaygpIHdhcyBjYWxsZWQgYnkgaXRzZWxmIG9yIHdpdGggYSBzdHJpbmcsXG5cdFx0Ly8gcmV0dXJuIHRoZSBzdHJpbmcgaXRzZWxmIGFzIGEgc3RyaW5nLlxuXHRcdHJldHVybiBzdHJpbmdzLmpvaW4oJyAnKTtcblx0fVxuXG5cdGNvbnN0IGFyZ3VtZW50c18gPSBzdHJpbmdzLnNsaWNlKDEpO1xuXHRjb25zdCBwYXJ0cyA9IFtmaXJzdFN0cmluZy5yYXdbMF1dO1xuXG5cdGZvciAobGV0IGkgPSAxOyBpIDwgZmlyc3RTdHJpbmcubGVuZ3RoOyBpKyspIHtcblx0XHRwYXJ0cy5wdXNoKFxuXHRcdFx0U3RyaW5nKGFyZ3VtZW50c19baSAtIDFdKS5yZXBsYWNlKC9be31cXFxcXS9nLCAnXFxcXCQmJyksXG5cdFx0XHRTdHJpbmcoZmlyc3RTdHJpbmcucmF3W2ldKVxuXHRcdCk7XG5cdH1cblxuXHRpZiAodGVtcGxhdGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRlbXBsYXRlID0gcmVxdWlyZSgnLi90ZW1wbGF0ZXMnKTtcblx0fVxuXG5cdHJldHVybiB0ZW1wbGF0ZShjaGFsaywgcGFydHMuam9pbignJykpO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ2hhbGsucHJvdG90eXBlLCBzdHlsZXMpO1xuXG5jb25zdCBjaGFsayA9IENoYWxrKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxuY2hhbGsuc3VwcG9ydHNDb2xvciA9IHN0ZG91dENvbG9yO1xuY2hhbGsuc3RkZXJyID0gQ2hhbGsoe2xldmVsOiBzdGRlcnJDb2xvciA/IHN0ZGVyckNvbG9yLmxldmVsIDogMH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcbmNoYWxrLnN0ZGVyci5zdXBwb3J0c0NvbG9yID0gc3RkZXJyQ29sb3I7XG5cbi8vIEZvciBUeXBlU2NyaXB0XG5jaGFsay5MZXZlbCA9IHtcblx0Tm9uZTogMCxcblx0QmFzaWM6IDEsXG5cdEFuc2kyNTY6IDIsXG5cdFRydWVDb2xvcjogMyxcblx0MDogJ05vbmUnLFxuXHQxOiAnQmFzaWMnLFxuXHQyOiAnQW5zaTI1NicsXG5cdDM6ICdUcnVlQ29sb3InXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNoYWxrO1xuIl0sIm1hcHBpbmdzIjoiQUFBQSxZQUFZOztBQUNaLE1BQU1BLFVBQVUsR0FBR0MsT0FBTyxDQUFDLGFBQWEsQ0FBQztBQUN6QyxNQUFNO0VBQUNDLE1BQU0sRUFBRUMsV0FBVztFQUFFQyxNQUFNLEVBQUVDO0FBQVcsQ0FBQyxHQUFHSixPQUFPLENBQUMsZ0JBQWdCLENBQUM7QUFDNUUsTUFBTTtFQUNMSyxnQkFBZ0I7RUFDaEJDO0FBQ0QsQ0FBQyxHQUFHTixPQUFPLENBQUMsUUFBUSxDQUFDOztBQUVyQjtBQUNBLE1BQU1PLFlBQVksR0FBRyxDQUNwQixNQUFNLEVBQ04sTUFBTSxFQUNOLFNBQVMsRUFDVCxTQUFTLENBQ1Q7QUFFRCxNQUFNQyxNQUFNLEdBQUdDLE1BQU0sQ0FBQ0MsTUFBTSxDQUFDLElBQUksQ0FBQztBQUVsQyxNQUFNQyxZQUFZLEdBQUdBLENBQUNDLE1BQU0sRUFBRUMsT0FBTyxHQUFHLENBQUMsQ0FBQyxLQUFLO0VBQzlDLElBQUlBLE9BQU8sQ0FBQ0MsS0FBSyxHQUFHLENBQUMsSUFBSUQsT0FBTyxDQUFDQyxLQUFLLEdBQUcsQ0FBQyxFQUFFO0lBQzNDLE1BQU0sSUFBSUMsS0FBSyxDQUFDLHFEQUFxRCxDQUFDO0VBQ3ZFOztFQUVBO0VBQ0EsTUFBTUMsVUFBVSxHQUFHZCxXQUFXLEdBQUdBLFdBQVcsQ0FBQ1ksS0FBSyxHQUFHLENBQUM7RUFDdERGLE1BQU0sQ0FBQ0UsS0FBSyxHQUFHRCxPQUFPLENBQUNDLEtBQUssS0FBS0csU0FBUyxHQUFHRCxVQUFVLEdBQUdILE9BQU8sQ0FBQ0MsS0FBSztBQUN4RSxDQUFDO0FBRUQsTUFBTUksVUFBVSxDQUFDO0VBQ2hCQyxXQUFXQSxDQUFDTixPQUFPLEVBQUU7SUFDcEIsT0FBT08sWUFBWSxD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