a2a8cd508617c98f628ecf6f2f8ba0f7
'use strict';

function resolveProps(tokens, {
  flow,
  indicator,
  next,
  offset,
  onError,
  startOnNewline
}) {
  let spaceBefore = false;
  let atNewline = startOnNewline;
  let hasSpace = startOnNewline;
  let comment = '';
  let commentSep = '';
  let hasNewline = false;
  let hasNewlineAfterProp = false;
  let reqSpace = false;
  let anchor = null;
  let tag = null;
  let comma = null;
  let found = null;
  let start = null;
  for (const token of tokens) {
    if (reqSpace) {
      if (token.type !== 'space' && token.type !== 'newline' && token.type !== 'comma') onError(token.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');
      reqSpace = false;
    }
    switch (token.type) {
      case 'space':
        // At the doc level, tabs at line start may be parsed
        // as leading white space rather than indentation.
        // In a flow collection, only the parser handles indent.
        if (!flow && atNewline && indicator !== 'doc-start' && token.source[0] === '\t') onError(token, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');
        hasSpace = true;
        break;
      case 'comment':
        {
          if (!hasSpace) onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');
          const cb = token.source.substring(1) || ' ';
          if (!comment) comment = cb;else comment += commentSep + cb;
          commentSep = '';
          atNewline = false;
          break;
        }
      case 'newline':
        if (atNewline) {
          if (comment) comment += token.source;else spaceBefore = true;
        } else commentSep += token.source;
        atNewline = true;
        hasNewline = true;
        if (anchor || tag) hasNewlineAfterProp = true;
        hasSpace = true;
        break;
      case 'anchor':
        if (anchor) onError(token, 'MULTIPLE_ANCHORS', 'A node can have at most one anchor');
        if (token.source.endsWith(':')) onError(token.offset + token.source.length - 1, 'BAD_ALIAS', 'Anchor ending in : is ambiguous', true);
        anchor = token;
        if (start === null) start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      case 'tag':
        {
          if (tag) onError(token, 'MULTIPLE_TAGS', 'A node can have at most one tag');
          tag = token;
          if (start === null) start = token.offset;
          atNewline = false;
          hasSpace = false;
          reqSpace = true;
          break;
        }
      case indicator:
        // Could here handle preceding comments differently
        if (anchor || tag) onError(token, 'BAD_PROP_ORDER', `Anchors and tags must be after the ${token.source} indicator`);
        if (found) onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.source} in ${flow ?? 'collection'}`);
        found = token;
        atNewline = false;
        hasSpace = false;
        break;
      case 'comma':
        if (flow) {
          if (comma) onError(token, 'UNEXPECTED_TOKEN', `Unexpected , in ${flow}`);
          comma = token;
          atNewline = false;
          hasSpace = false;
          break;
        }
      // else fallthrough
      default:
        onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.type} token`);
        atNewline = false;
        hasSpace = false;
    }
  }
  const last = tokens[tokens.length - 1];
  const end = last ? last.offset + last.source.length : offset;
  if (reqSpace && next && next.type !== 'space' && next.type !== 'newline' && next.type !== 'comma' && (next.type !== 'scalar' || next.source !== '')) onError(next.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');
  return {
    comma,
    found,
    spaceBefore,
    comment,
    hasNewline,
    hasNewlineAfterProp,
    anchor,
    tag,
    end,
    start: start ?? end
  };
}
exports.resolveProps = resolveProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJyZXNvbHZlUHJvcHMiLCJ0b2tlbnMiLCJmbG93IiwiaW5kaWNhdG9yIiwibmV4dCIsIm9mZnNldCIsIm9uRXJyb3IiLCJzdGFydE9uTmV3bGluZSIsInNwYWNlQmVmb3JlIiwiYXROZXdsaW5lIiwiaGFzU3BhY2UiLCJjb21tZW50IiwiY29tbWVudFNlcCIsImhhc05ld2xpbmUiLCJoYXNOZXdsaW5lQWZ0ZXJQcm9wIiwicmVxU3BhY2UiLCJhbmNob3IiLCJ0YWciLCJjb21tYSIsImZvdW5kIiwic3RhcnQiLCJ0b2tlbiIsInR5cGUiLCJzb3VyY2UiLCJjYiIsInN1YnN0cmluZyIsImVuZHNXaXRoIiwibGVuZ3RoIiwibGFzdCIsImVuZCIsImV4cG9ydHMiXSwic291cmNlcyI6WyJyZXNvbHZlLXByb3BzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gcmVzb2x2ZVByb3BzKHRva2VucywgeyBmbG93LCBpbmRpY2F0b3IsIG5leHQsIG9mZnNldCwgb25FcnJvciwgc3RhcnRPbk5ld2xpbmUgfSkge1xuICAgIGxldCBzcGFjZUJlZm9yZSA9IGZhbHNlO1xuICAgIGxldCBhdE5ld2xpbmUgPSBzdGFydE9uTmV3bGluZTtcbiAgICBsZXQgaGFzU3BhY2UgPSBzdGFydE9uTmV3bGluZTtcbiAgICBsZXQgY29tbWVudCA9ICcnO1xuICAgIGxldCBjb21tZW50U2VwID0gJyc7XG4gICAgbGV0IGhhc05ld2xpbmUgPSBmYWxzZTtcbiAgICBsZXQgaGFzTmV3bGluZUFmdGVyUHJvcCA9IGZhbHNlO1xuICAgIGxldCByZXFTcGFjZSA9IGZhbHNlO1xuICAgIGxldCBhbmNob3IgPSBudWxsO1xuICAgIGxldCB0YWcgPSBudWxsO1xuICAgIGxldCBjb21tYSA9IG51bGw7XG4gICAgbGV0IGZvdW5kID0gbnVsbDtcbiAgICBsZXQgc3RhcnQgPSBudWxsO1xuICAgIGZvciAoY29uc3QgdG9rZW4gb2YgdG9rZW5zKSB7XG4gICAgICAgIGlmIChyZXFTcGFjZSkge1xuICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09ICdzcGFjZScgJiZcbiAgICAgICAgICAgICAgICB0b2tlbi50eXBlICE9PSAnbmV3bGluZScgJiZcbiAgICAgICAgICAgICAgICB0b2tlbi50eXBlICE9PSAnY29tbWEnKVxuICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4ub2Zmc2V0LCAnTUlTU0lOR19DSEFSJywgJ1RhZ3MgYW5kIGFuY2hvcnMgbXVzdCBiZSBzZXBhcmF0ZWQgZnJvbSB0aGUgbmV4dCB0b2tlbiBieSB3aGl0ZSBzcGFjZScpO1xuICAgICAgICAgICAgcmVxU3BhY2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgICAgICAvLyBBdCB0aGUgZG9jIGxldmVsLCB0YWJzIGF0IGxpbmUgc3RhcnQgbWF5IGJlIHBhcnNlZFxuICAgICAgICAgICAgICAgIC8vIGFzIGxlYWRpbmcgd2hpdGUgc3BhY2UgcmF0aGVyIHRoYW4gaW5kZW50YXRpb24uXG4gICAgICAgICAgICAgICAgLy8gSW4gYSBmbG93IGNvbGxlY3Rpb24sIG9ubHkgdGhlIHBhcnNlciBoYW5kbGVzIGluZGVudC5cbiAgICAgICAgICAgICAgICBpZiAoIWZsb3cgJiZcbiAgICAgICAgICAgICAgICAgICAgYXROZXdsaW5lICYmXG4gICAgICAgICAgICAgICAgICAgIGluZGljYXRvciAhPT0gJ2RvYy1zdGFydCcgJiZcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4uc291cmNlWzBdID09PSAnXFx0JylcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ1RBQl9BU19JTkRFTlQnLCAnVGFicyBhcmUgbm90IGFsbG93ZWQgYXMgaW5kZW50YXRpb24nKTtcbiAgICAgICAgICAgICAgICBoYXNTcGFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjb21tZW50Jzoge1xuICAgICAgICAgICAgICAgIGlmICghaGFzU3BhY2UpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdNSVNTSU5HX0NIQVInLCAnQ29tbWVudHMgbXVzdCBiZSBzZXBhcmF0ZWQgZnJvbSBvdGhlciB0b2tlbnMgYnkgd2hpdGUgc3BhY2UgY2hhcmFjdGVycycpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNiID0gdG9rZW4uc291cmNlLnN1YnN0cmluZygxKSB8fCAnICc7XG4gICAgICAgICAgICAgICAgaWYgKCFjb21tZW50KVxuICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gY2I7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjb21tZW50ICs9IGNvbW1lbnRTZXAgKyBjYjtcbiAgICAgICAgICAgICAgICBjb21tZW50U2VwID0gJyc7XG4gICAgICAgICAgICAgICAgYXROZXdsaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICBpZiAoYXROZXdsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudCArPSB0b2tlbi5zb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYWNlQmVmb3JlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjb21tZW50U2VwICs9IHRva2VuLnNvdXJjZTtcbiAgICAgICAgICAgICAgICBhdE5ld2xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGhhc05ld2xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChhbmNob3IgfHwgdGFnKVxuICAgICAgICAgICAgICAgICAgICBoYXNOZXdsaW5lQWZ0ZXJQcm9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBoYXNTcGFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhbmNob3InOlxuICAgICAgICAgICAgICAgIGlmIChhbmNob3IpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdNVUxUSVBMRV9BTkNIT1JTJywgJ0Egbm9kZSBjYW4gaGF2ZSBhdCBtb3N0IG9uZSBhbmNob3InKTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4uc291cmNlLmVuZHNXaXRoKCc6JykpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4ub2Zmc2V0ICsgdG9rZW4uc291cmNlLmxlbmd0aCAtIDEsICdCQURfQUxJQVMnLCAnQW5jaG9yIGVuZGluZyBpbiA6IGlzIGFtYmlndW91cycsIHRydWUpO1xuICAgICAgICAgICAgICAgIGFuY2hvciA9IHRva2VuO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSB0b2tlbi5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgYXROZXdsaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaGFzU3BhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXFTcGFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd0YWcnOiB7XG4gICAgICAgICAgICAgICAgaWYgKHRhZylcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ01VTFRJUExFX1RBR1MnLCAnQSBub2RlIGNhbiBoYXZlIGF0IG1vc3Qgb25lIHRhZycpO1xuICAgICAgICAgICAgICAgIHRhZyA9IHRva2VuO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSB0b2tlbi5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgYXROZXdsaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaGFzU3BhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXFTcGFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIGluZGljYXRvcjpcbiAgICAgICAgICAgICAgICAvLyBDb3VsZCBoZXJlIGhhbmRsZSBwcmVjZWRpbmcgY29tbWVudHMgZGlmZmVyZW50bHlcbiAgICAgICAgICAgICAgICBpZiAoYW5jaG9yIHx8IHRhZylcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ0JBRF9QUk9QX09SREVSJywgYEFuY2hvcnMgYW5kIHRhZ3MgbXVzdCBiZSBhZnRlciB0aGUgJHt0b2tlbi5zb3VyY2V9IGluZGljYXRvcmApO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ1VORVhQRUNURURfVE9LRU4nLCBgVW5leHBlY3RlZCAke3Rva2VuLnNvdXJjZX0gaW4gJHtmbG93ID8/ICdjb2xsZWN0aW9uJ31gKTtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgIGF0TmV3bGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGhhc1NwYWNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjb21tYSc6XG4gICAgICAgICAgICAgICAgaWYgKGZsb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1hKVxuICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ1VORVhQRUNURURfVE9LRU4nLCBgVW5leHBlY3RlZCAsIGluICR7Zmxvd31gKTtcbiAgICAgICAgICAgICAgICAgICAgY29tbWEgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgYXROZXdsaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGhhc1NwYWNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVsc2UgZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ1VORVhQRUNURURfVE9LRU4nLCBgVW5leHBlY3RlZCAke3Rva2VuLnR5cGV9IHRva2VuYCk7XG4gICAgICAgICAgICAgICAgYXROZXdsaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaGFzU3BhY2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsYXN0ID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBlbmQgPSBsYXN0ID8gbGFzdC5vZmZzZXQgKyBsYXN0LnNvdXJjZS5sZW5ndGggOiBvZmZzZXQ7XG4gICAgaWYgKHJlcVNwYWNlICYmXG4gICAgICAgIG5leHQgJiZcbiAgICAgICAgbmV4dC50eXBlICE9PSAnc3BhY2UnICYmXG4gICAgICAgIG5leHQudHlwZSAhPT0gJ25ld2xpbmUnICYmXG4gICAgICAgIG5leHQudHlwZSAhPT0gJ2NvbW1hJyAmJlxuICAgICAgICAobmV4dC50eXBlICE9PSAnc2NhbGFyJyB8fCBuZXh0LnNvdXJjZSAhPT0gJycpKVxuICAgICAgICBvbkVycm9yKG5leHQub2Zmc2V0LCAnTUlTU0lOR19DSEFSJywgJ1RhZ3MgYW5kIGFuY2hvcnMgbXVzdCBiZSBzZXBhcmF0ZWQgZnJvbSB0aGUgbmV4dCB0b2tlbiBieSB3aGl0ZSBzcGFjZScpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbW1hLFxuICAgICAgICBmb3VuZCxcbiAgICAgICAgc3BhY2VCZWZvcmUsXG4gICAgICAgIGNvbW1lbnQsXG4gICAgICAgIGhhc05ld2xpbmUsXG4gICAgICAgIGhhc05ld2xpbmVBZnRlclByb3AsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgdGFnLFxuICAgICAgICBlbmQsXG4gICAgICAgIHN0YXJ0OiBzdGFydCA/PyBlbmRcbiAgICB9O1xufVxuXG5leHBvcnRzLnJlc29sdmVQcm9wcyA9IHJlc29sdmVQcm9wcztcbiJdLCJtYXBwaW5ncyI6IkFBQUEsWUFBWTs7QUFFWixTQUFTQSxZQUFZQSxDQUFDQyxNQUFNLEVBQUU7RUFBRUMsSUFBSTtFQUFFQyxTQUFTO0VBQUVDLElBQUk7RUFBRUMsTUFBTTtFQUFFQyxPQUFPO0VBQUVDO0FBQWUsQ0FBQyxFQUFFO0VBQ3RGLElBQUlDLFdBQVcsR0FBRyxLQUFLO0VBQ3ZCLElBQUlDLFNBQVMsR0FBR0YsY0FBYztFQUM5QixJQUFJRyxRQUFRLEdBQUdILGNBQWM7RUFDN0IsSUFBSUksT0FBTyxHQUFHLEVBQUU7RUFDaEIsSUFBSUMsVUFBVSxHQUFHLEVBQUU7RUFDbkIsSUFBSUMsVUFBVSxHQUFHLEtBQUs7RUFDdEIsSUFBSUMsbUJBQW1CLEdBQUcsS0FBSztFQUMvQixJQUFJQyxRQUFRLEdBQUcsS0FBSztFQUNwQixJQUFJQyxNQUFNLEdBQUcsSUFBSTtFQUNqQixJQUFJQyxHQUFHLEdBQUcsSUFBSTtFQUNkLElBQUlDLEtBQUssR0FBRyxJQUFJO0VBQ2hCLElBQUlDLEtBQUssR0FBRyxJQUFJO0VBQ2hCLElBQUlDLEtBQUssR0FBRyxJQUFJO0VBQ2hCLEtBQUssTUFBTUMsS0FBSyxJQUFJcEIsTUFBTSxFQUFFO0lBQ3hCLElBQUljLFFBQVEsRUFBRTtNQUNWLElBQUlNLEtBQUssQ0FBQ0MsSUFBSSxLQUFLLE9BQU8sSUFDdEJELEtBQUssQ0FBQ0MsSUFBSSxLQUFLLFNBQVMsSUFDeEJELEtBQUssQ0FBQ0MsSUFBSSxLQUFLLE9BQU8sRUFDdEJoQixPQUFPLENBQUNlLEtBQUssQ0FBQ2hCLE1BQU0sRUFBRSxjQUFjLEVBQUUsdUVBQXVFLENBQUM7TUFDbEhVLFFBQVEsR0FB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