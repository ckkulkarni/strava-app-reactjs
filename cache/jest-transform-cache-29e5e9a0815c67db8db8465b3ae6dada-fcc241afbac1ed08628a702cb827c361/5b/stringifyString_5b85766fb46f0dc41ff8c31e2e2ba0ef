0b776a63c441f345aa49a2a5cc836393
'use strict';

var Scalar = require('../nodes/Scalar.js');
var foldFlowLines = require('./foldFlowLines.js');
const getFoldOptions = ctx => ({
  indentAtStart: ctx.indentAtStart,
  lineWidth: ctx.options.lineWidth,
  minContentWidth: ctx.options.minContentWidth
});
// Also checks for lines starting with %, as parsing the output as YAML 1.1 will
// presume that's starting a new document.
const containsDocumentMarker = str => /^(%|---|\.\.\.)/m.test(str);
function lineLengthOverLimit(str, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0) return false;
  const limit = lineWidth - indentLength;
  const strLen = str.length;
  if (strLen <= limit) return false;
  for (let i = 0, start = 0; i < strLen; ++i) {
    if (str[i] === '\n') {
      if (i - start > limit) return true;
      start = i + 1;
      if (strLen - start <= limit) return false;
    }
  }
  return true;
}
function doubleQuotedString(value, ctx) {
  const json = JSON.stringify(value);
  if (ctx.options.doubleQuotedAsJSON) return json;
  const {
    implicitKey
  } = ctx;
  const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
  const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
  let str = '';
  let start = 0;
  for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
    if (ch === ' ' && json[i + 1] === '\\' && json[i + 2] === 'n') {
      // space before newline needs to be escaped to not be folded
      str += json.slice(start, i) + '\\ ';
      i += 1;
      start = i;
      ch = '\\';
    }
    if (ch === '\\') switch (json[i + 1]) {
      case 'u':
        {
          str += json.slice(start, i);
          const code = json.substr(i + 2, 4);
          switch (code) {
            case '0000':
              str += '\\0';
              break;
            case '0007':
              str += '\\a';
              break;
            case '000b':
              str += '\\v';
              break;
            case '001b':
              str += '\\e';
              break;
            case '0085':
              str += '\\N';
              break;
            case '00a0':
              str += '\\_';
              break;
            case '2028':
              str += '\\L';
              break;
            case '2029':
              str += '\\P';
              break;
            default:
              if (code.substr(0, 2) === '00') str += '\\x' + code.substr(2);else str += json.substr(i, 6);
          }
          i += 5;
          start = i + 1;
        }
        break;
      case 'n':
        if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
          i += 1;
        } else {
          // folding will eat first newline
          str += json.slice(start, i) + '\n\n';
          while (json[i + 2] === '\\' && json[i + 3] === 'n' && json[i + 4] !== '"') {
            str += '\n';
            i += 2;
          }
          str += indent;
          // space after newline needs to be escaped to not be folded
          if (json[i + 2] === ' ') str += '\\';
          i += 1;
          start = i + 1;
        }
        break;
      default:
        i += 1;
    }
  }
  str = start ? str + json.slice(start) : json;
  return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx));
}
function singleQuotedString(value, ctx) {
  if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes('\n') || /[ \t]\n|\n[ \t]/.test(value) // single quoted string can't have leading or trailing whitespace around newline
  ) return doubleQuotedString(value, ctx);
  const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
  const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&\n${indent}`) + "'";
  return ctx.implicitKey ? res : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx));
}
function quotedString(value, ctx) {
  const {
    singleQuote
  } = ctx.options;
  let qs;
  if (singleQuote === false) qs = doubleQuotedString;else {
    const hasDouble = value.includes('"');
    const hasSingle = value.includes("'");
    if (hasDouble && !hasSingle) qs = singleQuotedString;else if (hasSingle && !hasDouble) qs = doubleQuotedString;else qs = singleQuote ? singleQuotedString : doubleQuotedString;
  }
  return qs(value, ctx);
}
function blockString({
  comment,
  type,
  value
}, ctx, onComment, onChompKeep) {
  const {
    blockQuote,
    commentString,
    lineWidth
  } = ctx.options;
  // 1. Block can't end in whitespace unless the last line is non-empty.
  // 2. Strings consisting of only whitespace are best rendered explicitly.
  if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
    return quotedString(value, ctx);
  }
  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');
  const literal = blockQuote === 'literal' ? true : blockQuote === 'folded' || type === Scalar.Scalar.BLOCK_FOLDED ? false : type === Scalar.Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
  if (!value) return literal ? '|\n' : '>\n';
  // determine chomping from whitespace at value end
  let chomp;
  let endStart;
  for (endStart = value.length; endStart > 0; --endStart) {
    const ch = value[endStart - 1];
    if (ch !== '\n' && ch !== '\t' && ch !== ' ') break;
  }
  let end = value.substring(endStart);
  const endNlPos = end.indexOf('\n');
  if (endNlPos === -1) {
    chomp = '-'; // strip
  } else if (value === end || endNlPos !== end.length - 1) {
    chomp = '+'; // keep
    if (onChompKeep) onChompKeep();
  } else {
    chomp = ''; // clip
  }

  if (end) {
    value = value.slice(0, -end.length);
    if (end[end.length - 1] === '\n') end = end.slice(0, -1);
    end = end.replace(/\n+(?!\n|$)/g, `$&${indent}`);
  }
  // determine indent indicator from whitespace at value start
  let startWithSpace = false;
  let startEnd;
  let startNlPos = -1;
  for (startEnd = 0; startEnd < value.length; ++startEnd) {
    const ch = value[startEnd];
    if (ch === ' ') startWithSpace = true;else if (ch === '\n') startNlPos = startEnd;else break;
  }
  let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
  if (start) {
    value = value.substring(start.length);
    start = start.replace(/\n+/g, `$&${indent}`);
  }
  const indentSize = indent ? '2' : '1'; // root is at -1
  let header = (literal ? '|' : '>') + (startWithSpace ? indentSize : '') + chomp;
  if (comment) {
    header += ' ' + commentString(comment.replace(/ ?[\r\n]+/g, ' '));
    if (onComment) onComment();
  }
  if (literal) {
    value = value.replace(/\n+/g, `$&${indent}`);
    return `${header}\n${indent}${start}${value}${end}`;
  }
  value = value.replace(/\n+/g, '\n$&').replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, '$1$2') // more-indented lines aren't folded
  //                ^ more-ind. ^ empty     ^ capture next empty lines only at end of indent
  .replace(/\n+/g, `$&${indent}`);
  const body = foldFlowLines.foldFlowLines(`${start}${value}${end}`, indent, foldFlowLines.FOLD_BLOCK, getFoldOptions(ctx));
  return `${header}\n${indent}${body}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
  const {
    type,
    value
  } = item;
  const {
    actualString,
    implicitKey,
    indent,
    indentStep,
    inFlow
  } = ctx;
  if (implicitKey && /[\n[\]{},]/.test(value) || inFlow && /[[\]{},]/.test(value)) {
    return quotedString(value, ctx);
  }
  if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
    // not allowed:
    // - empty string, '-' or '?'
    // - start with an indicator character (except [?:-]) or /[?-] /
    // - '\n ', ': ' or ' \n' anywhere
    // - '#' not preceded by a non-space char
    // - end with ' ' or ':'
    return implicitKey || inFlow || !value.includes('\n') ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
  }
  if (!implicitKey && !inFlow && type !== Scalar.Scalar.PLAIN && value.includes('\n')) {
    // Where allowed & type not set explicitly, prefer block style for multiline strings
    return blockString(item, ctx, onComment, onChompKeep);
  }
  if (containsDocumentMarker(value)) {
    if (indent === '') {
      ctx.forceBlockIndent = true;
      return blockString(item, ctx, onComment, onChompKeep);
    } else if (implicitKey && indent === indentStep) {
      return quotedString(value, ctx);
    }
  }
  const str = value.replace(/\n+/g, `$&\n${indent}`);
  // Verify that output will be parsed as a string, as e.g. plain numbers and
  // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),
  // and others in v1.1.
  if (actualString) {
    const test = tag => tag.default && tag.tag !== 'tag:yaml.org,2002:str' && tag.test?.test(str);
    const {
      compat,
      tags
    } = ctx.doc.schema;
    if (tags.some(test) || compat?.some(test)) return quotedString(value, ctx);
  }
  return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
  const {
    implicitKey,
    inFlow
  } = ctx;
  const ss = typeof item.value === 'string' ? item : Object.assign({}, item, {
    value: String(item.value)
  });
  let {
    type
  } = item;
  if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
    // force double quotes on control characters & unpaired surrogates
    if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value)) type = Scalar.Scalar.QUOTE_DOUBLE;
  }
  const _stringify = _type => {
    switch (_type) {
      case Scalar.Scalar.BLOCK_FOLDED:
      case Scalar.Scalar.BLOCK_LITERAL:
        return implicitKey || inFlow ? quotedString(ss.value, ctx) // blocks are not valid inside flow containers
        : blockString(ss, ctx, onComment, onChompKeep);
      case Scalar.Scalar.QUOTE_DOUBLE:
        return doubleQuotedString(ss.value, ctx);
      case Scalar.Scalar.QUOTE_SINGLE:
        return singleQuotedString(ss.value, ctx);
      case Scalar.Scalar.PLAIN:
        return plainString(ss, ctx, onComment, onChompKeep);
      default:
        return null;
    }
  };
  let res = _stringify(type);
  if (res === null) {
    const {
      defaultKeyType,
      defaultStringType
    } = ctx.options;
    const t = implicitKey && defaultKeyType || defaultStringType;
    res = _stringify(t);
    if (res === null) throw new Error(`Unsupported default string type ${t}`);
  }
  return res;
}
exports.stringifyString = stringifyString;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJTY2FsYXIiLCJyZXF1aXJlIiwiZm9sZEZsb3dMaW5lcyIsImdldEZvbGRPcHRpb25zIiwiY3R4IiwiaW5kZW50QXRTdGFydCIsImxpbmVXaWR0aCIsIm9wdGlvbnMiLCJtaW5Db250ZW50V2lkdGgiLCJjb250YWluc0RvY3VtZW50TWFya2VyIiwic3RyIiwidGVzdCIsImxpbmVMZW5ndGhPdmVyTGltaXQiLCJpbmRlbnRMZW5ndGgiLCJsaW1pdCIsInN0ckxlbiIsImxlbmd0aCIsImkiLCJzdGFydCIsImRvdWJsZVF1b3RlZFN0cmluZyIsInZhbHVlIiwianNvbiIsIkpTT04iLCJzdHJpbmdpZnkiLCJkb3VibGVRdW90ZWRBc0pTT04iLCJpbXBsaWNpdEtleSIsIm1pbk11bHRpTGluZUxlbmd0aCIsImRvdWJsZVF1b3RlZE1pbk11bHRpTGluZUxlbmd0aCIsImluZGVudCIsImNoIiwic2xpY2UiLCJjb2RlIiwic3Vic3RyIiwiRk9MRF9RVU9URUQiLCJzaW5nbGVRdW90ZWRTdHJpbmciLCJzaW5nbGVRdW90ZSIsImluY2x1ZGVzIiwicmVzIiwicmVwbGFjZSIsIkZPTERfRkxPVyIsInF1b3RlZFN0cmluZyIsInFzIiwiaGFzRG91YmxlIiwiaGFzU2luZ2xlIiwiYmxvY2tTdHJpbmciLCJjb21tZW50IiwidHlwZSIsIm9uQ29tbWVudCIsIm9uQ2hvbXBLZWVwIiwiYmxvY2tRdW90ZSIsImNvbW1lbnRTdHJpbmciLCJmb3JjZUJsb2NrSW5kZW50IiwibGl0ZXJhbCIsIkJMT0NLX0ZPTERFRCIsIkJMT0NLX0xJVEVSQUwiLCJjaG9tcCIsImVuZFN0YXJ0IiwiZW5kIiwic3Vic3RyaW5nIiwiZW5kTmxQb3MiLCJpbmRleE9mIiwic3RhcnRXaXRoU3BhY2UiLCJzdGFydEVuZCIsInN0YXJ0TmxQb3MiLCJpbmRlbnRTaXplIiwiaGVhZGVyIiwiYm9keSIsIkZPTERfQkxPQ0siLCJwbGFpblN0cmluZyIsIml0ZW0iLCJhY3R1YWxTdHJpbmciLCJpbmRlbnRTdGVwIiwiaW5GbG93IiwiUExBSU4iLCJ0YWciLCJkZWZhdWx0IiwiY29tcGF0IiwidGFncyIsImRvYyIsInNjaGVtYSIsInNvbWUiLCJzdHJpbmdpZnlTdHJpbmciLCJzcyIsIk9iamVjdCIsImFzc2lnbiIsIlN0cmluZyIsIlFVT1RFX0RPVUJMRSIsIl9zdHJpbmdpZnkiLCJfdHlwZSIsIlFVT1RFX1NJTkdMRSIsImRlZmF1bHRLZXlUeXBlIiwiZGVmYXVsdFN0cmluZ1R5cGUiLCJ0IiwiRXJyb3IiLCJleHBvcnRzIl0sInNvdXJjZXMiOlsic3RyaW5naWZ5U3RyaW5nLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIFNjYWxhciA9IHJlcXVpcmUoJy4uL25vZGVzL1NjYWxhci5qcycpO1xudmFyIGZvbGRGbG93TGluZXMgPSByZXF1aXJlKCcuL2ZvbGRGbG93TGluZXMuanMnKTtcblxuY29uc3QgZ2V0Rm9sZE9wdGlvbnMgPSAoY3R4KSA9PiAoe1xuICAgIGluZGVudEF0U3RhcnQ6IGN0eC5pbmRlbnRBdFN0YXJ0LFxuICAgIGxpbmVXaWR0aDogY3R4Lm9wdGlvbnMubGluZVdpZHRoLFxuICAgIG1pbkNvbnRlbnRXaWR0aDogY3R4Lm9wdGlvbnMubWluQ29udGVudFdpZHRoXG59KTtcbi8vIEFsc28gY2hlY2tzIGZvciBsaW5lcyBzdGFydGluZyB3aXRoICUsIGFzIHBhcnNpbmcgdGhlIG91dHB1dCBhcyBZQU1MIDEuMSB3aWxsXG4vLyBwcmVzdW1lIHRoYXQncyBzdGFydGluZyBhIG5ldyBkb2N1bWVudC5cbmNvbnN0IGNvbnRhaW5zRG9jdW1lbnRNYXJrZXIgPSAoc3RyKSA9PiAvXiglfC0tLXxcXC5cXC5cXC4pL20udGVzdChzdHIpO1xuZnVuY3Rpb24gbGluZUxlbmd0aE92ZXJMaW1pdChzdHIsIGxpbmVXaWR0aCwgaW5kZW50TGVuZ3RoKSB7XG4gICAgaWYgKCFsaW5lV2lkdGggfHwgbGluZVdpZHRoIDwgMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGxpbWl0ID0gbGluZVdpZHRoIC0gaW5kZW50TGVuZ3RoO1xuICAgIGNvbnN0IHN0ckxlbiA9IHN0ci5sZW5ndGg7XG4gICAgaWYgKHN0ckxlbiA8PSBsaW1pdClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwLCBzdGFydCA9IDA7IGkgPCBzdHJMZW47ICsraSkge1xuICAgICAgICBpZiAoc3RyW2ldID09PSAnXFxuJykge1xuICAgICAgICAgICAgaWYgKGkgLSBzdGFydCA+IGxpbWl0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgIGlmIChzdHJMZW4gLSBzdGFydCA8PSBsaW1pdClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBkb3VibGVRdW90ZWRTdHJpbmcodmFsdWUsIGN0eCkge1xuICAgIGNvbnN0IGpzb24gPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgaWYgKGN0eC5vcHRpb25zLmRvdWJsZVF1b3RlZEFzSlNPTilcbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgY29uc3QgeyBpbXBsaWNpdEtleSB9ID0gY3R4O1xuICAgIGNvbnN0IG1pbk11bHRpTGluZUxlbmd0aCA9IGN0eC5vcHRpb25zLmRvdWJsZVF1b3RlZE1pbk11bHRpTGluZUxlbmd0aDtcbiAgICBjb25zdCBpbmRlbnQgPSBjdHguaW5kZW50IHx8IChjb250YWluc0RvY3VtZW50TWFya2VyKHZhbHVlKSA/ICcgICcgOiAnJyk7XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIGxldCBzdGFydCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDAsIGNoID0ganNvbltpXTsgY2g7IGNoID0ganNvblsrK2ldKSB7XG4gICAgICAgIGlmIChjaCA9PT0gJyAnICYmIGpzb25baSArIDFdID09PSAnXFxcXCcgJiYganNvbltpICsgMl0gPT09ICduJykge1xuICAgICAgICAgICAgLy8gc3BhY2UgYmVmb3JlIG5ld2xpbmUgbmVlZHMgdG8gYmUgZXNjYXBlZCB0byBub3QgYmUgZm9sZGVkXG4gICAgICAgICAgICBzdHIgKz0ganNvbi5zbGljZShzdGFydCwgaSkgKyAnXFxcXCAnO1xuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgc3RhcnQgPSBpO1xuICAgICAgICAgICAgY2ggPSAnXFxcXCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoID09PSAnXFxcXCcpXG4gICAgICAgICAgICBzd2l0Y2ggKGpzb25baSArIDFdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAndSc6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBqc29uLnNsaWNlKHN0YXJ0LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBqc29uLnN1YnN0cihpICsgMiwgNCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcwMDAwJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcMCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzAwMDcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFxhJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnMDAwYic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXHYnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcwMDFiJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzAwODUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFxOJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnMDBhMCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXF8nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcyMDI4JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcTCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzIwMjknOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFxQJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUuc3Vic3RyKDAsIDIpID09PSAnMDAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxceCcgKyBjb2RlLnN1YnN0cigyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGpzb24uc3Vic3RyKGksIDYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICduJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGltcGxpY2l0S2V5IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uW2kgKyAyXSA9PT0gJ1wiJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAganNvbi5sZW5ndGggPCBtaW5NdWx0aUxpbmVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvbGRpbmcgd2lsbCBlYXQgZmlyc3QgbmV3bGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGpzb24uc2xpY2Uoc3RhcnQsIGkpICsgJ1xcblxcbic7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoanNvbltpICsgMl0gPT09ICdcXFxcJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb25baSArIDNdID09PSAnbicgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uW2kgKyA0XSAhPT0gJ1wiJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gaW5kZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3BhY2UgYWZ0ZXIgbmV3bGluZSBuZWVkcyB0byBiZSBlc2NhcGVkIHRvIG5vdCBiZSBmb2xkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqc29uW2kgKyAyXSA9PT0gJyAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgc3RyID0gc3RhcnQgPyBzdHIgKyBqc29uLnNsaWNlKHN0YXJ0KSA6IGpzb247XG4gICAgcmV0dXJuIGltcGxpY2l0S2V5XG4gICAgICAgID8gc3RyXG4gICAgICAgIDogZm9sZEZsb3dMaW5lcy5mb2xkRmxvd0xpbmVzKHN0ciwgaW5kZW50LCBmb2xkRmxvd0xpbmVzLkZPTERfUVVPVEVELCBnZXRGb2xkT3B0aW9ucyhjdHgpKTtcbn1cbmZ1bmN0aW9uIHNpbmdsZVF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KSB7XG4gICAgaWYgKGN0eC5vcHRpb25zLnNpbmdsZVF1b3RlID09PSBmYWxzZSB8fFxuICAgICAgICAoY3R4LmltcGxpY2l0S2V5ICYmIHZhbHVlLmluY2x1ZGVzKCdcXG4nKSkgfHxcbiAgICAgICAgL1sgXFx0XVxcbnxcXG5bIFxcdF0vLnRlc3QodmFsdWUpIC8vIHNpbmdsZSBxdW90ZWQgc3RyaW5nIGNhbid0IGhhdmUgbGVhZGluZyBvciB0cmFpbGluZyB3aGl0ZXNwYWNlIGFyb3VuZCBuZXdsaW5lXG4gICAgKVxuICAgICAgICByZXR1cm4gZG91YmxlUXVvdGVkU3RyaW5nKHZhbHVlLCBjdHgpO1xuICAgIGNvbnN0IGluZGVudCA9IGN0eC5pbmRlbnQgfHwgKGNvbnRhaW5zRG9jdW1lbnRNYXJrZXIodmFsdWUpID8gJyAgJyA6ICcnKTtcbiAgICBjb25zdCByZXMgPSBcIidcIiArIHZhbHVlLnJlcGxhY2UoLycvZywgXCInJ1wiKS5yZXBsYWNlKC9cXG4rL2csIGAkJlxcbiR7aW5kZW50fWApICsgXCInXCI7XG4gICAgcmV0dXJuIGN0eC5pbXBsaWNpdEtleVxuICAgICAgICA/IHJlc1xuICAgICAgICA6IGZvbGRGbG93TGluZXMuZm9sZEZsb3dMaW5lcyhyZXMsIGluZGVudCwgZm9sZEZsb3dMaW5lcy5GT0xEX0ZMT1csIGdldEZvbGRPcHRpb25zKGN0eCkpO1xufVxuZnVuY3Rpb24gcXVvdGVkU3RyaW5nKHZhbHVlLCBjdHgpIHtcbiAgICBjb25zdCB7IHNpbmdsZVF1b3RlIH0gPSBjdHgub3B0aW9ucztcbiAgICBsZXQgcXM7XG4gICAgaWYgKHNpbmdsZVF1b3RlID09PSBmYWxzZSlcbiAgICAgICAgcXMgPSBkb3VibGVRdW90ZWRTdHJpbmc7XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGhhc0RvdWJsZSA9IHZhbHVlLmluY2x1ZGVzKCdcIicpO1xuICAgICAgICBjb25zdCBoYXNTaW5nbGUgPSB2YWx1ZS5pbmNsdWRlcyhcIidcIik7XG4gICAgICAgIGlmIChoYXNEb3VibGUgJiYgIWhhc1NpbmdsZSlcbiAgICAgICAgICAgIHFzID0gc2luZ2xlUXVvdGVkU3RyaW5nO1xuICAgICAgICBlbHNlIGlmIChoYXNTaW5nbGUgJiYgIWhhc0RvdWJsZSlcbiAgICAgICAgICAgIHFzID0gZG91YmxlUXVvdGVkU3RyaW5nO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBxcyA9IHNpbmdsZVF1b3RlID8gc2luZ2xlUXVvdGVkU3RyaW5nIDogZG91YmxlUXVvdGVkU3RyaW5nO1xuICAgIH1cbiAgICByZXR1cm4gcXModmFsdWUsIGN0eCk7XG59XG5mdW5jdGlvbiBibG9ja1N0cmluZyh7IGNvbW1lbnQsIHR5cGUsIHZhbHVlIH0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgIGNvbnN0IHsgYmxvY2tRdW90ZSwgY29tbWVudFN0cmluZywgbGluZVdpZHRoIH0gPSBjdHgub3B0aW9ucztcbiAgICAvLyAxLiBCbG9jayBjYW4ndCBlbmQgaW4gd2hpdGVzcGFjZSB1bmxlc3MgdGhlIGxhc3QgbGluZSBpcyBub24tZW1wdHkuXG4gICAgLy8gMi4gU3RyaW5ncyBjb25zaXN0aW5nIG9mIG9ubHkgd2hpdGVzcGFjZSBhcmUgYmVzdCByZW5kZXJlZCBleHBsaWNpdGx5LlxuICAgIGlmICghYmxvY2tRdW90ZSB8fCAvXFxuW1xcdCBdKyQvLnRlc3QodmFsdWUpIHx8IC9eXFxzKiQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBxdW90ZWRTdHJpbmcodmFsdWUsIGN0eCk7XG4gICAgfVxuICAgIGNvbnN0IGluZGVudCA9IGN0eC5pbmRlbnQgfHxcbiAgICAgICAgKGN0eC5mb3JjZUJsb2NrSW5kZW50IHx8IGNvbnRhaW5zRG9jdW1lbnRNYXJrZXIodmFsdWUpID8gJyAgJyA6ICcnKTtcbiAgICBjb25zdCBsaXRlcmFsID0gYmxvY2tRdW90ZSA9PT0gJ2xpdGVyYWwnXG4gICAgICAgID8gdHJ1ZVxuICAgICAgICA6IGJsb2NrUXVvdGUgPT09ICdmb2xkZWQnIHx8IHR5cGUgPT09IFNjYWxhci5TY2FsYXIuQkxPQ0tfRk9MREVEXG4gICAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgICA6IHR5cGUgPT09IFNjYWxhci5TY2FsYXIuQkxPQ0tfTElURVJBTFxuICAgICAgICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgICAgICAgIDogIWxpbmVMZW5ndGhPdmVyTGltaXQodmFsdWUsIGxpbmVXaWR0aCwgaW5kZW50Lmxlbmd0aCk7XG4gICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgcmV0dXJuIGxpdGVyYWwgPyAnfFxcbicgOiAnPlxcbic7XG4gICAgLy8gZGV0ZXJtaW5lIGNob21waW5nIGZyb20gd2hpdGVzcGFjZSBhdCB2YWx1ZSBlbmRcbiAgICBsZXQgY2hvbXA7XG4gICAgbGV0IGVuZFN0YXJ0O1xuICAgIGZvciAoZW5kU3RhcnQgPSB2YWx1ZS5sZW5ndGg7IGVuZFN0YXJ0ID4gMDsgLS1lbmRTdGFydCkge1xuICAgICAgICBjb25zdCBjaCA9IHZhbHVlW2VuZFN0YXJ0IC0gMV07XG4gICAgICAgIGlmIChjaCAhPT0gJ1xcbicgJiYgY2ggIT09ICdcXHQnICYmIGNoICE9PSAnICcpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgbGV0IGVuZCA9IHZhbHVlLnN1YnN0cmluZyhlbmRTdGFydCk7XG4gICAgY29uc3QgZW5kTmxQb3MgPSBlbmQuaW5kZXhPZignXFxuJyk7XG4gICAgaWYgKGVuZE5sUG9zID09PSAtMSkge1xuICAgICAgICBjaG9tcCA9ICctJzsgLy8gc3RyaXBcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUgPT09IGVuZCB8fCBlbmRObFBvcyAhPT0gZW5kLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgY2hvbXAgPSAnKyc7IC8vIGtlZXBcbiAgICAgICAgaWYgKG9uQ2hvbXBLZWVwKVxuICAgICAgICAgICAgb25DaG9tcEtlZXAoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNob21wID0gJyc7IC8vIGNsaXBcbiAgICB9XG4gICAgaWYgKGVuZCkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIC1lbmQubGVuZ3RoKTtcbiAgICAgICAgaWYgKGVuZFtlbmQubGVuZ3RoIC0gMV0gPT09ICdcXG4nKVxuICAgICAgICAgICAgZW5kID0gZW5kLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgZW5kID0gZW5kLnJlcGxhY2UoL1xcbisoPyFcXG58JCkvZywgYCQmJHtpbmRlbnR9YCk7XG4gICAgfVxuICAgIC8vIGRldGVybWluZSBpbmRlbnQgaW5kaWNhdG9yIGZyb20gd2hpdGVzcGFjZSBhdCB2YWx1ZSBzdGFydFxuICAgIGxldCBzdGFydFdpdGhTcGFjZSA9IGZhbHNlO1xuICAgIGxldCBzdGFydEVuZDtcbiAgICBsZXQgc3RhcnRObFBvcyA9IC0xO1xuICAgIGZvciAoc3RhcnRFbmQgPSAwOyBzdGFydEVuZCA8IHZhbHVlLmxlbmd0aDsgKytzdGFydEVuZCkge1xuICAgICAgICBjb25zdCBjaCA9IHZhbHVlW3N0YXJ0RW5kXTtcbiAgICAgICAgaWYgKGNoID09PSAnICcpXG4gICAgICAgICAgICBzdGFydFdpdGhTcGFjZSA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSAnXFxuJylcbiAgICAgICAgICAgIHN0YXJ0TmxQb3MgPSBzdGFydEVuZDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxldCBzdGFydCA9IHZhbHVlLnN1YnN0cmluZygwLCBzdGFydE5sUG9zIDwgc3RhcnRFbmQgPyBzdGFydE5sUG9zICsgMSA6IHN0YXJ0RW5kKTtcbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoc3RhcnQubGVuZ3RoKTtcbiAgICAgICAgc3RhcnQgPSBzdGFydC5yZXBsYWNlKC9cXG4rL2csIGAkJiR7aW5kZW50fWApO1xuICAgIH1cbiAgICBjb25zdCBpbmRlbnRTaXplID0gaW5kZW50ID8gJzInIDogJzEnOyAvLyByb290IGlzIGF0IC0xXG4gICAgbGV0IGhlYWRlciA9IChsaXRlcmFsID8gJ3wnIDogJz4nKSArIChzdGFydFdpdGhTcGFjZSA/IGluZGVudFNpemUgOiAnJykgKyBjaG9tcDtcbiAgICBpZiAoY29tbWVudCkge1xuICAgICAgICBoZWFkZXIgKz0gJyAnICsgY29tbWVudFN0cmluZyhjb21tZW50LnJlcGxhY2UoLyA/W1xcclxcbl0rL2csICcgJykpO1xuICAgICAgICBpZiAob25Db21tZW50KVxuICAgICAgICAgICAgb25Db21tZW50KCk7XG4gICAgfVxuICAgIGlmIChsaXRlcmFsKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxuKy9nLCBgJCYke2luZGVudH1gKTtcbiAgICAgICAgcmV0dXJuIGAke2hlYWRlcn1cXG4ke2luZGVudH0ke3N0YXJ0fSR7dmFsdWV9JHtlbmR9YDtcbiAgICB9XG4gICAgdmFsdWUgPSB2YWx1ZVxuICAgICAgICAucmVwbGFjZSgvXFxuKy9nLCAnXFxuJCYnKVxuICAgICAgICAucmVwbGFjZSgvKD86XnxcXG4pKFtcXHQgXS4qKSg/OihbXFxuXFx0IF0qKVxcbig/IVtcXG5cXHQgXSkpPy9nLCAnJDEkMicpIC8vIG1vcmUtaW5kZW50ZWQgbGluZXMgYXJlbid0IGZvbGRlZFxuICAgICAgICAvLyAgICAgICAgICAgICAgICBeIG1vcmUtaW5kLiBeIGVtcHR5ICAgICBeIGNhcHR1cmUgbmV4dCBlbXB0eSBsaW5lcyBvbmx5IGF0IGVuZCBvZiBpbmRlbnRcbiAgICAgICAgLnJlcGxhY2UoL1xcbisvZywgYCQmJHtpbmRlbnR9YCk7XG4gICAgY29uc3QgYm9keSA9IGZvbGRGbG93TGluZXMuZm9sZEZsb3dMaW5lcyhgJHtzdGFydH0ke3ZhbHVlfSR7ZW5kfWAsIGluZGVudCwgZm9sZEZsb3dMaW5lcy5GT0xEX0JMT0NLLCBnZXRGb2xkT3B0aW9ucyhjdHgpKTtcbiAgICByZXR1cm4gYCR7aGVhZGVyfVxcbiR7aW5kZW50fSR7Ym9keX1gO1xufVxuZnVuY3Rpb24gcGxhaW5TdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgY29uc3QgeyB0eXBlLCB2YWx1ZSB9ID0gaXRlbTtcbiAgICBjb25zdCB7IGFjdHVhbFN0cmluZywgaW1wbGljaXRLZXksIGluZGVudCwgaW5kZW50U3RlcCwgaW5GbG93IH0gPSBjdHg7XG4gICAgaWYgKChpbXBsaWNpdEtleSAmJiAvW1xcbltcXF17fSxdLy50ZXN0KHZhbHVlKSkgfHxcbiAgICAgICAgKGluRmxvdyAmJiAvW1tcXF17fSxdLy50ZXN0KHZhbHVlKSkpIHtcbiAgICAgICAgcmV0dXJuIHF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KTtcbiAgICB9XG4gICAgaWYgKCF2YWx1ZSB8fFxuICAgICAgICAvXltcXG5cXHQgLFtcXF17fSMmKiF8PidcIiVAYF18Xls/LV0kfF5bPy1dWyBcXHRdfFtcXG46XVsgXFx0XXxbIFxcdF1cXG58W1xcblxcdCBdI3xbXFxuXFx0IDpdJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgLy8gbm90IGFsbG93ZWQ6XG4gICAgICAgIC8vIC0gZW1wdHkgc3RyaW5nLCAnLScgb3IgJz8nXG4gICAgICAgIC8vIC0gc3RhcnQgd2l0aCBhbiBpbmRpY2F0b3IgY2hhcmFjdGVyIChleGNlcHQgWz86LV0pIG9yIC9bPy1dIC9cbiAgICAgICAgLy8gLSAnXFxuICcsICc6ICcgb3IgJyBcXG4nIGFueXdoZXJlXG4gICAgICAgIC8vIC0gJyMnIG5vdCBwcmVjZWRlZCBieSBhIG5vbi1zcGFjZSBjaGFyXG4gICAgICAgIC8vIC0gZW5kIHdpdGggJyAnIG9yICc6J1xuICAgICAgICByZXR1cm4gaW1wbGljaXRLZXkgfHwgaW5GbG93IHx8ICF2YWx1ZS5pbmNsdWRlcygnXFxuJylcbiAgICAgICAgICAgID8gcXVvdGVkU3RyaW5nKHZhbHVlLCBjdHgpXG4gICAgICAgICAgICA6IGJsb2NrU3RyaW5nKGl0ZW0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCk7XG4gICAgfVxuICAgIGlmICghaW1wbGljaXRLZXkgJiZcbiAgICAgICAgIWluRmxvdyAmJlxuICAgICAgICB0eXBlICE9PSBTY2FsYXIuU2NhbGFyLlBMQUlOICYmXG4gICAgICAgIHZhbHVlLmluY2x1ZGVzKCdcXG4nKSkge1xuICAgICAgICAvLyBXaGVyZSBhbGxvd2VkICYgdHlwZSBub3Qgc2V0IGV4cGxpY2l0bHksIHByZWZlciBibG9jayBzdHlsZSBmb3IgbXVsdGlsaW5lIHN0cmluZ3NcbiAgICAgICAgcmV0dXJuIGJsb2NrU3RyaW5nKGl0ZW0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCk7XG4gICAgfVxuICAgIGlmIChjb250YWluc0RvY3VtZW50TWFya2VyKHZhbHVlKSkge1xuICAgICAgICBpZiAoaW5kZW50ID09PSAnJykge1xuICAgICAgICAgICAgY3R4LmZvcmNlQmxvY2tJbmRlbnQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGJsb2NrU3RyaW5nKGl0ZW0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW1wbGljaXRLZXkgJiYgaW5kZW50ID09PSBpbmRlbnRTdGVwKSB7XG4gICAgICAgICAgICByZXR1cm4gcXVvdGVkU3RyaW5nKHZhbHVlLCBjdHgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHN0ciA9IHZhbHVlLnJlcGxhY2UoL1xcbisvZywgYCQmXFxuJHtpbmRlbnR9YCk7XG4gICAgLy8gVmVyaWZ5IHRoYXQgb3V0cHV0IHdpbGwgYmUgcGFyc2VkIGFzIGEgc3RyaW5nLCBhcyBlLmcuIHBsYWluIG51bWJlcnMgYW5kXG4gICAgLy8gYm9vbGVhbnMgZ2V0IHBhcnNlZCB3aXRoIHRob3NlIHR5cGVzIGluIHYxLjIgKGUuZy4gJzQyJywgJ3RydWUnICYgJzAuOWUtMycpLFxuICAgIC8vIGFuZCBvdGhlcnMgaW4gdjEuMS5cbiAgICBpZiAoYWN0dWFsU3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IHRlc3QgPSAodGFnKSA9PiB0YWcuZGVmYXVsdCAmJiB0YWcudGFnICE9PSAndGFnOnlhbWwub3JnLDIwMDI6c3RyJyAmJiB0YWcudGVzdD8udGVzdChzdHIpO1xuICAgICAgICBjb25zdCB7IGNvbXBhdCwgdGFncyB9ID0gY3R4LmRvYy5zY2hlbWE7XG4gICAgICAgIGlmICh0YWdzLnNvbWUodGVzdCkgfHwgY29tcGF0Py5zb21lKHRlc3QpKVxuICAgICAgICAgICAgcmV0dXJuIHF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KTtcbiAgICB9XG4gICAgcmV0dXJuIGltcGxpY2l0S2V5XG4gICAgICAgID8gc3RyXG4gICAgICAgIDogZm9sZEZsb3dMaW5lcy5mb2xkRmxvd0xpbmVzKHN0ciwgaW5kZW50LCBmb2xkRmxvd0xpbmVzLkZPTERfRkxPVywgZ2V0Rm9sZE9wdGlvbnMoY3R4KSk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlTdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgY29uc3QgeyBpbXBsaWNpdEtleSwgaW5GbG93IH0gPSBjdHg7XG4gICAgY29uc3Qgc3MgPSB0eXBlb2YgaXRlbS52YWx1ZSA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBpdGVtXG4gICAgICAgIDogT2JqZWN0LmFzc2lnbih7fSwgaXRlbSwgeyB2YWx1ZTogU3RyaW5nKGl0ZW0udmFsdWUpIH0pO1xuICAgIGxldCB7IHR5cGUgfSA9IGl0ZW07XG4gICAgaWYgKHR5cGUgIT09IFNjYWxhci5TY2FsYXIuUVVPVEVfRE9VQkxFKSB7XG4gICAgICAgIC8vIGZvcmNlIGRvdWJsZSBxdW90ZXMgb24gY29udHJvbCBjaGFyYWN0ZXJzICYgdW5wYWlyZWQgc3Vycm9nYXRlc1xuICAgICAgICBpZiAoL1tcXHgwMC1cXHgwOFxceDBiLVxceDFmXFx4N2YtXFx4OWZcXHV7RDgwMH0tXFx1e0RGRkZ9XS91LnRlc3Qoc3MudmFsdWUpKVxuICAgICAgICAgICAgdHlwZSA9IFNjYWxhci5TY2FsYXIuUVVPVEVfRE9VQkxFO1xuICAgIH1cbiAgICBjb25zdCBfc3RyaW5naWZ5ID0gKF90eXBlKSA9PiB7XG4gICAgICAgIHN3aXRjaCAoX3R5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyLlNjYWxhci5CTE9DS19GT0xERUQ6XG4gICAgICAgICAgICBjYXNlIFNjYWxhci5TY2FsYXIuQkxPQ0tfTElURVJBTDpcbiAgICAgICAgICAgICAgICByZXR1cm4gaW1wbGljaXRLZXkgfHwgaW5GbG93XG4gICAgICAgICAgICAgICAgICAgID8gcXVvdGVkU3RyaW5nKHNzLnZhbHVlLCBjdHgpIC8vIGJsb2NrcyBhcmUgbm90IHZhbGlkIGluc2lkZSBmbG93IGNvbnRhaW5lcnNcbiAgICAgICAgICAgICAgICAgICAgOiBibG9ja1N0cmluZyhzcywgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyLlNjYWxhci5RVU9URV9ET1VCTEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvdWJsZVF1b3RlZFN0cmluZyhzcy52YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyLlNjYWxhci5RVU9URV9TSU5HTEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpbmdsZVF1b3RlZFN0cmluZyhzcy52YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyLlNjYWxhci5QTEFJTjpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGxhaW5TdHJpbmcoc3MsIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgcmVzID0gX3N0cmluZ2lmeSh0eXBlKTtcbiAgICBpZiAocmVzID09PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHsgZGVmYXVsdEtleVR5cGUsIGRlZmF1bHRTdHJpbmdUeXBlIH0gPSBjdHgub3B0aW9ucztcbiAgICAgICAgY29uc3QgdCA9IChpbXBsaWNpdEtleSAmJiBkZWZhdWx0S2V5VHlwZSkgfHwgZGVmYXVsdFN0cmluZ1R5cGU7XG4gICAgICAgIHJlcyA9IF9zdHJpbmdpZnkodCk7XG4gICAgICAgIGlmIChyZXMgPT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRlZmF1bHQgc3RyaW5nIHR5cGUgJHt0fWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5leHBvcnRzLnN0cmluZ2lmeVN0cmluZyA9IHN0cmluZ2lmeVN0cmluZztcbiJdLCJtYXBwaW5ncyI6IkFBQUEsWUFBWTs7QUFFWixJQUFJQSxNQUFNLEdBQUdDLE9BQU8sQ0FBQyxvQkFBb0IsQ0FBQztBQUMxQyxJQUFJ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