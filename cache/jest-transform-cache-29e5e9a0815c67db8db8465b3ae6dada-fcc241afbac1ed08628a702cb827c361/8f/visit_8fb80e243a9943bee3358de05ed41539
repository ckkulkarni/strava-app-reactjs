d4afcf97221c8ccc3a45aaf17792742d
'use strict';

var Node = require('./nodes/Node.js');
const BREAK = Symbol('break visit');
const SKIP = Symbol('skip children');
const REMOVE = Symbol('remove node');
/**
 * Apply a visitor to an AST node or document.
 *
 * Walks through the tree (depth-first) starting from `node`, calling a
 * `visitor` function with three arguments:
 *   - `key`: For sequence values and map `Pair`, the node's index in the
 *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
 *     `null` for the root node.
 *   - `node`: The current node.
 *   - `path`: The ancestry of the current node.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this node, continue with next
 *     sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current node, then continue with the next one
 *   - `Node`: Replace the current node, then continue by visiting it
 *   - `number`: While iterating the items of a sequence or map, set the index
 *     of the next step. This is useful especially if the index of the current
 *     node has changed.
 *
 * If `visitor` is a single function, it will be called with all values
 * encountered in the tree, including e.g. `null` values. Alternatively,
 * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
 * `Alias` and `Scalar` node. To define the same visitor function for more than
 * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
 * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
 * specific defined one will be used for each node.
 */
function visit(node, visitor) {
  const visitor_ = initVisitor(visitor);
  if (Node.isDocument(node)) {
    const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
    if (cd === REMOVE) node.contents = null;
  } else visit_(null, node, visitor_, Object.freeze([]));
}
// Without the `as symbol` casts, TS declares these in the `visit`
// namespace using `var`, but then complains about that because
// `unique symbol` must be `const`.
/** Terminate visit traversal completely */
visit.BREAK = BREAK;
/** Do not visit the children of the current node */
visit.SKIP = SKIP;
/** Remove the current node */
visit.REMOVE = REMOVE;
function visit_(key, node, visitor, path) {
  const ctrl = callVisitor(key, node, visitor, path);
  if (Node.isNode(ctrl) || Node.isPair(ctrl)) {
    replaceNode(key, path, ctrl);
    return visit_(key, ctrl, visitor, path);
  }
  if (typeof ctrl !== 'symbol') {
    if (Node.isCollection(node)) {
      path = Object.freeze(path.concat(node));
      for (let i = 0; i < node.items.length; ++i) {
        const ci = visit_(i, node.items[i], visitor, path);
        if (typeof ci === 'number') i = ci - 1;else if (ci === BREAK) return BREAK;else if (ci === REMOVE) {
          node.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (Node.isPair(node)) {
      path = Object.freeze(path.concat(node));
      const ck = visit_('key', node.key, visitor, path);
      if (ck === BREAK) return BREAK;else if (ck === REMOVE) node.key = null;
      const cv = visit_('value', node.value, visitor, path);
      if (cv === BREAK) return BREAK;else if (cv === REMOVE) node.value = null;
    }
  }
  return ctrl;
}
/**
 * Apply an async visitor to an AST node or document.
 *
 * Walks through the tree (depth-first) starting from `node`, calling a
 * `visitor` function with three arguments:
 *   - `key`: For sequence values and map `Pair`, the node's index in the
 *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
 *     `null` for the root node.
 *   - `node`: The current node.
 *   - `path`: The ancestry of the current node.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `Promise`: Must resolve to one of the following values
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this node, continue with next
 *     sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current node, then continue with the next one
 *   - `Node`: Replace the current node, then continue by visiting it
 *   - `number`: While iterating the items of a sequence or map, set the index
 *     of the next step. This is useful especially if the index of the current
 *     node has changed.
 *
 * If `visitor` is a single function, it will be called with all values
 * encountered in the tree, including e.g. `null` values. Alternatively,
 * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
 * `Alias` and `Scalar` node. To define the same visitor function for more than
 * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
 * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
 * specific defined one will be used for each node.
 */
async function visitAsync(node, visitor) {
  const visitor_ = initVisitor(visitor);
  if (Node.isDocument(node)) {
    const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
    if (cd === REMOVE) node.contents = null;
  } else await visitAsync_(null, node, visitor_, Object.freeze([]));
}
// Without the `as symbol` casts, TS declares these in the `visit`
// namespace using `var`, but then complains about that because
// `unique symbol` must be `const`.
/** Terminate visit traversal completely */
visitAsync.BREAK = BREAK;
/** Do not visit the children of the current node */
visitAsync.SKIP = SKIP;
/** Remove the current node */
visitAsync.REMOVE = REMOVE;
async function visitAsync_(key, node, visitor, path) {
  const ctrl = await callVisitor(key, node, visitor, path);
  if (Node.isNode(ctrl) || Node.isPair(ctrl)) {
    replaceNode(key, path, ctrl);
    return visitAsync_(key, ctrl, visitor, path);
  }
  if (typeof ctrl !== 'symbol') {
    if (Node.isCollection(node)) {
      path = Object.freeze(path.concat(node));
      for (let i = 0; i < node.items.length; ++i) {
        const ci = await visitAsync_(i, node.items[i], visitor, path);
        if (typeof ci === 'number') i = ci - 1;else if (ci === BREAK) return BREAK;else if (ci === REMOVE) {
          node.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (Node.isPair(node)) {
      path = Object.freeze(path.concat(node));
      const ck = await visitAsync_('key', node.key, visitor, path);
      if (ck === BREAK) return BREAK;else if (ck === REMOVE) node.key = null;
      const cv = await visitAsync_('value', node.value, visitor, path);
      if (cv === BREAK) return BREAK;else if (cv === REMOVE) node.value = null;
    }
  }
  return ctrl;
}
function initVisitor(visitor) {
  if (typeof visitor === 'object' && (visitor.Collection || visitor.Node || visitor.Value)) {
    return Object.assign({
      Alias: visitor.Node,
      Map: visitor.Node,
      Scalar: visitor.Node,
      Seq: visitor.Node
    }, visitor.Value && {
      Map: visitor.Value,
      Scalar: visitor.Value,
      Seq: visitor.Value
    }, visitor.Collection && {
      Map: visitor.Collection,
      Seq: visitor.Collection
    }, visitor);
  }
  return visitor;
}
function callVisitor(key, node, visitor, path) {
  if (typeof visitor === 'function') return visitor(key, node, path);
  if (Node.isMap(node)) return visitor.Map?.(key, node, path);
  if (Node.isSeq(node)) return visitor.Seq?.(key, node, path);
  if (Node.isPair(node)) return visitor.Pair?.(key, node, path);
  if (Node.isScalar(node)) return visitor.Scalar?.(key, node, path);
  if (Node.isAlias(node)) return visitor.Alias?.(key, node, path);
  return undefined;
}
function replaceNode(key, path, node) {
  const parent = path[path.length - 1];
  if (Node.isCollection(parent)) {
    parent.items[key] = node;
  } else if (Node.isPair(parent)) {
    if (key === 'key') parent.key = node;else parent.value = node;
  } else if (Node.isDocument(parent)) {
    parent.contents = node;
  } else {
    const pt = Node.isAlias(parent) ? 'alias' : 'scalar';
    throw new Error(`Cannot replace node with ${pt} parent`);
  }
}
exports.visit = visit;
exports.visitAsync = visitAsync;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJOb2RlIiwicmVxdWlyZSIsIkJSRUFLIiwiU3ltYm9sIiwiU0tJUCIsIlJFTU9WRSIsInZpc2l0Iiwibm9kZSIsInZpc2l0b3IiLCJ2aXNpdG9yXyIsImluaXRWaXNpdG9yIiwiaXNEb2N1bWVudCIsImNkIiwidmlzaXRfIiwiY29udGVudHMiLCJPYmplY3QiLCJmcmVlemUiLCJrZXkiLCJwYXRoIiwiY3RybCIsImNhbGxWaXNpdG9yIiwiaXNOb2RlIiwiaXNQYWlyIiwicmVwbGFjZU5vZGUiLCJpc0NvbGxlY3Rpb24iLCJjb25jYXQiLCJpIiwiaXRlbXMiLCJsZW5ndGgiLCJjaSIsInNwbGljZSIsImNrIiwiY3YiLCJ2YWx1ZSIsInZpc2l0QXN5bmMiLCJ2aXNpdEFzeW5jXyIsIkNvbGxlY3Rpb24iLCJWYWx1ZSIsImFzc2lnbiIsIkFsaWFzIiwiTWFwIiwiU2NhbGFyIiwiU2VxIiwiaXNNYXAiLCJpc1NlcSIsIlBhaXIiLCJpc1NjYWxhciIsImlzQWxpYXMiLCJ1bmRlZmluZWQiLCJwYXJlbnQiLCJwdCIsIkVycm9yIiwiZXhwb3J0cyJdLCJzb3VyY2VzIjpbInZpc2l0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIE5vZGUgPSByZXF1aXJlKCcuL25vZGVzL05vZGUuanMnKTtcblxuY29uc3QgQlJFQUsgPSBTeW1ib2woJ2JyZWFrIHZpc2l0Jyk7XG5jb25zdCBTS0lQID0gU3ltYm9sKCdza2lwIGNoaWxkcmVuJyk7XG5jb25zdCBSRU1PVkUgPSBTeW1ib2woJ3JlbW92ZSBub2RlJyk7XG4vKipcbiAqIEFwcGx5IGEgdmlzaXRvciB0byBhbiBBU1Qgbm9kZSBvciBkb2N1bWVudC5cbiAqXG4gKiBXYWxrcyB0aHJvdWdoIHRoZSB0cmVlIChkZXB0aC1maXJzdCkgc3RhcnRpbmcgZnJvbSBgbm9kZWAsIGNhbGxpbmcgYVxuICogYHZpc2l0b3JgIGZ1bmN0aW9uIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICogICAtIGBrZXlgOiBGb3Igc2VxdWVuY2UgdmFsdWVzIGFuZCBtYXAgYFBhaXJgLCB0aGUgbm9kZSdzIGluZGV4IGluIHRoZVxuICogICAgIGNvbGxlY3Rpb24uIFdpdGhpbiBhIGBQYWlyYCwgYCdrZXknYCBvciBgJ3ZhbHVlJ2AsIGNvcnJlc3BvbmRpbmdseS5cbiAqICAgICBgbnVsbGAgZm9yIHRoZSByb290IG5vZGUuXG4gKiAgIC0gYG5vZGVgOiBUaGUgY3VycmVudCBub2RlLlxuICogICAtIGBwYXRoYDogVGhlIGFuY2VzdHJ5IG9mIHRoZSBjdXJyZW50IG5vZGUuXG4gKlxuICogVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgdmlzaXRvciBtYXkgYmUgdXNlZCB0byBjb250cm9sIHRoZSB0cmF2ZXJzYWw6XG4gKiAgIC0gYHVuZGVmaW5lZGAgKGRlZmF1bHQpOiBEbyBub3RoaW5nIGFuZCBjb250aW51ZVxuICogICAtIGB2aXNpdC5TS0lQYDogRG8gbm90IHZpc2l0IHRoZSBjaGlsZHJlbiBvZiB0aGlzIG5vZGUsIGNvbnRpbnVlIHdpdGggbmV4dFxuICogICAgIHNpYmxpbmdcbiAqICAgLSBgdmlzaXQuQlJFQUtgOiBUZXJtaW5hdGUgdHJhdmVyc2FsIGNvbXBsZXRlbHlcbiAqICAgLSBgdmlzaXQuUkVNT1ZFYDogUmVtb3ZlIHRoZSBjdXJyZW50IG5vZGUsIHRoZW4gY29udGludWUgd2l0aCB0aGUgbmV4dCBvbmVcbiAqICAgLSBgTm9kZWA6IFJlcGxhY2UgdGhlIGN1cnJlbnQgbm9kZSwgdGhlbiBjb250aW51ZSBieSB2aXNpdGluZyBpdFxuICogICAtIGBudW1iZXJgOiBXaGlsZSBpdGVyYXRpbmcgdGhlIGl0ZW1zIG9mIGEgc2VxdWVuY2Ugb3IgbWFwLCBzZXQgdGhlIGluZGV4XG4gKiAgICAgb2YgdGhlIG5leHQgc3RlcC4gVGhpcyBpcyB1c2VmdWwgZXNwZWNpYWxseSBpZiB0aGUgaW5kZXggb2YgdGhlIGN1cnJlbnRcbiAqICAgICBub2RlIGhhcyBjaGFuZ2VkLlxuICpcbiAqIElmIGB2aXNpdG9yYCBpcyBhIHNpbmdsZSBmdW5jdGlvbiwgaXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBhbGwgdmFsdWVzXG4gKiBlbmNvdW50ZXJlZCBpbiB0aGUgdHJlZSwgaW5jbHVkaW5nIGUuZy4gYG51bGxgIHZhbHVlcy4gQWx0ZXJuYXRpdmVseSxcbiAqIHNlcGFyYXRlIHZpc2l0b3IgZnVuY3Rpb25zIG1heSBiZSBkZWZpbmVkIGZvciBlYWNoIGBNYXBgLCBgUGFpcmAsIGBTZXFgLFxuICogYEFsaWFzYCBhbmQgYFNjYWxhcmAgbm9kZS4gVG8gZGVmaW5lIHRoZSBzYW1lIHZpc2l0b3IgZnVuY3Rpb24gZm9yIG1vcmUgdGhhblxuICogb25lIG5vZGUgdHlwZSwgdXNlIHRoZSBgQ29sbGVjdGlvbmAgKG1hcCBhbmQgc2VxKSwgYFZhbHVlYCAobWFwLCBzZXEgJiBzY2FsYXIpXG4gKiBhbmQgYE5vZGVgIChhbGlhcywgbWFwLCBzZXEgJiBzY2FsYXIpIHRhcmdldHMuIE9mIGFsbCB0aGVzZSwgb25seSB0aGUgbW9zdFxuICogc3BlY2lmaWMgZGVmaW5lZCBvbmUgd2lsbCBiZSB1c2VkIGZvciBlYWNoIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIHZpc2l0KG5vZGUsIHZpc2l0b3IpIHtcbiAgICBjb25zdCB2aXNpdG9yXyA9IGluaXRWaXNpdG9yKHZpc2l0b3IpO1xuICAgIGlmIChOb2RlLmlzRG9jdW1lbnQobm9kZSkpIHtcbiAgICAgICAgY29uc3QgY2QgPSB2aXNpdF8obnVsbCwgbm9kZS5jb250ZW50cywgdmlzaXRvcl8sIE9iamVjdC5mcmVlemUoW25vZGVdKSk7XG4gICAgICAgIGlmIChjZCA9PT0gUkVNT1ZFKVxuICAgICAgICAgICAgbm9kZS5jb250ZW50cyA9IG51bGw7XG4gICAgfVxuICAgIGVsc2VcbiAgICAgICAgdmlzaXRfKG51bGwsIG5vZGUsIHZpc2l0b3JfLCBPYmplY3QuZnJlZXplKFtdKSk7XG59XG4vLyBXaXRob3V0IHRoZSBgYXMgc3ltYm9sYCBjYXN0cywgVFMgZGVjbGFyZXMgdGhlc2UgaW4gdGhlIGB2aXNpdGBcbi8vIG5hbWVzcGFjZSB1c2luZyBgdmFyYCwgYnV0IHRoZW4gY29tcGxhaW5zIGFib3V0IHRoYXQgYmVjYXVzZVxuLy8gYHVuaXF1ZSBzeW1ib2xgIG11c3QgYmUgYGNvbnN0YC5cbi8qKiBUZXJtaW5hdGUgdmlzaXQgdHJhdmVyc2FsIGNvbXBsZXRlbHkgKi9cbnZpc2l0LkJSRUFLID0gQlJFQUs7XG4vKiogRG8gbm90IHZpc2l0IHRoZSBjaGlsZHJlbiBvZiB0aGUgY3VycmVudCBub2RlICovXG52aXNpdC5TS0lQID0gU0tJUDtcbi8qKiBSZW1vdmUgdGhlIGN1cnJlbnQgbm9kZSAqL1xudmlzaXQuUkVNT1ZFID0gUkVNT1ZFO1xuZnVuY3Rpb24gdmlzaXRfKGtleSwgbm9kZSwgdmlzaXRvciwgcGF0aCkge1xuICAgIGNvbnN0IGN0cmwgPSBjYWxsVmlzaXRvcihrZXksIG5vZGUsIHZpc2l0b3IsIHBhdGgpO1xuICAgIGlmIChOb2RlLmlzTm9kZShjdHJsKSB8fCBOb2RlLmlzUGFpcihjdHJsKSkge1xuICAgICAgICByZXBsYWNlTm9kZShrZXksIHBhdGgsIGN0cmwpO1xuICAgICAgICByZXR1cm4gdmlzaXRfKGtleSwgY3RybCwgdmlzaXRvciwgcGF0aCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY3RybCAhPT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgaWYgKE5vZGUuaXNDb2xsZWN0aW9uKG5vZGUpKSB7XG4gICAgICAgICAgICBwYXRoID0gT2JqZWN0LmZyZWV6ZShwYXRoLmNvbmNhdChub2RlKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaSA9IHZpc2l0XyhpLCBub2RlLml0ZW1zW2ldLCB2aXNpdG9yLCBwYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNpID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICAgICAgaSA9IGNpIC0gMTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaSA9PT0gQlJFQUspXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCUkVBSztcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaSA9PT0gUkVNT1ZFKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuaXRlbXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBpIC09IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKE5vZGUuaXNQYWlyKG5vZGUpKSB7XG4gICAgICAgICAgICBwYXRoID0gT2JqZWN0LmZyZWV6ZShwYXRoLmNvbmNhdChub2RlKSk7XG4gICAgICAgICAgICBjb25zdCBjayA9IHZpc2l0Xygna2V5Jywgbm9kZS5rZXksIHZpc2l0b3IsIHBhdGgpO1xuICAgICAgICAgICAgaWYgKGNrID09PSBCUkVBSylcbiAgICAgICAgICAgICAgICByZXR1cm4gQlJFQUs7XG4gICAgICAgICAgICBlbHNlIGlmIChjayA9PT0gUkVNT1ZFKVxuICAgICAgICAgICAgICAgIG5vZGUua2V5ID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGN2ID0gdmlzaXRfKCd2YWx1ZScsIG5vZGUudmFsdWUsIHZpc2l0b3IsIHBhdGgpO1xuICAgICAgICAgICAgaWYgKGN2ID09PSBCUkVBSylcbiAgICAgICAgICAgICAgICByZXR1cm4gQlJFQUs7XG4gICAgICAgICAgICBlbHNlIGlmIChjdiA9PT0gUkVNT1ZFKVxuICAgICAgICAgICAgICAgIG5vZGUudmFsdWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjdHJsO1xufVxuLyoqXG4gKiBBcHBseSBhbiBhc3luYyB2aXNpdG9yIHRvIGFuIEFTVCBub2RlIG9yIGRvY3VtZW50LlxuICpcbiAqIFdhbGtzIHRocm91Z2ggdGhlIHRyZWUgKGRlcHRoLWZpcnN0KSBzdGFydGluZyBmcm9tIGBub2RlYCwgY2FsbGluZyBhXG4gKiBgdmlzaXRvcmAgZnVuY3Rpb24gd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gKiAgIC0gYGtleWA6IEZvciBzZXF1ZW5jZSB2YWx1ZXMgYW5kIG1hcCBgUGFpcmAsIHRoZSBub2RlJ3MgaW5kZXggaW4gdGhlXG4gKiAgICAgY29sbGVjdGlvbi4gV2l0aGluIGEgYFBhaXJgLCBgJ2tleSdgIG9yIGAndmFsdWUnYCwgY29ycmVzcG9uZGluZ2x5LlxuICogICAgIGBudWxsYCBmb3IgdGhlIHJvb3Qgbm9kZS5cbiAqICAgLSBgbm9kZWA6IFRoZSBjdXJyZW50IG5vZGUuXG4gKiAgIC0gYHBhdGhgOiBUaGUgYW5jZXN0cnkgb2YgdGhlIGN1cnJlbnQgbm9kZS5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZSB2aXNpdG9yIG1heSBiZSB1c2VkIHRvIGNvbnRyb2wgdGhlIHRyYXZlcnNhbDpcbiAqICAgLSBgUHJvbWlzZWA6IE11c3QgcmVzb2x2ZSB0byBvbmUgb2YgdGhlIGZvbGxvd2luZyB2YWx1ZXNcbiAqICAgLSBgdW5kZWZpbmVkYCAoZGVmYXVsdCk6IERvIG5vdGhpbmcgYW5kIGNvbnRpbnVlXG4gKiAgIC0gYHZpc2l0LlNLSVBgOiBEbyBub3QgdmlzaXQgdGhlIGNoaWxkcmVuIG9mIHRoaXMgbm9kZSwgY29udGludWUgd2l0aCBuZXh0XG4gKiAgICAgc2libGluZ1xuICogICAtIGB2aXNpdC5CUkVBS2A6IFRlcm1pbmF0ZSB0cmF2ZXJzYWwgY29tcGxldGVseVxuICogICAtIGB2aXNpdC5SRU1PVkVgOiBSZW1vdmUgdGhlIGN1cnJlbnQgbm9kZSwgdGhlbiBjb250aW51ZSB3aXRoIHRoZSBuZXh0IG9uZVxuICogICAtIGBOb2RlYDogUmVwbGFjZSB0aGUgY3VycmVudCBub2RlLCB0aGVuIGNvbnRpbnVlIGJ5IHZpc2l0aW5nIGl0XG4gKiAgIC0gYG51bWJlcmA6IFdoaWxlIGl0ZXJhdGluZyB0aGUgaXRlbXMgb2YgYSBzZXF1ZW5jZSBvciBtYXAsIHNldCB0aGUgaW5kZXhcbiAqICAgICBvZiB0aGUgbmV4dCBzdGVwLiBUaGlzIGlzIHVzZWZ1bCBlc3BlY2lhbGx5IGlmIHRoZSBpbmRleCBvZiB0aGUgY3VycmVudFxuICogICAgIG5vZGUgaGFzIGNoYW5nZWQuXG4gKlxuICogSWYgYHZpc2l0b3JgIGlzIGEgc2luZ2xlIGZ1bmN0aW9uLCBpdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGFsbCB2YWx1ZXNcbiAqIGVuY291bnRlcmVkIGluIHRoZSB0cmVlLCBpbmNsdWRpbmcgZS5nLiBgbnVsbGAgdmFsdWVzLiBBbHRlcm5hdGl2ZWx5LFxuICogc2VwYXJhdGUgdmlzaXRvciBmdW5jdGlvbnMgbWF5IGJlIGRlZmluZWQgZm9yIGVhY2ggYE1hcGAsIGBQYWlyYCwgYFNlcWAsXG4gKiBgQWxpYXNgIGFuZCBgU2NhbGFyYCBub2RlLiBUbyBkZWZpbmUgdGhlIHNhbWUgdmlzaXRvciBmdW5jdGlvbiBmb3IgbW9yZSB0aGFuXG4gKiBvbmUgbm9kZSB0eXBlLCB1c2UgdGhlIGBDb2xsZWN0aW9uYCAobWFwIGFuZCBzZXEpLCBgVmFsdWVgIChtYXAsIHNlcSAmIHNjYWxhcilcbiAqIGFuZCBgTm9kZWAgKGFsaWFzLCBtYXAsIHNlcSAmIHNjYWxhcikgdGFyZ2V0cy4gT2YgYWxsIHRoZXNlLCBvbmx5IHRoZSBtb3N0XG4gKiBzcGVjaWZpYyBkZWZpbmVkIG9uZSB3aWxsIGJlIHVzZWQgZm9yIGVhY2ggbm9kZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gdmlzaXRBc3luYyhub2RlLCB2aXNpdG9yKSB7XG4gICAgY29uc3QgdmlzaXRvcl8gPSBpbml0VmlzaXRvcih2aXNpdG9yKTtcbiAgICBpZiAoTm9kZS5pc0RvY3VtZW50KG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGNkID0gYXdhaXQgdmlzaXRBc3luY18obnVsbCwgbm9kZS5jb250ZW50cywgdmlzaXRvcl8sIE9iamVjdC5mcmVlemUoW25vZGVdKSk7XG4gICAgICAgIGlmIChjZCA9PT0gUkVNT1ZFKVxuICAgICAgICAgICAgbm9kZS5jb250ZW50cyA9IG51bGw7XG4gICAgfVxuICAgIGVsc2VcbiAgICAgICAgYXdhaXQgdmlzaXRBc3luY18obnVsbCwgbm9kZSwgdmlzaXRvcl8sIE9iamVjdC5mcmVlemUoW10pKTtcbn1cbi8vIFdpdGhvdXQgdGhlIGBhcyBzeW1ib2xgIGNhc3RzLCBUUyBkZWNsYXJlcyB0aGVzZSBpbiB0aGUgYHZpc2l0YFxuLy8gbmFtZXNwYWNlIHVzaW5nIGB2YXJgLCBidXQgdGhlbiBjb21wbGFpbnMgYWJvdXQgdGhhdCBiZWNhdXNlXG4vLyBgdW5pcXVlIHN5bWJvbGAgbXVzdCBiZSBgY29uc3RgLlxuLyoqIFRlcm1pbmF0ZSB2aXNpdCB0cmF2ZXJzYWwgY29tcGxldGVseSAqL1xudmlzaXRBc3luYy5CUkVBSyA9IEJSRUFLO1xuLyoqIERvIG5vdCB2aXNpdCB0aGUgY2hpbGRyZW4gb2YgdGhlIGN1cnJlbnQgbm9kZSAqL1xudmlzaXRBc3luYy5TS0lQID0gU0tJUDtcbi8qKiBSZW1vdmUgdGhlIGN1cnJlbnQgbm9kZSAqL1xudmlzaXRBc3luYy5SRU1PVkUgPSBSRU1PVkU7XG5hc3luYyBmdW5jdGlvbiB2aXNpdEFzeW5jXyhrZXksIG5vZGUsIHZpc2l0b3IsIHBhdGgpIHtcbiAgICBjb25zdCBjdHJsID0gYXdhaXQgY2FsbFZpc2l0b3Ioa2V5LCBub2RlLCB2aXNpdG9yLCBwYXRoKTtcbiAgICBpZiAoTm9kZS5pc05vZGUoY3RybCkgfHwgTm9kZS5pc1BhaXIoY3RybCkpIHtcbiAgICAgICAgcmVwbGFjZU5vZGUoa2V5LCBwYXRoLCBjdHJsKTtcbiAgICAgICAgcmV0dXJuIHZpc2l0QXN5bmNfKGtleSwgY3RybCwgdmlzaXRvciwgcGF0aCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY3RybCAhPT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgaWYgKE5vZGUuaXNDb2xsZWN0aW9uKG5vZGUpKSB7XG4gICAgICAgICAgICBwYXRoID0gT2JqZWN0LmZyZWV6ZShwYXRoLmNvbmNhdChub2RlKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaSA9IGF3YWl0IHZpc2l0QXN5bmNfKGksIG5vZGUuaXRlbXNbaV0sIHZpc2l0b3IsIHBhdGgpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2kgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgICAgICBpID0gY2kgLSAxO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNpID09PSBCUkVBSylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJSRUFLO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNpID09PSBSRU1PVkUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5pdGVtcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoTm9kZS5pc1BhaXIobm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGggPSBPYmplY3QuZnJlZXplKHBhdGguY29uY2F0KG5vZGUpKTtcbiAgICAgICAgICAgIGNvbnN0IGNrID0gYXdhaXQgdmlzaXRBc3luY18oJ2tleScsIG5vZGUua2V5LCB2aXNpdG9yLCBwYXRoKTtcbiAgICAgICAgICAgIGlmIChjayA9PT0gQlJFQUspXG4gICAgICAgICAgICAgICAgcmV0dXJuIEJSRUFLO1xuICAgICAgICAgICAgZWxzZSBpZiAoY2sgPT09IFJFTU9WRSlcbiAgICAgICAgICAgICAgICBub2RlLmtleSA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBjdiA9IGF3YWl0IHZpc2l0QXN5bmNfKCd2YWx1ZScsIG5vZGUudmFsdWUsIHZpc2l0b3IsIHBhdGgpO1xuICAgICAgICAgICAgaWYgKGN2ID09PSBCUkVBSylcbiAgICAgICAgICAgICAgICByZXR1cm4gQlJFQUs7XG4gICAgICAgICAgICBlbHNlIGlmIChjdiA9PT0gUkVNT1ZFKVxuICAgICAgICAgICAgICAgIG5vZGUudmFsdWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjdHJsO1xufVxuZnVuY3Rpb24gaW5pdFZpc2l0b3IodmlzaXRvcikge1xuICAgIGlmICh0eXBlb2YgdmlzaXRvciA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgKHZpc2l0b3IuQ29sbGVjdGlvbiB8fCB2aXNpdG9yLk5vZGUgfHwgdmlzaXRvci5WYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgQWxpYXM6IHZpc2l0b3IuTm9kZSxcbiAgICAgICAgICAgIE1hcDogdmlzaXRvci5Ob2RlLFxuICAgICAgICAgICAgU2NhbGFyOiB2aXNpdG9yLk5vZGUsXG4gICAgICAgICAgICBTZXE6IHZpc2l0b3IuTm9kZVxuICAgICAgICB9LCB2aXNpdG9yLlZhbHVlICYmIHtcbiAgICAgICAgICAgIE1hcDogdmlzaXRvci5WYWx1ZSxcbiAgICAgICAgICAgIFNjYWxhcjogdmlzaXRvci5WYWx1ZSxcbiAgICAgICAgICAgIFNlcTogdmlzaXRvci5WYWx1ZVxuICAgICAgICB9LCB2aXNpdG9yLkNvbGxlY3Rpb24gJiYge1xuICAgICAgICAgICAgTWFwOiB2aXNpdG9yLkNvbGxlY3Rpb24sXG4gICAgICAgICAgICBTZXE6IHZpc2l0b3IuQ29sbGVjdGlvblxuICAgICAgICB9LCB2aXNpdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHZpc2l0b3I7XG59XG5mdW5jdGlvbiBjYWxsVmlzaXRvcihrZXksIG5vZGUsIHZpc2l0b3IsIHBhdGgpIHtcbiAgICBpZiAodHlwZW9mIHZpc2l0b3IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiB2aXNpdG9yKGtleSwgbm9kZSwgcGF0aCk7XG4gICAgaWYgKE5vZGUuaXNNYXAobm9kZSkpXG4gICAgICAgIHJldHVybiB2aXNpdG9yLk1hcD8uKGtleSwgbm9kZSwgcGF0aCk7XG4gICAgaWYgKE5vZGUuaXNTZXEobm9kZSkpXG4gICAgICAgIHJldHVybiB2aXNpdG9yLlNlcT8uKGtleSwgbm9kZSwgcGF0aCk7XG4gICAgaWYgKE5vZGUuaXNQYWlyKG5vZGUpKVxuICAgICAgICByZXR1cm4gdmlzaXRvci5QYWlyPy4oa2V5LCBub2RlLCBwYXRoKTtcbiAgICBpZiAoTm9kZS5pc1NjYWxhcihub2RlKSlcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuU2NhbGFyPy4oa2V5LCBub2RlLCBwYXRoKTtcbiAgICBpZiAoTm9kZS5pc0FsaWFzKG5vZGUpKVxuICAgICAgICByZXR1cm4gdmlzaXRvci5BbGlhcz8uKGtleSwgbm9kZSwgcGF0aCk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VOb2RlKGtleSwgcGF0aCwgbm9kZSkge1xuICAgIGNvbnN0IHBhcmVudCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICBpZiAoTm9kZS5pc0NvbGxlY3Rpb24ocGFyZW50KSkge1xuICAgICAgICBwYXJlbnQuaXRlbXNba2V5XSA9IG5vZGU7XG4gICAgfVxuICAgIGVsc2UgaWYgKE5vZGUuaXNQYWlyKHBhcmVudCkpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gJ2tleScpXG4gICAgICAgICAgICBwYXJlbnQua2V5ID0gbm9kZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcGFyZW50LnZhbHVlID0gbm9kZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoTm9kZS5pc0RvY3VtZW50KHBhcmVudCkpIHtcbiAgICAgICAgcGFyZW50LmNvbnRlbnRzID0gbm9kZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHB0ID0gTm9kZS5pc0FsaWFzKHBhcmVudCkgPyAnYWxpYXMnIDogJ3NjYWxhcic7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlcGxhY2Ugbm9kZSB3aXRoICR7cHR9IHBhcmVudGApO1xuICAgIH1cbn1cblxuZXhwb3J0cy52aXNpdCA9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