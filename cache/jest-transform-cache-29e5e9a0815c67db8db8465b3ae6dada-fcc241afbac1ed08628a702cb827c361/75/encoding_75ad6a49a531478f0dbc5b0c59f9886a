14d165f69703db2fd785ed5ea1a45c90
"use strict";

// This is free and unencumbered software released into the public domain.
// See LICENSE.md for more information.

/**
 * @fileoverview Global |this| required for resolving indexes in node.
 * @suppress {globalThis}
 */
(function (global) {
  'use strict';

  // If we're in node require encoding-indexes and attach it to the global.
  if (typeof module !== "undefined" && module.exports && !global["encoding-indexes"]) {
    global["encoding-indexes"] = require("./encoding-indexes.js")["encoding-indexes"];
  }

  //
  // Utilities
  //

  /**
   * @param {number} a The number to test.
   * @param {number} min The minimum value in the range, inclusive.
   * @param {number} max The maximum value in the range, inclusive.
   * @return {boolean} True if a >= min and a <= max.
   */
  function inRange(a, min, max) {
    return min <= a && a <= max;
  }

  /**
   * @param {!Array.<*>} array The array to check.
   * @param {*} item The item to look for in the array.
   * @return {boolean} True if the item appears in the array.
   */
  function includes(array, item) {
    return array.indexOf(item) !== -1;
  }
  var floor = Math.floor;

  /**
   * @param {*} o
   * @return {Object}
   */
  function ToDictionary(o) {
    if (o === undefined) return {};
    if (o === Object(o)) return o;
    throw TypeError('Could not convert argument to dictionary');
  }

  /**
   * @param {string} string Input string of UTF-16 code units.
   * @return {!Array.<number>} Code points.
   */
  function stringToCodePoints(string) {
    // https://heycam.github.io/webidl/#dfn-obtain-unicode

    // 1. Let S be the DOMString value.
    var s = String(string);

    // 2. Let n be the length of S.
    var n = s.length;

    // 3. Initialize i to 0.
    var i = 0;

    // 4. Initialize U to be an empty sequence of Unicode characters.
    var u = [];

    // 5. While i < n:
    while (i < n) {
      // 1. Let c be the code unit in S at index i.
      var c = s.charCodeAt(i);

      // 2. Depending on the value of c:

      // c < 0xD800 or c > 0xDFFF
      if (c < 0xD800 || c > 0xDFFF) {
        // Append to U the Unicode character with code point c.
        u.push(c);
      }

      // 0xDC00 ≤ c ≤ 0xDFFF
      else if (0xDC00 <= c && c <= 0xDFFF) {
        // Append to U a U+FFFD REPLACEMENT CHARACTER.
        u.push(0xFFFD);
      }

      // 0xD800 ≤ c ≤ 0xDBFF
      else if (0xD800 <= c && c <= 0xDBFF) {
        // 1. If i = n−1, then append to U a U+FFFD REPLACEMENT
        // CHARACTER.
        if (i === n - 1) {
          u.push(0xFFFD);
        }
        // 2. Otherwise, i < n−1:
        else {
          // 1. Let d be the code unit in S at index i+1.
          var d = s.charCodeAt(i + 1);

          // 2. If 0xDC00 ≤ d ≤ 0xDFFF, then:
          if (0xDC00 <= d && d <= 0xDFFF) {
            // 1. Let a be c & 0x3FF.
            var a = c & 0x3FF;

            // 2. Let b be d & 0x3FF.
            var b = d & 0x3FF;

            // 3. Append to U the Unicode character with code point
            // 2^16+2^10*a+b.
            u.push(0x10000 + (a << 10) + b);

            // 4. Set i to i+1.
            i += 1;
          }

          // 3. Otherwise, d < 0xDC00 or d > 0xDFFF. Append to U a
          // U+FFFD REPLACEMENT CHARACTER.
          else {
            u.push(0xFFFD);
          }
        }
      }

      // 3. Set i to i+1.
      i += 1;
    }

    // 6. Return U.
    return u;
  }

  /**
   * @param {!Array.<number>} code_points Array of code points.
   * @return {string} string String of UTF-16 code units.
   */
  function codePointsToString(code_points) {
    var s = '';
    for (var i = 0; i < code_points.length; ++i) {
      var cp = code_points[i];
      if (cp <= 0xFFFF) {
        s += String.fromCharCode(cp);
      } else {
        cp -= 0x10000;
        s += String.fromCharCode((cp >> 10) + 0xD800, (cp & 0x3FF) + 0xDC00);
      }
    }
    return s;
  }

  //
  // Implementation of Encoding specification
  // https://encoding.spec.whatwg.org/
  //

  //
  // 4. Terminology
  //

  /**
   * An ASCII byte is a byte in the range 0x00 to 0x7F, inclusive.
   * @param {number} a The number to test.
   * @return {boolean} True if a is in the range 0x00 to 0x7F, inclusive.
   */
  function isASCIIByte(a) {
    return 0x00 <= a && a <= 0x7F;
  }

  /**
   * An ASCII code point is a code point in the range U+0000 to
   * U+007F, inclusive.
   */
  var isASCIICodePoint = isASCIIByte;

  /**
   * End-of-stream is a special token that signifies no more tokens
   * are in the stream.
   * @const
   */
  var end_of_stream = -1;

  /**
   * A stream represents an ordered sequence of tokens.
   *
   * @constructor
   * @param {!(Array.<number>|Uint8Array)} tokens Array of tokens that provide
   * the stream.
   */
  function Stream(tokens) {
    /** @type {!Array.<number>} */
    this.tokens = [].slice.call(tokens);
    // Reversed as push/pop is more efficient than shift/unshift.
    this.tokens.reverse();
  }
  Stream.prototype = {
    /**
     * @return {boolean} True if end-of-stream has been hit.
     */
    endOfStream: function () {
      return !this.tokens.length;
    },
    /**
     * When a token is read from a stream, the first token in the
     * stream must be returned and subsequently removed, and
     * end-of-stream must be returned otherwise.
     *
     * @return {number} Get the next token from the stream, or
     * end_of_stream.
     */
    read: function () {
      if (!this.tokens.length) return end_of_stream;
      return this.tokens.pop();
    },
    /**
     * When one or more tokens are prepended to a stream, those tokens
     * must be inserted, in given order, before the first token in the
     * stream.
     *
     * @param {(number|!Array.<number>)} token The token(s) to prepend to the
     * stream.
     */
    prepend: function (token) {
      if (Array.isArray(token)) {
        var tokens = /**@type {!Array.<number>}*/token;
        while (tokens.length) this.tokens.push(tokens.pop());
      } else {
        this.tokens.push(token);
      }
    },
    /**
     * When one or more tokens are pushed to a stream, those tokens
     * must be inserted, in given order, after the last token in the
     * stream.
     *
     * @param {(number|!Array.<number>)} token The tokens(s) to push to the
     * stream.
     */
    push: function (token) {
      if (Array.isArray(token)) {
        var tokens = /**@type {!Array.<number>}*/token;
        while (tokens.length) this.tokens.unshift(tokens.shift());
      } else {
        this.tokens.unshift(token);
      }
    }
  };

  //
  // 5. Encodings
  //

  // 5.1 Encoders and decoders

  /** @const */
  var finished = -1;

  /**
   * @param {boolean} fatal If true, decoding errors raise an exception.
   * @param {number=} opt_code_point Override the standard fallback code point.
   * @return {number} The code point to insert on a decoding error.
   */
  function decoderError(fatal, opt_code_point) {
    if (fatal) throw TypeError('Decoder error');
    return opt_code_point || 0xFFFD;
  }

  /**
   * @param {number} code_point The code point that could not be encoded.
   * @return {number} Always throws, no value is actually returned.
   */
  function encoderError(code_point) {
    throw TypeError('The code point ' + code_point + ' could not be encoded.');
  }

  /** @interface */
  function Decoder() {}
  Decoder.prototype = {
    /**
     * @param {Stream} stream The stream of bytes being decoded.
     * @param {number} bite The next byte read from the stream.
     * @return {?(number|!Array.<number>)} The next code point(s)
     *     decoded, or null if not enough data exists in the input
     *     stream to decode a complete code point, or |finished|.
     */
    handler: function (stream, bite) {}
  };

  /** @interface */
  function Encoder() {}
  Encoder.prototype = {
    /**
     * @param {Stream} stream The stream of code points being encoded.
     * @param {number} code_point Next code point read from the stream.
     * @return {(number|!Array.<number>)} Byte(s) to emit, or |finished|.
     */
    handler: function (stream, code_point) {}
  };

  // 5.2 Names and labels

  // TODO: Define @typedef for Encoding: {name:string,labels:Array.<string>}
  // https://github.com/google/closure-compiler/issues/247

  /**
   * @param {string} label The encoding label.
   * @return {?{name:string,labels:Array.<string>}}
   */
  function getEncoding(label) {
    // 1. Remove any leading and trailing ASCII whitespace from label.
    label = String(label).trim().toLowerCase();

    // 2. If label is an ASCII case-insensitive match for any of the
    // labels listed in the table below, return the corresponding
    // encoding, and failure otherwise.
    if (Object.prototype.hasOwnProperty.call(label_to_encoding, label)) {
      return label_to_encoding[label];
    }
    return null;
  }

  /**
   * Encodings table: https://encoding.spec.whatwg.org/encodings.json
   * @const
   * @type {!Array.<{
   *          heading: string,
   *          encodings: Array.<{name:string,labels:Array.<string>}>
   *        }>}
   */
  var encodings = [{
    "encodings": [{
      "labels": ["unicode-1-1-utf-8", "utf-8", "utf8"],
      "name": "UTF-8"
    }],
    "heading": "The Encoding"
  }, {
    "encodings": [{
      "labels": ["866", "cp866", "csibm866", "ibm866"],
      "name": "IBM866"
    }, {
      "labels": ["csisolatin2", "iso-8859-2", "iso-ir-101", "iso8859-2", "iso88592", "iso_8859-2", "iso_8859-2:1987", "l2", "latin2"],
      "name": "ISO-8859-2"
    }, {
      "labels": ["csisolatin3", "iso-8859-3", "iso-ir-109", "iso8859-3", "iso88593", "iso_8859-3", "iso_8859-3:1988", "l3", "latin3"],
      "name": "ISO-8859-3"
    }, {
      "labels": ["csisolatin4", "iso-8859-4", "iso-ir-110", "iso8859-4", "iso88594", "iso_8859-4", "iso_8859-4:1988", "l4", "latin4"],
      "name": "ISO-8859-4"
    }, {
      "labels": ["csisolatincyrillic", "cyrillic", "iso-8859-5", "iso-ir-144", "iso8859-5", "iso88595", "iso_8859-5", "iso_8859-5:1988"],
      "name": "ISO-8859-5"
    }, {
      "labels": ["arabic", "asmo-708", "csiso88596e", "csiso88596i", "csisolatinarabic", "ecma-114", "iso-8859-6", "iso-8859-6-e", "iso-8859-6-i", "iso-ir-127", "iso8859-6", "iso88596", "iso_8859-6", "iso_8859-6:1987"],
      "name": "ISO-8859-6"
    }, {
      "labels": ["csisolatingreek", "ecma-118", "elot_928", "greek", "greek8", "iso-8859-7", "iso-ir-126", "iso8859-7", "iso88597", "iso_8859-7", "iso_8859-7:1987", "sun_eu_greek"],
      "name": "ISO-8859-7"
    }, {
      "labels": ["csiso88598e", "csisolatinhebrew", "hebrew", "iso-8859-8", "iso-8859-8-e", "iso-ir-138", "iso8859-8", "iso88598", "iso_8859-8", "iso_8859-8:1988", "visual"],
      "name": "ISO-8859-8"
    }, {
      "labels": ["csiso88598i", "iso-8859-8-i", "logical"],
      "name": "ISO-8859-8-I"
    }, {
      "labels": ["csisolatin6", "iso-8859-10", "iso-ir-157", "iso8859-10", "iso885910", "l6", "latin6"],
      "name": "ISO-8859-10"
    }, {
      "labels": ["iso-8859-13", "iso8859-13", "iso885913"],
      "name": "ISO-8859-13"
    }, {
      "labels": ["iso-8859-14", "iso8859-14", "iso885914"],
      "name": "ISO-8859-14"
    }, {
      "labels": ["csisolatin9", "iso-8859-15", "iso8859-15", "iso885915", "iso_8859-15", "l9"],
      "name": "ISO-8859-15"
    }, {
      "labels": ["iso-8859-16"],
      "name": "ISO-8859-16"
    }, {
      "labels": ["cskoi8r", "koi", "koi8", "koi8-r", "koi8_r"],
      "name": "KOI8-R"
    }, {
      "labels": ["koi8-ru", "koi8-u"],
      "name": "KOI8-U"
    }, {
      "labels": ["csmacintosh", "mac", "macintosh", "x-mac-roman"],
      "name": "macintosh"
    }, {
      "labels": ["dos-874", "iso-8859-11", "iso8859-11", "iso885911", "tis-620", "windows-874"],
      "name": "windows-874"
    }, {
      "labels": ["cp1250", "windows-1250", "x-cp1250"],
      "name": "windows-1250"
    }, {
      "labels": ["cp1251", "windows-1251", "x-cp1251"],
      "name": "windows-1251"
    }, {
      "labels": ["ansi_x3.4-1968", "ascii", "cp1252", "cp819", "csisolatin1", "ibm819", "iso-8859-1", "iso-ir-100", "iso8859-1", "iso88591", "iso_8859-1", "iso_8859-1:1987", "l1", "latin1", "us-ascii", "windows-1252", "x-cp1252"],
      "name": "windows-1252"
    }, {
      "labels": ["cp1253", "windows-1253", "x-cp1253"],
      "name": "windows-1253"
    }, {
      "labels": ["cp1254", "csisolatin5", "iso-8859-9", "iso-ir-148", "iso8859-9", "iso88599", "iso_8859-9", "iso_8859-9:1989", "l5", "latin5", "windows-1254", "x-cp1254"],
      "name": "windows-1254"
    }, {
      "labels": ["cp1255", "windows-1255", "x-cp1255"],
      "name": "windows-1255"
    }, {
      "labels": ["cp1256", "windows-1256", "x-cp1256"],
      "name": "windows-1256"
    }, {
      "labels": ["cp1257", "windows-1257", "x-cp1257"],
      "name": "windows-1257"
    }, {
      "labels": ["cp1258", "windows-1258", "x-cp1258"],
      "name": "windows-1258"
    }, {
      "labels": ["x-mac-cyrillic", "x-mac-ukrainian"],
      "name": "x-mac-cyrillic"
    }],
    "heading": "Legacy single-byte encodings"
  }, {
    "encodings": [{
      "labels": ["chinese", "csgb2312", "csiso58gb231280", "gb2312", "gb_2312", "gb_2312-80", "gbk", "iso-ir-58", "x-gbk"],
      "name": "GBK"
    }, {
      "labels": ["gb18030"],
      "name": "gb18030"
    }],
    "heading": "Legacy multi-byte Chinese (simplified) encodings"
  }, {
    "encodings": [{
      "labels": ["big5", "big5-hkscs", "cn-big5", "csbig5", "x-x-big5"],
      "name": "Big5"
    }],
    "heading": "Legacy multi-byte Chinese (traditional) encodings"
  }, {
    "encodings": [{
      "labels": ["cseucpkdfmtjapanese", "euc-jp", "x-euc-jp"],
      "name": "EUC-JP"
    }, {
      "labels": ["csiso2022jp", "iso-2022-jp"],
      "name": "ISO-2022-JP"
    }, {
      "labels": ["csshiftjis", "ms932", "ms_kanji", "shift-jis", "shift_jis", "sjis", "windows-31j", "x-sjis"],
      "name": "Shift_JIS"
    }],
    "heading": "Legacy multi-byte Japanese encodings"
  }, {
    "encodings": [{
      "labels": ["cseuckr", "csksc56011987", "euc-kr", "iso-ir-149", "korean", "ks_c_5601-1987", "ks_c_5601-1989", "ksc5601", "ksc_5601", "windows-949"],
      "name": "EUC-KR"
    }],
    "heading": "Legacy multi-byte Korean encodings"
  }, {
    "encodings": [{
      "labels": ["csiso2022kr", "hz-gb-2312", "iso-2022-cn", "iso-2022-cn-ext", "iso-2022-kr"],
      "name": "replacement"
    }, {
      "labels": ["utf-16be"],
      "name": "UTF-16BE"
    }, {
      "labels": ["utf-16", "utf-16le"],
      "name": "UTF-16LE"
    }, {
      "labels": ["x-user-defined"],
      "name": "x-user-defined"
    }],
    "heading": "Legacy miscellaneous encodings"
  }];

  // Label to encoding registry.
  /** @type {Object.<string,{name:string,labels:Array.<string>}>} */
  var label_to_encoding = {};
  encodings.forEach(function (category) {
    category.encodings.forEach(function (encoding) {
      encoding.labels.forEach(function (label) {
        label_to_encoding[label] = encoding;
      });
    });
  });

  // Registry of of encoder/decoder factories, by encoding name.
  /** @type {Object.<string, function({fatal:boolean}): Encoder>} */
  var encoders = {};
  /** @type {Object.<string, function({fatal:boolean}): Decoder>} */
  var decoders = {};

  //
  // 6. Indexes
  //

  /**
   * @param {number} pointer The |pointer| to search for.
   * @param {(!Array.<?number>|undefined)} index The |index| to search within.
   * @return {?number} The code point corresponding to |pointer| in |index|,
   *     or null if |code point| is not in |index|.
   */
  function indexCodePointFor(pointer, index) {
    if (!index) return null;
    return index[pointer] || null;
  }

  /**
   * @param {number} code_point The |code point| to search for.
   * @param {!Array.<?number>} index The |index| to search within.
   * @return {?number} The first pointer corresponding to |code point| in
   *     |index|, or null if |code point| is not in |index|.
   */
  function indexPointerFor(code_point, index) {
    var pointer = index.indexOf(code_point);
    return pointer === -1 ? null : pointer;
  }

  /**
   * @param {string} name Name of the index.
   * @return {(!Array.<number>|!Array.<Array.<number>>)}
   *  */
  function index(name) {
    if (!('encoding-indexes' in global)) {
      throw Error("Indexes missing." + " Did you forget to include encoding-indexes.js first?");
    }
    return global['encoding-indexes'][name];
  }

  /**
   * @param {number} pointer The |pointer| to search for in the gb18030 index.
   * @return {?number} The code point corresponding to |pointer| in |index|,
   *     or null if |code point| is not in the gb18030 index.
   */
  function indexGB18030RangesCodePointFor(pointer) {
    // 1. If pointer is greater than 39419 and less than 189000, or
    // pointer is greater than 1237575, return null.
    if (pointer > 39419 && pointer < 189000 || pointer > 1237575) return null;

    // 2. If pointer is 7457, return code point U+E7C7.
    if (pointer === 7457) return 0xE7C7;

    // 3. Let offset be the last pointer in index gb18030 ranges that
    // is equal to or less than pointer and let code point offset be
    // its corresponding code point.
    var offset = 0;
    var code_point_offset = 0;
    var idx = index('gb18030-ranges');
    var i;
    for (i = 0; i < idx.length; ++i) {
      /** @type {!Array.<number>} */
      var entry = idx[i];
      if (entry[0] <= pointer) {
        offset = entry[0];
        code_point_offset = entry[1];
      } else {
        break;
      }
    }

    // 4. Return a code point whose value is code point offset +
    // pointer − offset.
    return code_point_offset + pointer - offset;
  }

  /**
   * @param {number} code_point The |code point| to locate in the gb18030 index.
   * @return {number} The first pointer corresponding to |code point| in the
   *     gb18030 index.
   */
  function indexGB18030RangesPointerFor(code_point) {
    // 1. If code point is U+E7C7, return pointer 7457.
    if (code_point === 0xE7C7) return 7457;

    // 2. Let offset be the last code point in index gb18030 ranges
    // that is equal to or less than code point and let pointer offset
    // be its corresponding pointer.
    var offset = 0;
    var pointer_offset = 0;
    var idx = index('gb18030-ranges');
    var i;
    for (i = 0; i < idx.length; ++i) {
      /** @type {!Array.<number>} */
      var entry = idx[i];
      if (entry[1] <= code_point) {
        offset = entry[1];
        pointer_offset = entry[0];
      } else {
        break;
      }
    }

    // 3. Return a pointer whose value is pointer offset + code point
    // − offset.
    return pointer_offset + code_point - offset;
  }

  /**
   * @param {number} code_point The |code_point| to search for in the Shift_JIS
   *     index.
   * @return {?number} The code point corresponding to |pointer| in |index|,
   *     or null if |code point| is not in the Shift_JIS index.
   */
  function indexShiftJISPointerFor(code_point) {
    // 1. Let index be index jis0208 excluding all entries whose
    // pointer is in the range 8272 to 8835, inclusive.
    shift_jis_index = shift_jis_index || index('jis0208').map(function (code_point, pointer) {
      return inRange(pointer, 8272, 8835) ? null : code_point;
    });
    var index_ = shift_jis_index;

    // 2. Return the index pointer for code point in index.
    return index_.indexOf(code_point);
  }
  var shift_jis_index;

  /**
   * @param {number} code_point The |code_point| to search for in the big5
   *     index.
   * @return {?number} The code point corresponding to |pointer| in |index|,
   *     or null if |code point| is not in the big5 index.
   */
  function indexBig5PointerFor(code_point) {
    // 1. Let index be index Big5 excluding all entries whose pointer
    big5_index_no_hkscs = big5_index_no_hkscs || index('big5').map(function (code_point, pointer) {
      return pointer < (0xA1 - 0x81) * 157 ? null : code_point;
    });
    var index_ = big5_index_no_hkscs;

    // 2. If code point is U+2550, U+255E, U+2561, U+256A, U+5341, or
    // U+5345, return the last pointer corresponding to code point in
    // index.
    if (code_point === 0x2550 || code_point === 0x255E || code_point === 0x2561 || code_point === 0x256A || code_point === 0x5341 || code_point === 0x5345) {
      return index_.lastIndexOf(code_point);
    }

    // 3. Return the index pointer for code point in index.
    return indexPointerFor(code_point, index_);
  }
  var big5_index_no_hkscs;

  //
  // 8. API
  //

  /** @const */
  var DEFAULT_ENCODING = 'utf-8';

  // 8.1 Interface TextDecoder

  /**
   * @constructor
   * @param {string=} label The label of the encoding;
   *     defaults to 'utf-8'.
   * @param {Object=} options
   */
  function TextDecoder(label, options) {
    // Web IDL conventions
    if (!(this instanceof TextDecoder)) throw TypeError('Called as a function. Did you forget \'new\'?');
    label = label !== undefined ? String(label) : DEFAULT_ENCODING;
    options = ToDictionary(options);

    // A TextDecoder object has an associated encoding, decoder,
    // stream, ignore BOM flag (initially unset), BOM seen flag
    // (initially unset), error mode (initially replacement), and do
    // not flush flag (initially unset).

    /** @private */
    this._encoding = null;
    /** @private @type {?Decoder} */
    this._decoder = null;
    /** @private @type {boolean} */
    this._ignoreBOM = false;
    /** @private @type {boolean} */
    this._BOMseen = false;
    /** @private @type {string} */
    this._error_mode = 'replacement';
    /** @private @type {boolean} */
    this._do_not_flush = false;

    // 1. Let encoding be the result of getting an encoding from
    // label.
    var encoding = getEncoding(label);

    // 2. If encoding is failure or replacement, throw a RangeError.
    if (encoding === null || encoding.name === 'replacement') throw RangeError('Unknown encoding: ' + label);
    if (!decoders[encoding.name]) {
      throw Error('Decoder not present.' + ' Did you forget to include encoding-indexes.js first?');
    }

    // 3. Let dec be a new TextDecoder object.
    var dec = this;

    // 4. Set dec's encoding to encoding.
    dec._encoding = encoding;

    // 5. If options's fatal member is true, set dec's error mode to
    // fatal.
    if (Boolean(options['fatal'])) dec._error_mode = 'fatal';

    // 6. If options's ignoreBOM member is true, set dec's ignore BOM
    // flag.
    if (Boolean(options['ignoreBOM'])) dec._ignoreBOM = true;

    // For pre-ES5 runtimes:
    if (!Object.defineProperty) {
      this.encoding = dec._encoding.name.toLowerCase();
      this.fatal = dec._error_mode === 'fatal';
      this.ignoreBOM = dec._ignoreBOM;
    }

    // 7. Return dec.
    return dec;
  }
  if (Object.defineProperty) {
    // The encoding attribute's getter must return encoding's name.
    Object.defineProperty(TextDecoder.prototype, 'encoding', {
      /** @this {TextDecoder} */
      get: function () {
        return this._encoding.name.toLowerCase();
      }
    });

    // The fatal attribute's getter must return true if error mode
    // is fatal, and false otherwise.
    Object.defineProperty(TextDecoder.prototype, 'fatal', {
      /** @this {TextDecoder} */
      get: function () {
        return this._error_mode === 'fatal';
      }
    });

    // The ignoreBOM attribute's getter must return true if ignore
    // BOM flag is set, and false otherwise.
    Object.defineProperty(TextDecoder.prototype, 'ignoreBOM', {
      /** @this {TextDecoder} */
      get: function () {
        return this._ignoreBOM;
      }
    });
  }

  /**
   * @param {BufferSource=} input The buffer of bytes to decode.
   * @param {Object=} options
   * @return {string} The decoded string.
   */
  TextDecoder.prototype.decode = function decode(input, options) {
    var bytes;
    if (typeof input === 'object' && input instanceof ArrayBuffer) {
      bytes = new Uint8Array(input);
    } else if (typeof input === 'object' && 'buffer' in input && input.buffer instanceof ArrayBuffer) {
      bytes = new Uint8Array(input.buffer, input.byteOffset, input.byteLength);
    } else {
      bytes = new Uint8Array(0);
    }
    options = ToDictionary(options);

    // 1. If the do not flush flag is unset, set decoder to a new
    // encoding's decoder, set stream to a new stream, and unset the
    // BOM seen flag.
    if (!this._do_not_flush) {
      this._decoder = decoders[this._encoding.name]({
        fatal: this._error_mode === 'fatal'
      });
      this._BOMseen = false;
    }

    // 2. If options's stream is true, set the do not flush flag, and
    // unset the do not flush flag otherwise.
    this._do_not_flush = Boolean(options['stream']);

    // 3. If input is given, push a copy of input to stream.
    // TODO: Align with spec algorithm - maintain stream on instance.
    var input_stream = new Stream(bytes);

    // 4. Let output be a new stream.
    var output = [];

    /** @type {?(number|!Array.<number>)} */
    var result;

    // 5. While true:
    while (true) {
      // 1. Let token be the result of reading from stream.
      var token = input_stream.read();

      // 2. If token is end-of-stream and the do not flush flag is
      // set, return output, serialized.
      // TODO: Align with spec algorithm.
      if (token === end_of_stream) break;

      // 3. Otherwise, run these subsubsteps:

      // 1. Let result be the result of processing token for decoder,
      // stream, output, and error mode.
      result = this._decoder.handler(input_stream, token);

      // 2. If result is finished, return output, serialized.
      if (result === finished) break;
      if (result !== null) {
        if (Array.isArray(result)) output.push.apply(output, /**@type {!Array.<number>}*/result);else output.push(result);
      }

      // 3. Otherwise, if result is error, throw a TypeError.
      // (Thrown in handler)

      // 4. Otherwise, do nothing.
    }
    // TODO: Align with spec algorithm.
    if (!this._do_not_flush) {
      do {
        result = this._decoder.handler(input_stream, input_stream.read());
        if (result === finished) break;
        if (result === null) continue;
        if (Array.isArray(result)) output.push.apply(output, /**@type {!Array.<number>}*/result);else output.push(result);
      } while (!input_stream.endOfStream());
      this._decoder = null;
    }

    // A TextDecoder object also has an associated serialize stream
    // algorithm...
    /**
     * @param {!Array.<number>} stream
     * @return {string}
     * @this {TextDecoder}
     */
    function serializeStream(stream) {
      // 1. Let token be the result of reading from stream.
      // (Done in-place on array, rather than as a stream)

      // 2. If encoding is UTF-8, UTF-16BE, or UTF-16LE, and ignore
      // BOM flag and BOM seen flag are unset, run these subsubsteps:
      if (includes(['UTF-8', 'UTF-16LE', 'UTF-16BE'], this._encoding.name) && !this._ignoreBOM && !this._BOMseen) {
        if (stream.length > 0 && stream[0] === 0xFEFF) {
          // 1. If token is U+FEFF, set BOM seen flag.
          this._BOMseen = true;
          stream.shift();
        } else if (stream.length > 0) {
          // 2. Otherwise, if token is not end-of-stream, set BOM seen
          // flag and append token to stream.
          this._BOMseen = true;
        } else {
          // 3. Otherwise, if token is not end-of-stream, append token
          // to output.
          // (no-op)
        }
      }
      // 4. Otherwise, return output.
      return codePointsToString(stream);
    }
    return serializeStream.call(this, output);
  };

  // 8.2 Interface TextEncoder

  /**
   * @constructor
   * @param {string=} label The label of the encoding. NONSTANDARD.
   * @param {Object=} options NONSTANDARD.
   */
  function TextEncoder(label, options) {
    // Web IDL conventions
    if (!(this instanceof TextEncoder)) throw TypeError('Called as a function. Did you forget \'new\'?');
    options = ToDictionary(options);

    // A TextEncoder object has an associated encoding and encoder.

    /** @private */
    this._encoding = null;
    /** @private @type {?Encoder} */
    this._encoder = null;

    // Non-standard
    /** @private @type {boolean} */
    this._do_not_flush = false;
    /** @private @type {string} */
    this._fatal = Boolean(options['fatal']) ? 'fatal' : 'replacement';

    // 1. Let enc be a new TextEncoder object.
    var enc = this;

    // 2. Set enc's encoding to UTF-8's encoder.
    if (Boolean(options['NONSTANDARD_allowLegacyEncoding'])) {
      // NONSTANDARD behavior.
      label = label !== undefined ? String(label) : DEFAULT_ENCODING;
      var encoding = getEncoding(label);
      if (encoding === null || encoding.name === 'replacement') throw RangeError('Unknown encoding: ' + label);
      if (!encoders[encoding.name]) {
        throw Error('Encoder not present.' + ' Did you forget to include encoding-indexes.js first?');
      }
      enc._encoding = encoding;
    } else {
      // Standard behavior.
      enc._encoding = getEncoding('utf-8');
      if (label !== undefined && 'console' in global) {
        console.warn('TextEncoder constructor called with encoding label, ' + 'which is ignored.');
      }
    }

    // For pre-ES5 runtimes:
    if (!Object.defineProperty) this.encoding = enc._encoding.name.toLowerCase();

    // 3. Return enc.
    return enc;
  }
  if (Object.defineProperty) {
    // The encoding attribute's getter must return encoding's name.
    Object.defineProperty(TextEncoder.prototype, 'encoding', {
      /** @this {TextEncoder} */
      get: function () {
        return this._encoding.name.toLowerCase();
      }
    });
  }

  /**
   * @param {string=} opt_string The string to encode.
   * @param {Object=} options
   * @return {!Uint8Array} Encoded bytes, as a Uint8Array.
   */
  TextEncoder.prototype.encode = function encode(opt_string, options) {
    opt_string = opt_string === undefined ? '' : String(opt_string);
    options = ToDictionary(options);

    // NOTE: This option is nonstandard. None of the encodings
    // permitted for encoding (i.e. UTF-8, UTF-16) are stateful when
    // the input is a USVString so streaming is not necessary.
    if (!this._do_not_flush) this._encoder = encoders[this._encoding.name]({
      fatal: this._fatal === 'fatal'
    });
    this._do_not_flush = Boolean(options['stream']);

    // 1. Convert input to a stream.
    var input = new Stream(stringToCodePoints(opt_string));

    // 2. Let output be a new stream
    var output = [];

    /** @type {?(number|!Array.<number>)} */
    var result;
    // 3. While true, run these substeps:
    while (true) {
      // 1. Let token be the result of reading from input.
      var token = input.read();
      if (token === end_of_stream) break;
      // 2. Let result be the result of processing token for encoder,
      // input, output.
      result = this._encoder.handler(input, token);
      if (result === finished) break;
      if (Array.isArray(result)) output.push.apply(output, /**@type {!Array.<number>}*/result);else output.push(result);
    }
    // TODO: Align with spec algorithm.
    if (!this._do_not_flush) {
      while (true) {
        result = this._encoder.handler(input, input.read());
        if (result === finished) break;
        if (Array.isArray(result)) output.push.apply(output, /**@type {!Array.<number>}*/result);else output.push(result);
      }
      this._encoder = null;
    }
    // 3. If result is finished, convert output into a byte sequence,
    // and then return a Uint8Array object wrapping an ArrayBuffer
    // containing output.
    return new Uint8Array(output);
  };

  //
  // 9. The encoding
  //

  // 9.1 utf-8

  // 9.1.1 utf-8 decoder
  /**
   * @constructor
   * @implements {Decoder}
   * @param {{fatal: boolean}} options
   */
  function UTF8Decoder(options) {
    var fatal = options.fatal;

    // utf-8's decoder's has an associated utf-8 code point, utf-8
    // bytes seen, and utf-8 bytes needed (all initially 0), a utf-8
    // lower boundary (initially 0x80), and a utf-8 upper boundary
    // (initially 0xBF).
    var /** @type {number} */utf8_code_point = 0,
      /** @type {number} */utf8_bytes_seen = 0,
      /** @type {number} */utf8_bytes_needed = 0,
      /** @type {number} */utf8_lower_boundary = 0x80,
      /** @type {number} */utf8_upper_boundary = 0xBF;

    /**
     * @param {Stream} stream The stream of bytes being decoded.
     * @param {number} bite The next byte read from the stream.
     * @return {?(number|!Array.<number>)} The next code point(s)
     *     decoded, or null if not enough data exists in the input
     *     stream to decode a complete code point.
     */
    this.handler = function (stream, bite) {
      // 1. If byte is end-of-stream and utf-8 bytes needed is not 0,
      // set utf-8 bytes needed to 0 and return error.
      if (bite === end_of_stream && utf8_bytes_needed !== 0) {
        utf8_bytes_needed = 0;
        return decoderError(fatal);
      }

      // 2. If byte is end-of-stream, return finished.
      if (bite === end_of_stream) return finished;

      // 3. If utf-8 bytes needed is 0, based on byte:
      if (utf8_bytes_needed === 0) {
        // 0x00 to 0x7F
        if (inRange(bite, 0x00, 0x7F)) {
          // Return a code point whose value is byte.
          return bite;
        }

        // 0xC2 to 0xDF
        else if (inRange(bite, 0xC2, 0xDF)) {
          // 1. Set utf-8 bytes needed to 1.
          utf8_bytes_needed = 1;

          // 2. Set UTF-8 code point to byte & 0x1F.
          utf8_code_point = bite & 0x1F;
        }

        // 0xE0 to 0xEF
        else if (inRange(bite, 0xE0, 0xEF)) {
          // 1. If byte is 0xE0, set utf-8 lower boundary to 0xA0.
          if (bite === 0xE0) utf8_lower_boundary = 0xA0;
          // 2. If byte is 0xED, set utf-8 upper boundary to 0x9F.
          if (bite === 0xED) utf8_upper_boundary = 0x9F;
          // 3. Set utf-8 bytes needed to 2.
          utf8_bytes_needed = 2;
          // 4. Set UTF-8 code point to byte & 0xF.
          utf8_code_point = bite & 0xF;
        }

        // 0xF0 to 0xF4
        else if (inRange(bite, 0xF0, 0xF4)) {
          // 1. If byte is 0xF0, set utf-8 lower boundary to 0x90.
          if (bite === 0xF0) utf8_lower_boundary = 0x90;
          // 2. If byte is 0xF4, set utf-8 upper boundary to 0x8F.
          if (bite === 0xF4) utf8_upper_boundary = 0x8F;
          // 3. Set utf-8 bytes needed to 3.
          utf8_bytes_needed = 3;
          // 4. Set UTF-8 code point to byte & 0x7.
          utf8_code_point = bite & 0x7;
        }

        // Otherwise
        else {
          // Return error.
          return decoderError(fatal);
        }

        // Return continue.
        return null;
      }

      // 4. If byte is not in the range utf-8 lower boundary to utf-8
      // upper boundary, inclusive, run these substeps:
      if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {
        // 1. Set utf-8 code point, utf-8 bytes needed, and utf-8
        // bytes seen to 0, set utf-8 lower boundary to 0x80, and set
        // utf-8 upper boundary to 0xBF.
        utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
        utf8_lower_boundary = 0x80;
        utf8_upper_boundary = 0xBF;

        // 2. Prepend byte to stream.
        stream.prepend(bite);

        // 3. Return error.
        return decoderError(fatal);
      }

      // 5. Set utf-8 lower boundary to 0x80 and utf-8 upper boundary
      // to 0xBF.
      utf8_lower_boundary = 0x80;
      utf8_upper_boundary = 0xBF;

      // 6. Set UTF-8 code point to (UTF-8 code point << 6) | (byte &
      // 0x3F)
      utf8_code_point = utf8_code_point << 6 | bite & 0x3F;

      // 7. Increase utf-8 bytes seen by one.
      utf8_bytes_seen += 1;

      // 8. If utf-8 bytes seen is not equal to utf-8 bytes needed,
      // continue.
      if (utf8_bytes_seen !== utf8_bytes_needed) return null;

      // 9. Let code point be utf-8 code point.
      var code_point = utf8_code_point;

      // 10. Set utf-8 code point, utf-8 bytes needed, and utf-8 bytes
      // seen to 0.
      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;

      // 11. Return a code point whose value is code point.
      return code_point;
    };
  }

  // 9.1.2 utf-8 encoder
  /**
   * @constructor
   * @implements {Encoder}
   * @param {{fatal: boolean}} options
   */
  function UTF8Encoder(options) {
    var fatal = options.fatal;
    /**
     * @param {Stream} stream Input stream.
     * @param {number} code_point Next code point read from the stream.
     * @return {(number|!Array.<number>)} Byte(s) to emit.
     */
    this.handler = function (stream, code_point) {
      // 1. If code point is end-of-stream, return finished.
      if (code_point === end_of_stream) return finished;

      // 2. If code point is an ASCII code point, return a byte whose
      // value is code point.
      if (isASCIICodePoint(code_point)) return code_point;

      // 3. Set count and offset based on the range code point is in:
      var count, offset;
      // U+0080 to U+07FF, inclusive:
      if (inRange(code_point, 0x0080, 0x07FF)) {
        // 1 and 0xC0
        count = 1;
        offset = 0xC0;
      }
      // U+0800 to U+FFFF, inclusive:
      else if (inRange(code_point, 0x0800, 0xFFFF)) {
        // 2 and 0xE0
        count = 2;
        offset = 0xE0;
      }
      // U+10000 to U+10FFFF, inclusive:
      else if (inRange(code_point, 0x10000, 0x10FFFF)) {
        // 3 and 0xF0
        count = 3;
        offset = 0xF0;
      }

      // 4. Let bytes be a byte sequence whose first byte is (code
      // point >> (6 × count)) + offset.
      var bytes = [(code_point >> 6 * count) + offset];

      // 5. Run these substeps while count is greater than 0:
      while (count > 0) {
        // 1. Set temp to code point >> (6 × (count − 1)).
        var temp = code_point >> 6 * (count - 1);

        // 2. Append to bytes 0x80 | (temp & 0x3F).
        bytes.push(0x80 | temp & 0x3F);

        // 3. Decrease count by one.
        count -= 1;
      }

      // 6. Return bytes bytes, in order.
      return bytes;
    };
  }

  /** @param {{fatal: boolean}} options */
  encoders['UTF-8'] = function (options) {
    return new UTF8Encoder(options);
  };
  /** @param {{fatal: boolean}} options */
  decoders['UTF-8'] = function (options) {
    return new UTF8Decoder(options);
  };

  //
  // 10. Legacy single-byte encodings
  //

  // 10.1 single-byte decoder
  /**
   * @constructor
   * @implements {Decoder}
   * @param {!Array.<number>} index The encoding index.
   * @param {{fatal: boolean}} options
   */
  function SingleByteDecoder(index, options) {
    var fatal = options.fatal;
    /**
     * @param {Stream} stream The stream of bytes being decoded.
     * @param {number} bite The next byte read from the stream.
     * @return {?(number|!Array.<number>)} The next code point(s)
     *     decoded, or null if not enough data exists in the input
     *     stream to decode a complete code point.
     */
    this.handler = function (stream, bite) {
      // 1. If byte is end-of-stream, return finished.
      if (bite === end_of_stream) return finished;

      // 2. If byte is an ASCII byte, return a code point whose value
      // is byte.
      if (isASCIIByte(bite)) return bite;

      // 3. Let code point be the index code point for byte − 0x80 in
      // index single-byte.
      var code_point = index[bite - 0x80];

      // 4. If code point is null, return error.
      if (code_point === null) return decoderError(fatal);

      // 5. Return a code point whose value is code point.
      return code_point;
    };
  }

  // 10.2 single-byte encoder
  /**
   * @constructor
   * @implements {Encoder}
   * @param {!Array.<?number>} index The encoding index.
   * @param {{fatal: boolean}} options
   */
  function SingleByteEncoder(index, options) {
    var fatal = options.fatal;
    /**
     * @param {Stream} stream Input stream.
     * @param {number} code_point Next code point read from the stream.
     * @return {(number|!Array.<number>)} Byte(s) to emit.
     */
    this.handler = function (stream, code_point) {
      // 1. If code point is end-of-stream, return finished.
      if (code_point === end_of_stream) return finished;

      // 2. If code point is an ASCII code point, return a byte whose
      // value is code point.
      if (isASCIICodePoint(code_point)) return code_point;

      // 3. Let pointer be the index pointer for code point in index
      // single-byte.
      var pointer = indexPointerFor(code_point, index);

      // 4. If pointer is null, return error with code point.
      if (pointer === null) encoderError(code_point);

      // 5. Return a byte whose value is pointer + 0x80.
      return pointer + 0x80;
    };
  }
  (function () {
    if (!('encoding-indexes' in global)) return;
    encodings.forEach(function (category) {
      if (category.heading !== 'Legacy single-byte encodings') return;
      category.encodings.forEach(function (encoding) {
        var name = encoding.name;
        var idx = index(name.toLowerCase());
        /** @param {{fatal: boolean}} options */
        decoders[name] = function (options) {
          return new SingleByteDecoder(idx, options);
        };
        /** @param {{fatal: boolean}} options */
        encoders[name] = function (options) {
          return new SingleByteEncoder(idx, options);
        };
      });
    });
  })();

  //
  // 11. Legacy multi-byte Chinese (simplified) encodings
  //

  // 11.1 gbk

  // 11.1.1 gbk decoder
  // gbk's decoder is gb18030's decoder.
  /** @param {{fatal: boolean}} options */
  decoders['GBK'] = function (options) {
    return new GB18030Decoder(options);
  };

  // 11.1.2 gbk encoder
  // gbk's encoder is gb18030's encoder with its gbk flag set.
  /** @param {{fatal: boolean}} options */
  encoders['GBK'] = function (options) {
    return new GB18030Encoder(options, true);
  };

  // 11.2 gb18030

  // 11.2.1 gb18030 decoder
  /**
   * @constructor
   * @implements {Decoder}
   * @param {{fatal: boolean}} options
   */
  function GB18030Decoder(options) {
    var fatal = options.fatal;
    // gb18030's decoder has an associated gb18030 first, gb18030
    // second, and gb18030 third (all initially 0x00).
    var /** @type {number} */gb18030_first = 0x00,
      /** @type {number} */gb18030_second = 0x00,
      /** @type {number} */gb18030_third = 0x00;
    /**
     * @param {Stream} stream The stream of bytes being decoded.
     * @param {number} bite The next byte read from the stream.
     * @return {?(number|!Array.<number>)} The next code point(s)
     *     decoded, or null if not enough data exists in the input
     *     stream to decode a complete code point.
     */
    this.handler = function (stream, bite) {
      // 1. If byte is end-of-stream and gb18030 first, gb18030
      // second, and gb18030 third are 0x00, return finished.
      if (bite === end_of_stream && gb18030_first === 0x00 && gb18030_second === 0x00 && gb18030_third === 0x00) {
        return finished;
      }
      // 2. If byte is end-of-stream, and gb18030 first, gb18030
      // second, or gb18030 third is not 0x00, set gb18030 first,
      // gb18030 second, and gb18030 third to 0x00, and return error.
      if (bite === end_of_stream && (gb18030_first !== 0x00 || gb18030_second !== 0x00 || gb18030_third !== 0x00)) {
        gb18030_first = 0x00;
        gb18030_second = 0x00;
        gb18030_third = 0x00;
        decoderError(fatal);
      }
      var code_point;
      // 3. If gb18030 third is not 0x00, run these substeps:
      if (gb18030_third !== 0x00) {
        // 1. Let code point be null.
        code_point = null;
        // 2. If byte is in the range 0x30 to 0x39, inclusive, set
        // code point to the index gb18030 ranges code point for
        // (((gb18030 first − 0x81) × 10 + gb18030 second − 0x30) ×
        // 126 + gb18030 third − 0x81) × 10 + byte − 0x30.
        if (inRange(bite, 0x30, 0x39)) {
          code_point = indexGB18030RangesCodePointFor((((gb18030_first - 0x81) * 10 + gb18030_second - 0x30) * 126 + gb18030_third - 0x81) * 10 + bite - 0x30);
        }

        // 3. Let buffer be a byte sequence consisting of gb18030
        // second, gb18030 third, and byte, in order.
        var buffer = [gb18030_second, gb18030_third, bite];

        // 4. Set gb18030 first, gb18030 second, and gb18030 third to
        // 0x00.
        gb18030_first = 0x00;
        gb18030_second = 0x00;
        gb18030_third = 0x00;

        // 5. If code point is null, prepend buffer to stream and
        // return error.
        if (code_point === null) {
          stream.prepend(buffer);
          return decoderError(fatal);
        }

        // 6. Return a code point whose value is code point.
        return code_point;
      }

      // 4. If gb18030 second is not 0x00, run these substeps:
      if (gb18030_second !== 0x00) {
        // 1. If byte is in the range 0x81 to 0xFE, inclusive, set
        // gb18030 third to byte and return continue.
        if (inRange(bite, 0x81, 0xFE)) {
          gb18030_third = bite;
          return null;
        }

        // 2. Prepend gb18030 second followed by byte to stream, set
        // gb18030 first and gb18030 second to 0x00, and return error.
        stream.prepend([gb18030_second, bite]);
        gb18030_first = 0x00;
        gb18030_second = 0x00;
        return decoderError(fatal);
      }

      // 5. If gb18030 first is not 0x00, run these substeps:
      if (gb18030_first !== 0x00) {
        // 1. If byte is in the range 0x30 to 0x39, inclusive, set
        // gb18030 second to byte and return continue.
        if (inRange(bite, 0x30, 0x39)) {
          gb18030_second = bite;
          return null;
        }

        // 2. Let lead be gb18030 first, let pointer be null, and set
        // gb18030 first to 0x00.
        var lead = gb18030_first;
        var pointer = null;
        gb18030_first = 0x00;

        // 3. Let offset be 0x40 if byte is less than 0x7F and 0x41
        // otherwise.
        var offset = bite < 0x7F ? 0x40 : 0x41;

        // 4. If byte is in the range 0x40 to 0x7E, inclusive, or 0x80
        // to 0xFE, inclusive, set pointer to (lead − 0x81) × 190 +
        // (byte − offset).
        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFE)) pointer = (lead - 0x81) * 190 + (bite - offset);

        // 5. Let code point be null if pointer is null and the index
        // code point for pointer in index gb18030 otherwise.
        code_point = pointer === null ? null : indexCodePointFor(pointer, index('gb18030'));

        // 6. If code point is null and byte is an ASCII byte, prepend
        // byte to stream.
        if (code_point === null && isASCIIByte(bite)) stream.prepend(bite);

        // 7. If code point is null, return error.
        if (code_point === null) return decoderError(fatal);

        // 8. Return a code point whose value is code point.
        return code_point;
      }

      // 6. If byte is an ASCII byte, return a code point whose value
      // is byte.
      if (isASCIIByte(bite)) return bite;

      // 7. If byte is 0x80, return code point U+20AC.
      if (bite === 0x80) return 0x20AC;

      // 8. If byte is in the range 0x81 to 0xFE, inclusive, set
      // gb18030 first to byte and return continue.
      if (inRange(bite, 0x81, 0xFE)) {
        gb18030_first = bite;
        return null;
      }

      // 9. Return error.
      return decoderError(fatal);
    };
  }

  // 11.2.2 gb18030 encoder
  /**
   * @constructor
   * @implements {Encoder}
   * @param {{fatal: boolean}} options
   * @param {boolean=} gbk_flag
   */
  function GB18030Encoder(options, gbk_flag) {
    var fatal = options.fatal;
    // gb18030's decoder has an associated gbk flag (initially unset).
    /**
     * @param {Stream} stream Input stream.
     * @param {number} code_point Next code point read from the stream.
     * @return {(number|!Array.<number>)} Byte(s) to emit.
     */
    this.handler = function (stream, code_point) {
      // 1. If code point is end-of-stream, return finished.
      if (code_point === end_of_stream) return finished;

      // 2. If code point is an ASCII code point, return a byte whose
      // value is code point.
      if (isASCIICodePoint(code_point)) return code_point;

      // 3. If code point is U+E5E5, return error with code point.
      if (code_point === 0xE5E5) return encoderError(code_point);

      // 4. If the gbk flag is set and code point is U+20AC, return
      // byte 0x80.
      if (gbk_flag && code_point === 0x20AC) return 0x80;

      // 5. Let pointer be the index pointer for code point in index
      // gb18030.
      var pointer = indexPointerFor(code_point, index('gb18030'));

      // 6. If pointer is not null, run these substeps:
      if (pointer !== null) {
        // 1. Let lead be floor(pointer / 190) + 0x81.
        var lead = floor(pointer / 190) + 0x81;

        // 2. Let trail be pointer % 190.
        var trail = pointer % 190;

        // 3. Let offset be 0x40 if trail is less than 0x3F and 0x41 otherwise.
        var offset = trail < 0x3F ? 0x40 : 0x41;

        // 4. Return two bytes whose values are lead and trail + offset.
        return [lead, trail + offset];
      }

      // 7. If gbk flag is set, return error with code point.
      if (gbk_flag) return encoderError(code_point);

      // 8. Set pointer to the index gb18030 ranges pointer for code
      // point.
      pointer = indexGB18030RangesPointerFor(code_point);

      // 9. Let byte1 be floor(pointer / 10 / 126 / 10).
      var byte1 = floor(pointer / 10 / 126 / 10);

      // 10. Set pointer to pointer − byte1 × 10 × 126 × 10.
      pointer = pointer - byte1 * 10 * 126 * 10;

      // 11. Let byte2 be floor(pointer / 10 / 126).
      var byte2 = floor(pointer / 10 / 126);

      // 12. Set pointer to pointer − byte2 × 10 × 126.
      pointer = pointer - byte2 * 10 * 126;

      // 13. Let byte3 be floor(pointer / 10).
      var byte3 = floor(pointer / 10);

      // 14. Let byte4 be pointer − byte3 × 10.
      var byte4 = pointer - byte3 * 10;

      // 15. Return four bytes whose values are byte1 + 0x81, byte2 +
      // 0x30, byte3 + 0x81, byte4 + 0x30.
      return [byte1 + 0x81, byte2 + 0x30, byte3 + 0x81, byte4 + 0x30];
    };
  }

  /** @param {{fatal: boolean}} options */
  encoders['gb18030'] = function (options) {
    return new GB18030Encoder(options);
  };
  /** @param {{fatal: boolean}} options */
  decoders['gb18030'] = function (options) {
    return new GB18030Decoder(options);
  };

  //
  // 12. Legacy multi-byte Chinese (traditional) encodings
  //

  // 12.1 Big5

  // 12.1.1 Big5 decoder
  /**
   * @constructor
   * @implements {Decoder}
   * @param {{fatal: boolean}} options
   */
  function Big5Decoder(options) {
    var fatal = options.fatal;
    // Big5's decoder has an associated Big5 lead (initially 0x00).
    var /** @type {number} */Big5_lead = 0x00;

    /**
     * @param {Stream} stream The stream of bytes being decoded.
     * @param {number} bite The next byte read from the stream.
     * @return {?(number|!Array.<number>)} The next code point(s)
     *     decoded, or null if not enough data exists in the input
     *     stream to decode a complete code point.
     */
    this.handler = function (stream, bite) {
      // 1. If byte is end-of-stream and Big5 lead is not 0x00, set
      // Big5 lead to 0x00 and return error.
      if (bite === end_of_stream && Big5_lead !== 0x00) {
        Big5_lead = 0x00;
        return decoderError(fatal);
      }

      // 2. If byte is end-of-stream and Big5 lead is 0x00, return
      // finished.
      if (bite === end_of_stream && Big5_lead === 0x00) return finished;

      // 3. If Big5 lead is not 0x00, let lead be Big5 lead, let
      // pointer be null, set Big5 lead to 0x00, and then run these
      // substeps:
      if (Big5_lead !== 0x00) {
        var lead = Big5_lead;
        var pointer = null;
        Big5_lead = 0x00;

        // 1. Let offset be 0x40 if byte is less than 0x7F and 0x62
        // otherwise.
        var offset = bite < 0x7F ? 0x40 : 0x62;

        // 2. If byte is in the range 0x40 to 0x7E, inclusive, or 0xA1
        // to 0xFE, inclusive, set pointer to (lead − 0x81) × 157 +
        // (byte − offset).
        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0xA1, 0xFE)) pointer = (lead - 0x81) * 157 + (bite - offset);

        // 3. If there is a row in the table below whose first column
        // is pointer, return the two code points listed in its second
        // column
        // Pointer | Code points
        // --------+--------------
        // 1133    | U+00CA U+0304
        // 1135    | U+00CA U+030C
        // 1164    | U+00EA U+0304
        // 1166    | U+00EA U+030C
        switch (pointer) {
          case 1133:
            return [0x00CA, 0x0304];
          case 1135:
            return [0x00CA, 0x030C];
          case 1164:
            return [0x00EA, 0x0304];
          case 1166:
            return [0x00EA, 0x030C];
        }

        // 4. Let code point be null if pointer is null and the index
        // code point for pointer in index Big5 otherwise.
        var code_point = pointer === null ? null : indexCodePointFor(pointer, index('big5'));

        // 5. If code point is null and byte is an ASCII byte, prepend
        // byte to stream.
        if (code_point === null && isASCIIByte(bite)) stream.prepend(bite);

        // 6. If code point is null, return error.
        if (code_point === null) return decoderError(fatal);

        // 7. Return a code point whose value is code point.
        return code_point;
      }

      // 4. If byte is an ASCII byte, return a code point whose value
      // is byte.
      if (isASCIIByte(bite)) return bite;

      // 5. If byte is in the range 0x81 to 0xFE, inclusive, set Big5
      // lead to byte and return continue.
      if (inRange(bite, 0x81, 0xFE)) {
        Big5_lead = bite;
        return null;
      }

      // 6. Return error.
      return decoderError(fatal);
    };
  }

  // 12.1.2 Big5 encoder
  /**
   * @constructor
   * @implements {Encoder}
   * @param {{fatal: boolean}} options
   */
  function Big5Encoder(options) {
    var fatal = options.fatal;
    /**
     * @param {Stream} stream Input stream.
     * @param {number} code_point Next code point read from the stream.
     * @return {(number|!Array.<number>)} Byte(s) to emit.
     */
    this.handler = function (stream, code_point) {
      // 1. If code point is end-of-stream, return finished.
      if (code_point === end_of_stream) return finished;

      // 2. If code point is an ASCII code point, return a byte whose
      // value is code point.
      if (isASCIICodePoint(code_point)) return code_point;

      // 3. Let pointer be the index Big5 pointer for code point.
      var pointer = indexBig5PointerFor(code_point);

      // 4. If pointer is null, return error with code point.
      if (pointer === null) return encoderError(code_point);

      // 5. Let lead be floor(pointer / 157) + 0x81.
      var lead = floor(pointer / 157) + 0x81;

      // 6. If lead is less than 0xA1, return error with code point.
      if (lead < 0xA1) return encoderError(code_point);

      // 7. Let trail be pointer % 157.
      var trail = pointer % 157;

      // 8. Let offset be 0x40 if trail is less than 0x3F and 0x62
      // otherwise.
      var offset = trail < 0x3F ? 0x40 : 0x62;

      // Return two bytes whose values are lead and trail + offset.
      return [lead, trail + offset];
    };
  }

  /** @param {{fatal: boolean}} options */
  encoders['Big5'] = function (options) {
    return new Big5Encoder(options);
  };
  /** @param {{fatal: boolean}} options */
  decoders['Big5'] = function (options) {
    return new Big5Decoder(options);
  };

  //
  // 13. Legacy multi-byte Japanese encodings
  //

  // 13.1 euc-jp

  // 13.1.1 euc-jp decoder
  /**
   * @constructor
   * @implements {Decoder}
   * @param {{fatal: boolean}} options
   */
  function EUCJPDecoder(options) {
    var fatal = options.fatal;

    // euc-jp's decoder has an associated euc-jp jis0212 flag
    // (initially unset) and euc-jp lead (initially 0x00).
    var /** @type {boolean} */eucjp_jis0212_flag = false,
      /** @type {number} */eucjp_lead = 0x00;

    /**
     * @param {Stream} stream The stream of bytes being decoded.
     * @param {number} bite The next byte read from the stream.
     * @return {?(number|!Array.<number>)} The next code point(s)
     *     decoded, or null if not enough data exists in the input
     *     stream to decode a complete code point.
     */
    this.handler = function (stream, bite) {
      // 1. If byte is end-of-stream and euc-jp lead is not 0x00, set
      // euc-jp lead to 0x00, and return error.
      if (bite === end_of_stream && eucjp_lead !== 0x00) {
        eucjp_lead = 0x00;
        return decoderError(fatal);
      }

      // 2. If byte is end-of-stream and euc-jp lead is 0x00, return
      // finished.
      if (bite === end_of_stream && eucjp_lead === 0x00) return finished;

      // 3. If euc-jp lead is 0x8E and byte is in the range 0xA1 to
      // 0xDF, inclusive, set euc-jp lead to 0x00 and return a code
      // point whose value is 0xFF61 − 0xA1 + byte.
      if (eucjp_lead === 0x8E && inRange(bite, 0xA1, 0xDF)) {
        eucjp_lead = 0x00;
        return 0xFF61 - 0xA1 + bite;
      }

      // 4. If euc-jp lead is 0x8F and byte is in the range 0xA1 to
      // 0xFE, inclusive, set the euc-jp jis0212 flag, set euc-jp lead
      // to byte, and return continue.
      if (eucjp_lead === 0x8F && inRange(bite, 0xA1, 0xFE)) {
        eucjp_jis0212_flag = true;
        eucjp_lead = bite;
        return null;
      }

      // 5. If euc-jp lead is not 0x00, let lead be euc-jp lead, set
      // euc-jp lead to 0x00, and run these substeps:
      if (eucjp_lead !== 0x00) {
        var lead = eucjp_lead;
        eucjp_lead = 0x00;

        // 1. Let code point be null.
        var code_point = null;

        // 2. If lead and byte are both in the range 0xA1 to 0xFE,
        // inclusive, set code point to the index code point for (lead
        // − 0xA1) × 94 + byte − 0xA1 in index jis0208 if the euc-jp
        // jis0212 flag is unset and in index jis0212 otherwise.
        if (inRange(lead, 0xA1, 0xFE) && inRange(bite, 0xA1, 0xFE)) {
          code_point = indexCodePointFor((lead - 0xA1) * 94 + (bite - 0xA1), index(!eucjp_jis0212_flag ? 'jis0208' : 'jis0212'));
        }

        // 3. Unset the euc-jp jis0212 flag.
        eucjp_jis0212_flag = false;

        // 4. If byte is not in the range 0xA1 to 0xFE, inclusive,
        // prepend byte to stream.
        if (!inRange(bite, 0xA1, 0xFE)) stream.prepend(bite);

        // 5. If code point is null, return error.
        if (code_point === null) return decoderError(fatal);

        // 6. Return a code point whose value is code point.
        return code_point;
      }

      // 6. If byte is an ASCII byte, return a code point whose value
      // is byte.
      if (isASCIIByte(bite)) return bite;

      // 7. If byte is 0x8E, 0x8F, or in the range 0xA1 to 0xFE,
      // inclusive, set euc-jp lead to byte and return continue.
      if (bite === 0x8E || bite === 0x8F || inRange(bite, 0xA1, 0xFE)) {
        eucjp_lead = bite;
        return null;
      }

      // 8. Return error.
      return decoderError(fatal);
    };
  }

  // 13.1.2 euc-jp encoder
  /**
   * @constructor
   * @implements {Encoder}
   * @param {{fatal: boolean}} options
   */
  function EUCJPEncoder(options) {
    var fatal = options.fatal;
    /**
     * @param {Stream} stream Input stream.
     * @param {number} code_point Next code point read from the stream.
     * @return {(number|!Array.<number>)} Byte(s) to emit.
     */
    this.handler = function (stream, code_point) {
      // 1. If code point is end-of-stream, return finished.
      if (code_point === end_of_stream) return finished;

      // 2. If code point is an ASCII code point, return a byte whose
      // value is code point.
      if (isASCIICodePoint(code_point)) return code_point;

      // 3. If code point is U+00A5, return byte 0x5C.
      if (code_point === 0x00A5) return 0x5C;

      // 4. If code point is U+203E, return byte 0x7E.
      if (code_point === 0x203E) return 0x7E;

      // 5. If code point is in the range U+FF61 to U+FF9F, inclusive,
      // return two bytes whose values are 0x8E and code point −
      // 0xFF61 + 0xA1.
      if (inRange(code_point, 0xFF61, 0xFF9F)) return [0x8E, code_point - 0xFF61 + 0xA1];

      // 6. If code point is U+2212, set it to U+FF0D.
      if (code_point === 0x2212) code_point = 0xFF0D;

      // 7. Let pointer be the index pointer for code point in index
      // jis0208.
      var pointer = indexPointerFor(code_point, index('jis0208'));

      // 8. If pointer is null, return error with code point.
      if (pointer === null) return encoderError(code_point);

      // 9. Let lead be floor(pointer / 94) + 0xA1.
      var lead = floor(pointer / 94) + 0xA1;

      // 10. Let trail be pointer % 94 + 0xA1.
      var trail = pointer % 94 + 0xA1;

      // 11. Return two bytes whose values are lead and trail.
      return [lead, trail];
    };
  }

  /** @param {{fatal: boolean}} options */
  encoders['EUC-JP'] = function (options) {
    return new EUCJPEncoder(options);
  };
  /** @param {{fatal: boolean}} options */
  decoders['EUC-JP'] = function (options) {
    return new EUCJPDecoder(options);
  };

  // 13.2 iso-2022-jp

  // 13.2.1 iso-2022-jp decoder
  /**
   * @constructor
   * @implements {Decoder}
   * @param {{fatal: boolean}} options
   */
  function ISO2022JPDecoder(options) {
    var fatal = options.fatal;
    /** @enum */
    var states = {
      ASCII: 0,
      Roman: 1,
      Katakana: 2,
      LeadByte: 3,
      TrailByte: 4,
      EscapeStart: 5,
      Escape: 6
    };
    // iso-2022-jp's decoder has an associated iso-2022-jp decoder
    // state (initially ASCII), iso-2022-jp decoder output state
    // (initially ASCII), iso-2022-jp lead (initially 0x00), and
    // iso-2022-jp output flag (initially unset).
    var /** @type {number} */iso2022jp_decoder_state = states.ASCII,
      /** @type {number} */iso2022jp_decoder_output_state = states.ASCII,
      /** @type {number} */iso2022jp_lead = 0x00,
      /** @type {boolean} */iso2022jp_output_flag = false;
    /**
     * @param {Stream} stream The stream of bytes being decoded.
     * @param {number} bite The next byte read from the stream.
     * @return {?(number|!Array.<number>)} The next code point(s)
     *     decoded, or null if not enough data exists in the input
     *     stream to decode a complete code point.
     */
    this.handler = function (stream, bite) {
      // switching on iso-2022-jp decoder state:
      switch (iso2022jp_decoder_state) {
        default:
        case states.ASCII:
          // ASCII
          // Based on byte:

          // 0x1B
          if (bite === 0x1B) {
            // Set iso-2022-jp decoder state to escape start and return
            // continue.
            iso2022jp_decoder_state = states.EscapeStart;
            return null;
          }

          // 0x00 to 0x7F, excluding 0x0E, 0x0F, and 0x1B
          if (inRange(bite, 0x00, 0x7F) && bite !== 0x0E && bite !== 0x0F && bite !== 0x1B) {
            // Unset the iso-2022-jp output flag and return a code point
            // whose value is byte.
            iso2022jp_output_flag = false;
            return bite;
          }

          // end-of-stream
          if (bite === end_of_stream) {
            // Return finished.
            return finished;
          }

          // Otherwise
          // Unset the iso-2022-jp output flag and return error.
          iso2022jp_output_flag = false;
          return decoderError(fatal);
        case states.Roman:
          // Roman
          // Based on byte:

          // 0x1B
          if (bite === 0x1B) {
            // Set iso-2022-jp decoder state to escape start and return
            // continue.
            iso2022jp_decoder_state = states.EscapeStart;
            return null;
          }

          // 0x5C
          if (bite === 0x5C) {
            // Unset the iso-2022-jp output flag and return code point
            // U+00A5.
            iso2022jp_output_flag = false;
            return 0x00A5;
          }

          // 0x7E
          if (bite === 0x7E) {
            // Unset the iso-2022-jp output flag and return code point
            // U+203E.
            iso2022jp_output_flag = false;
            return 0x203E;
          }

          // 0x00 to 0x7F, excluding 0x0E, 0x0F, 0x1B, 0x5C, and 0x7E
          if (inRange(bite, 0x00, 0x7F) && bite !== 0x0E && bite !== 0x0F && bite !== 0x1B && bite !== 0x5C && bite !== 0x7E) {
            // Unset the iso-2022-jp output flag and return a code point
            // whose value is byte.
            iso2022jp_output_flag = false;
            return bite;
          }

          // end-of-stream
          if (bite === end_of_stream) {
            // Return finished.
            return finished;
          }

          // Otherwise
          // Unset the iso-2022-jp output flag and return error.
          iso2022jp_output_flag = false;
          return decoderError(fatal);
        case states.Katakana:
          // Katakana
          // Based on byte:

          // 0x1B
          if (bite === 0x1B) {
            // Set iso-2022-jp decoder state to escape start and return
            // continue.
            iso2022jp_decoder_state = states.EscapeStart;
            return null;
          }

          // 0x21 to 0x5F
          if (inRange(bite, 0x21, 0x5F)) {
            // Unset the iso-2022-jp output flag and return a code point
            // whose value is 0xFF61 − 0x21 + byte.
            iso2022jp_output_flag = false;
            return 0xFF61 - 0x21 + bite;
          }

          // end-of-stream
          if (bite === end_of_stream) {
            // Return finished.
            return finished;
          }

          // Otherwise
          // Unset the iso-2022-jp output flag and return error.
          iso2022jp_output_flag = false;
          return decoderError(fatal);
        case states.LeadByte:
          // Lead byte
          // Based on byte:

          // 0x1B
          if (bite === 0x1B) {
            // Set iso-2022-jp decoder state to escape start and return
            // continue.
            iso2022jp_decoder_state = states.EscapeStart;
            return null;
          }

          // 0x21 to 0x7E
          if (inRange(bite, 0x21, 0x7E)) {
            // Unset the iso-2022-jp output flag, set iso-2022-jp lead
            // to byte, iso-2022-jp decoder state to trail byte, and
            // return continue.
            iso2022jp_output_flag = false;
            iso2022jp_lead = bite;
            iso2022jp_decoder_state = states.TrailByte;
            return null;
          }

          // end-of-stream
          if (bite === end_of_stream) {
            // Return finished.
            return finished;
          }

          // Otherwise
          // Unset the iso-2022-jp output flag and return error.
          iso2022jp_output_flag = false;
          return decoderError(fatal);
        case states.TrailByte:
          // Trail byte
          // Based on byte:

          // 0x1B
          if (bite === 0x1B) {
            // Set iso-2022-jp decoder state to escape start and return
            // continue.
            iso2022jp_decoder_state = states.EscapeStart;
            return decoderError(fatal);
          }

          // 0x21 to 0x7E
          if (inRange(bite, 0x21, 0x7E)) {
            // 1. Set the iso-2022-jp decoder state to lead byte.
            iso2022jp_decoder_state = states.LeadByte;

            // 2. Let pointer be (iso-2022-jp lead − 0x21) × 94 + byte − 0x21.
            var pointer = (iso2022jp_lead - 0x21) * 94 + bite - 0x21;

            // 3. Let code point be the index code point for pointer in
            // index jis0208.
            var code_point = indexCodePointFor(pointer, index('jis0208'));

            // 4. If code point is null, return error.
            if (code_point === null) return decoderError(fatal);

            // 5. Return a code point whose value is code point.
            return code_point;
          }

          // end-of-stream
          if (bite === end_of_stream) {
            // Set the iso-2022-jp decoder state to lead byte, prepend
            // byte to stream, and return error.
            iso2022jp_decoder_state = states.LeadByte;
            stream.prepend(bite);
            return decoderError(fatal);
          }

          // Otherwise
          // Set iso-2022-jp decoder state to lead byte and return
          // error.
          iso2022jp_decoder_state = states.LeadByte;
          return decoderError(fatal);
        case states.EscapeStart:
          // Escape start

          // 1. If byte is either 0x24 or 0x28, set iso-2022-jp lead to
          // byte, iso-2022-jp decoder state to escape, and return
          // continue.
          if (bite === 0x24 || bite === 0x28) {
            iso2022jp_lead = bite;
            iso2022jp_decoder_state = states.Escape;
            return null;
          }

          // 2. Prepend byte to stream.
          stream.prepend(bite);

          // 3. Unset the iso-2022-jp output flag, set iso-2022-jp
          // decoder state to iso-2022-jp decoder output state, and
          // return error.
          iso2022jp_output_flag = false;
          iso2022jp_decoder_state = iso2022jp_decoder_output_state;
          return decoderError(fatal);
        case states.Escape:
          // Escape

          // 1. Let lead be iso-2022-jp lead and set iso-2022-jp lead to
          // 0x00.
          var lead = iso2022jp_lead;
          iso2022jp_lead = 0x00;

          // 2. Let state be null.
          var state = null;

          // 3. If lead is 0x28 and byte is 0x42, set state to ASCII.
          if (lead === 0x28 && bite === 0x42) state = states.ASCII;

          // 4. If lead is 0x28 and byte is 0x4A, set state to Roman.
          if (lead === 0x28 && bite === 0x4A) state = states.Roman;

          // 5. If lead is 0x28 and byte is 0x49, set state to Katakana.
          if (lead === 0x28 && bite === 0x49) state = states.Katakana;

          // 6. If lead is 0x24 and byte is either 0x40 or 0x42, set
          // state to lead byte.
          if (lead === 0x24 && (bite === 0x40 || bite === 0x42)) state = states.LeadByte;

          // 7. If state is non-null, run these substeps:
          if (state !== null) {
            // 1. Set iso-2022-jp decoder state and iso-2022-jp decoder
            // output state to states.
            iso2022jp_decoder_state = iso2022jp_decoder_state = state;

            // 2. Let output flag be the iso-2022-jp output flag.
            var output_flag = iso2022jp_output_flag;

            // 3. Set the iso-2022-jp output flag.
            iso2022jp_output_flag = true;

            // 4. Return continue, if output flag is unset, and error
            // otherwise.
            return !output_flag ? null : decoderError(fatal);
          }

          // 8. Prepend lead and byte to stream.
          stream.prepend([lead, bite]);

          // 9. Unset the iso-2022-jp output flag, set iso-2022-jp
          // decoder state to iso-2022-jp decoder output state and
          // return error.
          iso2022jp_output_flag = false;
          iso2022jp_decoder_state = iso2022jp_decoder_output_state;
          return decoderError(fatal);
      }
    };
  }

  // 13.2.2 iso-2022-jp encoder
  /**
   * @constructor
   * @implements {Encoder}
   * @param {{fatal: boolean}} options
   */
  function ISO2022JPEncoder(options) {
    var fatal = options.fatal;
    // iso-2022-jp's encoder has an associated iso-2022-jp encoder
    // state which is one of ASCII, Roman, and jis0208 (initially
    // ASCII).
    /** @enum */
    var states = {
      ASCII: 0,
      Roman: 1,
      jis0208: 2
    };
    var /** @type {number} */iso2022jp_state = states.ASCII;
    /**
     * @param {Stream} stream Input stream.
     * @param {number} code_point Next code point read from the stream.
     * @return {(number|!Array.<number>)} Byte(s) to emit.
     */
    this.handler = function (stream, code_point) {
      // 1. If code point is end-of-stream and iso-2022-jp encoder
      // state is not ASCII, prepend code point to stream, set
      // iso-2022-jp encoder state to ASCII, and return three bytes
      // 0x1B 0x28 0x42.
      if (code_point === end_of_stream && iso2022jp_state !== states.ASCII) {
        stream.prepend(code_point);
        iso2022jp_state = states.ASCII;
        return [0x1B, 0x28, 0x42];
      }

      // 2. If code point is end-of-stream and iso-2022-jp encoder
      // state is ASCII, return finished.
      if (code_point === end_of_stream && iso2022jp_state === states.ASCII) return finished;

      // 3. If ISO-2022-JP encoder state is ASCII or Roman, and code
      // point is U+000E, U+000F, or U+001B, return error with U+FFFD.
      if ((iso2022jp_state === states.ASCII || iso2022jp_state === states.Roman) && (code_point === 0x000E || code_point === 0x000F || code_point === 0x001B)) {
        return encoderError(0xFFFD);
      }

      // 4. If iso-2022-jp encoder state is ASCII and code point is an
      // ASCII code point, return a byte whose value is code point.
      if (iso2022jp_state === states.ASCII && isASCIICodePoint(code_point)) return code_point;

      // 5. If iso-2022-jp encoder state is Roman and code point is an
      // ASCII code point, excluding U+005C and U+007E, or is U+00A5
      // or U+203E, run these substeps:
      if (iso2022jp_state === states.Roman && (isASCIICodePoint(code_point) && code_point !== 0x005C && code_point !== 0x007E || code_point == 0x00A5 || code_point == 0x203E)) {
        // 1. If code point is an ASCII code point, return a byte
        // whose value is code point.
        if (isASCIICodePoint(code_point)) return code_point;

        // 2. If code point is U+00A5, return byte 0x5C.
        if (code_point === 0x00A5) return 0x5C;

        // 3. If code point is U+203E, return byte 0x7E.
        if (code_point === 0x203E) return 0x7E;
      }

      // 6. If code point is an ASCII code point, and iso-2022-jp
      // encoder state is not ASCII, prepend code point to stream, set
      // iso-2022-jp encoder state to ASCII, and return three bytes
      // 0x1B 0x28 0x42.
      if (isASCIICodePoint(code_point) && iso2022jp_state !== states.ASCII) {
        stream.prepend(code_point);
        iso2022jp_state = states.ASCII;
        return [0x1B, 0x28, 0x42];
      }

      // 7. If code point is either U+00A5 or U+203E, and iso-2022-jp
      // encoder state is not Roman, prepend code point to stream, set
      // iso-2022-jp encoder state to Roman, and return three bytes
      // 0x1B 0x28 0x4A.
      if ((code_point === 0x00A5 || code_point === 0x203E) && iso2022jp_state !== states.Roman) {
        stream.prepend(code_point);
        iso2022jp_state = states.Roman;
        return [0x1B, 0x28, 0x4A];
      }

      // 8. If code point is U+2212, set it to U+FF0D.
      if (code_point === 0x2212) code_point = 0xFF0D;

      // 9. Let pointer be the index pointer for code point in index
      // jis0208.
      var pointer = indexPointerFor(code_point, index('jis0208'));

      // 10. If pointer is null, return error with code point.
      if (pointer === null) return encoderError(code_point);

      // 11. If iso-2022-jp encoder state is not jis0208, prepend code
      // point to stream, set iso-2022-jp encoder state to jis0208,
      // and return three bytes 0x1B 0x24 0x42.
      if (iso2022jp_state !== states.jis0208) {
        stream.prepend(code_point);
        iso2022jp_state = states.jis0208;
        return [0x1B, 0x24, 0x42];
      }

      // 12. Let lead be floor(pointer / 94) + 0x21.
      var lead = floor(pointer / 94) + 0x21;

      // 13. Let trail be pointer % 94 + 0x21.
      var trail = pointer % 94 + 0x21;

      // 14. Return two bytes whose values are lead and trail.
      return [lead, trail];
    };
  }

  /** @param {{fatal: boolean}} options */
  encoders['ISO-2022-JP'] = function (options) {
    return new ISO2022JPEncoder(options);
  };
  /** @param {{fatal: boolean}} options */
  decoders['ISO-2022-JP'] = function (options) {
    return new ISO2022JPDecoder(options);
  };

  // 13.3 Shift_JIS

  // 13.3.1 Shift_JIS decoder
  /**
   * @constructor
   * @implements {Decoder}
   * @param {{fatal: boolean}} options
   */
  function ShiftJISDecoder(options) {
    var fatal = options.fatal;
    // Shift_JIS's decoder has an associated Shift_JIS lead (initially
    // 0x00).
    var /** @type {number} */Shift_JIS_lead = 0x00;
    /**
     * @param {Stream} stream The stream of bytes being decoded.
     * @param {number} bite The next byte read from the stream.
     * @return {?(number|!Array.<number>)} The next code point(s)
     *     decoded, or null if not enough data exists in the input
     *     stream to decode a complete code point.
     */
    this.handler = function (stream, bite) {
      // 1. If byte is end-of-stream and Shift_JIS lead is not 0x00,
      // set Shift_JIS lead to 0x00 and return error.
      if (bite === end_of_stream && Shift_JIS_lead !== 0x00) {
        Shift_JIS_lead = 0x00;
        return decoderError(fatal);
      }

      // 2. If byte is end-of-stream and Shift_JIS lead is 0x00,
      // return finished.
      if (bite === end_of_stream && Shift_JIS_lead === 0x00) return finished;

      // 3. If Shift_JIS lead is not 0x00, let lead be Shift_JIS lead,
      // let pointer be null, set Shift_JIS lead to 0x00, and then run
      // these substeps:
      if (Shift_JIS_lead !== 0x00) {
        var lead = Shift_JIS_lead;
        var pointer = null;
        Shift_JIS_lead = 0x00;

        // 1. Let offset be 0x40, if byte is less than 0x7F, and 0x41
        // otherwise.
        var offset = bite < 0x7F ? 0x40 : 0x41;

        // 2. Let lead offset be 0x81, if lead is less than 0xA0, and
        // 0xC1 otherwise.
        var lead_offset = lead < 0xA0 ? 0x81 : 0xC1;

        // 3. If byte is in the range 0x40 to 0x7E, inclusive, or 0x80
        // to 0xFC, inclusive, set pointer to (lead − lead offset) ×
        // 188 + byte − offset.
        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFC)) pointer = (lead - lead_offset) * 188 + bite - offset;

        // 4. If pointer is in the range 8836 to 10715, inclusive,
        // return a code point whose value is 0xE000 − 8836 + pointer.
        if (inRange(pointer, 8836, 10715)) return 0xE000 - 8836 + pointer;

        // 5. Let code point be null, if pointer is null, and the
        // index code point for pointer in index jis0208 otherwise.
        var code_point = pointer === null ? null : indexCodePointFor(pointer, index('jis0208'));

        // 6. If code point is null and byte is an ASCII byte, prepend
        // byte to stream.
        if (code_point === null && isASCIIByte(bite)) stream.prepend(bite);

        // 7. If code point is null, return error.
        if (code_point === null) return decoderError(fatal);

        // 8. Return a code point whose value is code point.
        return code_point;
      }

      // 4. If byte is an ASCII byte or 0x80, return a code point
      // whose value is byte.
      if (isASCIIByte(bite) || bite === 0x80) return bite;

      // 5. If byte is in the range 0xA1 to 0xDF, inclusive, return a
      // code point whose value is 0xFF61 − 0xA1 + byte.
      if (inRange(bite, 0xA1, 0xDF)) return 0xFF61 - 0xA1 + bite;

      // 6. If byte is in the range 0x81 to 0x9F, inclusive, or 0xE0
      // to 0xFC, inclusive, set Shift_JIS lead to byte and return
      // continue.
      if (inRange(bite, 0x81, 0x9F) || inRange(bite, 0xE0, 0xFC)) {
        Shift_JIS_lead = bite;
        return null;
      }

      // 7. Return error.
      return decoderError(fatal);
    };
  }

  // 13.3.2 Shift_JIS encoder
  /**
   * @constructor
   * @implements {Encoder}
   * @param {{fatal: boolean}} options
   */
  function ShiftJISEncoder(options) {
    var fatal = options.fatal;
    /**
     * @param {Stream} stream Input stream.
     * @param {number} code_point Next code point read from the stream.
     * @return {(number|!Array.<number>)} Byte(s) to emit.
     */
    this.handler = function (stream, code_point) {
      // 1. If code point is end-of-stream, return finished.
      if (code_point === end_of_stream) return finished;

      // 2. If code point is an ASCII code point or U+0080, return a
      // byte whose value is code point.
      if (isASCIICodePoint(code_point) || code_point === 0x0080) return code_point;

      // 3. If code point is U+00A5, return byte 0x5C.
      if (code_point === 0x00A5) return 0x5C;

      // 4. If code point is U+203E, return byte 0x7E.
      if (code_point === 0x203E) return 0x7E;

      // 5. If code point is in the range U+FF61 to U+FF9F, inclusive,
      // return a byte whose value is code point − 0xFF61 + 0xA1.
      if (inRange(code_point, 0xFF61, 0xFF9F)) return code_point - 0xFF61 + 0xA1;

      // 6. If code point is U+2212, set it to U+FF0D.
      if (code_point === 0x2212) code_point = 0xFF0D;

      // 7. Let pointer be the index Shift_JIS pointer for code point.
      var pointer = indexShiftJISPointerFor(code_point);

      // 8. If pointer is null, return error with code point.
      if (pointer === null) return encoderError(code_point);

      // 9. Let lead be floor(pointer / 188).
      var lead = floor(pointer / 188);

      // 10. Let lead offset be 0x81, if lead is less than 0x1F, and
      // 0xC1 otherwise.
      var lead_offset = lead < 0x1F ? 0x81 : 0xC1;

      // 11. Let trail be pointer % 188.
      var trail = pointer % 188;

      // 12. Let offset be 0x40, if trail is less than 0x3F, and 0x41
      // otherwise.
      var offset = trail < 0x3F ? 0x40 : 0x41;

      // 13. Return two bytes whose values are lead + lead offset and
      // trail + offset.
      return [lead + lead_offset, trail + offset];
    };
  }

  /** @param {{fatal: boolean}} options */
  encoders['Shift_JIS'] = function (options) {
    return new ShiftJISEncoder(options);
  };
  /** @param {{fatal: boolean}} options */
  decoders['Shift_JIS'] = function (options) {
    return new ShiftJISDecoder(options);
  };

  //
  // 14. Legacy multi-byte Korean encodings
  //

  // 14.1 euc-kr

  // 14.1.1 euc-kr decoder
  /**
   * @constructor
   * @implements {Decoder}
   * @param {{fatal: boolean}} options
   */
  function EUCKRDecoder(options) {
    var fatal = options.fatal;

    // euc-kr's decoder has an associated euc-kr lead (initially 0x00).
    var /** @type {number} */euckr_lead = 0x00;
    /**
     * @param {Stream} stream The stream of bytes being decoded.
     * @param {number} bite The next byte read from the stream.
     * @return {?(number|!Array.<number>)} The next code point(s)
     *     decoded, or null if not enough data exists in the input
     *     stream to decode a complete code point.
     */
    this.handler = function (stream, bite) {
      // 1. If byte is end-of-stream and euc-kr lead is not 0x00, set
      // euc-kr lead to 0x00 and return error.
      if (bite === end_of_stream && euckr_lead !== 0) {
        euckr_lead = 0x00;
        return decoderError(fatal);
      }

      // 2. If byte is end-of-stream and euc-kr lead is 0x00, return
      // finished.
      if (bite === end_of_stream && euckr_lead === 0) return finished;

      // 3. If euc-kr lead is not 0x00, let lead be euc-kr lead, let
      // pointer be null, set euc-kr lead to 0x00, and then run these
      // substeps:
      if (euckr_lead !== 0x00) {
        var lead = euckr_lead;
        var pointer = null;
        euckr_lead = 0x00;

        // 1. If byte is in the range 0x41 to 0xFE, inclusive, set
        // pointer to (lead − 0x81) × 190 + (byte − 0x41).
        if (inRange(bite, 0x41, 0xFE)) pointer = (lead - 0x81) * 190 + (bite - 0x41);

        // 2. Let code point be null, if pointer is null, and the
        // index code point for pointer in index euc-kr otherwise.
        var code_point = pointer === null ? null : indexCodePointFor(pointer, index('euc-kr'));

        // 3. If code point is null and byte is an ASCII byte, prepend
        // byte to stream.
        if (pointer === null && isASCIIByte(bite)) stream.prepend(bite);

        // 4. If code point is null, return error.
        if (code_point === null) return decoderError(fatal);

        // 5. Return a code point whose value is code point.
        return code_point;
      }

      // 4. If byte is an ASCII byte, return a code point whose value
      // is byte.
      if (isASCIIByte(bite)) return bite;

      // 5. If byte is in the range 0x81 to 0xFE, inclusive, set
      // euc-kr lead to byte and return continue.
      if (inRange(bite, 0x81, 0xFE)) {
        euckr_lead = bite;
        return null;
      }

      // 6. Return error.
      return decoderError(fatal);
    };
  }

  // 14.1.2 euc-kr encoder
  /**
   * @constructor
   * @implements {Encoder}
   * @param {{fatal: boolean}} options
   */
  function EUCKREncoder(options) {
    var fatal = options.fatal;
    /**
     * @param {Stream} stream Input stream.
     * @param {number} code_point Next code point read from the stream.
     * @return {(number|!Array.<number>)} Byte(s) to emit.
     */
    this.handler = function (stream, code_point) {
      // 1. If code point is end-of-stream, return finished.
      if (code_point === end_of_stream) return finished;

      // 2. If code point is an ASCII code point, return a byte whose
      // value is code point.
      if (isASCIICodePoint(code_point)) return code_point;

      // 3. Let pointer be the index pointer for code point in index
      // euc-kr.
      var pointer = indexPointerFor(code_point, index('euc-kr'));

      // 4. If pointer is null, return error with code point.
      if (pointer === null) return encoderError(code_point);

      // 5. Let lead be floor(pointer / 190) + 0x81.
      var lead = floor(pointer / 190) + 0x81;

      // 6. Let trail be pointer % 190 + 0x41.
      var trail = pointer % 190 + 0x41;

      // 7. Return two bytes whose values are lead and trail.
      return [lead, trail];
    };
  }

  /** @param {{fatal: boolean}} options */
  encoders['EUC-KR'] = function (options) {
    return new EUCKREncoder(options);
  };
  /** @param {{fatal: boolean}} options */
  decoders['EUC-KR'] = function (options) {
    return new EUCKRDecoder(options);
  };

  //
  // 15. Legacy miscellaneous encodings
  //

  // 15.1 replacement

  // Not needed - API throws RangeError

  // 15.2 Common infrastructure for utf-16be and utf-16le

  /**
   * @param {number} code_unit
   * @param {boolean} utf16be
   * @return {!Array.<number>} bytes
   */
  function convertCodeUnitToBytes(code_unit, utf16be) {
    // 1. Let byte1 be code unit >> 8.
    var byte1 = code_unit >> 8;

    // 2. Let byte2 be code unit & 0x00FF.
    var byte2 = code_unit & 0x00FF;

    // 3. Then return the bytes in order:
    // utf-16be flag is set: byte1, then byte2.
    if (utf16be) return [byte1, byte2];
    // utf-16be flag is unset: byte2, then byte1.
    return [byte2, byte1];
  }

  // 15.2.1 shared utf-16 decoder
  /**
   * @constructor
   * @implements {Decoder}
   * @param {boolean} utf16_be True if big-endian, false if little-endian.
   * @param {{fatal: boolean}} options
   */
  function UTF16Decoder(utf16_be, options) {
    var fatal = options.fatal;
    var /** @type {?number} */utf16_lead_byte = null,
      /** @type {?number} */utf16_lead_surrogate = null;
    /**
     * @param {Stream} stream The stream of bytes being decoded.
     * @param {number} bite The next byte read from the stream.
     * @return {?(number|!Array.<number>)} The next code point(s)
     *     decoded, or null if not enough data exists in the input
     *     stream to decode a complete code point.
     */
    this.handler = function (stream, bite) {
      // 1. If byte is end-of-stream and either utf-16 lead byte or
      // utf-16 lead surrogate is not null, set utf-16 lead byte and
      // utf-16 lead surrogate to null, and return error.
      if (bite === end_of_stream && (utf16_lead_byte !== null || utf16_lead_surrogate !== null)) {
        return decoderError(fatal);
      }

      // 2. If byte is end-of-stream and utf-16 lead byte and utf-16
      // lead surrogate are null, return finished.
      if (bite === end_of_stream && utf16_lead_byte === null && utf16_lead_surrogate === null) {
        return finished;
      }

      // 3. If utf-16 lead byte is null, set utf-16 lead byte to byte
      // and return continue.
      if (utf16_lead_byte === null) {
        utf16_lead_byte = bite;
        return null;
      }

      // 4. Let code unit be the result of:
      var code_unit;
      if (utf16_be) {
        // utf-16be decoder flag is set
        //   (utf-16 lead byte << 8) + byte.
        code_unit = (utf16_lead_byte << 8) + bite;
      } else {
        // utf-16be decoder flag is unset
        //   (byte << 8) + utf-16 lead byte.
        code_unit = (bite << 8) + utf16_lead_byte;
      }
      // Then set utf-16 lead byte to null.
      utf16_lead_byte = null;

      // 5. If utf-16 lead surrogate is not null, let lead surrogate
      // be utf-16 lead surrogate, set utf-16 lead surrogate to null,
      // and then run these substeps:
      if (utf16_lead_surrogate !== null) {
        var lead_surrogate = utf16_lead_surrogate;
        utf16_lead_surrogate = null;

        // 1. If code unit is in the range U+DC00 to U+DFFF,
        // inclusive, return a code point whose value is 0x10000 +
        // ((lead surrogate − 0xD800) << 10) + (code unit − 0xDC00).
        if (inRange(code_unit, 0xDC00, 0xDFFF)) {
          return 0x10000 + (lead_surrogate - 0xD800) * 0x400 + (code_unit - 0xDC00);
        }

        // 2. Prepend the sequence resulting of converting code unit
        // to bytes using utf-16be decoder flag to stream and return
        // error.
        stream.prepend(convertCodeUnitToBytes(code_unit, utf16_be));
        return decoderError(fatal);
      }

      // 6. If code unit is in the range U+D800 to U+DBFF, inclusive,
      // set utf-16 lead surrogate to code unit and return continue.
      if (inRange(code_unit, 0xD800, 0xDBFF)) {
        utf16_lead_surrogate = code_unit;
        return null;
      }

      // 7. If code unit is in the range U+DC00 to U+DFFF, inclusive,
      // return error.
      if (inRange(code_unit, 0xDC00, 0xDFFF)) return decoderError(fatal);

      // 8. Return code point code unit.
      return code_unit;
    };
  }

  // 15.2.2 shared utf-16 encoder
  /**
   * @constructor
   * @implements {Encoder}
   * @param {boolean} utf16_be True if big-endian, false if little-endian.
   * @param {{fatal: boolean}} options
   */
  function UTF16Encoder(utf16_be, options) {
    var fatal = options.fatal;
    /**
     * @param {Stream} stream Input stream.
     * @param {number} code_point Next code point read from the stream.
     * @return {(number|!Array.<number>)} Byte(s) to emit.
     */
    this.handler = function (stream, code_point) {
      // 1. If code point is end-of-stream, return finished.
      if (code_point === end_of_stream) return finished;

      // 2. If code point is in the range U+0000 to U+FFFF, inclusive,
      // return the sequence resulting of converting code point to
      // bytes using utf-16be encoder flag.
      if (inRange(code_point, 0x0000, 0xFFFF)) return convertCodeUnitToBytes(code_point, utf16_be);

      // 3. Let lead be ((code point − 0x10000) >> 10) + 0xD800,
      // converted to bytes using utf-16be encoder flag.
      var lead = convertCodeUnitToBytes((code_point - 0x10000 >> 10) + 0xD800, utf16_be);

      // 4. Let trail be ((code point − 0x10000) & 0x3FF) + 0xDC00,
      // converted to bytes using utf-16be encoder flag.
      var trail = convertCodeUnitToBytes((code_point - 0x10000 & 0x3FF) + 0xDC00, utf16_be);

      // 5. Return a byte sequence of lead followed by trail.
      return lead.concat(trail);
    };
  }

  // 15.3 utf-16be
  // 15.3.1 utf-16be decoder
  /** @param {{fatal: boolean}} options */
  encoders['UTF-16BE'] = function (options) {
    return new UTF16Encoder(true, options);
  };
  // 15.3.2 utf-16be encoder
  /** @param {{fatal: boolean}} options */
  decoders['UTF-16BE'] = function (options) {
    return new UTF16Decoder(true, options);
  };

  // 15.4 utf-16le
  // 15.4.1 utf-16le decoder
  /** @param {{fatal: boolean}} options */
  encoders['UTF-16LE'] = function (options) {
    return new UTF16Encoder(false, options);
  };
  // 15.4.2 utf-16le encoder
  /** @param {{fatal: boolean}} options */
  decoders['UTF-16LE'] = function (options) {
    return new UTF16Decoder(false, options);
  };

  // 15.5 x-user-defined

  // 15.5.1 x-user-defined decoder
  /**
   * @constructor
   * @implements {Decoder}
   * @param {{fatal: boolean}} options
   */
  function XUserDefinedDecoder(options) {
    var fatal = options.fatal;
    /**
     * @param {Stream} stream The stream of bytes being decoded.
     * @param {number} bite The next byte read from the stream.
     * @return {?(number|!Array.<number>)} The next code point(s)
     *     decoded, or null if not enough data exists in the input
     *     stream to decode a complete code point.
     */
    this.handler = function (stream, bite) {
      // 1. If byte is end-of-stream, return finished.
      if (bite === end_of_stream) return finished;

      // 2. If byte is an ASCII byte, return a code point whose value
      // is byte.
      if (isASCIIByte(bite)) return bite;

      // 3. Return a code point whose value is 0xF780 + byte − 0x80.
      return 0xF780 + bite - 0x80;
    };
  }

  // 15.5.2 x-user-defined encoder
  /**
   * @constructor
   * @implements {Encoder}
   * @param {{fatal: boolean}} options
   */
  function XUserDefinedEncoder(options) {
    var fatal = options.fatal;
    /**
     * @param {Stream} stream Input stream.
     * @param {number} code_point Next code point read from the stream.
     * @return {(number|!Array.<number>)} Byte(s) to emit.
     */
    this.handler = function (stream, code_point) {
      // 1.If code point is end-of-stream, return finished.
      if (code_point === end_of_stream) return finished;

      // 2. If code point is an ASCII code point, return a byte whose
      // value is code point.
      if (isASCIICodePoint(code_point)) return code_point;

      // 3. If code point is in the range U+F780 to U+F7FF, inclusive,
      // return a byte whose value is code point − 0xF780 + 0x80.
      if (inRange(code_point, 0xF780, 0xF7FF)) return code_point - 0xF780 + 0x80;

      // 4. Return error with code point.
      return encoderError(code_point);
    };
  }

  /** @param {{fatal: boolean}} options */
  encoders['x-user-defined'] = function (options) {
    return new XUserDefinedEncoder(options);
  };
  /** @param {{fatal: boolean}} options */
  decoders['x-user-defined'] = function (options) {
    return new XUserDefinedDecoder(options);
  };
  if (!global['TextEncoder']) global['TextEncoder'] = TextEncoder;
  if (!global['TextDecoder']) global['TextDecoder'] = TextDecoder;
  if (typeof module !== "undefined" && module.exports) {
    module.exports = {
      TextEncoder: global['TextEncoder'],
      TextDecoder: global['TextDecoder'],
      EncodingIndexes: global["encoding-indexes"]
    };
  }

  // For strict environments where `this` inside the global scope
  // is `undefined`, take a pure object instead
})(void 0 || {});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJnbG9iYWwiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSIsImluUmFuZ2UiLCJhIiwibWluIiwibWF4IiwiaW5jbHVkZXMiLCJhcnJheSIsIml0ZW0iLCJpbmRleE9mIiwiZmxvb3IiLCJNYXRoIiwiVG9EaWN0aW9uYXJ5IiwibyIsInVuZGVmaW5lZCIsIk9iamVjdCIsIlR5cGVFcnJvciIsInN0cmluZ1RvQ29kZVBvaW50cyIsInN0cmluZyIsInMiLCJTdHJpbmciLCJuIiwibGVuZ3RoIiwiaSIsInUiLCJjIiwiY2hhckNvZGVBdCIsInB1c2giLCJkIiwiYiIsImNvZGVQb2ludHNUb1N0cmluZyIsImNvZGVfcG9pbnRzIiwiY3AiLCJmcm9tQ2hhckNvZGUiLCJpc0FTQ0lJQnl0ZSIsImlzQVNDSUlDb2RlUG9pbnQiLCJlbmRfb2Zfc3RyZWFtIiwiU3RyZWFtIiwidG9rZW5zIiwic2xpY2UiLCJjYWxsIiwicmV2ZXJzZSIsInByb3RvdHlwZSIsImVuZE9mU3RyZWFtIiwicmVhZCIsInBvcCIsInByZXBlbmQiLCJ0b2tlbiIsIkFycmF5IiwiaXNBcnJheSIsInVuc2hpZnQiLCJzaGlmdCIsImZpbmlzaGVkIiwiZGVjb2RlckVycm9yIiwiZmF0YWwiLCJvcHRfY29kZV9wb2ludCIsImVuY29kZXJFcnJvciIsImNvZGVfcG9pbnQiLCJEZWNvZGVyIiwiaGFuZGxlciIsInN0cmVhbSIsImJpdGUiLCJFbmNvZGVyIiwiZ2V0RW5jb2RpbmciLCJsYWJlbCIsInRyaW0iLCJ0b0xvd2VyQ2FzZSIsImhhc093blByb3BlcnR5IiwibGFiZWxfdG9fZW5jb2RpbmciLCJlbmNvZGluZ3MiLCJmb3JFYWNoIiwiY2F0ZWdvcnkiLCJlbmNvZGluZyIsImxhYmVscyIsImVuY29kZXJzIiwiZGVjb2RlcnMiLCJpbmRleENvZGVQb2ludEZvciIsInBvaW50ZXIiLCJpbmRleCIsImluZGV4UG9pbnRlckZvciIsIm5hbWUiLCJFcnJvciIsImluZGV4R0IxODAzMFJhbmdlc0NvZGVQb2ludEZvciIsIm9mZnNldCIsImNvZGVfcG9pbnRfb2Zmc2V0IiwiaWR4IiwiZW50cnkiLCJpbmRleEdCMTgwMzBSYW5nZXNQb2ludGVyRm9yIiwicG9pbnRlcl9vZmZzZXQiLCJpbmRleFNoaWZ0SklTUG9pbnRlckZvciIsInNoaWZ0X2ppc19pbmRleCIsIm1hcCIsImluZGV4XyIsImluZGV4QmlnNVBvaW50ZXJGb3IiLCJiaWc1X2luZGV4X25vX2hrc2NzIiwibGFzdEluZGV4T2YiLCJERUZBVUxUX0VOQ09ESU5HIiwiVGV4dERlY29kZXIiLCJvcHRpb25zIiwiX2VuY29kaW5nIiwiX2RlY29kZXIiLCJfaWdub3JlQk9NIiwiX0JPTXNlZW4iLCJfZXJyb3JfbW9kZSIsIl9kb19ub3RfZmx1c2giLCJSYW5nZUVycm9yIiwiZGVjIiwiQm9vbGVhbiIsImRlZmluZVByb3BlcnR5IiwiaWdub3JlQk9NIiwiZ2V0IiwiZGVjb2RlIiwiaW5wdXQiLCJieXRlcyIsIkFycmF5QnVmZmVyIiwiVWludDhBcnJheSIsImJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwiaW5wdXRfc3RyZWFtIiwib3V0cHV0IiwicmVzdWx0IiwiYXBwbHkiLCJzZXJpYWxpemVTdHJlYW0iLCJUZXh0RW5jb2RlciIsIl9lbmNvZGVyIiwiX2ZhdGFsIiwiZW5jIiwiY29uc29sZSIsIndhcm4iLCJlbmNvZGUiLCJvcHRfc3RyaW5nIiwiVVRGOERlY29kZXIiLCJ1dGY4X2NvZGVfcG9pbnQiLCJ1dGY4X2J5dGVzX3NlZW4iLCJ1dGY4X2J5dGVzX25lZWRlZCIsInV0ZjhfbG93ZXJfYm91bmRhcnkiLCJ1dGY4X3VwcGVyX2JvdW5kYXJ5IiwiVVRGOEVuY29kZXIiLCJjb3VudCIsInRlbXAiLCJTaW5nbGVCeXRlRGVjb2RlciIsIlNpbmdsZUJ5dGVFbmNvZGVyIiwiaGVhZGluZyIsIkdCMTgwMzBEZWNvZGVyIiwiR0IxODAzMEVuY29kZXIiLCJnYjE4MDMwX2ZpcnN0IiwiZ2IxODAzMF9zZWNvbmQiLCJnYjE4MDMwX3RoaXJkIiwibGVhZCIsImdia19mbGFnIiwidHJhaWwiLCJieXRlMSIsImJ5dGUyIiwiYnl0ZTMiLCJieXRlNCIsIkJpZzVEZWNvZGVyIiwiQmlnNV9sZWFkIiwiQmlnNUVuY29kZXIiLCJFVUNKUERlY29kZXIiLCJldWNqcF9qaXMwMjEyX2ZsYWciLCJldWNqcF9sZWFkIiwiRVVDSlBFbmNvZGVyIiwiSVNPMjAyMkpQRGVjb2RlciIsInN0YXRlcyIsIkFTQ0lJIiwiUm9tYW4iLCJLYXRha2FuYSIsIkxlYWRCeXRlIiwiVHJhaWxCeXRlIiwiRXNjYXBlU3RhcnQiLCJFc2NhcGUiLCJpc28yMDIyanBfZGVjb2Rlcl9zdGF0ZSIsImlzbzIwMjJqcF9kZWNvZGVyX291dHB1dF9zdGF0ZSIsImlzbzIwMjJqcF9sZWFkIiwiaXNvMjAyMmpwX291dHB1dF9mbGFnIiwic3RhdGUiLCJvdXRwdXRfZmxhZyIsIklTTzIwMjJKUEVuY29kZXIiLCJqaXMwMjA4IiwiaXNvMjAyMmpwX3N0YXRlIiwiU2hpZnRKSVNEZWNvZGVyIiwiU2hpZnRfSklTX2xlYWQiLCJsZWFkX29mZnNldCIsIlNoaWZ0SklTRW5jb2RlciIsIkVVQ0tSRGVjb2RlciIsImV1Y2tyX2xlYWQiLCJFVUNLUkVuY29kZXIiLCJjb252ZXJ0Q29kZVVuaXRUb0J5dGVzIiwiY29kZV91bml0IiwidXRmMTZiZSIsIlVURjE2RGVjb2RlciIsInV0ZjE2X2JlIiwidXRmMTZfbGVhZF9ieXRlIiwidXRmMTZfbGVhZF9zdXJyb2dhdGUiLCJsZWFkX3N1cnJvZ2F0ZSIsIlVURjE2RW5jb2RlciIsImNvbmNhdCIsIlhVc2VyRGVmaW5lZERlY29kZXIiLCJYVXNlckRlZmluZWRFbmNvZGVyIiwiRW5jb2RpbmdJbmRleGVzIl0sInNvdXJjZXMiOlsiZW5jb2RpbmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhpcyBpcyBmcmVlIGFuZCB1bmVuY3VtYmVyZWQgc29mdHdhcmUgcmVsZWFzZWQgaW50byB0aGUgcHVibGljIGRvbWFpbi5cbi8vIFNlZSBMSUNFTlNFLm1kIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgR2xvYmFsIHx0aGlzfCByZXF1aXJlZCBmb3IgcmVzb2x2aW5nIGluZGV4ZXMgaW4gbm9kZS5cbiAqIEBzdXBwcmVzcyB7Z2xvYmFsVGhpc31cbiAqL1xuKGZ1bmN0aW9uKGdsb2JhbCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gSWYgd2UncmUgaW4gbm9kZSByZXF1aXJlIGVuY29kaW5nLWluZGV4ZXMgYW5kIGF0dGFjaCBpdCB0byB0aGUgZ2xvYmFsLlxuICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cyAmJlxuICAgICFnbG9iYWxbXCJlbmNvZGluZy1pbmRleGVzXCJdKSB7XG4gICAgZ2xvYmFsW1wiZW5jb2RpbmctaW5kZXhlc1wiXSA9XG4gICAgICByZXF1aXJlKFwiLi9lbmNvZGluZy1pbmRleGVzLmpzXCIpW1wiZW5jb2RpbmctaW5kZXhlc1wiXTtcbiAgfVxuXG4gIC8vXG4gIC8vIFV0aWxpdGllc1xuICAvL1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgbnVtYmVyIHRvIHRlc3QuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmltdW0gdmFsdWUgaW4gdGhlIHJhbmdlLCBpbmNsdXNpdmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggVGhlIG1heGltdW0gdmFsdWUgaW4gdGhlIHJhbmdlLCBpbmNsdXNpdmUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYSA+PSBtaW4gYW5kIGEgPD0gbWF4LlxuICAgKi9cbiAgZnVuY3Rpb24gaW5SYW5nZShhLCBtaW4sIG1heCkge1xuICAgIHJldHVybiBtaW4gPD0gYSAmJiBhIDw9IG1heDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFBcnJheS48Kj59IGFycmF5IFRoZSBhcnJheSB0byBjaGVjay5cbiAgICogQHBhcmFtIHsqfSBpdGVtIFRoZSBpdGVtIHRvIGxvb2sgZm9yIGluIHRoZSBhcnJheS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgaXRlbSBhcHBlYXJzIGluIHRoZSBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGluY2x1ZGVzKGFycmF5LCBpdGVtKSB7XG4gICAgcmV0dXJuIGFycmF5LmluZGV4T2YoaXRlbSkgIT09IC0xO1xuICB9XG5cbiAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcblxuICAvKipcbiAgICogQHBhcmFtIHsqfSBvXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGZ1bmN0aW9uIFRvRGljdGlvbmFyeShvKSB7XG4gICAgaWYgKG8gPT09IHVuZGVmaW5lZCkgcmV0dXJuIHt9O1xuICAgIGlmIChvID09PSBPYmplY3QobykpIHJldHVybiBvO1xuICAgIHRocm93IFR5cGVFcnJvcignQ291bGQgbm90IGNvbnZlcnQgYXJndW1lbnQgdG8gZGljdGlvbmFyeScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgSW5wdXQgc3RyaW5nIG9mIFVURi0xNiBjb2RlIHVuaXRzLlxuICAgKiBAcmV0dXJuIHshQXJyYXkuPG51bWJlcj59IENvZGUgcG9pbnRzLlxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaW5nVG9Db2RlUG9pbnRzKHN0cmluZykge1xuICAgIC8vIGh0dHBzOi8vaGV5Y2FtLmdpdGh1Yi5pby93ZWJpZGwvI2Rmbi1vYnRhaW4tdW5pY29kZVxuXG4gICAgLy8gMS4gTGV0IFMgYmUgdGhlIERPTVN0cmluZyB2YWx1ZS5cbiAgICB2YXIgcyA9IFN0cmluZyhzdHJpbmcpO1xuXG4gICAgLy8gMi4gTGV0IG4gYmUgdGhlIGxlbmd0aCBvZiBTLlxuICAgIHZhciBuID0gcy5sZW5ndGg7XG5cbiAgICAvLyAzLiBJbml0aWFsaXplIGkgdG8gMC5cbiAgICB2YXIgaSA9IDA7XG5cbiAgICAvLyA0LiBJbml0aWFsaXplIFUgdG8gYmUgYW4gZW1wdHkgc2VxdWVuY2Ugb2YgVW5pY29kZSBjaGFyYWN0ZXJzLlxuICAgIHZhciB1ID0gW107XG5cbiAgICAvLyA1LiBXaGlsZSBpIDwgbjpcbiAgICB3aGlsZSAoaSA8IG4pIHtcblxuICAgICAgLy8gMS4gTGV0IGMgYmUgdGhlIGNvZGUgdW5pdCBpbiBTIGF0IGluZGV4IGkuXG4gICAgICB2YXIgYyA9IHMuY2hhckNvZGVBdChpKTtcblxuICAgICAgLy8gMi4gRGVwZW5kaW5nIG9uIHRoZSB2YWx1ZSBvZiBjOlxuXG4gICAgICAvLyBjIDwgMHhEODAwIG9yIGMgPiAweERGRkZcbiAgICAgIGlmIChjIDwgMHhEODAwIHx8IGMgPiAweERGRkYpIHtcbiAgICAgICAgLy8gQXBwZW5kIHRvIFUgdGhlIFVuaWNvZGUgY2hhcmFjdGVyIHdpdGggY29kZSBwb2ludCBjLlxuICAgICAgICB1LnB1c2goYyk7XG4gICAgICB9XG5cbiAgICAgIC8vIDB4REMwMCDiiaQgYyDiiaQgMHhERkZGXG4gICAgICBlbHNlIGlmICgweERDMDAgPD0gYyAmJiBjIDw9IDB4REZGRikge1xuICAgICAgICAvLyBBcHBlbmQgdG8gVSBhIFUrRkZGRCBSRVBMQUNFTUVOVCBDSEFSQUNURVIuXG4gICAgICAgIHUucHVzaCgweEZGRkQpO1xuICAgICAgfVxuXG4gICAgICAvLyAweEQ4MDAg4omkIGMg4omkIDB4REJGRlxuICAgICAgZWxzZSBpZiAoMHhEODAwIDw9IGMgJiYgYyA8PSAweERCRkYpIHtcbiAgICAgICAgLy8gMS4gSWYgaSA9IG7iiJIxLCB0aGVuIGFwcGVuZCB0byBVIGEgVStGRkZEIFJFUExBQ0VNRU5UXG4gICAgICAgIC8vIENIQVJBQ1RFUi5cbiAgICAgICAgaWYgKGkgPT09IG4gLSAxKSB7XG4gICAgICAgICAgdS5wdXNoKDB4RkZGRCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMi4gT3RoZXJ3aXNlLCBpIDwgbuKIkjE6XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIDEuIExldCBkIGJlIHRoZSBjb2RlIHVuaXQgaW4gUyBhdCBpbmRleCBpKzEuXG4gICAgICAgICAgdmFyIGQgPSBzLmNoYXJDb2RlQXQoaSArIDEpO1xuXG4gICAgICAgICAgLy8gMi4gSWYgMHhEQzAwIOKJpCBkIOKJpCAweERGRkYsIHRoZW46XG4gICAgICAgICAgaWYgKDB4REMwMCA8PSBkICYmIGQgPD0gMHhERkZGKSB7XG4gICAgICAgICAgICAvLyAxLiBMZXQgYSBiZSBjICYgMHgzRkYuXG4gICAgICAgICAgICB2YXIgYSA9IGMgJiAweDNGRjtcblxuICAgICAgICAgICAgLy8gMi4gTGV0IGIgYmUgZCAmIDB4M0ZGLlxuICAgICAgICAgICAgdmFyIGIgPSBkICYgMHgzRkY7XG5cbiAgICAgICAgICAgIC8vIDMuIEFwcGVuZCB0byBVIHRoZSBVbmljb2RlIGNoYXJhY3RlciB3aXRoIGNvZGUgcG9pbnRcbiAgICAgICAgICAgIC8vIDJeMTYrMl4xMCphK2IuXG4gICAgICAgICAgICB1LnB1c2goMHgxMDAwMCArIChhIDw8IDEwKSArIGIpO1xuXG4gICAgICAgICAgICAvLyA0LiBTZXQgaSB0byBpKzEuXG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gMy4gT3RoZXJ3aXNlLCBkIDwgMHhEQzAwIG9yIGQgPiAweERGRkYuIEFwcGVuZCB0byBVIGFcbiAgICAgICAgICAvLyBVK0ZGRkQgUkVQTEFDRU1FTlQgQ0hBUkFDVEVSLlxuICAgICAgICAgIGVsc2UgIHtcbiAgICAgICAgICAgIHUucHVzaCgweEZGRkQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyAzLiBTZXQgaSB0byBpKzEuXG4gICAgICBpICs9IDE7XG4gICAgfVxuXG4gICAgLy8gNi4gUmV0dXJuIFUuXG4gICAgcmV0dXJuIHU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGNvZGVfcG9pbnRzIEFycmF5IG9mIGNvZGUgcG9pbnRzLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHN0cmluZyBTdHJpbmcgb2YgVVRGLTE2IGNvZGUgdW5pdHMuXG4gICAqL1xuICBmdW5jdGlvbiBjb2RlUG9pbnRzVG9TdHJpbmcoY29kZV9wb2ludHMpIHtcbiAgICB2YXIgcyA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29kZV9wb2ludHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBjcCA9IGNvZGVfcG9pbnRzW2ldO1xuICAgICAgaWYgKGNwIDw9IDB4RkZGRikge1xuICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3AgLT0gMHgxMDAwMDtcbiAgICAgICAgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjcCA+PiAxMCkgKyAweEQ4MDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY3AgJiAweDNGRikgKyAweERDMDApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcztcbiAgfVxuXG5cbiAgLy9cbiAgLy8gSW1wbGVtZW50YXRpb24gb2YgRW5jb2Rpbmcgc3BlY2lmaWNhdGlvblxuICAvLyBodHRwczovL2VuY29kaW5nLnNwZWMud2hhdHdnLm9yZy9cbiAgLy9cblxuICAvL1xuICAvLyA0LiBUZXJtaW5vbG9neVxuICAvL1xuXG4gIC8qKlxuICAgKiBBbiBBU0NJSSBieXRlIGlzIGEgYnl0ZSBpbiB0aGUgcmFuZ2UgMHgwMCB0byAweDdGLCBpbmNsdXNpdmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBudW1iZXIgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhIGlzIGluIHRoZSByYW5nZSAweDAwIHRvIDB4N0YsIGluY2x1c2l2ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGlzQVNDSUlCeXRlKGEpIHtcbiAgICByZXR1cm4gMHgwMCA8PSBhICYmIGEgPD0gMHg3RjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBBU0NJSSBjb2RlIHBvaW50IGlzIGEgY29kZSBwb2ludCBpbiB0aGUgcmFuZ2UgVSswMDAwIHRvXG4gICAqIFUrMDA3RiwgaW5jbHVzaXZlLlxuICAgKi9cbiAgdmFyIGlzQVNDSUlDb2RlUG9pbnQgPSBpc0FTQ0lJQnl0ZTtcblxuXG4gIC8qKlxuICAgKiBFbmQtb2Ytc3RyZWFtIGlzIGEgc3BlY2lhbCB0b2tlbiB0aGF0IHNpZ25pZmllcyBubyBtb3JlIHRva2Vuc1xuICAgKiBhcmUgaW4gdGhlIHN0cmVhbS5cbiAgICogQGNvbnN0XG4gICAqLyB2YXIgZW5kX29mX3N0cmVhbSA9IC0xO1xuXG4gIC8qKlxuICAgKiBBIHN0cmVhbSByZXByZXNlbnRzIGFuIG9yZGVyZWQgc2VxdWVuY2Ugb2YgdG9rZW5zLlxuICAgKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHshKEFycmF5LjxudW1iZXI+fFVpbnQ4QXJyYXkpfSB0b2tlbnMgQXJyYXkgb2YgdG9rZW5zIHRoYXQgcHJvdmlkZVxuICAgKiB0aGUgc3RyZWFtLlxuICAgKi9cbiAgZnVuY3Rpb24gU3RyZWFtKHRva2Vucykge1xuICAgIC8qKiBAdHlwZSB7IUFycmF5LjxudW1iZXI+fSAqL1xuICAgIHRoaXMudG9rZW5zID0gW10uc2xpY2UuY2FsbCh0b2tlbnMpO1xuICAgIC8vIFJldmVyc2VkIGFzIHB1c2gvcG9wIGlzIG1vcmUgZWZmaWNpZW50IHRoYW4gc2hpZnQvdW5zaGlmdC5cbiAgICB0aGlzLnRva2Vucy5yZXZlcnNlKCk7XG4gIH1cblxuICBTdHJlYW0ucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgZW5kLW9mLXN0cmVhbSBoYXMgYmVlbiBoaXQuXG4gICAgICovXG4gICAgZW5kT2ZTdHJlYW06IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICF0aGlzLnRva2Vucy5sZW5ndGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYSB0b2tlbiBpcyByZWFkIGZyb20gYSBzdHJlYW0sIHRoZSBmaXJzdCB0b2tlbiBpbiB0aGVcbiAgICAgKiBzdHJlYW0gbXVzdCBiZSByZXR1cm5lZCBhbmQgc3Vic2VxdWVudGx5IHJlbW92ZWQsIGFuZFxuICAgICAqIGVuZC1vZi1zdHJlYW0gbXVzdCBiZSByZXR1cm5lZCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IEdldCB0aGUgbmV4dCB0b2tlbiBmcm9tIHRoZSBzdHJlYW0sIG9yXG4gICAgICogZW5kX29mX3N0cmVhbS5cbiAgICAgKi9cbiAgICAgcmVhZDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMudG9rZW5zLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGVuZF9vZl9zdHJlYW07XG4gICAgICAgcmV0dXJuIHRoaXMudG9rZW5zLnBvcCgpO1xuICAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBvbmUgb3IgbW9yZSB0b2tlbnMgYXJlIHByZXBlbmRlZCB0byBhIHN0cmVhbSwgdGhvc2UgdG9rZW5zXG4gICAgICogbXVzdCBiZSBpbnNlcnRlZCwgaW4gZ2l2ZW4gb3JkZXIsIGJlZm9yZSB0aGUgZmlyc3QgdG9rZW4gaW4gdGhlXG4gICAgICogc3RyZWFtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsobnVtYmVyfCFBcnJheS48bnVtYmVyPil9IHRva2VuIFRoZSB0b2tlbihzKSB0byBwcmVwZW5kIHRvIHRoZVxuICAgICAqIHN0cmVhbS5cbiAgICAgKi9cbiAgICBwcmVwZW5kOiBmdW5jdGlvbih0b2tlbikge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodG9rZW4pKSB7XG4gICAgICAgIHZhciB0b2tlbnMgPSAvKipAdHlwZSB7IUFycmF5LjxudW1iZXI+fSovKHRva2VuKTtcbiAgICAgICAgd2hpbGUgKHRva2Vucy5sZW5ndGgpXG4gICAgICAgICAgdGhpcy50b2tlbnMucHVzaCh0b2tlbnMucG9wKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gb25lIG9yIG1vcmUgdG9rZW5zIGFyZSBwdXNoZWQgdG8gYSBzdHJlYW0sIHRob3NlIHRva2Vuc1xuICAgICAqIG11c3QgYmUgaW5zZXJ0ZWQsIGluIGdpdmVuIG9yZGVyLCBhZnRlciB0aGUgbGFzdCB0b2tlbiBpbiB0aGVcbiAgICAgKiBzdHJlYW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyhudW1iZXJ8IUFycmF5LjxudW1iZXI+KX0gdG9rZW4gVGhlIHRva2VucyhzKSB0byBwdXNoIHRvIHRoZVxuICAgICAqIHN0cmVhbS5cbiAgICAgKi9cbiAgICBwdXNoOiBmdW5jdGlvbih0b2tlbikge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodG9rZW4pKSB7XG4gICAgICAgIHZhciB0b2tlbnMgPSAvKipAdHlwZSB7IUFycmF5LjxudW1iZXI+fSovKHRva2VuKTtcbiAgICAgICAgd2hpbGUgKHRva2Vucy5sZW5ndGgpXG4gICAgICAgICAgdGhpcy50b2tlbnMudW5zaGlmdCh0b2tlbnMuc2hpZnQoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRva2Vucy51bnNoaWZ0KHRva2VuKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy9cbiAgLy8gNS4gRW5jb2RpbmdzXG4gIC8vXG5cbiAgLy8gNS4xIEVuY29kZXJzIGFuZCBkZWNvZGVyc1xuXG4gIC8qKiBAY29uc3QgKi9cbiAgdmFyIGZpbmlzaGVkID0gLTE7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmF0YWwgSWYgdHJ1ZSwgZGVjb2RpbmcgZXJyb3JzIHJhaXNlIGFuIGV4Y2VwdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXI9fSBvcHRfY29kZV9wb2ludCBPdmVycmlkZSB0aGUgc3RhbmRhcmQgZmFsbGJhY2sgY29kZSBwb2ludC5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgY29kZSBwb2ludCB0byBpbnNlcnQgb24gYSBkZWNvZGluZyBlcnJvci5cbiAgICovXG4gIGZ1bmN0aW9uIGRlY29kZXJFcnJvcihmYXRhbCwgb3B0X2NvZGVfcG9pbnQpIHtcbiAgICBpZiAoZmF0YWwpXG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ0RlY29kZXIgZXJyb3InKTtcbiAgICByZXR1cm4gb3B0X2NvZGVfcG9pbnQgfHwgMHhGRkZEO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlX3BvaW50IFRoZSBjb2RlIHBvaW50IHRoYXQgY291bGQgbm90IGJlIGVuY29kZWQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gQWx3YXlzIHRocm93cywgbm8gdmFsdWUgaXMgYWN0dWFsbHkgcmV0dXJuZWQuXG4gICAqL1xuICBmdW5jdGlvbiBlbmNvZGVyRXJyb3IoY29kZV9wb2ludCkge1xuICAgIHRocm93IFR5cGVFcnJvcignVGhlIGNvZGUgcG9pbnQgJyArIGNvZGVfcG9pbnQgKyAnIGNvdWxkIG5vdCBiZSBlbmNvZGVkLicpO1xuICB9XG5cbiAgLyoqIEBpbnRlcmZhY2UgKi9cbiAgZnVuY3Rpb24gRGVjb2RlcigpIHt9XG4gIERlY29kZXIucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyZWFtfSBzdHJlYW0gVGhlIHN0cmVhbSBvZiBieXRlcyBiZWluZyBkZWNvZGVkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRlIFRoZSBuZXh0IGJ5dGUgcmVhZCBmcm9tIHRoZSBzdHJlYW0uXG4gICAgICogQHJldHVybiB7PyhudW1iZXJ8IUFycmF5LjxudW1iZXI+KX0gVGhlIG5leHQgY29kZSBwb2ludChzKVxuICAgICAqICAgICBkZWNvZGVkLCBvciBudWxsIGlmIG5vdCBlbm91Z2ggZGF0YSBleGlzdHMgaW4gdGhlIGlucHV0XG4gICAgICogICAgIHN0cmVhbSB0byBkZWNvZGUgYSBjb21wbGV0ZSBjb2RlIHBvaW50LCBvciB8ZmluaXNoZWR8LlxuICAgICAqL1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uKHN0cmVhbSwgYml0ZSkge31cbiAgfTtcblxuICAvKiogQGludGVyZmFjZSAqL1xuICBmdW5jdGlvbiBFbmNvZGVyKCkge31cbiAgRW5jb2Rlci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJlYW19IHN0cmVhbSBUaGUgc3RyZWFtIG9mIGNvZGUgcG9pbnRzIGJlaW5nIGVuY29kZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvZGVfcG9pbnQgTmV4dCBjb2RlIHBvaW50IHJlYWQgZnJvbSB0aGUgc3RyZWFtLlxuICAgICAqIEByZXR1cm4geyhudW1iZXJ8IUFycmF5LjxudW1iZXI+KX0gQnl0ZShzKSB0byBlbWl0LCBvciB8ZmluaXNoZWR8LlxuICAgICAqL1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uKHN0cmVhbSwgY29kZV9wb2ludCkge31cbiAgfTtcblxuICAvLyA1LjIgTmFtZXMgYW5kIGxhYmVsc1xuXG4gIC8vIFRPRE86IERlZmluZSBAdHlwZWRlZiBmb3IgRW5jb2Rpbmc6IHtuYW1lOnN0cmluZyxsYWJlbHM6QXJyYXkuPHN0cmluZz59XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvY2xvc3VyZS1jb21waWxlci9pc3N1ZXMvMjQ3XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYWJlbCBUaGUgZW5jb2RpbmcgbGFiZWwuXG4gICAqIEByZXR1cm4gez97bmFtZTpzdHJpbmcsbGFiZWxzOkFycmF5LjxzdHJpbmc+fX1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEVuY29kaW5nKGxhYmVsKSB7XG4gICAgLy8gMS4gUmVtb3ZlIGFueSBsZWFkaW5nIGFuZCB0cmFpbGluZyBBU0NJSSB3aGl0ZXNwYWNlIGZyb20gbGFiZWwuXG4gICAgbGFiZWwgPSBTdHJpbmcobGFiZWwpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gMi4gSWYgbGFiZWwgaXMgYW4gQVNDSUkgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBmb3IgYW55IG9mIHRoZVxuICAgIC8vIGxhYmVscyBsaXN0ZWQgaW4gdGhlIHRhYmxlIGJlbG93LCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAvLyBlbmNvZGluZywgYW5kIGZhaWx1cmUgb3RoZXJ3aXNlLlxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobGFiZWxfdG9fZW5jb2RpbmcsIGxhYmVsKSkge1xuICAgICAgcmV0dXJuIGxhYmVsX3RvX2VuY29kaW5nW2xhYmVsXTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogRW5jb2RpbmdzIHRhYmxlOiBodHRwczovL2VuY29kaW5nLnNwZWMud2hhdHdnLm9yZy9lbmNvZGluZ3MuanNvblxuICAgKiBAY29uc3RcbiAgICogQHR5cGUgeyFBcnJheS48e1xuICAgKiAgICAgICAgICBoZWFkaW5nOiBzdHJpbmcsXG4gICAqICAgICAgICAgIGVuY29kaW5nczogQXJyYXkuPHtuYW1lOnN0cmluZyxsYWJlbHM6QXJyYXkuPHN0cmluZz59PlxuICAgKiAgICAgICAgfT59XG4gICAqL1xuICB2YXIgZW5jb2RpbmdzID0gW1xuICAgIHtcbiAgICAgIFwiZW5jb2RpbmdzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgIFwibGFiZWxzXCI6IFtcbiAgICAgICAgICAgIFwidW5pY29kZS0xLTEtdXRmLThcIixcbiAgICAgICAgICAgIFwidXRmLThcIixcbiAgICAgICAgICAgIFwidXRmOFwiXG4gICAgICAgICAgXSxcbiAgICAgICAgICBcIm5hbWVcIjogXCJVVEYtOFwiXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICBcImhlYWRpbmdcIjogXCJUaGUgRW5jb2RpbmdcIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJlbmNvZGluZ3NcIjogW1xuICAgICAgICB7XG4gICAgICAgICAgXCJsYWJlbHNcIjogW1xuICAgICAgICAgICAgXCI4NjZcIixcbiAgICAgICAgICAgIFwiY3A4NjZcIixcbiAgICAgICAgICAgIFwiY3NpYm04NjZcIixcbiAgICAgICAgICAgIFwiaWJtODY2XCJcbiAgICAgICAgICBdLFxuICAgICAgICAgIFwibmFtZVwiOiBcIklCTTg2NlwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBcImxhYmVsc1wiOiBbXG4gICAgICAgICAgICBcImNzaXNvbGF0aW4yXCIsXG4gICAgICAgICAgICBcImlzby04ODU5LTJcIixcbiAgICAgICAgICAgIFwiaXNvLWlyLTEwMVwiLFxuICAgICAgICAgICAgXCJpc284ODU5LTJcIixcbiAgICAgICAgICAgIFwiaXNvODg1OTJcIixcbiAgICAgICAgICAgIFwiaXNvXzg4NTktMlwiLFxuICAgICAgICAgICAgXCJpc29fODg1OS0yOjE5ODdcIixcbiAgICAgICAgICAgIFwibDJcIixcbiAgICAgICAgICAgIFwibGF0aW4yXCJcbiAgICAgICAgICBdLFxuICAgICAgICAgIFwibmFtZVwiOiBcIklTTy04ODU5LTJcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgXCJsYWJlbHNcIjogW1xuICAgICAgICAgICAgXCJjc2lzb2xhdGluM1wiLFxuICAgICAgICAgICAgXCJpc28tODg1OS0zXCIsXG4gICAgICAgICAgICBcImlzby1pci0xMDlcIixcbiAgICAgICAgICAgIFwiaXNvODg1OS0zXCIsXG4gICAgICAgICAgICBcImlzbzg4NTkzXCIsXG4gICAgICAgICAgICBcImlzb184ODU5LTNcIixcbiAgICAgICAgICAgIFwiaXNvXzg4NTktMzoxOTg4XCIsXG4gICAgICAgICAgICBcImwzXCIsXG4gICAgICAgICAgICBcImxhdGluM1wiXG4gICAgICAgICAgXSxcbiAgICAgICAgICBcIm5hbWVcIjogXCJJU08tODg1OS0zXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIFwibGFiZWxzXCI6IFtcbiAgICAgICAgICAgIFwiY3Npc29sYXRpbjRcIixcbiAgICAgICAgICAgIFwiaXNvLTg4NTktNFwiLFxuICAgICAgICAgICAgXCJpc28taXItMTEwXCIsXG4gICAgICAgICAgICBcImlzbzg4NTktNFwiLFxuICAgICAgICAgICAgXCJpc284ODU5NFwiLFxuICAgICAgICAgICAgXCJpc29fODg1OS00XCIsXG4gICAgICAgICAgICBcImlzb184ODU5LTQ6MTk4OFwiLFxuICAgICAgICAgICAgXCJsNFwiLFxuICAgICAgICAgICAgXCJsYXRpbjRcIlxuICAgICAgICAgIF0sXG4gICAgICAgICAgXCJuYW1lXCI6IFwiSVNPLTg4NTktNFwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBcImxhYmVsc1wiOiBbXG4gICAgICAgICAgICBcImNzaXNvbGF0aW5jeXJpbGxpY1wiLFxuICAgICAgICAgICAgXCJjeXJpbGxpY1wiLFxuICAgICAgICAgICAgXCJpc28tODg1OS01XCIsXG4gICAgICAgICAgICBcImlzby1pci0xNDRcIixcbiAgICAgICAgICAgIFwiaXNvODg1OS01XCIsXG4gICAgICAgICAgICBcImlzbzg4NTk1XCIsXG4gICAgICAgICAgICBcImlzb184ODU5LTVcIixcbiAgICAgICAgICAgIFwiaXNvXzg4NTktNToxOTg4XCJcbiAgICAgICAgICBdLFxuICAgICAgICAgIFwibmFtZVwiOiBcIklTTy04ODU5LTVcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgXCJsYWJlbHNcIjogW1xuICAgICAgICAgICAgXCJhcmFiaWNcIixcbiAgICAgICAgICAgIFwiYXNtby03MDhcIixcbiAgICAgICAgICAgIFwiY3Npc284ODU5NmVcIixcbiAgICAgICAgICAgIFwiY3Npc284ODU5NmlcIixcbiAgICAgICAgICAgIFwiY3Npc29sYXRpbmFyYWJpY1wiLFxuICAgICAgICAgICAgXCJlY21hLTExNFwiLFxuICAgICAgICAgICAgXCJpc28tODg1OS02XCIsXG4gICAgICAgICAgICBcImlzby04ODU5LTYtZVwiLFxuICAgICAgICAgICAgXCJpc28tODg1OS02LWlcIixcbiAgICAgICAgICAgIFwiaXNvLWlyLTEyN1wiLFxuICAgICAgICAgICAgXCJpc284ODU5LTZcIixcbiAgICAgICAgICAgIFwiaXNvODg1OTZcIixcbiAgICAgICAgICAgIFwiaXNvXzg4NTktNlwiLFxuICAgICAgICAgICAgXCJpc29fODg1OS02OjE5ODdcIlxuICAgICAgICAgIF0sXG4gICAgICAgICAgXCJuYW1lXCI6IFwiSVNPLTg4NTktNlwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBcImxhYmVsc1wiOiBbXG4gICAgICAgICAgICBcImNzaXNvbGF0aW5ncmVla1wiLFxuICAgICAgICAgICAgXCJlY21hLTExOFwiLFxuICAgICAgICAgICAgXCJlbG90XzkyOFwiLFxuICAgICAgICAgICAgXCJncmVla1wiLFxuICAgICAgICAgICAgXCJncmVlazhcIixcbiAgICAgICAgICAgIFwiaXNvLTg4NTktN1wiLFxuICAgICAgICAgICAgXCJpc28taXItMTI2XCIsXG4gICAgICAgICAgICBcImlzbzg4NTktN1wiLFxuICAgICAgICAgICAgXCJpc284ODU5N1wiLFxuICAgICAgICAgICAgXCJpc29fODg1OS03XCIsXG4gICAgICAgICAgICBcImlzb184ODU5LTc6MTk4N1wiLFxuICAgICAgICAgICAgXCJzdW5fZXVfZ3JlZWtcIlxuICAgICAgICAgIF0sXG4gICAgICAgICAgXCJuYW1lXCI6IFwiSVNPLTg4NTktN1wiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBcImxhYmVsc1wiOiBbXG4gICAgICAgICAgICBcImNzaXNvODg1OThlXCIsXG4gICAgICAgICAgICBcImNzaXNvbGF0aW5oZWJyZXdcIixcbiAgICAgICAgICAgIFwiaGVicmV3XCIsXG4gICAgICAgICAgICBcImlzby04ODU5LThcIixcbiAgICAgICAgICAgIFwiaXNvLTg4NTktOC1lXCIsXG4gICAgICAgICAgICBcImlzby1pci0xMzhcIixcbiAgICAgICAgICAgIFwiaXNvODg1OS04XCIsXG4gICAgICAgICAgICBcImlzbzg4NTk4XCIsXG4gICAgICAgICAgICBcImlzb184ODU5LThcIixcbiAgICAgICAgICAgIFwiaXNvXzg4NTktODoxOTg4XCIsXG4gICAgICAgICAgICBcInZpc3VhbFwiXG4gICAgICAgICAgXSxcbiAgICAgICAgICBcIm5hbWVcIjogXCJJU08tODg1OS04XCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIFwibGFiZWxzXCI6IFtcbiAgICAgICAgICAgIFwiY3Npc284ODU5OGlcIixcbiAgICAgICAgICAgIFwiaXNvLTg4NTktOC1pXCIsXG4gICAgICAgICAgICBcImxvZ2ljYWxcIlxuICAgICAgICAgIF0sXG4gICAgICAgICAgXCJuYW1lXCI6IFwiSVNPLTg4NTktOC1JXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIFwibGFiZWxzXCI6IFtcbiAgICAgICAgICAgIFwiY3Npc29sYXRpbjZcIixcbiAgICAgICAgICAgIFwiaXNvLTg4NTktMTBcIixcbiAgICAgICAgICAgIFwiaXNvLWlyLTE1N1wiLFxuICAgICAgICAgICAgXCJpc284ODU5LTEwXCIsXG4gICAgICAgICAgICBcImlzbzg4NTkxMFwiLFxuICAgICAgICAgICAgXCJsNlwiLFxuICAgICAgICAgICAgXCJsYXRpbjZcIlxuICAgICAgICAgIF0sXG4gICAgICAgICAgXCJuYW1lXCI6IFwiSVNPLTg4NTktMTBcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgXCJsYWJlbHNcIjogW1xuICAgICAgICAgICAgXCJpc28tODg1OS0xM1wiLFxuICAgICAgICAgICAgXCJpc284ODU5LTEzXCIsXG4gICAgICAgICAgICBcImlzbzg4NTkxM1wiXG4gICAgICAgICAgXSxcbiAgICAgICAgICBcIm5hbWVcIjogXCJJU08tODg1OS0xM1wiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBcImxhYmVsc1wiOiBbXG4gICAgICAgICAgICBcImlzby04ODU5LTE0XCIsXG4gICAgICAgICAgICBcImlzbzg4NTktMTRcIixcbiAgICAgICAgICAgIFwiaXNvODg1OTE0XCJcbiAgICAgICAgICBdLFxuICAgICAgICAgIFwibmFtZVwiOiBcIklTTy04ODU5LTE0XCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIFwibGFiZWxzXCI6IFtcbiAgICAgICAgICAgIFwiY3Npc29sYXRpbjlcIixcbiAgICAgICAgICAgIFwiaXNvLTg4NTktMTVcIixcbiAgICAgICAgICAgIFwiaXNvODg1OS0xNVwiLFxuICAgICAgICAgICAgXCJpc284ODU5MTVcIixcbiAgICAgICAgICAgIFwiaXNvXzg4NTktMTVcIixcbiAgICAgICAgICAgIFwibDlcIlxuICAgICAgICAgIF0sXG4gICAgICAgICAgXCJuYW1lXCI6IFwiSVNPLTg4NTktMTVcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgXCJsYWJlbHNcIjogW1xuICAgICAgICAgICAgXCJpc28tODg1OS0xNlwiXG4gICAgICAgICAgXSxcbiAgICAgICAgICBcIm5hbWVcIjogXCJJU08tODg1OS0xNlwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBcImxhYmVsc1wiOiBbXG4gICAgICAgICAgICBcImNza29pOHJcIixcbiAgICAgICAgICAgIFwia29pXCIsXG4gICAgICAgICAgICBcImtvaThcIixcbiAgICAgICAgICAgIFwia29pOC1yXCIsXG4gICAgICAgICAgICBcImtvaThfclwiXG4gICAgICAgICAgXSxcbiAgICAgICAgICBcIm5hbWVcIjogXCJLT0k4LVJcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgXCJsYWJlbHNcIjogW1xuICAgICAgICAgICAgXCJrb2k4LXJ1XCIsXG4gICAgICAgICAgICBcImtvaTgtdVwiXG4gICAgICAgICAgXSxcbiAgICAgICAgICBcIm5hbWVcIjogXCJLT0k4LVVcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgXCJsYWJlbHNcIjogW1xuICAgICAgICAgICAgXCJjc21hY2ludG9zaFwiLFxuICAgICAgICAgICAgXCJtYWNcIixcbiAgICAgICAgICAgIFwibWFjaW50b3NoXCIsXG4gICAgICAgICAgICBcIngtbWFjLXJvbWFuXCJcbiAgICAgICAgICBdLFxuICAgICAgICAgIFwibmFtZVwiOiBcIm1hY2ludG9zaFwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBcImxhYmVsc1wiOiBbXG4gICAgICAgICAgICBcImRvcy04NzRcIixcbiAgICAgICAgICAgIFwiaXNvLTg4NTktMTFcIixcbiAgICAgICAgICAgIFwiaXNvODg1OS0xMVwiLFxuICAgICAgICAgICAgXCJpc284ODU5MTFcIixcbiAgICAgICAgICAgIFwidGlzLTYyMFwiLFxuICAgICAgICAgICAgXCJ3aW5kb3dzLTg3NFwiXG4gICAgICAgICAgXSxcbiAgICAgICAgICBcIm5hbWVcIjogXCJ3aW5kb3dzLTg3NFwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBcImxhYmVsc1wiOiBbXG4gICAgICAgICAgICBcImNwMTI1MFwiLFxuICAgICAgICAgICAgXCJ3aW5kb3dzLTEyNTBcIixcbiAgICAgICAgICAgIFwieC1jcDEyNTBcIlxuICAgICAgICAgIF0sXG4gICAgICAgICAgXCJuYW1lXCI6IFwid2luZG93cy0xMjUwXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIFwibGFiZWxzXCI6IFtcbiAgICAgICAgICAgIFwiY3AxMjUxXCIsXG4gICAgICAgICAgICBcIndpbmRvd3MtMTI1MVwiLFxuICAgICAgICAgICAgXCJ4LWNwMTI1MVwiXG4gICAgICAgICAgXSxcbiAgICAgICAgICBcIm5hbWVcIjogXCJ3aW5kb3dzLTEyNTFcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgXCJsYWJlbHNcIjogW1xuICAgICAgICAgICAgXCJhbnNpX3gzLjQtMTk2OFwiLFxuICAgICAgICAgICAgXCJhc2NpaVwiLFxuICAgICAgICAgICAgXCJjcDEyNTJcIixcbiAgICAgICAgICAgIFwiY3A4MTlcIixcbiAgICAgICAgICAgIFwiY3Npc29sYXRpbjFcIixcbiAgICAgICAgICAgIFwiaWJtODE5XCIsXG4gICAgICAgICAgICBcImlzby04ODU5LTFcIixcbiAgICAgICAgICAgIFwiaXNvLWlyLTEwMFwiLFxuICAgICAgICAgICAgXCJpc284ODU5LTFcIixcbiAgICAgICAgICAgIFwiaXNvODg1OTFcIixcbiAgICAgICAgICAgIFwiaXNvXzg4NTktMVwiLFxuICAgICAgICAgICAgXCJpc29fODg1OS0xOjE5ODdcIixcbiAgICAgICAgICAgIFwibDFcIixcbiAgICAgICAgICAgIFwibGF0aW4xXCIsXG4gICAgICAgICAgICBcInVzLWFzY2lpXCIsXG4gICAgICAgICAgICBcIndpbmRvd3MtMTI1MlwiLFxuICAgICAgICAgICAgXCJ4LWNwMTI1MlwiXG4gICAgICAgICAgXSxcbiAgICAgICAgICBcIm5hbWVcIjogXCJ3aW5kb3dzLTEyNTJcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgXCJsYWJlbHNcIjogW1xuICAgICAgICAgICAgXCJjcDEyNTNcIixcbiAgICAgICAgICAgIFwid2luZG93cy0xMjUzXCIsXG4gICAgICAgICAgICBcIngtY3AxMjUzXCJcbiAgICAgICAgICBdLFxuICAgICAgICAgIFwibmFtZVwiOiBcIndpbmRvd3MtMTI1M1wiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBcImxhYmVsc1wiOiBbXG4gICAgICAgICAgICBcImNwMTI1NFwiLFxuICAgICAgICAgICAgXCJjc2lzb2xhdGluNVwiLFxuICAgICAgICAgICAgXCJpc28tODg1OS05XCIsXG4gICAgICAgICAgICBcImlzby1pci0xNDhcIixcbiAgICAgICAgICAgIFwiaXNvODg1OS05XCIsXG4gICAgICAgICAgICBcImlzbzg4NTk5XCIsXG4gICAgICAgICAgICBcImlzb184ODU5LTlcIixcbiAgICAgICAgICAgIFwiaXNvXzg4NTktOToxOTg5XCIsXG4gICAgICAgICAgICBcImw1XCIsXG4gICAgICAgICAgICBcImxhdGluNVwiLFxuICAgICAgICAgICAgXCJ3aW5kb3dzLTEyNTRcIixcbiAgICAgICAgICAgIFwieC1jcDEyNTRcIlxuICAgICAgICAgIF0sXG4gICAgICAgICAgXCJuYW1lXCI6IFwid2luZG93cy0xMjU0XCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIFwibGFiZWxzXCI6IFtcbiAgICAgICAgICAgIFwiY3AxMjU1XCIsXG4gICAgICAgICAgICBcIndpbmRvd3MtMTI1NVwiLFxuICAgICAgICAgICAgXCJ4LWNwMTI1NVwiXG4gICAgICAgICAgXSxcbiAgICAgICAgICBcIm5hbWVcIjogXCJ3aW5kb3dzLTEyNTVcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgXCJsYWJlbHNcIjogW1xuICAgICAgICAgICAgXCJjcDEyNTZcIixcbiAgICAgICAgICAgIFwid2luZG93cy0xMjU2XCIsXG4gICAgICAgICAgICBcIngtY3AxMjU2XCJcbiAgICAgICAgICBdLFxuICAgICAgICAgIFwibmFtZVwiOiBcIndpbmRvd3MtMTI1NlwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBcImxhYmVsc1wiOiBbXG4gICAgICAgICAgICBcImNwMTI1N1wiLFxuICAgICAgICAgICAgXCJ3aW5kb3dzLTEyNTdcIixcbiAgICAgICAgICAgIFwieC1jcDEyNTdcIlxuICAgICAgICAgIF0sXG4gICAgICAgICAgXCJuYW1lXCI6IFwid2luZG93cy0xMjU3XCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIFwibGFiZWxzXCI6IFtcbiAgICAgICAgICAgIFwiY3AxMjU4XCIsXG4gICAgICAgICAgICBcIndpbmRvd3MtMTI1OFwiLFxuICAgICAgICAgICAgXCJ4LWNwMTI1OFwiXG4gICAgICAgICAgXSxcbiAgICAgICAgICBcIm5hbWVcIjogXCJ3aW5kb3dzLTEyNThcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgXCJsYWJlbHNcIjogW1xuICAgICAgICAgICAgXCJ4LW1hYy1jeXJpbGxpY1wiLFxuICAgICAgICAgICAgXCJ4LW1hYy11a3JhaW5pYW5cIlxuICAgICAgICAgIF0sXG4gICAgICAgICAgXCJuYW1lXCI6IFwieC1tYWMtY3lyaWxsaWNcIlxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgXCJoZWFkaW5nXCI6IFwiTGVnYWN5IHNpbmdsZS1ieXRlIGVuY29kaW5nc1wiXG4gICAgfSxcbiAgICB7XG4gICAgICBcImVuY29kaW5nc1wiOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBcImxhYmVsc1wiOiBbXG4gICAgICAgICAgICBcImNoaW5lc2VcIixcbiAgICAgICAgICAgIFwiY3NnYjIzMTJcIixcbiAgICAgICAgICAgIFwiY3Npc281OGdiMjMxMjgwXCIsXG4gICAgICAgICAgICBcImdiMjMxMlwiLFxuICAgICAgICAgICAgXCJnYl8yMzEyXCIsXG4gICAgICAgICAgICBcImdiXzIzMTItODBcIixcbiAgICAgICAgICAgIFwiZ2JrXCIsXG4gICAgICAgICAgICBcImlzby1pci01OFwiLFxuICAgICAgICAgICAgXCJ4LWdia1wiXG4gICAgICAgICAgXSxcbiAgICAgICAgICBcIm5hbWVcIjogXCJHQktcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgXCJsYWJlbHNcIjogW1xuICAgICAgICAgICAgXCJnYjE4MDMwXCJcbiAgICAgICAgICBdLFxuICAgICAgICAgIFwibmFtZVwiOiBcImdiMTgwMzBcIlxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgXCJoZWFkaW5nXCI6IFwiTGVnYWN5IG11bHRpLWJ5dGUgQ2hpbmVzZSAoc2ltcGxpZmllZCkgZW5jb2RpbmdzXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZW5jb2RpbmdzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgIFwibGFiZWxzXCI6IFtcbiAgICAgICAgICAgIFwiYmlnNVwiLFxuICAgICAgICAgICAgXCJiaWc1LWhrc2NzXCIsXG4gICAgICAgICAgICBcImNuLWJpZzVcIixcbiAgICAgICAgICAgIFwiY3NiaWc1XCIsXG4gICAgICAgICAgICBcIngteC1iaWc1XCJcbiAgICAgICAgICBdLFxuICAgICAgICAgIFwibmFtZVwiOiBcIkJpZzVcIlxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgXCJoZWFkaW5nXCI6IFwiTGVnYWN5IG11bHRpLWJ5dGUgQ2hpbmVzZSAodHJhZGl0aW9uYWwpIGVuY29kaW5nc1wiXG4gICAgfSxcbiAgICB7XG4gICAgICBcImVuY29kaW5nc1wiOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBcImxhYmVsc1wiOiBbXG4gICAgICAgICAgICBcImNzZXVjcGtkZm10amFwYW5lc2VcIixcbiAgICAgICAgICAgIFwiZXVjLWpwXCIsXG4gICAgICAgICAgICBcIngtZXVjLWpwXCJcbiAgICAgICAgICBdLFxuICAgICAgICAgIFwibmFtZVwiOiBcIkVVQy1KUFwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBcImxhYmVsc1wiOiBbXG4gICAgICAgICAgICBcImNzaXNvMjAyMmpwXCIsXG4gICAgICAgICAgICBcImlzby0yMDIyLWpwXCJcbiAgICAgICAgICBdLFxuICAgICAgICAgIFwibmFtZVwiOiBcIklTTy0yMDIyLUpQXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIFwibGFiZWxzXCI6IFtcbiAgICAgICAgICAgIFwiY3NzaGlmdGppc1wiLFxuICAgICAgICAgICAgXCJtczkzMlwiLFxuICAgICAgICAgICAgXCJtc19rYW5qaVwiLFxuICAgICAgICAgICAgXCJzaGlmdC1qaXNcIixcbiAgICAgICAgICAgIFwic2hpZnRfamlzXCIsXG4gICAgICAgICAgICBcInNqaXNcIixcbiAgICAgICAgICAgIFwid2luZG93cy0zMWpcIixcbiAgICAgICAgICAgIFwieC1zamlzXCJcbiAgICAgICAgICBdLFxuICAgICAgICAgIFwibmFtZVwiOiBcIlNoaWZ0X0pJU1wiXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICBcImhlYWRpbmdcIjogXCJMZWdhY3kgbXVsdGktYnl0ZSBKYXBhbmVzZSBlbmNvZGluZ3NcIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJlbmNvZGluZ3NcIjogW1xuICAgICAgICB7XG4gICAgICAgICAgXCJsYWJlbHNcIjogW1xuICAgICAgICAgICAgXCJjc2V1Y2tyXCIsXG4gICAgICAgICAgICBcImNza3NjNTYwMTE5ODdcIixcbiAgICAgICAgICAgIFwiZXVjLWtyXCIsXG4gICAgICAgICAgICBcImlzby1pci0xNDlcIixcbiAgICAgICAgICAgIFwia29yZWFuXCIsXG4gICAgICAgICAgICBcImtzX2NfNTYwMS0xOTg3XCIsXG4gICAgICAgICAgICBcImtzX2NfNTYwMS0xOTg5XCIsXG4gICAgICAgICAgICBcImtzYzU2MDFcIixcbiAgICAgICAgICAgIFwia3NjXzU2MDFcIixcbiAgICAgICAgICAgIFwid2luZG93cy05NDlcIlxuICAgICAgICAgIF0sXG4gICAgICAgICAgXCJuYW1lXCI6IFwiRVVDLUtSXCJcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIFwiaGVhZGluZ1wiOiBcIkxlZ2FjeSBtdWx0aS1ieXRlIEtvcmVhbiBlbmNvZGluZ3NcIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJlbmNvZGluZ3NcIjogW1xuICAgICAgICB7XG4gICAgICAgICAgXCJsYWJlbHNcIjogW1xuICAgICAgICAgICAgXCJjc2lzbzIwMjJrclwiLFxuICAgICAgICAgICAgXCJoei1nYi0yMzEyXCIsXG4gICAgICAgICAgICBcImlzby0yMDIyLWNuXCIsXG4gICAgICAgICAgICBcImlzby0yMDIyLWNuLWV4dFwiLFxuICAgICAgICAgICAgXCJpc28tMjAyMi1rclwiXG4gICAgICAgICAgXSxcbiAgICAgICAgICBcIm5hbWVcIjogXCJyZXBsYWNlbWVudFwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBcImxhYmVsc1wiOiBbXG4gICAgICAgICAgICBcInV0Zi0xNmJlXCJcbiAgICAgICAgICBdLFxuICAgICAgICAgIFwibmFtZVwiOiBcIlVURi0xNkJFXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIFwibGFiZWxzXCI6IFtcbiAgICAgICAgICAgIFwidXRmLTE2XCIsXG4gICAgICAgICAgICBcInV0Zi0xNmxlXCJcbiAgICAgICAgICBdLFxuICAgICAgICAgIFwibmFtZVwiOiBcIlVURi0xNkxFXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIFwibGFiZWxzXCI6IFtcbiAgICAgICAgICAgIFwieC11c2VyLWRlZmluZWRcIlxuICAgICAgICAgIF0sXG4gICAgICAgICAgXCJuYW1lXCI6IFwieC11c2VyLWRlZmluZWRcIlxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgXCJoZWFkaW5nXCI6IFwiTGVnYWN5IG1pc2NlbGxhbmVvdXMgZW5jb2RpbmdzXCJcbiAgICB9XG4gIF07XG5cbiAgLy8gTGFiZWwgdG8gZW5jb2RpbmcgcmVnaXN0cnkuXG4gIC8qKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcse25hbWU6c3RyaW5nLGxhYmVsczpBcnJheS48c3RyaW5nPn0+fSAqL1xuICB2YXIgbGFiZWxfdG9fZW5jb2RpbmcgPSB7fTtcbiAgZW5jb2RpbmdzLmZvckVhY2goZnVuY3Rpb24oY2F0ZWdvcnkpIHtcbiAgICBjYXRlZ29yeS5lbmNvZGluZ3MuZm9yRWFjaChmdW5jdGlvbihlbmNvZGluZykge1xuICAgICAgZW5jb2RpbmcubGFiZWxzLmZvckVhY2goZnVuY3Rpb24obGFiZWwpIHtcbiAgICAgICAgbGFiZWxfdG9fZW5jb2RpbmdbbGFiZWxdID0gZW5jb2Rpbmc7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gUmVnaXN0cnkgb2Ygb2YgZW5jb2Rlci9kZWNvZGVyIGZhY3RvcmllcywgYnkgZW5jb2RpbmcgbmFtZS5cbiAgLyoqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgZnVuY3Rpb24oe2ZhdGFsOmJvb2xlYW59KTogRW5jb2Rlcj59ICovXG4gIHZhciBlbmNvZGVycyA9IHt9O1xuICAvKiogQHR5cGUge09iamVjdC48c3RyaW5nLCBmdW5jdGlvbih7ZmF0YWw6Ym9vbGVhbn0pOiBEZWNvZGVyPn0gKi9cbiAgdmFyIGRlY29kZXJzID0ge307XG5cbiAgLy9cbiAgLy8gNi4gSW5kZXhlc1xuICAvL1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcG9pbnRlciBUaGUgfHBvaW50ZXJ8IHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7KCFBcnJheS48P251bWJlcj58dW5kZWZpbmVkKX0gaW5kZXggVGhlIHxpbmRleHwgdG8gc2VhcmNoIHdpdGhpbi5cbiAgICogQHJldHVybiB7P251bWJlcn0gVGhlIGNvZGUgcG9pbnQgY29ycmVzcG9uZGluZyB0byB8cG9pbnRlcnwgaW4gfGluZGV4fCxcbiAgICogICAgIG9yIG51bGwgaWYgfGNvZGUgcG9pbnR8IGlzIG5vdCBpbiB8aW5kZXh8LlxuICAgKi9cbiAgZnVuY3Rpb24gaW5kZXhDb2RlUG9pbnRGb3IocG9pbnRlciwgaW5kZXgpIHtcbiAgICBpZiAoIWluZGV4KSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gaW5kZXhbcG9pbnRlcl0gfHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY29kZV9wb2ludCBUaGUgfGNvZGUgcG9pbnR8IHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7IUFycmF5Ljw/bnVtYmVyPn0gaW5kZXggVGhlIHxpbmRleHwgdG8gc2VhcmNoIHdpdGhpbi5cbiAgICogQHJldHVybiB7P251bWJlcn0gVGhlIGZpcnN0IHBvaW50ZXIgY29ycmVzcG9uZGluZyB0byB8Y29kZSBwb2ludHwgaW5cbiAgICogICAgIHxpbmRleHwsIG9yIG51bGwgaWYgfGNvZGUgcG9pbnR8IGlzIG5vdCBpbiB8aW5kZXh8LlxuICAgKi9cbiAgZnVuY3Rpb24gaW5kZXhQb2ludGVyRm9yKGNvZGVfcG9pbnQsIGluZGV4KSB7XG4gICAgdmFyIHBvaW50ZXIgPSBpbmRleC5pbmRleE9mKGNvZGVfcG9pbnQpO1xuICAgIHJldHVybiBwb2ludGVyID09PSAtMSA/IG51bGwgOiBwb2ludGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIGluZGV4LlxuICAgKiBAcmV0dXJuIHsoIUFycmF5LjxudW1iZXI+fCFBcnJheS48QXJyYXkuPG51bWJlcj4+KX1cbiAgICogICovXG4gIGZ1bmN0aW9uIGluZGV4KG5hbWUpIHtcbiAgICBpZiAoISgnZW5jb2RpbmctaW5kZXhlcycgaW4gZ2xvYmFsKSkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJJbmRleGVzIG1pc3NpbmcuXCIgK1xuICAgICAgICAgICAgICAgICAgXCIgRGlkIHlvdSBmb3JnZXQgdG8gaW5jbHVkZSBlbmNvZGluZy1pbmRleGVzLmpzIGZpcnN0P1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIGdsb2JhbFsnZW5jb2RpbmctaW5kZXhlcyddW25hbWVdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwb2ludGVyIFRoZSB8cG9pbnRlcnwgdG8gc2VhcmNoIGZvciBpbiB0aGUgZ2IxODAzMCBpbmRleC5cbiAgICogQHJldHVybiB7P251bWJlcn0gVGhlIGNvZGUgcG9pbnQgY29ycmVzcG9uZGluZyB0byB8cG9pbnRlcnwgaW4gfGluZGV4fCxcbiAgICogICAgIG9yIG51bGwgaWYgfGNvZGUgcG9pbnR8IGlzIG5vdCBpbiB0aGUgZ2IxODAzMCBpbmRleC5cbiAgICovXG4gIGZ1bmN0aW9uIGluZGV4R0IxODAzMFJhbmdlc0NvZGVQb2ludEZvcihwb2ludGVyKSB7XG4gICAgLy8gMS4gSWYgcG9pbnRlciBpcyBncmVhdGVyIHRoYW4gMzk0MTkgYW5kIGxlc3MgdGhhbiAxODkwMDAsIG9yXG4gICAgLy8gcG9pbnRlciBpcyBncmVhdGVyIHRoYW4gMTIzNzU3NSwgcmV0dXJuIG51bGwuXG4gICAgaWYgKChwb2ludGVyID4gMzk0MTkgJiYgcG9pbnRlciA8IDE4OTAwMCkgfHwgKHBvaW50ZXIgPiAxMjM3NTc1KSlcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgLy8gMi4gSWYgcG9pbnRlciBpcyA3NDU3LCByZXR1cm4gY29kZSBwb2ludCBVK0U3QzcuXG4gICAgaWYgKHBvaW50ZXIgPT09IDc0NTcpIHJldHVybiAweEU3Qzc7XG5cbiAgICAvLyAzLiBMZXQgb2Zmc2V0IGJlIHRoZSBsYXN0IHBvaW50ZXIgaW4gaW5kZXggZ2IxODAzMCByYW5nZXMgdGhhdFxuICAgIC8vIGlzIGVxdWFsIHRvIG9yIGxlc3MgdGhhbiBwb2ludGVyIGFuZCBsZXQgY29kZSBwb2ludCBvZmZzZXQgYmVcbiAgICAvLyBpdHMgY29ycmVzcG9uZGluZyBjb2RlIHBvaW50LlxuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIHZhciBjb2RlX3BvaW50X29mZnNldCA9IDA7XG4gICAgdmFyIGlkeCA9IGluZGV4KCdnYjE4MDMwLXJhbmdlcycpO1xuICAgIHZhciBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBpZHgubGVuZ3RoOyArK2kpIHtcbiAgICAgIC8qKiBAdHlwZSB7IUFycmF5LjxudW1iZXI+fSAqL1xuICAgICAgdmFyIGVudHJ5ID0gaWR4W2ldO1xuICAgICAgaWYgKGVudHJ5WzBdIDw9IHBvaW50ZXIpIHtcbiAgICAgICAgb2Zmc2V0ID0gZW50cnlbMF07XG4gICAgICAgIGNvZGVfcG9pbnRfb2Zmc2V0ID0gZW50cnlbMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA0LiBSZXR1cm4gYSBjb2RlIHBvaW50IHdob3NlIHZhbHVlIGlzIGNvZGUgcG9pbnQgb2Zmc2V0ICtcbiAgICAvLyBwb2ludGVyIOKIkiBvZmZzZXQuXG4gICAgcmV0dXJuIGNvZGVfcG9pbnRfb2Zmc2V0ICsgcG9pbnRlciAtIG9mZnNldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY29kZV9wb2ludCBUaGUgfGNvZGUgcG9pbnR8IHRvIGxvY2F0ZSBpbiB0aGUgZ2IxODAzMCBpbmRleC5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgZmlyc3QgcG9pbnRlciBjb3JyZXNwb25kaW5nIHRvIHxjb2RlIHBvaW50fCBpbiB0aGVcbiAgICogICAgIGdiMTgwMzAgaW5kZXguXG4gICAqL1xuICBmdW5jdGlvbiBpbmRleEdCMTgwMzBSYW5nZXNQb2ludGVyRm9yKGNvZGVfcG9pbnQpIHtcbiAgICAvLyAxLiBJZiBjb2RlIHBvaW50IGlzIFUrRTdDNywgcmV0dXJuIHBvaW50ZXIgNzQ1Ny5cbiAgICBpZiAoY29kZV9wb2ludCA9PT0gMHhFN0M3KSByZXR1cm4gNzQ1NztcblxuICAgIC8vIDIuIExldCBvZmZzZXQgYmUgdGhlIGxhc3QgY29kZSBwb2ludCBpbiBpbmRleCBnYjE4MDMwIHJhbmdlc1xuICAgIC8vIHRoYXQgaXMgZXF1YWwgdG8gb3IgbGVzcyB0aGFuIGNvZGUgcG9pbnQgYW5kIGxldCBwb2ludGVyIG9mZnNldFxuICAgIC8vIGJlIGl0cyBjb3JyZXNwb25kaW5nIHBvaW50ZXIuXG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgdmFyIHBvaW50ZXJfb2Zmc2V0ID0gMDtcbiAgICB2YXIgaWR4ID0gaW5kZXgoJ2diMTgwMzAtcmFuZ2VzJyk7XG4gICAgdmFyIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGlkeC5sZW5ndGg7ICsraSkge1xuICAgICAgLyoqIEB0eXBlIHshQXJyYXkuPG51bWJlcj59ICovXG4gICAgICB2YXIgZW50cnkgPSBpZHhbaV07XG4gICAgICBpZiAoZW50cnlbMV0gPD0gY29kZV9wb2ludCkge1xuICAgICAgICBvZmZzZXQgPSBlbnRyeVsxXTtcbiAgICAgICAgcG9pbnRlcl9vZmZzZXQgPSBlbnRyeVswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDMuIFJldHVybiBhIHBvaW50ZXIgd2hvc2UgdmFsdWUgaXMgcG9pbnRlciBvZmZzZXQgKyBjb2RlIHBvaW50XG4gICAgLy8g4oiSIG9mZnNldC5cbiAgICByZXR1cm4gcG9pbnRlcl9vZmZzZXQgKyBjb2RlX3BvaW50IC0gb2Zmc2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlX3BvaW50IFRoZSB8Y29kZV9wb2ludHwgdG8gc2VhcmNoIGZvciBpbiB0aGUgU2hpZnRfSklTXG4gICAqICAgICBpbmRleC5cbiAgICogQHJldHVybiB7P251bWJlcn0gVGhlIGNvZGUgcG9pbnQgY29ycmVzcG9uZGluZyB0byB8cG9pbnRlcnwgaW4gfGluZGV4fCxcbiAgICogICAgIG9yIG51bGwgaWYgfGNvZGUgcG9pbnR8IGlzIG5vdCBpbiB0aGUgU2hpZnRfSklTIGluZGV4LlxuICAgKi9cbiAgZnVuY3Rpb24gaW5kZXhTaGlmdEpJU1BvaW50ZXJGb3IoY29kZV9wb2ludCkge1xuICAgIC8vIDEuIExldCBpbmRleCBiZSBpbmRleCBqaXMwMjA4IGV4Y2x1ZGluZyBhbGwgZW50cmllcyB3aG9zZVxuICAgIC8vIHBvaW50ZXIgaXMgaW4gdGhlIHJhbmdlIDgyNzIgdG8gODgzNSwgaW5jbHVzaXZlLlxuICAgIHNoaWZ0X2ppc19pbmRleCA9IHNoaWZ0X2ppc19pbmRleCB8fFxuICAgICAgaW5kZXgoJ2ppczAyMDgnKS5tYXAoZnVuY3Rpb24oY29kZV9wb2ludCwgcG9pbnRlcikge1xuICAgICAgICByZXR1cm4gaW5SYW5nZShwb2ludGVyLCA4MjcyLCA4ODM1KSA/IG51bGwgOiBjb2RlX3BvaW50O1xuICAgICAgfSk7XG4gICAgdmFyIGluZGV4XyA9IHNoaWZ0X2ppc19pbmRleDtcblxuICAgIC8vIDIuIFJldHVybiB0aGUgaW5kZXggcG9pbnRlciBmb3IgY29kZSBwb2ludCBpbiBpbmRleC5cbiAgICByZXR1cm4gaW5kZXhfLmluZGV4T2YoY29kZV9wb2ludCk7XG4gIH1cbiAgdmFyIHNoaWZ0X2ppc19pbmRleDtcblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvZGVfcG9pbnQgVGhlIHxjb2RlX3BvaW50fCB0byBzZWFyY2ggZm9yIGluIHRoZSBiaWc1XG4gICAqICAgICBpbmRleC5cbiAgICogQHJldHVybiB7P251bWJlcn0gVGhlIGNvZGUgcG9pbnQgY29ycmVzcG9uZGluZyB0byB8cG9pbnRlcnwgaW4gfGluZGV4fCxcbiAgICogICAgIG9yIG51bGwgaWYgfGNvZGUgcG9pbnR8IGlzIG5vdCBpbiB0aGUgYmlnNSBpbmRleC5cbiAgICovXG4gIGZ1bmN0aW9uIGluZGV4QmlnNVBvaW50ZXJGb3IoY29kZV9wb2ludCkge1xuICAgIC8vIDEuIExldCBpbmRleCBiZSBpbmRleCBCaWc1IGV4Y2x1ZGluZyBhbGwgZW50cmllcyB3aG9zZSBwb2ludGVyXG4gICAgYmlnNV9pbmRleF9ub19oa3NjcyA9IGJpZzVfaW5kZXhfbm9faGtzY3MgfHxcbiAgICAgIGluZGV4KCdiaWc1JykubWFwKGZ1bmN0aW9uKGNvZGVfcG9pbnQsIHBvaW50ZXIpIHtcbiAgICAgICAgcmV0dXJuIChwb2ludGVyIDwgKDB4QTEgLSAweDgxKSAqIDE1NykgPyBudWxsIDogY29kZV9wb2ludDtcbiAgICAgIH0pO1xuICAgIHZhciBpbmRleF8gPSBiaWc1X2luZGV4X25vX2hrc2NzO1xuXG4gICAgLy8gMi4gSWYgY29kZSBwb2ludCBpcyBVKzI1NTAsIFUrMjU1RSwgVSsyNTYxLCBVKzI1NkEsIFUrNTM0MSwgb3JcbiAgICAvLyBVKzUzNDUsIHJldHVybiB0aGUgbGFzdCBwb2ludGVyIGNvcnJlc3BvbmRpbmcgdG8gY29kZSBwb2ludCBpblxuICAgIC8vIGluZGV4LlxuICAgIGlmIChjb2RlX3BvaW50ID09PSAweDI1NTAgfHwgY29kZV9wb2ludCA9PT0gMHgyNTVFIHx8XG4gICAgICAgIGNvZGVfcG9pbnQgPT09IDB4MjU2MSB8fCBjb2RlX3BvaW50ID09PSAweDI1NkEgfHxcbiAgICAgICAgY29kZV9wb2ludCA9PT0gMHg1MzQxIHx8IGNvZGVfcG9pbnQgPT09IDB4NTM0NSkge1xuICAgICAgcmV0dXJuIGluZGV4Xy5sYXN0SW5kZXhPZihjb2RlX3BvaW50KTtcbiAgICB9XG5cbiAgICAvLyAzLiBSZXR1cm4gdGhlIGluZGV4IHBvaW50ZXIgZm9yIGNvZGUgcG9pbnQgaW4gaW5kZXguXG4gICAgcmV0dXJuIGluZGV4UG9pbnRlckZvcihjb2RlX3BvaW50LCBpbmRleF8pO1xuICB9XG4gIHZhciBiaWc1X2luZGV4X25vX2hrc2NzO1xuXG4gIC8vXG4gIC8vIDguIEFQSVxuICAvL1xuXG4gIC8qKiBAY29uc3QgKi8gdmFyIERFRkFVTFRfRU5DT0RJTkcgPSAndXRmLTgnO1xuXG4gIC8vIDguMSBJbnRlcmZhY2UgVGV4dERlY29kZXJcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gbGFiZWwgVGhlIGxhYmVsIG9mIHRoZSBlbmNvZGluZztcbiAgICogICAgIGRlZmF1bHRzIHRvICd1dGYtOCcuXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gVGV4dERlY29kZXIobGFiZWwsIG9wdGlvbnMpIHtcbiAgICAvLyBXZWIgSURMIGNvbnZlbnRpb25zXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRleHREZWNvZGVyKSlcbiAgICAgIHRocm93IFR5cGVFcnJvcignQ2FsbGVkIGFzIGEgZnVuY3Rpb24uIERpZCB5b3UgZm9yZ2V0IFxcJ25ld1xcJz8nKTtcbiAgICBsYWJlbCA9IGxhYmVsICE9PSB1bmRlZmluZWQgPyBTdHJpbmcobGFiZWwpIDogREVGQVVMVF9FTkNPRElORztcbiAgICBvcHRpb25zID0gVG9EaWN0aW9uYXJ5KG9wdGlvbnMpO1xuXG4gICAgLy8gQSBUZXh0RGVjb2RlciBvYmplY3QgaGFzIGFuIGFzc29jaWF0ZWQgZW5jb2RpbmcsIGRlY29kZXIsXG4gICAgLy8gc3RyZWFtLCBpZ25vcmUgQk9NIGZsYWcgKGluaXRpYWxseSB1bnNldCksIEJPTSBzZWVuIGZsYWdcbiAgICAvLyAoaW5pdGlhbGx5IHVuc2V0KSwgZXJyb3IgbW9kZSAoaW5pdGlhbGx5IHJlcGxhY2VtZW50KSwgYW5kIGRvXG4gICAgLy8gbm90IGZsdXNoIGZsYWcgKGluaXRpYWxseSB1bnNldCkuXG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICB0aGlzLl9lbmNvZGluZyA9IG51bGw7XG4gICAgLyoqIEBwcml2YXRlIEB0eXBlIHs/RGVjb2Rlcn0gKi9cbiAgICB0aGlzLl9kZWNvZGVyID0gbnVsbDtcbiAgICAvKiogQHByaXZhdGUgQHR5cGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5faWdub3JlQk9NID0gZmFsc2U7XG4gICAgLyoqIEBwcml2YXRlIEB0eXBlIHtib29sZWFufSAqL1xuICAgIHRoaXMuX0JPTXNlZW4gPSBmYWxzZTtcbiAgICAvKiogQHByaXZhdGUgQHR5cGUge3N0cmluZ30gKi9cbiAgICB0aGlzLl9lcnJvcl9tb2RlID0gJ3JlcGxhY2VtZW50JztcbiAgICAvKiogQHByaXZhdGUgQHR5cGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5fZG9fbm90X2ZsdXNoID0gZmFsc2U7XG5cblxuICAgIC8vIDEuIExldCBlbmNvZGluZyBiZSB0aGUgcmVzdWx0IG9mIGdldHRpbmcgYW4gZW5jb2RpbmcgZnJvbVxuICAgIC8vIGxhYmVsLlxuICAgIHZhciBlbmNvZGluZyA9IGdldEVuY29kaW5nKGxhYmVsKTtcblxuICAgIC8vIDIuIElmIGVuY29kaW5nIGlzIGZhaWx1cmUgb3IgcmVwbGFjZW1lbnQsIHRocm93IGEgUmFuZ2VFcnJvci5cbiAgICBpZiAoZW5jb2RpbmcgPT09IG51bGwgfHwgZW5jb2RpbmcubmFtZSA9PT0gJ3JlcGxhY2VtZW50JylcbiAgICAgIHRocm93IFJhbmdlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBsYWJlbCk7XG4gICAgaWYgKCFkZWNvZGVyc1tlbmNvZGluZy5uYW1lXSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0RlY29kZXIgbm90IHByZXNlbnQuJyArXG4gICAgICAgICAgICAgICAgICAnIERpZCB5b3UgZm9yZ2V0IHRvIGluY2x1ZGUgZW5jb2RpbmctaW5kZXhlcy5qcyBmaXJzdD8nKTtcbiAgICB9XG5cbiAgICAvLyAzLiBMZXQgZGVjIGJlIGEgbmV3IFRleHREZWNvZGVyIG9iamVjdC5cbiAgICB2YXIgZGVjID0gdGhpcztcblxuICAgIC8vIDQuIFNldCBkZWMncyBlbmNvZGluZyB0byBlbmNvZGluZy5cbiAgICBkZWMuX2VuY29kaW5nID0gZW5jb2Rpbmc7XG5cbiAgICAvLyA1LiBJZiBvcHRpb25zJ3MgZmF0YWwgbWVtYmVyIGlzIHRydWUsIHNldCBkZWMncyBlcnJvciBtb2RlIHRvXG4gICAgLy8gZmF0YWwuXG4gICAgaWYgKEJvb2xlYW4ob3B0aW9uc1snZmF0YWwnXSkpXG4gICAgICBkZWMuX2Vycm9yX21vZGUgPSAnZmF0YWwnO1xuXG4gICAgLy8gNi4gSWYgb3B0aW9ucydzIGlnbm9yZUJPTSBtZW1iZXIgaXMgdHJ1ZSwgc2V0IGRlYydzIGlnbm9yZSBCT01cbiAgICAvLyBmbGFnLlxuICAgIGlmIChCb29sZWFuKG9wdGlvbnNbJ2lnbm9yZUJPTSddKSlcbiAgICAgIGRlYy5faWdub3JlQk9NID0gdHJ1ZTtcblxuICAgIC8vIEZvciBwcmUtRVM1IHJ1bnRpbWVzOlxuICAgIGlmICghT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7XG4gICAgICB0aGlzLmVuY29kaW5nID0gZGVjLl9lbmNvZGluZy5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICB0aGlzLmZhdGFsID0gZGVjLl9lcnJvcl9tb2RlID09PSAnZmF0YWwnO1xuICAgICAgdGhpcy5pZ25vcmVCT00gPSBkZWMuX2lnbm9yZUJPTTtcbiAgICB9XG5cbiAgICAvLyA3LiBSZXR1cm4gZGVjLlxuICAgIHJldHVybiBkZWM7XG4gIH1cblxuICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7XG4gICAgLy8gVGhlIGVuY29kaW5nIGF0dHJpYnV0ZSdzIGdldHRlciBtdXN0IHJldHVybiBlbmNvZGluZydzIG5hbWUuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRleHREZWNvZGVyLnByb3RvdHlwZSwgJ2VuY29kaW5nJywge1xuICAgICAgLyoqIEB0aGlzIHtUZXh0RGVjb2Rlcn0gKi9cbiAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9lbmNvZGluZy5uYW1lLnRvTG93ZXJDYXNlKCk7IH1cbiAgICB9KTtcblxuICAgIC8vIFRoZSBmYXRhbCBhdHRyaWJ1dGUncyBnZXR0ZXIgbXVzdCByZXR1cm4gdHJ1ZSBpZiBlcnJvciBtb2RlXG4gICAgLy8gaXMgZmF0YWwsIGFuZCBmYWxzZSBvdGhlcndpc2UuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRleHREZWNvZGVyLnByb3RvdHlwZSwgJ2ZhdGFsJywge1xuICAgICAgLyoqIEB0aGlzIHtUZXh0RGVjb2Rlcn0gKi9cbiAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9lcnJvcl9tb2RlID09PSAnZmF0YWwnOyB9XG4gICAgfSk7XG5cbiAgICAvLyBUaGUgaWdub3JlQk9NIGF0dHJpYnV0ZSdzIGdldHRlciBtdXN0IHJldHVybiB0cnVlIGlmIGlnbm9yZVxuICAgIC8vIEJPTSBmbGFnIGlzIHNldCwgYW5kIGZhbHNlIG90aGVyd2lzZS5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGV4dERlY29kZXIucHJvdG90eXBlLCAnaWdub3JlQk9NJywge1xuICAgICAgLyoqIEB0aGlzIHtUZXh0RGVjb2Rlcn0gKi9cbiAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9pZ25vcmVCT007IH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0J1ZmZlclNvdXJjZT19IGlucHV0IFRoZSBidWZmZXIgb2YgYnl0ZXMgdG8gZGVjb2RlLlxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgZGVjb2RlZCBzdHJpbmcuXG4gICAqL1xuICBUZXh0RGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgdmFyIGJ5dGVzO1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmIGlucHV0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiAnYnVmZmVyJyBpbiBpbnB1dCAmJlxuICAgICAgICAgICAgICAgaW5wdXQuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXQuYnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5ieXRlT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5ieXRlTGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheSgwKTtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gVG9EaWN0aW9uYXJ5KG9wdGlvbnMpO1xuXG4gICAgLy8gMS4gSWYgdGhlIGRvIG5vdCBmbHVzaCBmbGFnIGlzIHVuc2V0LCBzZXQgZGVjb2RlciB0byBhIG5ld1xuICAgIC8vIGVuY29kaW5nJ3MgZGVjb2Rlciwgc2V0IHN0cmVhbSB0byBhIG5ldyBzdHJlYW0sIGFuZCB1bnNldCB0aGVcbiAgICAvLyBCT00gc2VlbiBmbGFnLlxuICAgIGlmICghdGhpcy5fZG9fbm90X2ZsdXNoKSB7XG4gICAgICB0aGlzLl9kZWNvZGVyID0gZGVjb2RlcnNbdGhpcy5fZW5jb2RpbmcubmFtZV0oe1xuICAgICAgICBmYXRhbDogdGhpcy5fZXJyb3JfbW9kZSA9PT0gJ2ZhdGFsJ30pO1xuICAgICAgdGhpcy5fQk9Nc2VlbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIDIuIElmIG9wdGlvbnMncyBzdHJlYW0gaXMgdHJ1ZSwgc2V0IHRoZSBkbyBub3QgZmx1c2ggZmxhZywgYW5kXG4gICAgLy8gdW5zZXQgdGhlIGRvIG5vdCBmbHVzaCBmbGFnIG90aGVyd2lzZS5cbiAgICB0aGlzLl9kb19ub3RfZmx1c2ggPSBCb29sZWFuKG9wdGlvbnNbJ3N0cmVhbSddKTtcblxuICAgIC8vIDMuIElmIGlucHV0IGlzIGdpdmVuLCBwdXNoIGEgY29weSBvZiBpbnB1dCB0byBzdHJlYW0uXG4gICAgLy8gVE9ETzogQWxpZ24gd2l0aCBzcGVjIGFsZ29yaXRobSAtIG1haW50YWluIHN0cmVhbSBvbiBpbnN0YW5jZS5cbiAgICB2YXIgaW5wdXRfc3RyZWFtID0gbmV3IFN0cmVhbShieXRlcyk7XG5cbiAgICAvLyA0LiBMZXQgb3V0cHV0IGJlIGEgbmV3IHN0cmVhbS5cbiAgICB2YXIgb3V0cHV0ID0gW107XG5cbiAgICAvKiogQHR5cGUgez8obnVtYmVyfCFBcnJheS48bnVtYmVyPil9ICovXG4gICAgdmFyIHJlc3VsdDtcblxuICAgIC8vIDUuIFdoaWxlIHRydWU6XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIC8vIDEuIExldCB0b2tlbiBiZSB0aGUgcmVzdWx0IG9mIHJlYWRpbmcgZnJvbSBzdHJlYW0uXG4gICAgICB2YXIgdG9rZW4gPSBpbnB1dF9zdHJlYW0ucmVhZCgpO1xuXG4gICAgICAvLyAyLiBJZiB0b2tlbiBpcyBlbmQtb2Ytc3RyZWFtIGFuZCB0aGUgZG8gbm90IGZsdXNoIGZsYWcgaXNcbiAgICAgIC8vIHNldCwgcmV0dXJuIG91dHB1dCwgc2VyaWFsaXplZC5cbiAgICAgIC8vIFRPRE86IEFsaWduIHdpdGggc3BlYyBhbGdvcml0aG0uXG4gICAgICBpZiAodG9rZW4gPT09IGVuZF9vZl9zdHJlYW0pXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAvLyAzLiBPdGhlcndpc2UsIHJ1biB0aGVzZSBzdWJzdWJzdGVwczpcblxuICAgICAgLy8gMS4gTGV0IHJlc3VsdCBiZSB0aGUgcmVzdWx0IG9mIHByb2Nlc3NpbmcgdG9rZW4gZm9yIGRlY29kZXIsXG4gICAgICAvLyBzdHJlYW0sIG91dHB1dCwgYW5kIGVycm9yIG1vZGUuXG4gICAgICByZXN1bHQgPSB0aGlzLl9kZWNvZGVyLmhhbmRsZXIoaW5wdXRfc3RyZWFtLCB0b2tlbik7XG5cbiAgICAgIC8vIDIuIElmIHJlc3VsdCBpcyBmaW5pc2hlZCwgcmV0dXJuIG91dHB1dCwgc2VyaWFsaXplZC5cbiAgICAgIGlmIChyZXN1bHQgPT09IGZpbmlzaGVkKVxuICAgICAgICBicmVhaztcblxuICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKVxuICAgICAgICAgIG91dHB1dC5wdXNoLmFwcGx5KG91dHB1dCwgLyoqQHR5cGUgeyFBcnJheS48bnVtYmVyPn0qLyhyZXN1bHQpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG91dHB1dC5wdXNoKHJlc3VsdCk7XG4gICAgICB9XG5cbiAgICAgIC8vIDMuIE90aGVyd2lzZSwgaWYgcmVzdWx0IGlzIGVycm9yLCB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAgIC8vIChUaHJvd24gaW4gaGFuZGxlcilcblxuICAgICAgLy8gNC4gT3RoZXJ3aXNlLCBkbyBub3RoaW5nLlxuICAgIH1cbiAgICAvLyBUT0RPOiBBbGlnbiB3aXRoIHNwZWMgYWxnb3JpdGhtLlxuICAgIGlmICghdGhpcy5fZG9fbm90X2ZsdXNoKSB7XG4gICAgICBkbyB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX2RlY29kZXIuaGFuZGxlcihpbnB1dF9zdHJlYW0sIGlucHV0X3N0cmVhbS5yZWFkKCkpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBmaW5pc2hlZClcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbClcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSlcbiAgICAgICAgICBvdXRwdXQucHVzaC5hcHBseShvdXRwdXQsIC8qKkB0eXBlIHshQXJyYXkuPG51bWJlcj59Ki8ocmVzdWx0KSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBvdXRwdXQucHVzaChyZXN1bHQpO1xuICAgICAgfSB3aGlsZSAoIWlucHV0X3N0cmVhbS5lbmRPZlN0cmVhbSgpKTtcbiAgICAgIHRoaXMuX2RlY29kZXIgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIEEgVGV4dERlY29kZXIgb2JqZWN0IGFsc28gaGFzIGFuIGFzc29jaWF0ZWQgc2VyaWFsaXplIHN0cmVhbVxuICAgIC8vIGFsZ29yaXRobS4uLlxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IUFycmF5LjxudW1iZXI+fSBzdHJlYW1cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICogQHRoaXMge1RleHREZWNvZGVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZVN0cmVhbShzdHJlYW0pIHtcbiAgICAgIC8vIDEuIExldCB0b2tlbiBiZSB0aGUgcmVzdWx0IG9mIHJlYWRpbmcgZnJvbSBzdHJlYW0uXG4gICAgICAvLyAoRG9uZSBpbi1wbGFjZSBvbiBhcnJheSwgcmF0aGVyIHRoYW4gYXMgYSBzdHJlYW0pXG5cbiAgICAgIC8vIDIuIElmIGVuY29kaW5nIGlzIFVURi04LCBVVEYtMTZCRSwgb3IgVVRGLTE2TEUsIGFuZCBpZ25vcmVcbiAgICAgIC8vIEJPTSBmbGFnIGFuZCBCT00gc2VlbiBmbGFnIGFyZSB1bnNldCwgcnVuIHRoZXNlIHN1YnN1YnN0ZXBzOlxuICAgICAgaWYgKGluY2x1ZGVzKFsnVVRGLTgnLCAnVVRGLTE2TEUnLCAnVVRGLTE2QkUnXSwgdGhpcy5fZW5jb2RpbmcubmFtZSkgJiZcbiAgICAgICAgICAhdGhpcy5faWdub3JlQk9NICYmICF0aGlzLl9CT01zZWVuKSB7XG4gICAgICAgIGlmIChzdHJlYW0ubGVuZ3RoID4gMCAmJiBzdHJlYW1bMF0gPT09IDB4RkVGRikge1xuICAgICAgICAgIC8vIDEuIElmIHRva2VuIGlzIFUrRkVGRiwgc2V0IEJPTSBzZWVuIGZsYWcuXG4gICAgICAgICAgdGhpcy5fQk9Nc2VlbiA9IHRydWU7XG4gICAgICAgICAgc3RyZWFtLnNoaWZ0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyAyLiBPdGhlcndpc2UsIGlmIHRva2VuIGlzIG5vdCBlbmQtb2Ytc3RyZWFtLCBzZXQgQk9NIHNlZW5cbiAgICAgICAgICAvLyBmbGFnIGFuZCBhcHBlbmQgdG9rZW4gdG8gc3RyZWFtLlxuICAgICAgICAgIHRoaXMuX0JPTXNlZW4gPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIDMuIE90aGVyd2lzZSwgaWYgdG9rZW4gaXMgbm90IGVuZC1vZi1zdHJlYW0sIGFwcGVuZCB0b2tlblxuICAgICAgICAgIC8vIHRvIG91dHB1dC5cbiAgICAgICAgICAvLyAobm8tb3ApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIDQuIE90aGVyd2lzZSwgcmV0dXJuIG91dHB1dC5cbiAgICAgIHJldHVybiBjb2RlUG9pbnRzVG9TdHJpbmcoc3RyZWFtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VyaWFsaXplU3RyZWFtLmNhbGwodGhpcywgb3V0cHV0KTtcbiAgfTtcblxuICAvLyA4LjIgSW50ZXJmYWNlIFRleHRFbmNvZGVyXG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge3N0cmluZz19IGxhYmVsIFRoZSBsYWJlbCBvZiB0aGUgZW5jb2RpbmcuIE5PTlNUQU5EQVJELlxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgTk9OU1RBTkRBUkQuXG4gICAqL1xuICBmdW5jdGlvbiBUZXh0RW5jb2RlcihsYWJlbCwgb3B0aW9ucykge1xuICAgIC8vIFdlYiBJREwgY29udmVudGlvbnNcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVGV4dEVuY29kZXIpKVxuICAgICAgdGhyb3cgVHlwZUVycm9yKCdDYWxsZWQgYXMgYSBmdW5jdGlvbi4gRGlkIHlvdSBmb3JnZXQgXFwnbmV3XFwnPycpO1xuICAgIG9wdGlvbnMgPSBUb0RpY3Rpb25hcnkob3B0aW9ucyk7XG5cbiAgICAvLyBBIFRleHRFbmNvZGVyIG9iamVjdCBoYXMgYW4gYXNzb2NpYXRlZCBlbmNvZGluZyBhbmQgZW5jb2Rlci5cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHRoaXMuX2VuY29kaW5nID0gbnVsbDtcbiAgICAvKiogQHByaXZhdGUgQHR5cGUgez9FbmNvZGVyfSAqL1xuICAgIHRoaXMuX2VuY29kZXIgPSBudWxsO1xuXG4gICAgLy8gTm9uLXN0YW5kYXJkXG4gICAgLyoqIEBwcml2YXRlIEB0eXBlIHtib29sZWFufSAqL1xuICAgIHRoaXMuX2RvX25vdF9mbHVzaCA9IGZhbHNlO1xuICAgIC8qKiBAcHJpdmF0ZSBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIHRoaXMuX2ZhdGFsID0gQm9vbGVhbihvcHRpb25zWydmYXRhbCddKSA/ICdmYXRhbCcgOiAncmVwbGFjZW1lbnQnO1xuXG4gICAgLy8gMS4gTGV0IGVuYyBiZSBhIG5ldyBUZXh0RW5jb2RlciBvYmplY3QuXG4gICAgdmFyIGVuYyA9IHRoaXM7XG5cbiAgICAvLyAyLiBTZXQgZW5jJ3MgZW5jb2RpbmcgdG8gVVRGLTgncyBlbmNvZGVyLlxuICAgIGlmIChCb29sZWFuKG9wdGlvbnNbJ05PTlNUQU5EQVJEX2FsbG93TGVnYWN5RW5jb2RpbmcnXSkpIHtcbiAgICAgIC8vIE5PTlNUQU5EQVJEIGJlaGF2aW9yLlxuICAgICAgbGFiZWwgPSBsYWJlbCAhPT0gdW5kZWZpbmVkID8gU3RyaW5nKGxhYmVsKSA6IERFRkFVTFRfRU5DT0RJTkc7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBnZXRFbmNvZGluZyhsYWJlbCk7XG4gICAgICBpZiAoZW5jb2RpbmcgPT09IG51bGwgfHwgZW5jb2RpbmcubmFtZSA9PT0gJ3JlcGxhY2VtZW50JylcbiAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGxhYmVsKTtcbiAgICAgIGlmICghZW5jb2RlcnNbZW5jb2RpbmcubmFtZV0pIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0VuY29kZXIgbm90IHByZXNlbnQuJyArXG4gICAgICAgICAgICAgICAgICAgICcgRGlkIHlvdSBmb3JnZXQgdG8gaW5jbHVkZSBlbmNvZGluZy1pbmRleGVzLmpzIGZpcnN0PycpO1xuICAgICAgfVxuICAgICAgZW5jLl9lbmNvZGluZyA9IGVuY29kaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGFuZGFyZCBiZWhhdmlvci5cbiAgICAgIGVuYy5fZW5jb2RpbmcgPSBnZXRFbmNvZGluZygndXRmLTgnKTtcblxuICAgICAgaWYgKGxhYmVsICE9PSB1bmRlZmluZWQgJiYgJ2NvbnNvbGUnIGluIGdsb2JhbCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RleHRFbmNvZGVyIGNvbnN0cnVjdG9yIGNhbGxlZCB3aXRoIGVuY29kaW5nIGxhYmVsLCAnXG4gICAgICAgICAgICAgICAgICAgICArICd3aGljaCBpcyBpZ25vcmVkLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZvciBwcmUtRVM1IHJ1bnRpbWVzOlxuICAgIGlmICghT2JqZWN0LmRlZmluZVByb3BlcnR5KVxuICAgICAgdGhpcy5lbmNvZGluZyA9IGVuYy5fZW5jb2RpbmcubmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gMy4gUmV0dXJuIGVuYy5cbiAgICByZXR1cm4gZW5jO1xuICB9XG5cbiAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICAgIC8vIFRoZSBlbmNvZGluZyBhdHRyaWJ1dGUncyBnZXR0ZXIgbXVzdCByZXR1cm4gZW5jb2RpbmcncyBuYW1lLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZXh0RW5jb2Rlci5wcm90b3R5cGUsICdlbmNvZGluZycsIHtcbiAgICAgIC8qKiBAdGhpcyB7VGV4dEVuY29kZXJ9ICovXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fZW5jb2RpbmcubmFtZS50b0xvd2VyQ2FzZSgpOyB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfc3RyaW5nIFRoZSBzdHJpbmcgdG8gZW5jb2RlLlxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAgICogQHJldHVybiB7IVVpbnQ4QXJyYXl9IEVuY29kZWQgYnl0ZXMsIGFzIGEgVWludDhBcnJheS5cbiAgICovXG4gIFRleHRFbmNvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUob3B0X3N0cmluZywgb3B0aW9ucykge1xuICAgIG9wdF9zdHJpbmcgPSBvcHRfc3RyaW5nID09PSB1bmRlZmluZWQgPyAnJyA6IFN0cmluZyhvcHRfc3RyaW5nKTtcbiAgICBvcHRpb25zID0gVG9EaWN0aW9uYXJ5KG9wdGlvbnMpO1xuXG4gICAgLy8gTk9URTogVGhpcyBvcHRpb24gaXMgbm9uc3RhbmRhcmQuIE5vbmUgb2YgdGhlIGVuY29kaW5nc1xuICAgIC8vIHBlcm1pdHRlZCBmb3IgZW5jb2RpbmcgKGkuZS4gVVRGLTgsIFVURi0xNikgYXJlIHN0YXRlZnVsIHdoZW5cbiAgICAvLyB0aGUgaW5wdXQgaXMgYSBVU1ZTdHJpbmcgc28gc3RyZWFtaW5nIGlzIG5vdCBuZWNlc3NhcnkuXG4gICAgaWYgKCF0aGlzLl9kb19ub3RfZmx1c2gpXG4gICAgICB0aGlzLl9lbmNvZGVyID0gZW5jb2RlcnNbdGhpcy5fZW5jb2RpbmcubmFtZV0oe1xuICAgICAgICBmYXRhbDogdGhpcy5fZmF0YWwgPT09ICdmYXRhbCd9KTtcbiAgICB0aGlzLl9kb19ub3RfZmx1c2ggPSBCb29sZWFuKG9wdGlvbnNbJ3N0cmVhbSddKTtcblxuICAgIC8vIDEuIENvbnZlcnQgaW5wdXQgdG8gYSBzdHJlYW0uXG4gICAgdmFyIGlucHV0ID0gbmV3IFN0cmVhbShzdHJpbmdUb0NvZGVQb2ludHMob3B0X3N0cmluZykpO1xuXG4gICAgLy8gMi4gTGV0IG91dHB1dCBiZSBhIG5ldyBzdHJlYW1cbiAgICB2YXIgb3V0cHV0ID0gW107XG5cbiAgICAvKiogQHR5cGUgez8obnVtYmVyfCFBcnJheS48bnVtYmVyPil9ICovXG4gICAgdmFyIHJlc3VsdDtcbiAgICAvLyAzLiBXaGlsZSB0cnVlLCBydW4gdGhlc2Ugc3Vic3RlcHM6XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIC8vIDEuIExldCB0b2tlbiBiZSB0aGUgcmVzdWx0IG9mIHJlYWRpbmcgZnJvbSBpbnB1dC5cbiAgICAgIHZhciB0b2tlbiA9IGlucHV0LnJlYWQoKTtcbiAgICAgIGlmICh0b2tlbiA9PT0gZW5kX29mX3N0cmVhbSlcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyAyLiBMZXQgcmVzdWx0IGJlIHRoZSByZXN1bHQgb2YgcHJvY2Vzc2luZyB0b2tlbiBmb3IgZW5jb2RlcixcbiAgICAgIC8vIGlucHV0LCBvdXRwdXQuXG4gICAgICByZXN1bHQgPSB0aGlzLl9lbmNvZGVyLmhhbmRsZXIoaW5wdXQsIHRva2VuKTtcbiAgICAgIGlmIChyZXN1bHQgPT09IGZpbmlzaGVkKVxuICAgICAgICBicmVhaztcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpXG4gICAgICAgIG91dHB1dC5wdXNoLmFwcGx5KG91dHB1dCwgLyoqQHR5cGUgeyFBcnJheS48bnVtYmVyPn0qLyhyZXN1bHQpKTtcbiAgICAgIGVsc2VcbiAgICAgICAgb3V0cHV0LnB1c2gocmVzdWx0KTtcbiAgICB9XG4gICAgLy8gVE9ETzogQWxpZ24gd2l0aCBzcGVjIGFsZ29yaXRobS5cbiAgICBpZiAoIXRoaXMuX2RvX25vdF9mbHVzaCkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5fZW5jb2Rlci5oYW5kbGVyKGlucHV0LCBpbnB1dC5yZWFkKCkpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBmaW5pc2hlZClcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSlcbiAgICAgICAgICBvdXRwdXQucHVzaC5hcHBseShvdXRwdXQsIC8qKkB0eXBlIHshQXJyYXkuPG51bWJlcj59Ki8ocmVzdWx0KSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBvdXRwdXQucHVzaChyZXN1bHQpO1xuICAgICAgfVxuICAgICAgdGhpcy5fZW5jb2RlciA9IG51bGw7XG4gICAgfVxuICAgIC8vIDMuIElmIHJlc3VsdCBpcyBmaW5pc2hlZCwgY29udmVydCBvdXRwdXQgaW50byBhIGJ5dGUgc2VxdWVuY2UsXG4gICAgLy8gYW5kIHRoZW4gcmV0dXJuIGEgVWludDhBcnJheSBvYmplY3Qgd3JhcHBpbmcgYW4gQXJyYXlCdWZmZXJcbiAgICAvLyBjb250YWluaW5nIG91dHB1dC5cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkob3V0cHV0KTtcbiAgfTtcblxuXG4gIC8vXG4gIC8vIDkuIFRoZSBlbmNvZGluZ1xuICAvL1xuXG4gIC8vIDkuMSB1dGYtOFxuXG4gIC8vIDkuMS4xIHV0Zi04IGRlY29kZXJcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAaW1wbGVtZW50cyB7RGVjb2Rlcn1cbiAgICogQHBhcmFtIHt7ZmF0YWw6IGJvb2xlYW59fSBvcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBVVEY4RGVjb2RlcihvcHRpb25zKSB7XG4gICAgdmFyIGZhdGFsID0gb3B0aW9ucy5mYXRhbDtcblxuICAgIC8vIHV0Zi04J3MgZGVjb2RlcidzIGhhcyBhbiBhc3NvY2lhdGVkIHV0Zi04IGNvZGUgcG9pbnQsIHV0Zi04XG4gICAgLy8gYnl0ZXMgc2VlbiwgYW5kIHV0Zi04IGJ5dGVzIG5lZWRlZCAoYWxsIGluaXRpYWxseSAwKSwgYSB1dGYtOFxuICAgIC8vIGxvd2VyIGJvdW5kYXJ5IChpbml0aWFsbHkgMHg4MCksIGFuZCBhIHV0Zi04IHVwcGVyIGJvdW5kYXJ5XG4gICAgLy8gKGluaXRpYWxseSAweEJGKS5cbiAgICB2YXIgLyoqIEB0eXBlIHtudW1iZXJ9ICovIHV0ZjhfY29kZV9wb2ludCA9IDAsXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyB1dGY4X2J5dGVzX3NlZW4gPSAwLFxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi8gdXRmOF9ieXRlc19uZWVkZWQgPSAwLFxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi8gdXRmOF9sb3dlcl9ib3VuZGFyeSA9IDB4ODAsXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyB1dGY4X3VwcGVyX2JvdW5kYXJ5ID0gMHhCRjtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyZWFtfSBzdHJlYW0gVGhlIHN0cmVhbSBvZiBieXRlcyBiZWluZyBkZWNvZGVkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRlIFRoZSBuZXh0IGJ5dGUgcmVhZCBmcm9tIHRoZSBzdHJlYW0uXG4gICAgICogQHJldHVybiB7PyhudW1iZXJ8IUFycmF5LjxudW1iZXI+KX0gVGhlIG5leHQgY29kZSBwb2ludChzKVxuICAgICAqICAgICBkZWNvZGVkLCBvciBudWxsIGlmIG5vdCBlbm91Z2ggZGF0YSBleGlzdHMgaW4gdGhlIGlucHV0XG4gICAgICogICAgIHN0cmVhbSB0byBkZWNvZGUgYSBjb21wbGV0ZSBjb2RlIHBvaW50LlxuICAgICAqL1xuICAgIHRoaXMuaGFuZGxlciA9IGZ1bmN0aW9uKHN0cmVhbSwgYml0ZSkge1xuICAgICAgLy8gMS4gSWYgYnl0ZSBpcyBlbmQtb2Ytc3RyZWFtIGFuZCB1dGYtOCBieXRlcyBuZWVkZWQgaXMgbm90IDAsXG4gICAgICAvLyBzZXQgdXRmLTggYnl0ZXMgbmVlZGVkIHRvIDAgYW5kIHJldHVybiBlcnJvci5cbiAgICAgIGlmIChiaXRlID09PSBlbmRfb2Zfc3RyZWFtICYmIHV0ZjhfYnl0ZXNfbmVlZGVkICE9PSAwKSB7XG4gICAgICAgIHV0ZjhfYnl0ZXNfbmVlZGVkID0gMDtcbiAgICAgICAgcmV0dXJuIGRlY29kZXJFcnJvcihmYXRhbCk7XG4gICAgICB9XG5cbiAgICAgIC8vIDIuIElmIGJ5dGUgaXMgZW5kLW9mLXN0cmVhbSwgcmV0dXJuIGZpbmlzaGVkLlxuICAgICAgaWYgKGJpdGUgPT09IGVuZF9vZl9zdHJlYW0pXG4gICAgICAgIHJldHVybiBmaW5pc2hlZDtcblxuICAgICAgLy8gMy4gSWYgdXRmLTggYnl0ZXMgbmVlZGVkIGlzIDAsIGJhc2VkIG9uIGJ5dGU6XG4gICAgICBpZiAodXRmOF9ieXRlc19uZWVkZWQgPT09IDApIHtcblxuICAgICAgICAvLyAweDAwIHRvIDB4N0ZcbiAgICAgICAgaWYgKGluUmFuZ2UoYml0ZSwgMHgwMCwgMHg3RikpIHtcbiAgICAgICAgICAvLyBSZXR1cm4gYSBjb2RlIHBvaW50IHdob3NlIHZhbHVlIGlzIGJ5dGUuXG4gICAgICAgICAgcmV0dXJuIGJpdGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAweEMyIHRvIDB4REZcbiAgICAgICAgZWxzZSBpZiAoaW5SYW5nZShiaXRlLCAweEMyLCAweERGKSkge1xuICAgICAgICAgIC8vIDEuIFNldCB1dGYtOCBieXRlcyBuZWVkZWQgdG8gMS5cbiAgICAgICAgICB1dGY4X2J5dGVzX25lZWRlZCA9IDE7XG5cbiAgICAgICAgICAvLyAyLiBTZXQgVVRGLTggY29kZSBwb2ludCB0byBieXRlICYgMHgxRi5cbiAgICAgICAgICB1dGY4X2NvZGVfcG9pbnQgPSBiaXRlICYgMHgxRjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDB4RTAgdG8gMHhFRlxuICAgICAgICBlbHNlIGlmIChpblJhbmdlKGJpdGUsIDB4RTAsIDB4RUYpKSB7XG4gICAgICAgICAgLy8gMS4gSWYgYnl0ZSBpcyAweEUwLCBzZXQgdXRmLTggbG93ZXIgYm91bmRhcnkgdG8gMHhBMC5cbiAgICAgICAgICBpZiAoYml0ZSA9PT0gMHhFMClcbiAgICAgICAgICAgIHV0ZjhfbG93ZXJfYm91bmRhcnkgPSAweEEwO1xuICAgICAgICAgIC8vIDIuIElmIGJ5dGUgaXMgMHhFRCwgc2V0IHV0Zi04IHVwcGVyIGJvdW5kYXJ5IHRvIDB4OUYuXG4gICAgICAgICAgaWYgKGJpdGUgPT09IDB4RUQpXG4gICAgICAgICAgICB1dGY4X3VwcGVyX2JvdW5kYXJ5ID0gMHg5RjtcbiAgICAgICAgICAvLyAzLiBTZXQgdXRmLTggYnl0ZXMgbmVlZGVkIHRvIDIuXG4gICAgICAgICAgdXRmOF9ieXRlc19uZWVkZWQgPSAyO1xuICAgICAgICAgIC8vIDQuIFNldCBVVEYtOCBjb2RlIHBvaW50IHRvIGJ5dGUgJiAweEYuXG4gICAgICAgICAgdXRmOF9jb2RlX3BvaW50ID0gYml0ZSAmIDB4RjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDB4RjAgdG8gMHhGNFxuICAgICAgICBlbHNlIGlmIChpblJhbmdlKGJpdGUsIDB4RjAsIDB4RjQpKSB7XG4gICAgICAgICAgLy8gMS4gSWYgYnl0ZSBpcyAweEYwLCBzZXQgdXRmLTggbG93ZXIgYm91bmRhcnkgdG8gMHg5MC5cbiAgICAgICAgICBpZiAoYml0ZSA9PT0gMHhGMClcbiAgICAgICAgICAgIHV0ZjhfbG93ZXJfYm91bmRhcnkgPSAweDkwO1xuICAgICAgICAgIC8vIDIuIElmIGJ5dGUgaXMgMHhGNCwgc2V0IHV0Zi04IHVwcGVyIGJvdW5kYXJ5IHRvIDB4OEYuXG4gICAgICAgICAgaWYgKGJpdGUgPT09IDB4RjQpXG4gICAgICAgICAgICB1dGY4X3VwcGVyX2JvdW5kYXJ5ID0gMHg4RjtcbiAgICAgICAgICAvLyAzLiBTZXQgdXRmLTggYnl0ZXMgbmVlZGVkIHRvIDMuXG4gICAgICAgICAgdXRmOF9ieXRlc19uZWVkZWQgPSAzO1xuICAgICAgICAgIC8vIDQuIFNldCBVVEYtOCBjb2RlIHBvaW50IHRvIGJ5dGUgJiAweDcuXG4gICAgICAgICAgdXRmOF9jb2RlX3BvaW50ID0gYml0ZSAmIDB4NztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE90aGVyd2lzZVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBSZXR1cm4gZXJyb3IuXG4gICAgICAgICAgcmV0dXJuIGRlY29kZXJFcnJvcihmYXRhbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXR1cm4gY29udGludWUuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyA0LiBJZiBieXRlIGlzIG5vdCBpbiB0aGUgcmFuZ2UgdXRmLTggbG93ZXIgYm91bmRhcnkgdG8gdXRmLThcbiAgICAgIC8vIHVwcGVyIGJvdW5kYXJ5LCBpbmNsdXNpdmUsIHJ1biB0aGVzZSBzdWJzdGVwczpcbiAgICAgIGlmICghaW5SYW5nZShiaXRlLCB1dGY4X2xvd2VyX2JvdW5kYXJ5LCB1dGY4X3VwcGVyX2JvdW5kYXJ5KSkge1xuXG4gICAgICAgIC8vIDEuIFNldCB1dGYtOCBjb2RlIHBvaW50LCB1dGYtOCBieXRlcyBuZWVkZWQsIGFuZCB1dGYtOFxuICAgICAgICAvLyBieXRlcyBzZWVuIHRvIDAsIHNldCB1dGYtOCBsb3dlciBib3VuZGFyeSB0byAweDgwLCBhbmQgc2V0XG4gICAgICAgIC8vIHV0Zi04IHVwcGVyIGJvdW5kYXJ5IHRvIDB4QkYuXG4gICAgICAgIHV0ZjhfY29kZV9wb2ludCA9IHV0ZjhfYnl0ZXNfbmVlZGVkID0gdXRmOF9ieXRlc19zZWVuID0gMDtcbiAgICAgICAgdXRmOF9sb3dlcl9ib3VuZGFyeSA9IDB4ODA7XG4gICAgICAgIHV0ZjhfdXBwZXJfYm91bmRhcnkgPSAweEJGO1xuXG4gICAgICAgIC8vIDIuIFByZXBlbmQgYnl0ZSB0byBzdHJlYW0uXG4gICAgICAgIHN0cmVhbS5wcmVwZW5kKGJpdGUpO1xuXG4gICAgICAgIC8vIDMuIFJldHVybiBlcnJvci5cbiAgICAgICAgcmV0dXJuIGRlY29kZXJFcnJvcihmYXRhbCk7XG4gICAgICB9XG5cbiAgICAgIC8vIDUuIFNldCB1dGYtOCBsb3dlciBib3VuZGFyeSB0byAweDgwIGFuZCB1dGYtOCB1cHBlciBib3VuZGFyeVxuICAgICAgLy8gdG8gMHhCRi5cbiAgICAgIHV0ZjhfbG93ZXJfYm91bmRhcnkgPSAweDgwO1xuICAgICAgdXRmOF91cHBlcl9ib3VuZGFyeSA9IDB4QkY7XG5cbiAgICAgIC8vIDYuIFNldCBVVEYtOCBjb2RlIHBvaW50IHRvIChVVEYtOCBjb2RlIHBvaW50IDw8IDYpIHwgKGJ5dGUgJlxuICAgICAgLy8gMHgzRilcbiAgICAgIHV0ZjhfY29kZV9wb2ludCA9ICh1dGY4X2NvZGVfcG9pbnQgPDwgNikgfCAoYml0ZSAmIDB4M0YpO1xuXG4gICAgICAvLyA3LiBJbmNyZWFzZSB1dGYtOCBieXRlcyBzZWVuIGJ5IG9uZS5cbiAgICAgIHV0ZjhfYnl0ZXNfc2VlbiArPSAxO1xuXG4gICAgICAvLyA4LiBJZiB1dGYtOCBieXRlcyBzZWVuIGlzIG5vdCBlcXVhbCB0byB1dGYtOCBieXRlcyBuZWVkZWQsXG4gICAgICAvLyBjb250aW51ZS5cbiAgICAgIGlmICh1dGY4X2J5dGVzX3NlZW4gIT09IHV0ZjhfYnl0ZXNfbmVlZGVkKVxuICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgLy8gOS4gTGV0IGNvZGUgcG9pbnQgYmUgdXRmLTggY29kZSBwb2ludC5cbiAgICAgIHZhciBjb2RlX3BvaW50ID0gdXRmOF9jb2RlX3BvaW50O1xuXG4gICAgICAvLyAxMC4gU2V0IHV0Zi04IGNvZGUgcG9pbnQsIHV0Zi04IGJ5dGVzIG5lZWRlZCwgYW5kIHV0Zi04IGJ5dGVzXG4gICAgICAvLyBzZWVuIHRvIDAuXG4gICAgICB1dGY4X2NvZGVfcG9pbnQgPSB1dGY4X2J5dGVzX25lZWRlZCA9IHV0ZjhfYnl0ZXNfc2VlbiA9IDA7XG5cbiAgICAgIC8vIDExLiBSZXR1cm4gYSBjb2RlIHBvaW50IHdob3NlIHZhbHVlIGlzIGNvZGUgcG9pbnQuXG4gICAgICByZXR1cm4gY29kZV9wb2ludDtcbiAgICB9O1xuICB9XG5cbiAgLy8gOS4xLjIgdXRmLTggZW5jb2RlclxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBpbXBsZW1lbnRzIHtFbmNvZGVyfVxuICAgKiBAcGFyYW0ge3tmYXRhbDogYm9vbGVhbn19IG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIFVURjhFbmNvZGVyKG9wdGlvbnMpIHtcbiAgICB2YXIgZmF0YWwgPSBvcHRpb25zLmZhdGFsO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyZWFtfSBzdHJlYW0gSW5wdXQgc3RyZWFtLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlX3BvaW50IE5leHQgY29kZSBwb2ludCByZWFkIGZyb20gdGhlIHN0cmVhbS5cbiAgICAgKiBAcmV0dXJuIHsobnVtYmVyfCFBcnJheS48bnVtYmVyPil9IEJ5dGUocykgdG8gZW1pdC5cbiAgICAgKi9cbiAgICB0aGlzLmhhbmRsZXIgPSBmdW5jdGlvbihzdHJlYW0sIGNvZGVfcG9pbnQpIHtcbiAgICAgIC8vIDEuIElmIGNvZGUgcG9pbnQgaXMgZW5kLW9mLXN0cmVhbSwgcmV0dXJuIGZpbmlzaGVkLlxuICAgICAgaWYgKGNvZGVfcG9pbnQgPT09IGVuZF9vZl9zdHJlYW0pXG4gICAgICAgIHJldHVybiBmaW5pc2hlZDtcblxuICAgICAgLy8gMi4gSWYgY29kZSBwb2ludCBpcyBhbiBBU0NJSSBjb2RlIHBvaW50LCByZXR1cm4gYSBieXRlIHdob3NlXG4gICAgICAvLyB2YWx1ZSBpcyBjb2RlIHBvaW50LlxuICAgICAgaWYgKGlzQVNDSUlDb2RlUG9pbnQoY29kZV9wb2ludCkpXG4gICAgICAgIHJldHVybiBjb2RlX3BvaW50O1xuXG4gICAgICAvLyAzLiBTZXQgY291bnQgYW5kIG9mZnNldCBiYXNlZCBvbiB0aGUgcmFuZ2UgY29kZSBwb2ludCBpcyBpbjpcbiAgICAgIHZhciBjb3VudCwgb2Zmc2V0O1xuICAgICAgLy8gVSswMDgwIHRvIFUrMDdGRiwgaW5jbHVzaXZlOlxuICAgICAgaWYgKGluUmFuZ2UoY29kZV9wb2ludCwgMHgwMDgwLCAweDA3RkYpKSB7XG4gICAgICAgIC8vIDEgYW5kIDB4QzBcbiAgICAgICAgY291bnQgPSAxO1xuICAgICAgICBvZmZzZXQgPSAweEMwO1xuICAgICAgfVxuICAgICAgLy8gVSswODAwIHRvIFUrRkZGRiwgaW5jbHVzaXZlOlxuICAgICAgZWxzZSBpZiAoaW5SYW5nZShjb2RlX3BvaW50LCAweDA4MDAsIDB4RkZGRikpIHtcbiAgICAgICAgLy8gMiBhbmQgMHhFMFxuICAgICAgICBjb3VudCA9IDI7XG4gICAgICAgIG9mZnNldCA9IDB4RTA7XG4gICAgICB9XG4gICAgICAvLyBVKzEwMDAwIHRvIFUrMTBGRkZGLCBpbmNsdXNpdmU6XG4gICAgICBlbHNlIGlmIChpblJhbmdlKGNvZGVfcG9pbnQsIDB4MTAwMDAsIDB4MTBGRkZGKSkge1xuICAgICAgICAvLyAzIGFuZCAweEYwXG4gICAgICAgIGNvdW50ID0gMztcbiAgICAgICAgb2Zmc2V0ID0gMHhGMDtcbiAgICAgIH1cblxuICAgICAgLy8gNC4gTGV0IGJ5dGVzIGJlIGEgYnl0ZSBzZXF1ZW5jZSB3aG9zZSBmaXJzdCBieXRlIGlzIChjb2RlXG4gICAgICAvLyBwb2ludCA+PiAoNiDDlyBjb3VudCkpICsgb2Zmc2V0LlxuICAgICAgdmFyIGJ5dGVzID0gWyhjb2RlX3BvaW50ID4+ICg2ICogY291bnQpKSArIG9mZnNldF07XG5cbiAgICAgIC8vIDUuIFJ1biB0aGVzZSBzdWJzdGVwcyB3aGlsZSBjb3VudCBpcyBncmVhdGVyIHRoYW4gMDpcbiAgICAgIHdoaWxlIChjb3VudCA+IDApIHtcblxuICAgICAgICAvLyAxLiBTZXQgdGVtcCB0byBjb2RlIHBvaW50ID4+ICg2IMOXIChjb3VudCDiiJIgMSkpLlxuICAgICAgICB2YXIgdGVtcCA9IGNvZGVfcG9pbnQgPj4gKDYgKiAoY291bnQgLSAxKSk7XG5cbiAgICAgICAgLy8gMi4gQXBwZW5kIHRvIGJ5dGVzIDB4ODAgfCAodGVtcCAmIDB4M0YpLlxuICAgICAgICBieXRlcy5wdXNoKDB4ODAgfCAodGVtcCAmIDB4M0YpKTtcblxuICAgICAgICAvLyAzLiBEZWNyZWFzZSBjb3VudCBieSBvbmUuXG4gICAgICAgIGNvdW50IC09IDE7XG4gICAgICB9XG5cbiAgICAgIC8vIDYuIFJldHVybiBieXRlcyBieXRlcywgaW4gb3JkZXIuXG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfTtcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge3tmYXRhbDogYm9vbGVhbn19IG9wdGlvbnMgKi9cbiAgZW5jb2RlcnNbJ1VURi04J10gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBVVEY4RW5jb2RlcihvcHRpb25zKTtcbiAgfTtcbiAgLyoqIEBwYXJhbSB7e2ZhdGFsOiBib29sZWFufX0gb3B0aW9ucyAqL1xuICBkZWNvZGVyc1snVVRGLTgnXSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFVURjhEZWNvZGVyKG9wdGlvbnMpO1xuICB9O1xuXG4gIC8vXG4gIC8vIDEwLiBMZWdhY3kgc2luZ2xlLWJ5dGUgZW5jb2RpbmdzXG4gIC8vXG5cbiAgLy8gMTAuMSBzaW5nbGUtYnl0ZSBkZWNvZGVyXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGltcGxlbWVudHMge0RlY29kZXJ9XG4gICAqIEBwYXJhbSB7IUFycmF5LjxudW1iZXI+fSBpbmRleCBUaGUgZW5jb2RpbmcgaW5kZXguXG4gICAqIEBwYXJhbSB7e2ZhdGFsOiBib29sZWFufX0gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gU2luZ2xlQnl0ZURlY29kZXIoaW5kZXgsIG9wdGlvbnMpIHtcbiAgICB2YXIgZmF0YWwgPSBvcHRpb25zLmZhdGFsO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyZWFtfSBzdHJlYW0gVGhlIHN0cmVhbSBvZiBieXRlcyBiZWluZyBkZWNvZGVkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRlIFRoZSBuZXh0IGJ5dGUgcmVhZCBmcm9tIHRoZSBzdHJlYW0uXG4gICAgICogQHJldHVybiB7PyhudW1iZXJ8IUFycmF5LjxudW1iZXI+KX0gVGhlIG5leHQgY29kZSBwb2ludChzKVxuICAgICAqICAgICBkZWNvZGVkLCBvciBudWxsIGlmIG5vdCBlbm91Z2ggZGF0YSBleGlzdHMgaW4gdGhlIGlucHV0XG4gICAgICogICAgIHN0cmVhbSB0byBkZWNvZGUgYSBjb21wbGV0ZSBjb2RlIHBvaW50LlxuICAgICAqL1xuICAgIHRoaXMuaGFuZGxlciA9IGZ1bmN0aW9uKHN0cmVhbSwgYml0ZSkge1xuICAgICAgLy8gMS4gSWYgYnl0ZSBpcyBlbmQtb2Ytc3RyZWFtLCByZXR1cm4gZmluaXNoZWQuXG4gICAgICBpZiAoYml0ZSA9PT0gZW5kX29mX3N0cmVhbSlcbiAgICAgICAgcmV0dXJuIGZpbmlzaGVkO1xuXG4gICAgICAvLyAyLiBJZiBieXRlIGlzIGFuIEFTQ0lJIGJ5dGUsIHJldHVybiBhIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWVcbiAgICAgIC8vIGlzIGJ5dGUuXG4gICAgICBpZiAoaXNBU0NJSUJ5dGUoYml0ZSkpXG4gICAgICAgIHJldHVybiBiaXRlO1xuXG4gICAgICAvLyAzLiBMZXQgY29kZSBwb2ludCBiZSB0aGUgaW5kZXggY29kZSBwb2ludCBmb3IgYnl0ZSDiiJIgMHg4MCBpblxuICAgICAgLy8gaW5kZXggc2luZ2xlLWJ5dGUuXG4gICAgICB2YXIgY29kZV9wb2ludCA9IGluZGV4W2JpdGUgLSAweDgwXTtcblxuICAgICAgLy8gNC4gSWYgY29kZSBwb2ludCBpcyBudWxsLCByZXR1cm4gZXJyb3IuXG4gICAgICBpZiAoY29kZV9wb2ludCA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGRlY29kZXJFcnJvcihmYXRhbCk7XG5cbiAgICAgIC8vIDUuIFJldHVybiBhIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgaXMgY29kZSBwb2ludC5cbiAgICAgIHJldHVybiBjb2RlX3BvaW50O1xuICAgIH07XG4gIH1cblxuICAvLyAxMC4yIHNpbmdsZS1ieXRlIGVuY29kZXJcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAaW1wbGVtZW50cyB7RW5jb2Rlcn1cbiAgICogQHBhcmFtIHshQXJyYXkuPD9udW1iZXI+fSBpbmRleCBUaGUgZW5jb2RpbmcgaW5kZXguXG4gICAqIEBwYXJhbSB7e2ZhdGFsOiBib29sZWFufX0gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gU2luZ2xlQnl0ZUVuY29kZXIoaW5kZXgsIG9wdGlvbnMpIHtcbiAgICB2YXIgZmF0YWwgPSBvcHRpb25zLmZhdGFsO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyZWFtfSBzdHJlYW0gSW5wdXQgc3RyZWFtLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlX3BvaW50IE5leHQgY29kZSBwb2ludCByZWFkIGZyb20gdGhlIHN0cmVhbS5cbiAgICAgKiBAcmV0dXJuIHsobnVtYmVyfCFBcnJheS48bnVtYmVyPil9IEJ5dGUocykgdG8gZW1pdC5cbiAgICAgKi9cbiAgICB0aGlzLmhhbmRsZXIgPSBmdW5jdGlvbihzdHJlYW0sIGNvZGVfcG9pbnQpIHtcbiAgICAgIC8vIDEuIElmIGNvZGUgcG9pbnQgaXMgZW5kLW9mLXN0cmVhbSwgcmV0dXJuIGZpbmlzaGVkLlxuICAgICAgaWYgKGNvZGVfcG9pbnQgPT09IGVuZF9vZl9zdHJlYW0pXG4gICAgICAgIHJldHVybiBmaW5pc2hlZDtcblxuICAgICAgLy8gMi4gSWYgY29kZSBwb2ludCBpcyBhbiBBU0NJSSBjb2RlIHBvaW50LCByZXR1cm4gYSBieXRlIHdob3NlXG4gICAgICAvLyB2YWx1ZSBpcyBjb2RlIHBvaW50LlxuICAgICAgaWYgKGlzQVNDSUlDb2RlUG9pbnQoY29kZV9wb2ludCkpXG4gICAgICAgIHJldHVybiBjb2RlX3BvaW50O1xuXG4gICAgICAvLyAzLiBMZXQgcG9pbnRlciBiZSB0aGUgaW5kZXggcG9pbnRlciBmb3IgY29kZSBwb2ludCBpbiBpbmRleFxuICAgICAgLy8gc2luZ2xlLWJ5dGUuXG4gICAgICB2YXIgcG9pbnRlciA9IGluZGV4UG9pbnRlckZvcihjb2RlX3BvaW50LCBpbmRleCk7XG5cbiAgICAgIC8vIDQuIElmIHBvaW50ZXIgaXMgbnVsbCwgcmV0dXJuIGVycm9yIHdpdGggY29kZSBwb2ludC5cbiAgICAgIGlmIChwb2ludGVyID09PSBudWxsKVxuICAgICAgICBlbmNvZGVyRXJyb3IoY29kZV9wb2ludCk7XG5cbiAgICAgIC8vIDUuIFJldHVybiBhIGJ5dGUgd2hvc2UgdmFsdWUgaXMgcG9pbnRlciArIDB4ODAuXG4gICAgICByZXR1cm4gcG9pbnRlciArIDB4ODA7XG4gICAgfTtcbiAgfVxuXG4gIChmdW5jdGlvbigpIHtcbiAgICBpZiAoISgnZW5jb2RpbmctaW5kZXhlcycgaW4gZ2xvYmFsKSlcbiAgICAgIHJldHVybjtcbiAgICBlbmNvZGluZ3MuZm9yRWFjaChmdW5jdGlvbihjYXRlZ29yeSkge1xuICAgICAgaWYgKGNhdGVnb3J5LmhlYWRpbmcgIT09ICdMZWdhY3kgc2luZ2xlLWJ5dGUgZW5jb2RpbmdzJylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2F0ZWdvcnkuZW5jb2RpbmdzLmZvckVhY2goZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBlbmNvZGluZy5uYW1lO1xuICAgICAgICB2YXIgaWR4ID0gaW5kZXgobmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgLyoqIEBwYXJhbSB7e2ZhdGFsOiBib29sZWFufX0gb3B0aW9ucyAqL1xuICAgICAgICBkZWNvZGVyc1tuYW1lXSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFNpbmdsZUJ5dGVEZWNvZGVyKGlkeCwgb3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAcGFyYW0ge3tmYXRhbDogYm9vbGVhbn19IG9wdGlvbnMgKi9cbiAgICAgICAgZW5jb2RlcnNbbmFtZV0gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBTaW5nbGVCeXRlRW5jb2RlcihpZHgsIG9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0oKSk7XG5cbiAgLy9cbiAgLy8gMTEuIExlZ2FjeSBtdWx0aS1ieXRlIENoaW5lc2UgKHNpbXBsaWZpZWQpIGVuY29kaW5nc1xuICAvL1xuXG4gIC8vIDExLjEgZ2JrXG5cbiAgLy8gMTEuMS4xIGdiayBkZWNvZGVyXG4gIC8vIGdiaydzIGRlY29kZXIgaXMgZ2IxODAzMCdzIGRlY29kZXIuXG4gIC8qKiBAcGFyYW0ge3tmYXRhbDogYm9vbGVhbn19IG9wdGlvbnMgKi9cbiAgZGVjb2RlcnNbJ0dCSyddID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgR0IxODAzMERlY29kZXIob3B0aW9ucyk7XG4gIH07XG5cbiAgLy8gMTEuMS4yIGdiayBlbmNvZGVyXG4gIC8vIGdiaydzIGVuY29kZXIgaXMgZ2IxODAzMCdzIGVuY29kZXIgd2l0aCBpdHMgZ2JrIGZsYWcgc2V0LlxuICAvKiogQHBhcmFtIHt7ZmF0YWw6IGJvb2xlYW59fSBvcHRpb25zICovXG4gIGVuY29kZXJzWydHQksnXSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEdCMTgwMzBFbmNvZGVyKG9wdGlvbnMsIHRydWUpO1xuICB9O1xuXG4gIC8vIDExLjIgZ2IxODAzMFxuXG4gIC8vIDExLjIuMSBnYjE4MDMwIGRlY29kZXJcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAaW1wbGVtZW50cyB7RGVjb2Rlcn1cbiAgICogQHBhcmFtIHt7ZmF0YWw6IGJvb2xlYW59fSBvcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBHQjE4MDMwRGVjb2RlcihvcHRpb25zKSB7XG4gICAgdmFyIGZhdGFsID0gb3B0aW9ucy5mYXRhbDtcbiAgICAvLyBnYjE4MDMwJ3MgZGVjb2RlciBoYXMgYW4gYXNzb2NpYXRlZCBnYjE4MDMwIGZpcnN0LCBnYjE4MDMwXG4gICAgLy8gc2Vjb25kLCBhbmQgZ2IxODAzMCB0aGlyZCAoYWxsIGluaXRpYWxseSAweDAwKS5cbiAgICB2YXIgLyoqIEB0eXBlIHtudW1iZXJ9ICovIGdiMTgwMzBfZmlyc3QgPSAweDAwLFxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi8gZ2IxODAzMF9zZWNvbmQgPSAweDAwLFxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi8gZ2IxODAzMF90aGlyZCA9IDB4MDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJlYW19IHN0cmVhbSBUaGUgc3RyZWFtIG9mIGJ5dGVzIGJlaW5nIGRlY29kZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdGUgVGhlIG5leHQgYnl0ZSByZWFkIGZyb20gdGhlIHN0cmVhbS5cbiAgICAgKiBAcmV0dXJuIHs/KG51bWJlcnwhQXJyYXkuPG51bWJlcj4pfSBUaGUgbmV4dCBjb2RlIHBvaW50KHMpXG4gICAgICogICAgIGRlY29kZWQsIG9yIG51bGwgaWYgbm90IGVub3VnaCBkYXRhIGV4aXN0cyBpbiB0aGUgaW5wdXRcbiAgICAgKiAgICAgc3RyZWFtIHRvIGRlY29kZSBhIGNvbXBsZXRlIGNvZGUgcG9pbnQuXG4gICAgICovXG4gICAgdGhpcy5oYW5kbGVyID0gZnVuY3Rpb24oc3RyZWFtLCBiaXRlKSB7XG4gICAgICAvLyAxLiBJZiBieXRlIGlzIGVuZC1vZi1zdHJlYW0gYW5kIGdiMTgwMzAgZmlyc3QsIGdiMTgwMzBcbiAgICAgIC8vIHNlY29uZCwgYW5kIGdiMTgwMzAgdGhpcmQgYXJlIDB4MDAsIHJldHVybiBmaW5pc2hlZC5cbiAgICAgIGlmIChiaXRlID09PSBlbmRfb2Zfc3RyZWFtICYmIGdiMTgwMzBfZmlyc3QgPT09IDB4MDAgJiZcbiAgICAgICAgICBnYjE4MDMwX3NlY29uZCA9PT0gMHgwMCAmJiBnYjE4MDMwX3RoaXJkID09PSAweDAwKSB7XG4gICAgICAgIHJldHVybiBmaW5pc2hlZDtcbiAgICAgIH1cbiAgICAgIC8vIDIuIElmIGJ5dGUgaXMgZW5kLW9mLXN0cmVhbSwgYW5kIGdiMTgwMzAgZmlyc3QsIGdiMTgwMzBcbiAgICAgIC8vIHNlY29uZCwgb3IgZ2IxODAzMCB0aGlyZCBpcyBub3QgMHgwMCwgc2V0IGdiMTgwMzAgZmlyc3QsXG4gICAgICAvLyBnYjE4MDMwIHNlY29uZCwgYW5kIGdiMTgwMzAgdGhpcmQgdG8gMHgwMCwgYW5kIHJldHVybiBlcnJvci5cbiAgICAgIGlmIChiaXRlID09PSBlbmRfb2Zfc3RyZWFtICYmXG4gICAgICAgICAgKGdiMTgwMzBfZmlyc3QgIT09IDB4MDAgfHwgZ2IxODAzMF9zZWNvbmQgIT09IDB4MDAgfHxcbiAgICAgICAgICAgZ2IxODAzMF90aGlyZCAhPT0gMHgwMCkpIHtcbiAgICAgICAgZ2IxODAzMF9maXJzdCA9IDB4MDA7XG4gICAgICAgIGdiMTgwMzBfc2Vjb25kID0gMHgwMDtcbiAgICAgICAgZ2IxODAzMF90aGlyZCA9IDB4MDA7XG4gICAgICAgIGRlY29kZXJFcnJvcihmYXRhbCk7XG4gICAgICB9XG4gICAgICB2YXIgY29kZV9wb2ludDtcbiAgICAgIC8vIDMuIElmIGdiMTgwMzAgdGhpcmQgaXMgbm90IDB4MDAsIHJ1biB0aGVzZSBzdWJzdGVwczpcbiAgICAgIGlmIChnYjE4MDMwX3RoaXJkICE9PSAweDAwKSB7XG4gICAgICAgIC8vIDEuIExldCBjb2RlIHBvaW50IGJlIG51bGwuXG4gICAgICAgIGNvZGVfcG9pbnQgPSBudWxsO1xuICAgICAgICAvLyAyLiBJZiBieXRlIGlzIGluIHRoZSByYW5nZSAweDMwIHRvIDB4MzksIGluY2x1c2l2ZSwgc2V0XG4gICAgICAgIC8vIGNvZGUgcG9pbnQgdG8gdGhlIGluZGV4IGdiMTgwMzAgcmFuZ2VzIGNvZGUgcG9pbnQgZm9yXG4gICAgICAgIC8vICgoKGdiMTgwMzAgZmlyc3Qg4oiSIDB4ODEpIMOXIDEwICsgZ2IxODAzMCBzZWNvbmQg4oiSIDB4MzApIMOXXG4gICAgICAgIC8vIDEyNiArIGdiMTgwMzAgdGhpcmQg4oiSIDB4ODEpIMOXIDEwICsgYnl0ZSDiiJIgMHgzMC5cbiAgICAgICAgaWYgKGluUmFuZ2UoYml0ZSwgMHgzMCwgMHgzOSkpIHtcbiAgICAgICAgICBjb2RlX3BvaW50ID0gaW5kZXhHQjE4MDMwUmFuZ2VzQ29kZVBvaW50Rm9yKFxuICAgICAgICAgICAgICAoKChnYjE4MDMwX2ZpcnN0IC0gMHg4MSkgKiAxMCArIGdiMTgwMzBfc2Vjb25kIC0gMHgzMCkgKiAxMjYgK1xuICAgICAgICAgICAgICAgZ2IxODAzMF90aGlyZCAtIDB4ODEpICogMTAgKyBiaXRlIC0gMHgzMCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAzLiBMZXQgYnVmZmVyIGJlIGEgYnl0ZSBzZXF1ZW5jZSBjb25zaXN0aW5nIG9mIGdiMTgwMzBcbiAgICAgICAgLy8gc2Vjb25kLCBnYjE4MDMwIHRoaXJkLCBhbmQgYnl0ZSwgaW4gb3JkZXIuXG4gICAgICAgIHZhciBidWZmZXIgPSBbZ2IxODAzMF9zZWNvbmQsIGdiMTgwMzBfdGhpcmQsIGJpdGVdO1xuXG4gICAgICAgIC8vIDQuIFNldCBnYjE4MDMwIGZpcnN0LCBnYjE4MDMwIHNlY29uZCwgYW5kIGdiMTgwMzAgdGhpcmQgdG9cbiAgICAgICAgLy8gMHgwMC5cbiAgICAgICAgZ2IxODAzMF9maXJzdCA9IDB4MDA7XG4gICAgICAgIGdiMTgwMzBfc2Vjb25kID0gMHgwMDtcbiAgICAgICAgZ2IxODAzMF90aGlyZCA9IDB4MDA7XG5cbiAgICAgICAgLy8gNS4gSWYgY29kZSBwb2ludCBpcyBudWxsLCBwcmVwZW5kIGJ1ZmZlciB0byBzdHJlYW0gYW5kXG4gICAgICAgIC8vIHJldHVybiBlcnJvci5cbiAgICAgICAgaWYgKGNvZGVfcG9pbnQgPT09IG51bGwpIHtcbiAgICAgICAgICBzdHJlYW0ucHJlcGVuZChidWZmZXIpO1xuICAgICAgICAgIHJldHVybiBkZWNvZGVyRXJyb3IoZmF0YWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gNi4gUmV0dXJuIGEgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSBpcyBjb2RlIHBvaW50LlxuICAgICAgICByZXR1cm4gY29kZV9wb2ludDtcbiAgICAgIH1cblxuICAgICAgLy8gNC4gSWYgZ2IxODAzMCBzZWNvbmQgaXMgbm90IDB4MDAsIHJ1biB0aGVzZSBzdWJzdGVwczpcbiAgICAgIGlmIChnYjE4MDMwX3NlY29uZCAhPT0gMHgwMCkge1xuXG4gICAgICAgIC8vIDEuIElmIGJ5dGUgaXMgaW4gdGhlIHJhbmdlIDB4ODEgdG8gMHhGRSwgaW5jbHVzaXZlLCBzZXRcbiAgICAgICAgLy8gZ2IxODAzMCB0aGlyZCB0byBieXRlIGFuZCByZXR1cm4gY29udGludWUuXG4gICAgICAgIGlmIChpblJhbmdlKGJpdGUsIDB4ODEsIDB4RkUpKSB7XG4gICAgICAgICAgZ2IxODAzMF90aGlyZCA9IGJpdGU7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAyLiBQcmVwZW5kIGdiMTgwMzAgc2Vjb25kIGZvbGxvd2VkIGJ5IGJ5dGUgdG8gc3RyZWFtLCBzZXRcbiAgICAgICAgLy8gZ2IxODAzMCBmaXJzdCBhbmQgZ2IxODAzMCBzZWNvbmQgdG8gMHgwMCwgYW5kIHJldHVybiBlcnJvci5cbiAgICAgICAgc3RyZWFtLnByZXBlbmQoW2diMTgwMzBfc2Vjb25kLCBiaXRlXSk7XG4gICAgICAgIGdiMTgwMzBfZmlyc3QgPSAweDAwO1xuICAgICAgICBnYjE4MDMwX3NlY29uZCA9IDB4MDA7XG4gICAgICAgIHJldHVybiBkZWNvZGVyRXJyb3IoZmF0YWwpO1xuICAgICAgfVxuXG4gICAgICAvLyA1LiBJZiBnYjE4MDMwIGZpcnN0IGlzIG5vdCAweDAwLCBydW4gdGhlc2Ugc3Vic3RlcHM6XG4gICAgICBpZiAoZ2IxODAzMF9maXJzdCAhPT0gMHgwMCkge1xuXG4gICAgICAgIC8vIDEuIElmIGJ5dGUgaXMgaW4gdGhlIHJhbmdlIDB4MzAgdG8gMHgzOSwgaW5jbHVzaXZlLCBzZXRcbiAgICAgICAgLy8gZ2IxODAzMCBzZWNvbmQgdG8gYnl0ZSBhbmQgcmV0dXJuIGNvbnRpbnVlLlxuICAgICAgICBpZiAoaW5SYW5nZShiaXRlLCAweDMwLCAweDM5KSkge1xuICAgICAgICAgIGdiMTgwMzBfc2Vjb25kID0gYml0ZTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDIuIExldCBsZWFkIGJlIGdiMTgwMzAgZmlyc3QsIGxldCBwb2ludGVyIGJlIG51bGwsIGFuZCBzZXRcbiAgICAgICAgLy8gZ2IxODAzMCBmaXJzdCB0byAweDAwLlxuICAgICAgICB2YXIgbGVhZCA9IGdiMTgwMzBfZmlyc3Q7XG4gICAgICAgIHZhciBwb2ludGVyID0gbnVsbDtcbiAgICAgICAgZ2IxODAzMF9maXJzdCA9IDB4MDA7XG5cbiAgICAgICAgLy8gMy4gTGV0IG9mZnNldCBiZSAweDQwIGlmIGJ5dGUgaXMgbGVzcyB0aGFuIDB4N0YgYW5kIDB4NDFcbiAgICAgICAgLy8gb3RoZXJ3aXNlLlxuICAgICAgICB2YXIgb2Zmc2V0ID0gYml0ZSA8IDB4N0YgPyAweDQwIDogMHg0MTtcblxuICAgICAgICAvLyA0LiBJZiBieXRlIGlzIGluIHRoZSByYW5nZSAweDQwIHRvIDB4N0UsIGluY2x1c2l2ZSwgb3IgMHg4MFxuICAgICAgICAvLyB0byAweEZFLCBpbmNsdXNpdmUsIHNldCBwb2ludGVyIHRvIChsZWFkIOKIkiAweDgxKSDDlyAxOTAgK1xuICAgICAgICAvLyAoYnl0ZSDiiJIgb2Zmc2V0KS5cbiAgICAgICAgaWYgKGluUmFuZ2UoYml0ZSwgMHg0MCwgMHg3RSkgfHwgaW5SYW5nZShiaXRlLCAweDgwLCAweEZFKSlcbiAgICAgICAgICBwb2ludGVyID0gKGxlYWQgLSAweDgxKSAqIDE5MCArIChiaXRlIC0gb2Zmc2V0KTtcblxuICAgICAgICAvLyA1LiBMZXQgY29kZSBwb2ludCBiZSBudWxsIGlmIHBvaW50ZXIgaXMgbnVsbCBhbmQgdGhlIGluZGV4XG4gICAgICAgIC8vIGNvZGUgcG9pbnQgZm9yIHBvaW50ZXIgaW4gaW5kZXggZ2IxODAzMCBvdGhlcndpc2UuXG4gICAgICAgIGNvZGVfcG9pbnQgPSBwb2ludGVyID09PSBudWxsID8gbnVsbCA6XG4gICAgICAgICAgICBpbmRleENvZGVQb2ludEZvcihwb2ludGVyLCBpbmRleCgnZ2IxODAzMCcpKTtcblxuICAgICAgICAvLyA2LiBJZiBjb2RlIHBvaW50IGlzIG51bGwgYW5kIGJ5dGUgaXMgYW4gQVNDSUkgYnl0ZSwgcHJlcGVuZFxuICAgICAgICAvLyBieXRlIHRvIHN0cmVhbS5cbiAgICAgICAgaWYgKGNvZGVfcG9pbnQgPT09IG51bGwgJiYgaXNBU0NJSUJ5dGUoYml0ZSkpXG4gICAgICAgICAgc3RyZWFtLnByZXBlbmQoYml0ZSk7XG5cbiAgICAgICAgLy8gNy4gSWYgY29kZSBwb2ludCBpcyBudWxsLCByZXR1cm4gZXJyb3IuXG4gICAgICAgIGlmIChjb2RlX3BvaW50ID09PSBudWxsKVxuICAgICAgICAgIHJldHVybiBkZWNvZGVyRXJyb3IoZmF0YWwpO1xuXG4gICAgICAgIC8vIDguIFJldHVybiBhIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgaXMgY29kZSBwb2ludC5cbiAgICAgICAgcmV0dXJuIGNvZGVfcG9pbnQ7XG4gICAgICB9XG5cbiAgICAgIC8vIDYuIElmIGJ5dGUgaXMgYW4gQVNDSUkgYnl0ZSwgcmV0dXJuIGEgY29kZSBwb2ludCB3aG9zZSB2YWx1ZVxuICAgICAgLy8gaXMgYnl0ZS5cbiAgICAgIGlmIChpc0FTQ0lJQnl0ZShiaXRlKSlcbiAgICAgICAgcmV0dXJuIGJpdGU7XG5cbiAgICAgIC8vIDcuIElmIGJ5dGUgaXMgMHg4MCwgcmV0dXJuIGNvZGUgcG9pbnQgVSsyMEFDLlxuICAgICAgaWYgKGJpdGUgPT09IDB4ODApXG4gICAgICAgIHJldHVybiAweDIwQUM7XG5cbiAgICAgIC8vIDguIElmIGJ5dGUgaXMgaW4gdGhlIHJhbmdlIDB4ODEgdG8gMHhGRSwgaW5jbHVzaXZlLCBzZXRcbiAgICAgIC8vIGdiMTgwMzAgZmlyc3QgdG8gYnl0ZSBhbmQgcmV0dXJuIGNvbnRpbnVlLlxuICAgICAgaWYgKGluUmFuZ2UoYml0ZSwgMHg4MSwgMHhGRSkpIHtcbiAgICAgICAgZ2IxODAzMF9maXJzdCA9IGJpdGU7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyA5LiBSZXR1cm4gZXJyb3IuXG4gICAgICByZXR1cm4gZGVjb2RlckVycm9yKGZhdGFsKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gMTEuMi4yIGdiMTgwMzAgZW5jb2RlclxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBpbXBsZW1lbnRzIHtFbmNvZGVyfVxuICAgKiBAcGFyYW0ge3tmYXRhbDogYm9vbGVhbn19IG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFuPX0gZ2JrX2ZsYWdcbiAgICovXG4gIGZ1bmN0aW9uIEdCMTgwMzBFbmNvZGVyKG9wdGlvbnMsIGdia19mbGFnKSB7XG4gICAgdmFyIGZhdGFsID0gb3B0aW9ucy5mYXRhbDtcbiAgICAvLyBnYjE4MDMwJ3MgZGVjb2RlciBoYXMgYW4gYXNzb2NpYXRlZCBnYmsgZmxhZyAoaW5pdGlhbGx5IHVuc2V0KS5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmVhbX0gc3RyZWFtIElucHV0IHN0cmVhbS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29kZV9wb2ludCBOZXh0IGNvZGUgcG9pbnQgcmVhZCBmcm9tIHRoZSBzdHJlYW0uXG4gICAgICogQHJldHVybiB7KG51bWJlcnwhQXJyYXkuPG51bWJlcj4pfSBCeXRlKHMpIHRvIGVtaXQuXG4gICAgICovXG4gICAgdGhpcy5oYW5kbGVyID0gZnVuY3Rpb24oc3RyZWFtLCBjb2RlX3BvaW50KSB7XG4gICAgICAvLyAxLiBJZiBjb2RlIHBvaW50IGlzIGVuZC1vZi1zdHJlYW0sIHJldHVybiBmaW5pc2hlZC5cbiAgICAgIGlmIChjb2RlX3BvaW50ID09PSBlbmRfb2Zfc3RyZWFtKVxuICAgICAgICByZXR1cm4gZmluaXNoZWQ7XG5cbiAgICAgIC8vIDIuIElmIGNvZGUgcG9pbnQgaXMgYW4gQVNDSUkgY29kZSBwb2ludCwgcmV0dXJuIGEgYnl0ZSB3aG9zZVxuICAgICAgLy8gdmFsdWUgaXMgY29kZSBwb2ludC5cbiAgICAgIGlmIChpc0FTQ0lJQ29kZVBvaW50KGNvZGVfcG9pbnQpKVxuICAgICAgICByZXR1cm4gY29kZV9wb2ludDtcblxuICAgICAgLy8gMy4gSWYgY29kZSBwb2ludCBpcyBVK0U1RTUsIHJldHVybiBlcnJvciB3aXRoIGNvZGUgcG9pbnQuXG4gICAgICBpZiAoY29kZV9wb2ludCA9PT0gMHhFNUU1KVxuICAgICAgICByZXR1cm4gZW5jb2RlckVycm9yKGNvZGVfcG9pbnQpO1xuXG4gICAgICAvLyA0LiBJZiB0aGUgZ2JrIGZsYWcgaXMgc2V0IGFuZCBjb2RlIHBvaW50IGlzIFUrMjBBQywgcmV0dXJuXG4gICAgICAvLyBieXRlIDB4ODAuXG4gICAgICBpZiAoZ2JrX2ZsYWcgJiYgY29kZV9wb2ludCA9PT0gMHgyMEFDKVxuICAgICAgICByZXR1cm4gMHg4MDtcblxuICAgICAgLy8gNS4gTGV0IHBvaW50ZXIgYmUgdGhlIGluZGV4IHBvaW50ZXIgZm9yIGNvZGUgcG9pbnQgaW4gaW5kZXhcbiAgICAgIC8vIGdiMTgwMzAuXG4gICAgICB2YXIgcG9pbnRlciA9IGluZGV4UG9pbnRlckZvcihjb2RlX3BvaW50LCBpbmRleCgnZ2IxODAzMCcpKTtcblxuICAgICAgLy8gNi4gSWYgcG9pbnRlciBpcyBub3QgbnVsbCwgcnVuIHRoZXNlIHN1YnN0ZXBzOlxuICAgICAgaWYgKHBvaW50ZXIgIT09IG51bGwpIHtcblxuICAgICAgICAvLyAxLiBMZXQgbGVhZCBiZSBmbG9vcihwb2ludGVyIC8gMTkwKSArIDB4ODEuXG4gICAgICAgIHZhciBsZWFkID0gZmxvb3IocG9pbnRlciAvIDE5MCkgKyAweDgxO1xuXG4gICAgICAgIC8vIDIuIExldCB0cmFpbCBiZSBwb2ludGVyICUgMTkwLlxuICAgICAgICB2YXIgdHJhaWwgPSBwb2ludGVyICUgMTkwO1xuXG4gICAgICAgIC8vIDMuIExldCBvZmZzZXQgYmUgMHg0MCBpZiB0cmFpbCBpcyBsZXNzIHRoYW4gMHgzRiBhbmQgMHg0MSBvdGhlcndpc2UuXG4gICAgICAgIHZhciBvZmZzZXQgPSB0cmFpbCA8IDB4M0YgPyAweDQwIDogMHg0MTtcblxuICAgICAgICAvLyA0LiBSZXR1cm4gdHdvIGJ5dGVzIHdob3NlIHZhbHVlcyBhcmUgbGVhZCBhbmQgdHJhaWwgKyBvZmZzZXQuXG4gICAgICAgIHJldHVybiBbbGVhZCwgdHJhaWwgKyBvZmZzZXRdO1xuICAgICAgfVxuXG4gICAgICAvLyA3LiBJZiBnYmsgZmxhZyBpcyBzZXQsIHJldHVybiBlcnJvciB3aXRoIGNvZGUgcG9pbnQuXG4gICAgICBpZiAoZ2JrX2ZsYWcpXG4gICAgICAgIHJldHVybiBlbmNvZGVyRXJyb3IoY29kZV9wb2ludCk7XG5cbiAgICAgIC8vIDguIFNldCBwb2ludGVyIHRvIHRoZSBpbmRleCBnYjE4MDMwIHJhbmdlcyBwb2ludGVyIGZvciBjb2RlXG4gICAgICAvLyBwb2ludC5cbiAgICAgIHBvaW50ZXIgPSBpbmRleEdCMTgwMzBSYW5nZXNQb2ludGVyRm9yKGNvZGVfcG9pbnQpO1xuXG4gICAgICAvLyA5LiBMZXQgYnl0ZTEgYmUgZmxvb3IocG9pbnRlciAvIDEwIC8gMTI2IC8gMTApLlxuICAgICAgdmFyIGJ5dGUxID0gZmxvb3IocG9pbnRlciAvIDEwIC8gMTI2IC8gMTApO1xuXG4gICAgICAvLyAxMC4gU2V0IHBvaW50ZXIgdG8gcG9pbnRlciDiiJIgYnl0ZTEgw5cgMTAgw5cgMTI2IMOXIDEwLlxuICAgICAgcG9pbnRlciA9IHBvaW50ZXIgLSBieXRlMSAqIDEwICogMTI2ICogMTA7XG5cbiAgICAgIC8vIDExLiBMZXQgYnl0ZTIgYmUgZmxvb3IocG9pbnRlciAvIDEwIC8gMTI2KS5cbiAgICAgIHZhciBieXRlMiA9IGZsb29yKHBvaW50ZXIgLyAxMCAvIDEyNik7XG5cbiAgICAgIC8vIDEyLiBTZXQgcG9pbnRlciB0byBwb2ludGVyIOKIkiBieXRlMiDDlyAxMCDDlyAxMjYuXG4gICAgICBwb2ludGVyID0gcG9pbnRlciAtIGJ5dGUyICogMTAgKiAxMjY7XG5cbiAgICAgIC8vIDEzLiBMZXQgYnl0ZTMgYmUgZmxvb3IocG9pbnRlciAvIDEwKS5cbiAgICAgIHZhciBieXRlMyA9IGZsb29yKHBvaW50ZXIgLyAxMCk7XG5cbiAgICAgIC8vIDE0LiBMZXQgYnl0ZTQgYmUgcG9pbnRlciDiiJIgYnl0ZTMgw5cgMTAuXG4gICAgICB2YXIgYnl0ZTQgPSBwb2ludGVyIC0gYnl0ZTMgKiAxMDtcblxuICAgICAgLy8gMTUuIFJldHVybiBmb3VyIGJ5dGVzIHdob3NlIHZhbHVlcyBhcmUgYnl0ZTEgKyAweDgxLCBieXRlMiArXG4gICAgICAvLyAweDMwLCBieXRlMyArIDB4ODEsIGJ5dGU0ICsgMHgzMC5cbiAgICAgIHJldHVybiBbYnl0ZTEgKyAweDgxLFxuICAgICAgICAgICAgICBieXRlMiArIDB4MzAsXG4gICAgICAgICAgICAgIGJ5dGUzICsgMHg4MSxcbiAgICAgICAgICAgICAgYnl0ZTQgKyAweDMwXTtcbiAgICB9O1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7e2ZhdGFsOiBib29sZWFufX0gb3B0aW9ucyAqL1xuICBlbmNvZGVyc1snZ2IxODAzMCddID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgR0IxODAzMEVuY29kZXIob3B0aW9ucyk7XG4gIH07XG4gIC8qKiBAcGFyYW0ge3tmYXRhbDogYm9vbGVhbn19IG9wdGlvbnMgKi9cbiAgZGVjb2RlcnNbJ2diMTgwMzAnXSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEdCMTgwMzBEZWNvZGVyKG9wdGlvbnMpO1xuICB9O1xuXG5cbiAgLy9cbiAgLy8gMTIuIExlZ2FjeSBtdWx0aS1ieXRlIENoaW5lc2UgKHRyYWRpdGlvbmFsKSBlbmNvZGluZ3NcbiAgLy9cblxuICAvLyAxMi4xIEJpZzVcblxuICAvLyAxMi4xLjEgQmlnNSBkZWNvZGVyXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGltcGxlbWVudHMge0RlY29kZXJ9XG4gICAqIEBwYXJhbSB7e2ZhdGFsOiBib29sZWFufX0gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gQmlnNURlY29kZXIob3B0aW9ucykge1xuICAgIHZhciBmYXRhbCA9IG9wdGlvbnMuZmF0YWw7XG4gICAgLy8gQmlnNSdzIGRlY29kZXIgaGFzIGFuIGFzc29jaWF0ZWQgQmlnNSBsZWFkIChpbml0aWFsbHkgMHgwMCkuXG4gICAgdmFyIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyBCaWc1X2xlYWQgPSAweDAwO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJlYW19IHN0cmVhbSBUaGUgc3RyZWFtIG9mIGJ5dGVzIGJlaW5nIGRlY29kZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdGUgVGhlIG5leHQgYnl0ZSByZWFkIGZyb20gdGhlIHN0cmVhbS5cbiAgICAgKiBAcmV0dXJuIHs/KG51bWJlcnwhQXJyYXkuPG51bWJlcj4pfSBUaGUgbmV4dCBjb2RlIHBvaW50KHMpXG4gICAgICogICAgIGRlY29kZWQsIG9yIG51bGwgaWYgbm90IGVub3VnaCBkYXRhIGV4aXN0cyBpbiB0aGUgaW5wdXRcbiAgICAgKiAgICAgc3RyZWFtIHRvIGRlY29kZSBhIGNvbXBsZXRlIGNvZGUgcG9pbnQuXG4gICAgICovXG4gICAgdGhpcy5oYW5kbGVyID0gZnVuY3Rpb24oc3RyZWFtLCBiaXRlKSB7XG4gICAgICAvLyAxLiBJZiBieXRlIGlzIGVuZC1vZi1zdHJlYW0gYW5kIEJpZzUgbGVhZCBpcyBub3QgMHgwMCwgc2V0XG4gICAgICAvLyBCaWc1IGxlYWQgdG8gMHgwMCBhbmQgcmV0dXJuIGVycm9yLlxuICAgICAgaWYgKGJpdGUgPT09IGVuZF9vZl9zdHJlYW0gJiYgQmlnNV9sZWFkICE9PSAweDAwKSB7XG4gICAgICAgIEJpZzVfbGVhZCA9IDB4MDA7XG4gICAgICAgIHJldHVybiBkZWNvZGVyRXJyb3IoZmF0YWwpO1xuICAgICAgfVxuXG4gICAgICAvLyAyLiBJZiBieXRlIGlzIGVuZC1vZi1zdHJlYW0gYW5kIEJpZzUgbGVhZCBpcyAweDAwLCByZXR1cm5cbiAgICAgIC8vIGZpbmlzaGVkLlxuICAgICAgaWYgKGJpdGUgPT09IGVuZF9vZl9zdHJlYW0gJiYgQmlnNV9sZWFkID09PSAweDAwKVxuICAgICAgICByZXR1cm4gZmluaXNoZWQ7XG5cbiAgICAgIC8vIDMuIElmIEJpZzUgbGVhZCBpcyBub3QgMHgwMCwgbGV0IGxlYWQgYmUgQmlnNSBsZWFkLCBsZXRcbiAgICAgIC8vIHBvaW50ZXIgYmUgbnVsbCwgc2V0IEJpZzUgbGVhZCB0byAweDAwLCBhbmQgdGhlbiBydW4gdGhlc2VcbiAgICAgIC8vIHN1YnN0ZXBzOlxuICAgICAgaWYgKEJpZzVfbGVhZCAhPT0gMHgwMCkge1xuICAgICAgICB2YXIgbGVhZCA9IEJpZzVfbGVhZDtcbiAgICAgICAgdmFyIHBvaW50ZXIgPSBudWxsO1xuICAgICAgICBCaWc1X2xlYWQgPSAweDAwO1xuXG4gICAgICAgIC8vIDEuIExldCBvZmZzZXQgYmUgMHg0MCBpZiBieXRlIGlzIGxlc3MgdGhhbiAweDdGIGFuZCAweDYyXG4gICAgICAgIC8vIG90aGVyd2lzZS5cbiAgICAgICAgdmFyIG9mZnNldCA9IGJpdGUgPCAweDdGID8gMHg0MCA6IDB4NjI7XG5cbiAgICAgICAgLy8gMi4gSWYgYnl0ZSBpcyBpbiB0aGUgcmFuZ2UgMHg0MCB0byAweDdFLCBpbmNsdXNpdmUsIG9yIDB4QTFcbiAgICAgICAgLy8gdG8gMHhGRSwgaW5jbHVzaXZlLCBzZXQgcG9pbnRlciB0byAobGVhZCDiiJIgMHg4MSkgw5cgMTU3ICtcbiAgICAgICAgLy8gKGJ5dGUg4oiSIG9mZnNldCkuXG4gICAgICAgIGlmIChpblJhbmdlKGJpdGUsIDB4NDAsIDB4N0UpIHx8IGluUmFuZ2UoYml0ZSwgMHhBMSwgMHhGRSkpXG4gICAgICAgICAgcG9pbnRlciA9IChsZWFkIC0gMHg4MSkgKiAxNTcgKyAoYml0ZSAtIG9mZnNldCk7XG5cbiAgICAgICAgLy8gMy4gSWYgdGhlcmUgaXMgYSByb3cgaW4gdGhlIHRhYmxlIGJlbG93IHdob3NlIGZpcnN0IGNvbHVtblxuICAgICAgICAvLyBpcyBwb2ludGVyLCByZXR1cm4gdGhlIHR3byBjb2RlIHBvaW50cyBsaXN0ZWQgaW4gaXRzIHNlY29uZFxuICAgICAgICAvLyBjb2x1bW5cbiAgICAgICAgLy8gUG9pbnRlciB8IENvZGUgcG9pbnRzXG4gICAgICAgIC8vIC0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIDExMzMgICAgfCBVKzAwQ0EgVSswMzA0XG4gICAgICAgIC8vIDExMzUgICAgfCBVKzAwQ0EgVSswMzBDXG4gICAgICAgIC8vIDExNjQgICAgfCBVKzAwRUEgVSswMzA0XG4gICAgICAgIC8vIDExNjYgICAgfCBVKzAwRUEgVSswMzBDXG4gICAgICAgIHN3aXRjaCAocG9pbnRlcikge1xuICAgICAgICAgIGNhc2UgMTEzMzogcmV0dXJuIFsweDAwQ0EsIDB4MDMwNF07XG4gICAgICAgICAgY2FzZSAxMTM1OiByZXR1cm4gWzB4MDBDQSwgMHgwMzBDXTtcbiAgICAgICAgICBjYXNlIDExNjQ6IHJldHVybiBbMHgwMEVBLCAweDAzMDRdO1xuICAgICAgICAgIGNhc2UgMTE2NjogcmV0dXJuIFsweDAwRUEsIDB4MDMwQ107XG4gICAgICAgIH1cblxuICAgICAgICAvLyA0LiBMZXQgY29kZSBwb2ludCBiZSBudWxsIGlmIHBvaW50ZXIgaXMgbnVsbCBhbmQgdGhlIGluZGV4XG4gICAgICAgIC8vIGNvZGUgcG9pbnQgZm9yIHBvaW50ZXIgaW4gaW5kZXggQmlnNSBvdGhlcndpc2UuXG4gICAgICAgIHZhciBjb2RlX3BvaW50ID0gKHBvaW50ZXIgPT09IG51bGwpID8gbnVsbCA6XG4gICAgICAgICAgICBpbmRleENvZGVQb2ludEZvcihwb2ludGVyLCBpbmRleCgnYmlnNScpKTtcblxuICAgICAgICAvLyA1LiBJZiBjb2RlIHBvaW50IGlzIG51bGwgYW5kIGJ5dGUgaXMgYW4gQVNDSUkgYnl0ZSwgcHJlcGVuZFxuICAgICAgICAvLyBieXRlIHRvIHN0cmVhbS5cbiAgICAgICAgaWYgKGNvZGVfcG9pbnQgPT09IG51bGwgJiYgaXNBU0NJSUJ5dGUoYml0ZSkpXG4gICAgICAgICAgc3RyZWFtLnByZXBlbmQoYml0ZSk7XG5cbiAgICAgICAgLy8gNi4gSWYgY29kZSBwb2ludCBpcyBudWxsLCByZXR1cm4gZXJyb3IuXG4gICAgICAgIGlmIChjb2RlX3BvaW50ID09PSBudWxsKVxuICAgICAgICAgIHJldHVybiBkZWNvZGVyRXJyb3IoZmF0YWwpO1xuXG4gICAgICAgIC8vIDcuIFJldHVybiBhIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgaXMgY29kZSBwb2ludC5cbiAgICAgICAgcmV0dXJuIGNvZGVfcG9pbnQ7XG4gICAgICB9XG5cbiAgICAgIC8vIDQuIElmIGJ5dGUgaXMgYW4gQVNDSUkgYnl0ZSwgcmV0dXJuIGEgY29kZSBwb2ludCB3aG9zZSB2YWx1ZVxuICAgICAgLy8gaXMgYnl0ZS5cbiAgICAgIGlmIChpc0FTQ0lJQnl0ZShiaXRlKSlcbiAgICAgICAgcmV0dXJuIGJpdGU7XG5cbiAgICAgIC8vIDUuIElmIGJ5dGUgaXMgaW4gdGhlIHJhbmdlIDB4ODEgdG8gMHhGRSwgaW5jbHVzaXZlLCBzZXQgQmlnNVxuICAgICAgLy8gbGVhZCB0byBieXRlIGFuZCByZXR1cm4gY29udGludWUuXG4gICAgICBpZiAoaW5SYW5nZShiaXRlLCAweDgxLCAweEZFKSkge1xuICAgICAgICBCaWc1X2xlYWQgPSBiaXRlO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gNi4gUmV0dXJuIGVycm9yLlxuICAgICAgcmV0dXJuIGRlY29kZXJFcnJvcihmYXRhbCk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIDEyLjEuMiBCaWc1IGVuY29kZXJcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAaW1wbGVtZW50cyB7RW5jb2Rlcn1cbiAgICogQHBhcmFtIHt7ZmF0YWw6IGJvb2xlYW59fSBvcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBCaWc1RW5jb2RlcihvcHRpb25zKSB7XG4gICAgdmFyIGZhdGFsID0gb3B0aW9ucy5mYXRhbDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmVhbX0gc3RyZWFtIElucHV0IHN0cmVhbS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29kZV9wb2ludCBOZXh0IGNvZGUgcG9pbnQgcmVhZCBmcm9tIHRoZSBzdHJlYW0uXG4gICAgICogQHJldHVybiB7KG51bWJlcnwhQXJyYXkuPG51bWJlcj4pfSBCeXRlKHMpIHRvIGVtaXQuXG4gICAgICovXG4gICAgdGhpcy5oYW5kbGVyID0gZnVuY3Rpb24oc3RyZWFtLCBjb2RlX3BvaW50KSB7XG4gICAgICAvLyAxLiBJZiBjb2RlIHBvaW50IGlzIGVuZC1vZi1zdHJlYW0sIHJldHVybiBmaW5pc2hlZC5cbiAgICAgIGlmIChjb2RlX3BvaW50ID09PSBlbmRfb2Zfc3RyZWFtKVxuICAgICAgICByZXR1cm4gZmluaXNoZWQ7XG5cbiAgICAgIC8vIDIuIElmIGNvZGUgcG9pbnQgaXMgYW4gQVNDSUkgY29kZSBwb2ludCwgcmV0dXJuIGEgYnl0ZSB3aG9zZVxuICAgICAgLy8gdmFsdWUgaXMgY29kZSBwb2ludC5cbiAgICAgIGlmIChpc0FTQ0lJQ29kZVBvaW50KGNvZGVfcG9pbnQpKVxuICAgICAgICByZXR1cm4gY29kZV9wb2ludDtcblxuICAgICAgLy8gMy4gTGV0IHBvaW50ZXIgYmUgdGhlIGluZGV4IEJpZzUgcG9pbnRlciBmb3IgY29kZSBwb2ludC5cbiAgICAgIHZhciBwb2ludGVyID0gaW5kZXhCaWc1UG9pbnRlckZvcihjb2RlX3BvaW50KTtcblxuICAgICAgLy8gNC4gSWYgcG9pbnRlciBpcyBudWxsLCByZXR1cm4gZXJyb3Igd2l0aCBjb2RlIHBvaW50LlxuICAgICAgaWYgKHBvaW50ZXIgPT09IG51bGwpXG4gICAgICAgIHJldHVybiBlbmNvZGVyRXJyb3IoY29kZV9wb2ludCk7XG5cbiAgICAgIC8vIDUuIExldCBsZWFkIGJlIGZsb29yKHBvaW50ZXIgLyAxNTcpICsgMHg4MS5cbiAgICAgIHZhciBsZWFkID0gZmxvb3IocG9pbnRlciAvIDE1NykgKyAweDgxO1xuXG4gICAgICAvLyA2LiBJZiBsZWFkIGlzIGxlc3MgdGhhbiAweEExLCByZXR1cm4gZXJyb3Igd2l0aCBjb2RlIHBvaW50LlxuICAgICAgaWYgKGxlYWQgPCAweEExKVxuICAgICAgICByZXR1cm4gZW5jb2RlckVycm9yKGNvZGVfcG9pbnQpO1xuXG4gICAgICAvLyA3LiBMZXQgdHJhaWwgYmUgcG9pbnRlciAlIDE1Ny5cbiAgICAgIHZhciB0cmFpbCA9IHBvaW50ZXIgJSAxNTc7XG5cbiAgICAgIC8vIDguIExldCBvZmZzZXQgYmUgMHg0MCBpZiB0cmFpbCBpcyBsZXNzIHRoYW4gMHgzRiBhbmQgMHg2MlxuICAgICAgLy8gb3RoZXJ3aXNlLlxuICAgICAgdmFyIG9mZnNldCA9IHRyYWlsIDwgMHgzRiA/IDB4NDAgOiAweDYyO1xuXG4gICAgICAvLyBSZXR1cm4gdHdvIGJ5dGVzIHdob3NlIHZhbHVlcyBhcmUgbGVhZCBhbmQgdHJhaWwgKyBvZmZzZXQuXG4gICAgICByZXR1cm4gW2xlYWQsIHRyYWlsICsgb2Zmc2V0XTtcbiAgICB9O1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7e2ZhdGFsOiBib29sZWFufX0gb3B0aW9ucyAqL1xuICBlbmNvZGVyc1snQmlnNSddID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgQmlnNUVuY29kZXIob3B0aW9ucyk7XG4gIH07XG4gIC8qKiBAcGFyYW0ge3tmYXRhbDogYm9vbGVhbn19IG9wdGlvbnMgKi9cbiAgZGVjb2RlcnNbJ0JpZzUnXSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEJpZzVEZWNvZGVyKG9wdGlvbnMpO1xuICB9O1xuXG5cbiAgLy9cbiAgLy8gMTMuIExlZ2FjeSBtdWx0aS1ieXRlIEphcGFuZXNlIGVuY29kaW5nc1xuICAvL1xuXG4gIC8vIDEzLjEgZXVjLWpwXG5cbiAgLy8gMTMuMS4xIGV1Yy1qcCBkZWNvZGVyXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGltcGxlbWVudHMge0RlY29kZXJ9XG4gICAqIEBwYXJhbSB7e2ZhdGFsOiBib29sZWFufX0gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gRVVDSlBEZWNvZGVyKG9wdGlvbnMpIHtcbiAgICB2YXIgZmF0YWwgPSBvcHRpb25zLmZhdGFsO1xuXG4gICAgLy8gZXVjLWpwJ3MgZGVjb2RlciBoYXMgYW4gYXNzb2NpYXRlZCBldWMtanAgamlzMDIxMiBmbGFnXG4gICAgLy8gKGluaXRpYWxseSB1bnNldCkgYW5kIGV1Yy1qcCBsZWFkIChpbml0aWFsbHkgMHgwMCkuXG4gICAgdmFyIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi8gZXVjanBfamlzMDIxMl9mbGFnID0gZmFsc2UsXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyBldWNqcF9sZWFkID0gMHgwMDtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyZWFtfSBzdHJlYW0gVGhlIHN0cmVhbSBvZiBieXRlcyBiZWluZyBkZWNvZGVkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRlIFRoZSBuZXh0IGJ5dGUgcmVhZCBmcm9tIHRoZSBzdHJlYW0uXG4gICAgICogQHJldHVybiB7PyhudW1iZXJ8IUFycmF5LjxudW1iZXI+KX0gVGhlIG5leHQgY29kZSBwb2ludChzKVxuICAgICAqICAgICBkZWNvZGVkLCBvciBudWxsIGlmIG5vdCBlbm91Z2ggZGF0YSBleGlzdHMgaW4gdGhlIGlucHV0XG4gICAgICogICAgIHN0cmVhbSB0byBkZWNvZGUgYSBjb21wbGV0ZSBjb2RlIHBvaW50LlxuICAgICAqL1xuICAgIHRoaXMuaGFuZGxlciA9IGZ1bmN0aW9uKHN0cmVhbSwgYml0ZSkge1xuICAgICAgLy8gMS4gSWYgYnl0ZSBpcyBlbmQtb2Ytc3RyZWFtIGFuZCBldWMtanAgbGVhZCBpcyBub3QgMHgwMCwgc2V0XG4gICAgICAvLyBldWMtanAgbGVhZCB0byAweDAwLCBhbmQgcmV0dXJuIGVycm9yLlxuICAgICAgaWYgKGJpdGUgPT09IGVuZF9vZl9zdHJlYW0gJiYgZXVjanBfbGVhZCAhPT0gMHgwMCkge1xuICAgICAgICBldWNqcF9sZWFkID0gMHgwMDtcbiAgICAgICAgcmV0dXJuIGRlY29kZXJFcnJvcihmYXRhbCk7XG4gICAgICB9XG5cbiAgICAgIC8vIDIuIElmIGJ5dGUgaXMgZW5kLW9mLXN0cmVhbSBhbmQgZXVjLWpwIGxlYWQgaXMgMHgwMCwgcmV0dXJuXG4gICAgICAvLyBmaW5pc2hlZC5cbiAgICAgIGlmIChiaXRlID09PSBlbmRfb2Zfc3RyZWFtICYmIGV1Y2pwX2xlYWQgPT09IDB4MDApXG4gICAgICAgIHJldHVybiBmaW5pc2hlZDtcblxuICAgICAgLy8gMy4gSWYgZXVjLWpwIGxlYWQgaXMgMHg4RSBhbmQgYnl0ZSBpcyBpbiB0aGUgcmFuZ2UgMHhBMSB0b1xuICAgICAgLy8gMHhERiwgaW5jbHVzaXZlLCBzZXQgZXVjLWpwIGxlYWQgdG8gMHgwMCBhbmQgcmV0dXJuIGEgY29kZVxuICAgICAgLy8gcG9pbnQgd2hvc2UgdmFsdWUgaXMgMHhGRjYxIOKIkiAweEExICsgYnl0ZS5cbiAgICAgIGlmIChldWNqcF9sZWFkID09PSAweDhFICYmIGluUmFuZ2UoYml0ZSwgMHhBMSwgMHhERikpIHtcbiAgICAgICAgZXVjanBfbGVhZCA9IDB4MDA7XG4gICAgICAgIHJldHVybiAweEZGNjEgLSAweEExICsgYml0ZTtcbiAgICAgIH1cblxuICAgICAgLy8gNC4gSWYgZXVjLWpwIGxlYWQgaXMgMHg4RiBhbmQgYnl0ZSBpcyBpbiB0aGUgcmFuZ2UgMHhBMSB0b1xuICAgICAgLy8gMHhGRSwgaW5jbHVzaXZlLCBzZXQgdGhlIGV1Yy1qcCBqaXMwMjEyIGZsYWcsIHNldCBldWMtanAgbGVhZFxuICAgICAgLy8gdG8gYnl0ZSwgYW5kIHJldHVybiBjb250aW51ZS5cbiAgICAgIGlmIChldWNqcF9sZWFkID09PSAweDhGICYmIGluUmFuZ2UoYml0ZSwgMHhBMSwgMHhGRSkpIHtcbiAgICAgICAgZXVjanBfamlzMDIxMl9mbGFnID0gdHJ1ZTtcbiAgICAgICAgZXVjanBfbGVhZCA9IGJpdGU7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyA1LiBJZiBldWMtanAgbGVhZCBpcyBub3QgMHgwMCwgbGV0IGxlYWQgYmUgZXVjLWpwIGxlYWQsIHNldFxuICAgICAgLy8gZXVjLWpwIGxlYWQgdG8gMHgwMCwgYW5kIHJ1biB0aGVzZSBzdWJzdGVwczpcbiAgICAgIGlmIChldWNqcF9sZWFkICE9PSAweDAwKSB7XG4gICAgICAgIHZhciBsZWFkID0gZXVjanBfbGVhZDtcbiAgICAgICAgZXVjanBfbGVhZCA9IDB4MDA7XG5cbiAgICAgICAgLy8gMS4gTGV0IGNvZGUgcG9pbnQgYmUgbnVsbC5cbiAgICAgICAgdmFyIGNvZGVfcG9pbnQgPSBudWxsO1xuXG4gICAgICAgIC8vIDIuIElmIGxlYWQgYW5kIGJ5dGUgYXJlIGJvdGggaW4gdGhlIHJhbmdlIDB4QTEgdG8gMHhGRSxcbiAgICAgICAgLy8gaW5jbHVzaXZlLCBzZXQgY29kZSBwb2ludCB0byB0aGUgaW5kZXggY29kZSBwb2ludCBmb3IgKGxlYWRcbiAgICAgICAgLy8g4oiSIDB4QTEpIMOXIDk0ICsgYnl0ZSDiiJIgMHhBMSBpbiBpbmRleCBqaXMwMjA4IGlmIHRoZSBldWMtanBcbiAgICAgICAgLy8gamlzMDIxMiBmbGFnIGlzIHVuc2V0IGFuZCBpbiBpbmRleCBqaXMwMjEyIG90aGVyd2lzZS5cbiAgICAgICAgaWYgKGluUmFuZ2UobGVhZCwgMHhBMSwgMHhGRSkgJiYgaW5SYW5nZShiaXRlLCAweEExLCAweEZFKSkge1xuICAgICAgICAgIGNvZGVfcG9pbnQgPSBpbmRleENvZGVQb2ludEZvcihcbiAgICAgICAgICAgIChsZWFkIC0gMHhBMSkgKiA5NCArIChiaXRlIC0gMHhBMSksXG4gICAgICAgICAgICBpbmRleCghZXVjanBfamlzMDIxMl9mbGFnID8gJ2ppczAyMDgnIDogJ2ppczAyMTInKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAzLiBVbnNldCB0aGUgZXVjLWpwIGppczAyMTIgZmxhZy5cbiAgICAgICAgZXVjanBfamlzMDIxMl9mbGFnID0gZmFsc2U7XG5cbiAgICAgICAgLy8gNC4gSWYgYnl0ZSBpcyBub3QgaW4gdGhlIHJhbmdlIDB4QTEgdG8gMHhGRSwgaW5jbHVzaXZlLFxuICAgICAgICAvLyBwcmVwZW5kIGJ5dGUgdG8gc3RyZWFtLlxuICAgICAgICBpZiAoIWluUmFuZ2UoYml0ZSwgMHhBMSwgMHhGRSkpXG4gICAgICAgICAgc3RyZWFtLnByZXBlbmQoYml0ZSk7XG5cbiAgICAgICAgLy8gNS4gSWYgY29kZSBwb2ludCBpcyBudWxsLCByZXR1cm4gZXJyb3IuXG4gICAgICAgIGlmIChjb2RlX3BvaW50ID09PSBudWxsKVxuICAgICAgICAgIHJldHVybiBkZWNvZGVyRXJyb3IoZmF0YWwpO1xuXG4gICAgICAgIC8vIDYuIFJldHVybiBhIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgaXMgY29kZSBwb2ludC5cbiAgICAgICAgcmV0dXJuIGNvZGVfcG9pbnQ7XG4gICAgICB9XG5cbiAgICAgIC8vIDYuIElmIGJ5dGUgaXMgYW4gQVNDSUkgYnl0ZSwgcmV0dXJuIGEgY29kZSBwb2ludCB3aG9zZSB2YWx1ZVxuICAgICAgLy8gaXMgYnl0ZS5cbiAgICAgIGlmIChpc0FTQ0lJQnl0ZShiaXRlKSlcbiAgICAgICAgcmV0dXJuIGJpdGU7XG5cbiAgICAgIC8vIDcuIElmIGJ5dGUgaXMgMHg4RSwgMHg4Riwgb3IgaW4gdGhlIHJhbmdlIDB4QTEgdG8gMHhGRSxcbiAgICAgIC8vIGluY2x1c2l2ZSwgc2V0IGV1Yy1qcCBsZWFkIHRvIGJ5dGUgYW5kIHJldHVybiBjb250aW51ZS5cbiAgICAgIGlmIChiaXRlID09PSAweDhFIHx8IGJpdGUgPT09IDB4OEYgfHwgaW5SYW5nZShiaXRlLCAweEExLCAweEZFKSkge1xuICAgICAgICBldWNqcF9sZWFkID0gYml0ZTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIDguIFJldHVybiBlcnJvci5cbiAgICAgIHJldHVybiBkZWNvZGVyRXJyb3IoZmF0YWwpO1xuICAgIH07XG4gIH1cblxuICAvLyAxMy4xLjIgZXVjLWpwIGVuY29kZXJcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAaW1wbGVtZW50cyB7RW5jb2Rlcn1cbiAgICogQHBhcmFtIHt7ZmF0YWw6IGJvb2xlYW59fSBvcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBFVUNKUEVuY29kZXIob3B0aW9ucykge1xuICAgIHZhciBmYXRhbCA9IG9wdGlvbnMuZmF0YWw7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJlYW19IHN0cmVhbSBJbnB1dCBzdHJlYW0uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvZGVfcG9pbnQgTmV4dCBjb2RlIHBvaW50IHJlYWQgZnJvbSB0aGUgc3RyZWFtLlxuICAgICAqIEByZXR1cm4geyhudW1iZXJ8IUFycmF5LjxudW1iZXI+KX0gQnl0ZShzKSB0byBlbWl0LlxuICAgICAqL1xuICAgIHRoaXMuaGFuZGxlciA9IGZ1bmN0aW9uKHN0cmVhbSwgY29kZV9wb2ludCkge1xuICAgICAgLy8gMS4gSWYgY29kZSBwb2ludCBpcyBlbmQtb2Ytc3RyZWFtLCByZXR1cm4gZmluaXNoZWQuXG4gICAgICBpZiAoY29kZV9wb2ludCA9PT0gZW5kX29mX3N0cmVhbSlcbiAgICAgICAgcmV0dXJuIGZpbmlzaGVkO1xuXG4gICAgICAvLyAyLiBJZiBjb2RlIHBvaW50IGlzIGFuIEFTQ0lJIGNvZGUgcG9pbnQsIHJldHVybiBhIGJ5dGUgd2hvc2VcbiAgICAgIC8vIHZhbHVlIGlzIGNvZGUgcG9pbnQuXG4gICAgICBpZiAoaXNBU0NJSUNvZGVQb2ludChjb2RlX3BvaW50KSlcbiAgICAgICAgcmV0dXJuIGNvZGVfcG9pbnQ7XG5cbiAgICAgIC8vIDMuIElmIGNvZGUgcG9pbnQgaXMgVSswMEE1LCByZXR1cm4gYnl0ZSAweDVDLlxuICAgICAgaWYgKGNvZGVfcG9pbnQgPT09IDB4MDBBNSlcbiAgICAgICAgcmV0dXJuIDB4NUM7XG5cbiAgICAgIC8vIDQuIElmIGNvZGUgcG9pbnQgaXMgVSsyMDNFLCByZXR1cm4gYnl0ZSAweDdFLlxuICAgICAgaWYgKGNvZGVfcG9pbnQgPT09IDB4MjAzRSlcbiAgICAgICAgcmV0dXJuIDB4N0U7XG5cbiAgICAgIC8vIDUuIElmIGNvZGUgcG9pbnQgaXMgaW4gdGhlIHJhbmdlIFUrRkY2MSB0byBVK0ZGOUYsIGluY2x1c2l2ZSxcbiAgICAgIC8vIHJldHVybiB0d28gYnl0ZXMgd2hvc2UgdmFsdWVzIGFyZSAweDhFIGFuZCBjb2RlIHBvaW50IOKIklxuICAgICAgLy8gMHhGRjYxICsgMHhBMS5cbiAgICAgIGlmIChpblJhbmdlKGNvZGVfcG9pbnQsIDB4RkY2MSwgMHhGRjlGKSlcbiAgICAgICAgcmV0dXJuIFsweDhFLCBjb2RlX3BvaW50IC0gMHhGRjYxICsgMHhBMV07XG5cbiAgICAgIC8vIDYuIElmIGNvZGUgcG9pbnQgaXMgVSsyMjEyLCBzZXQgaXQgdG8gVStGRjBELlxuICAgICAgaWYgKGNvZGVfcG9pbnQgPT09IDB4MjIxMilcbiAgICAgICAgY29kZV9wb2ludCA9IDB4RkYwRDtcblxuICAgICAgLy8gNy4gTGV0IHBvaW50ZXIgYmUgdGhlIGluZGV4IHBvaW50ZXIgZm9yIGNvZGUgcG9pbnQgaW4gaW5kZXhcbiAgICAgIC8vIGppczAyMDguXG4gICAgICB2YXIgcG9pbnRlciA9IGluZGV4UG9pbnRlckZvcihjb2RlX3BvaW50LCBpbmRleCgnamlzMDIwOCcpKTtcblxuICAgICAgLy8gOC4gSWYgcG9pbnRlciBpcyBudWxsLCByZXR1cm4gZXJyb3Igd2l0aCBjb2RlIHBvaW50LlxuICAgICAgaWYgKHBvaW50ZXIgPT09IG51bGwpXG4gICAgICAgIHJldHVybiBlbmNvZGVyRXJyb3IoY29kZV9wb2ludCk7XG5cbiAgICAgIC8vIDkuIExldCBsZWFkIGJlIGZsb29yKHBvaW50ZXIgLyA5NCkgKyAweEExLlxuICAgICAgdmFyIGxlYWQgPSBmbG9vcihwb2ludGVyIC8gOTQpICsgMHhBMTtcblxuICAgICAgLy8gMTAuIExldCB0cmFpbCBiZSBwb2ludGVyICUgOTQgKyAweEExLlxuICAgICAgdmFyIHRyYWlsID0gcG9pbnRlciAlIDk0ICsgMHhBMTtcblxuICAgICAgLy8gMTEuIFJldHVybiB0d28gYnl0ZXMgd2hvc2UgdmFsdWVzIGFyZSBsZWFkIGFuZCB0cmFpbC5cbiAgICAgIHJldHVybiBbbGVhZCwgdHJhaWxdO1xuICAgIH07XG4gIH1cblxuICAvKiogQHBhcmFtIHt7ZmF0YWw6IGJvb2xlYW59fSBvcHRpb25zICovXG4gIGVuY29kZXJzWydFVUMtSlAnXSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEVVQ0pQRW5jb2RlcihvcHRpb25zKTtcbiAgfTtcbiAgLyoqIEBwYXJhbSB7e2ZhdGFsOiBib29sZWFufX0gb3B0aW9ucyAqL1xuICBkZWNvZGVyc1snRVVDLUpQJ10gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBFVUNKUERlY29kZXIob3B0aW9ucyk7XG4gIH07XG5cbiAgLy8gMTMuMiBpc28tMjAyMi1qcFxuXG4gIC8vIDEzLjIuMSBpc28tMjAyMi1qcCBkZWNvZGVyXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGltcGxlbWVudHMge0RlY29kZXJ9XG4gICAqIEBwYXJhbSB7e2ZhdGFsOiBib29sZWFufX0gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gSVNPMjAyMkpQRGVjb2RlcihvcHRpb25zKSB7XG4gICAgdmFyIGZhdGFsID0gb3B0aW9ucy5mYXRhbDtcbiAgICAvKiogQGVudW0gKi9cbiAgICB2YXIgc3RhdGVzID0ge1xuICAgICAgQVNDSUk6IDAsXG4gICAgICBSb21hbjogMSxcbiAgICAgIEthdGFrYW5hOiAyLFxuICAgICAgTGVhZEJ5dGU6IDMsXG4gICAgICBUcmFpbEJ5dGU6IDQsXG4gICAgICBFc2NhcGVTdGFydDogNSxcbiAgICAgIEVzY2FwZTogNlxuICAgIH07XG4gICAgLy8gaXNvLTIwMjItanAncyBkZWNvZGVyIGhhcyBhbiBhc3NvY2lhdGVkIGlzby0yMDIyLWpwIGRlY29kZXJcbiAgICAvLyBzdGF0ZSAoaW5pdGlhbGx5IEFTQ0lJKSwgaXNvLTIwMjItanAgZGVjb2RlciBvdXRwdXQgc3RhdGVcbiAgICAvLyAoaW5pdGlhbGx5IEFTQ0lJKSwgaXNvLTIwMjItanAgbGVhZCAoaW5pdGlhbGx5IDB4MDApLCBhbmRcbiAgICAvLyBpc28tMjAyMi1qcCBvdXRwdXQgZmxhZyAoaW5pdGlhbGx5IHVuc2V0KS5cbiAgICB2YXIgLyoqIEB0eXBlIHtudW1iZXJ9ICovIGlzbzIwMjJqcF9kZWNvZGVyX3N0YXRlID0gc3RhdGVzLkFTQ0lJLFxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi8gaXNvMjAyMmpwX2RlY29kZXJfb3V0cHV0X3N0YXRlID0gc3RhdGVzLkFTQ0lJLFxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi8gaXNvMjAyMmpwX2xlYWQgPSAweDAwLFxuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovIGlzbzIwMjJqcF9vdXRwdXRfZmxhZyA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyZWFtfSBzdHJlYW0gVGhlIHN0cmVhbSBvZiBieXRlcyBiZWluZyBkZWNvZGVkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRlIFRoZSBuZXh0IGJ5dGUgcmVhZCBmcm9tIHRoZSBzdHJlYW0uXG4gICAgICogQHJldHVybiB7PyhudW1iZXJ8IUFycmF5LjxudW1iZXI+KX0gVGhlIG5leHQgY29kZSBwb2ludChzKVxuICAgICAqICAgICBkZWNvZGVkLCBvciBudWxsIGlmIG5vdCBlbm91Z2ggZGF0YSBleGlzdHMgaW4gdGhlIGlucHV0XG4gICAgICogICAgIHN0cmVhbSB0byBkZWNvZGUgYSBjb21wbGV0ZSBjb2RlIHBvaW50LlxuICAgICAqL1xuICAgIHRoaXMuaGFuZGxlciA9IGZ1bmN0aW9uKHN0cmVhbSwgYml0ZSkge1xuICAgICAgLy8gc3dpdGNoaW5nIG9uIGlzby0yMDIyLWpwIGRlY29kZXIgc3RhdGU6XG4gICAgICBzd2l0Y2ggKGlzbzIwMjJqcF9kZWNvZGVyX3N0YXRlKSB7XG4gICAgICBkZWZhdWx0OlxuICAgICAgY2FzZSBzdGF0ZXMuQVNDSUk6XG4gICAgICAgIC8vIEFTQ0lJXG4gICAgICAgIC8vIEJhc2VkIG9uIGJ5dGU6XG5cbiAgICAgICAgLy8gMHgxQlxuICAgICAgICBpZiAoYml0ZSA9PT0gMHgxQikge1xuICAgICAgICAgIC8vIFNldCBpc28tMjAyMi1qcCBkZWNvZGVyIHN0YXRlIHRvIGVzY2FwZSBzdGFydCBhbmQgcmV0dXJuXG4gICAgICAgICAgLy8gY29udGludWUuXG4gICAgICAgICAgaXNvMjAyMmpwX2RlY29kZXJfc3RhdGUgPSBzdGF0ZXMuRXNjYXBlU3RhcnQ7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAweDAwIHRvIDB4N0YsIGV4Y2x1ZGluZyAweDBFLCAweDBGLCBhbmQgMHgxQlxuICAgICAgICBpZiAoaW5SYW5nZShiaXRlLCAweDAwLCAweDdGKSAmJiBiaXRlICE9PSAweDBFXG4gICAgICAgICAgICAmJiBiaXRlICE9PSAweDBGICYmIGJpdGUgIT09IDB4MUIpIHtcbiAgICAgICAgICAvLyBVbnNldCB0aGUgaXNvLTIwMjItanAgb3V0cHV0IGZsYWcgYW5kIHJldHVybiBhIGNvZGUgcG9pbnRcbiAgICAgICAgICAvLyB3aG9zZSB2YWx1ZSBpcyBieXRlLlxuICAgICAgICAgIGlzbzIwMjJqcF9vdXRwdXRfZmxhZyA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBiaXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW5kLW9mLXN0cmVhbVxuICAgICAgICBpZiAoYml0ZSA9PT0gZW5kX29mX3N0cmVhbSkge1xuICAgICAgICAgIC8vIFJldHVybiBmaW5pc2hlZC5cbiAgICAgICAgICByZXR1cm4gZmluaXNoZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPdGhlcndpc2VcbiAgICAgICAgLy8gVW5zZXQgdGhlIGlzby0yMDIyLWpwIG91dHB1dCBmbGFnIGFuZCByZXR1cm4gZXJyb3IuXG4gICAgICAgIGlzbzIwMjJqcF9vdXRwdXRfZmxhZyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZGVjb2RlckVycm9yKGZhdGFsKTtcblxuICAgICAgY2FzZSBzdGF0ZXMuUm9tYW46XG4gICAgICAgIC8vIFJvbWFuXG4gICAgICAgIC8vIEJhc2VkIG9uIGJ5dGU6XG5cbiAgICAgICAgLy8gMHgxQlxuICAgICAgICBpZiAoYml0ZSA9PT0gMHgxQikge1xuICAgICAgICAgIC8vIFNldCBpc28tMjAyMi1qcCBkZWNvZGVyIHN0YXRlIHRvIGVzY2FwZSBzdGFydCBhbmQgcmV0dXJuXG4gICAgICAgICAgLy8gY29udGludWUuXG4gICAgICAgICAgaXNvMjAyMmpwX2RlY29kZXJfc3RhdGUgPSBzdGF0ZXMuRXNjYXBlU3RhcnQ7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAweDVDXG4gICAgICAgIGlmIChiaXRlID09PSAweDVDKSB7XG4gICAgICAgICAgLy8gVW5zZXQgdGhlIGlzby0yMDIyLWpwIG91dHB1dCBmbGFnIGFuZCByZXR1cm4gY29kZSBwb2ludFxuICAgICAgICAgIC8vIFUrMDBBNS5cbiAgICAgICAgICBpc28yMDIyanBfb3V0cHV0X2ZsYWcgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gMHgwMEE1O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gMHg3RVxuICAgICAgICBpZiAoYml0ZSA9PT0gMHg3RSkge1xuICAgICAgICAgIC8vIFVuc2V0IHRoZSBpc28tMjAyMi1qcCBvdXRwdXQgZmxhZyBhbmQgcmV0dXJuIGNvZGUgcG9pbnRcbiAgICAgICAgICAvLyBVKzIwM0UuXG4gICAgICAgICAgaXNvMjAyMmpwX291dHB1dF9mbGFnID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIDB4MjAzRTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDB4MDAgdG8gMHg3RiwgZXhjbHVkaW5nIDB4MEUsIDB4MEYsIDB4MUIsIDB4NUMsIGFuZCAweDdFXG4gICAgICAgIGlmIChpblJhbmdlKGJpdGUsIDB4MDAsIDB4N0YpICYmIGJpdGUgIT09IDB4MEUgJiYgYml0ZSAhPT0gMHgwRlxuICAgICAgICAgICAgJiYgYml0ZSAhPT0gMHgxQiAmJiBiaXRlICE9PSAweDVDICYmIGJpdGUgIT09IDB4N0UpIHtcbiAgICAgICAgICAvLyBVbnNldCB0aGUgaXNvLTIwMjItanAgb3V0cHV0IGZsYWcgYW5kIHJldHVybiBhIGNvZGUgcG9pbnRcbiAgICAgICAgICAvLyB3aG9zZSB2YWx1ZSBpcyBieXRlLlxuICAgICAgICAgIGlzbzIwMjJqcF9vdXRwdXRfZmxhZyA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBiaXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW5kLW9mLXN0cmVhbVxuICAgICAgICBpZiAoYml0ZSA9PT0gZW5kX29mX3N0cmVhbSkge1xuICAgICAgICAgIC8vIFJldHVybiBmaW5pc2hlZC5cbiAgICAgICAgICByZXR1cm4gZmluaXNoZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPdGhlcndpc2VcbiAgICAgICAgLy8gVW5zZXQgdGhlIGlzby0yMDIyLWpwIG91dHB1dCBmbGFnIGFuZCByZXR1cm4gZXJyb3IuXG4gICAgICAgIGlzbzIwMjJqcF9vdXRwdXRfZmxhZyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZGVjb2RlckVycm9yKGZhdGFsKTtcblxuICAgICAgY2FzZSBzdGF0ZXMuS2F0YWthbmE6XG4gICAgICAgIC8vIEthdGFrYW5hXG4gICAgICAgIC8vIEJhc2VkIG9uIGJ5dGU6XG5cbiAgICAgICAgLy8gMHgxQlxuICAgICAgICBpZiAoYml0ZSA9PT0gMHgxQikge1xuICAgICAgICAgIC8vIFNldCBpc28tMjAyMi1qcCBkZWNvZGVyIHN0YXRlIHRvIGVzY2FwZSBzdGFydCBhbmQgcmV0dXJuXG4gICAgICAgICAgLy8gY29udGludWUuXG4gICAgICAgICAgaXNvMjAyMmpwX2RlY29kZXJfc3RhdGUgPSBzdGF0ZXMuRXNjYXBlU3RhcnQ7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAweDIxIHRvIDB4NUZcbiAgICAgICAgaWYgKGluUmFuZ2UoYml0ZSwgMHgyMSwgMHg1RikpIHtcbiAgICAgICAgICAvLyBVbnNldCB0aGUgaXNvLTIwMjItanAgb3V0cHV0IGZsYWcgYW5kIHJldHVybiBhIGNvZGUgcG9pbnRcbiAgICAgICAgICAvLyB3aG9zZSB2YWx1ZSBpcyAweEZGNjEg4oiSIDB4MjEgKyBieXRlLlxuICAgICAgICAgIGlzbzIwMjJqcF9vdXRwdXRfZmxhZyA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiAweEZGNjEgLSAweDIxICsgYml0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVuZC1vZi1zdHJlYW1cbiAgICAgICAgaWYgKGJpdGUgPT09IGVuZF9vZl9zdHJlYW0pIHtcbiAgICAgICAgICAvLyBSZXR1cm4gZmluaXNoZWQuXG4gICAgICAgICAgcmV0dXJuIGZpbmlzaGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlXG4gICAgICAgIC8vIFVuc2V0IHRoZSBpc28tMjAyMi1qcCBvdXRwdXQgZmxhZyBhbmQgcmV0dXJuIGVycm9yLlxuICAgICAgICBpc28yMDIyanBfb3V0cHV0X2ZsYWcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGRlY29kZXJFcnJvcihmYXRhbCk7XG5cbiAgICAgIGNhc2Ugc3RhdGVzLkxlYWRCeXRlOlxuICAgICAgICAvLyBMZWFkIGJ5dGVcbiAgICAgICAgLy8gQmFzZWQgb24gYnl0ZTpcblxuICAgICAgICAvLyAweDFCXG4gICAgICAgIGlmIChiaXRlID09PSAweDFCKSB7XG4gICAgICAgICAgLy8gU2V0IGlzby0yMDIyLWpwIGRlY29kZXIgc3RhdGUgdG8gZXNjYXBlIHN0YXJ0IGFuZCByZXR1cm5cbiAgICAgICAgICAvLyBjb250aW51ZS5cbiAgICAgICAgICBpc28yMDIyanBfZGVjb2Rlcl9zdGF0ZSA9IHN0YXRlcy5Fc2NhcGVTdGFydDtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDB4MjEgdG8gMHg3RVxuICAgICAgICBpZiAoaW5SYW5nZShiaXRlLCAweDIxLCAweDdFKSkge1xuICAgICAgICAgIC8vIFVuc2V0IHRoZSBpc28tMjAyMi1qcCBvdXRwdXQgZmxhZywgc2V0IGlzby0yMDIyLWpwIGxlYWRcbiAgICAgICAgICAvLyB0byBieXRlLCBpc28tMjAyMi1qcCBkZWNvZGVyIHN0YXRlIHRvIHRyYWlsIGJ5dGUsIGFuZFxuICAgICAgICAgIC8vIHJldHVybiBjb250aW51ZS5cbiAgICAgICAgICBpc28yMDIyanBfb3V0cHV0X2ZsYWcgPSBmYWxzZTtcbiAgICAgICAgICBpc28yMDIyanBfbGVhZCA9IGJpdGU7XG4gICAgICAgICAgaXNvMjAyMmpwX2RlY29kZXJfc3RhdGUgPSBzdGF0ZXMuVHJhaWxCeXRlO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW5kLW9mLXN0cmVhbVxuICAgICAgICBpZiAoYml0ZSA9PT0gZW5kX29mX3N0cmVhbSkge1xuICAgICAgICAgIC8vIFJldHVybiBmaW5pc2hlZC5cbiAgICAgICAgICByZXR1cm4gZmluaXNoZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPdGhlcndpc2VcbiAgICAgICAgLy8gVW5zZXQgdGhlIGlzby0yMDIyLWpwIG91dHB1dCBmbGFnIGFuZCByZXR1cm4gZXJyb3IuXG4gICAgICAgIGlzbzIwMjJqcF9vdXRwdXRfZmxhZyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZGVjb2RlckVycm9yKGZhdGFsKTtcblxuICAgICAgY2FzZSBzdGF0ZXMuVHJhaWxCeXRlOlxuICAgICAgICAvLyBUcmFpbCBieXRlXG4gICAgICAgIC8vIEJhc2VkIG9uIGJ5dGU6XG5cbiAgICAgICAgLy8gMHgxQlxuICAgICAgICBpZiAoYml0ZSA9PT0gMHgxQikge1xuICAgICAgICAgIC8vIFNldCBpc28tMjAyMi1qcCBkZWNvZGVyIHN0YXRlIHRvIGVzY2FwZSBzdGFydCBhbmQgcmV0dXJuXG4gICAgICAgICAgLy8gY29udGludWUuXG4gICAgICAgICAgaXNvMjAyMmpwX2RlY29kZXJfc3RhdGUgPSBzdGF0ZXMuRXNjYXBlU3RhcnQ7XG4gICAgICAgICAgcmV0dXJuIGRlY29kZXJFcnJvcihmYXRhbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAweDIxIHRvIDB4N0VcbiAgICAgICAgaWYgKGluUmFuZ2UoYml0ZSwgMHgyMSwgMHg3RSkpIHtcbiAgICAgICAgICAvLyAxLiBTZXQgdGhlIGlzby0yMDIyLWpwIGRlY29kZXIgc3RhdGUgdG8gbGVhZCBieXRlLlxuICAgICAgICAgIGlzbzIwMjJqcF9kZWNvZGVyX3N0YXRlID0gc3RhdGVzLkxlYWRCeXRlO1xuXG4gICAgICAgICAgLy8gMi4gTGV0IHBvaW50ZXIgYmUgKGlzby0yMDIyLWpwIGxlYWQg4oiSIDB4MjEpIMOXIDk0ICsgYnl0ZSDiiJIgMHgyMS5cbiAgICAgICAgICB2YXIgcG9pbnRlciA9IChpc28yMDIyanBfbGVhZCAtIDB4MjEpICogOTQgKyBiaXRlIC0gMHgyMTtcblxuICAgICAgICAgIC8vIDMuIExldCBjb2RlIHBvaW50IGJlIHRoZSBpbmRleCBjb2RlIHBvaW50IGZvciBwb2ludGVyIGluXG4gICAgICAgICAgLy8gaW5kZXggamlzMDIwOC5cbiAgICAgICAgICB2YXIgY29kZV9wb2ludCA9IGluZGV4Q29kZVBvaW50Rm9yKHBvaW50ZXIsIGluZGV4KCdqaXMwMjA4JykpO1xuXG4gICAgICAgICAgLy8gNC4gSWYgY29kZSBwb2ludCBpcyBudWxsLCByZXR1cm4gZXJyb3IuXG4gICAgICAgICAgaWYgKGNvZGVfcG9pbnQgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlckVycm9yKGZhdGFsKTtcblxuICAgICAgICAgIC8vIDUuIFJldHVybiBhIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgaXMgY29kZSBwb2ludC5cbiAgICAgICAgICByZXR1cm4gY29kZV9wb2ludDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVuZC1vZi1zdHJlYW1cbiAgICAgICAgaWYgKGJpdGUgPT09IGVuZF9vZl9zdHJlYW0pIHtcbiAgICAgICAgICAvLyBTZXQgdGhlIGlzby0yMDIyLWpwIGRlY29kZXIgc3RhdGUgdG8gbGVhZCBieXRlLCBwcmVwZW5kXG4gICAgICAgICAgLy8gYnl0ZSB0byBzdHJlYW0sIGFuZCByZXR1cm4gZXJyb3IuXG4gICAgICAgICAgaXNvMjAyMmpwX2RlY29kZXJfc3RhdGUgPSBzdGF0ZXMuTGVhZEJ5dGU7XG4gICAgICAgICAgc3RyZWFtLnByZXBlbmQoYml0ZSk7XG4gICAgICAgICAgcmV0dXJuIGRlY29kZXJFcnJvcihmYXRhbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPdGhlcndpc2VcbiAgICAgICAgLy8gU2V0IGlzby0yMDIyLWpwIGRlY29kZXIgc3RhdGUgdG8gbGVhZCBieXRlIGFuZCByZXR1cm5cbiAgICAgICAgLy8gZXJyb3IuXG4gICAgICAgIGlzbzIwMjJqcF9kZWNvZGVyX3N0YXRlID0gc3RhdGVzLkxlYWRCeXRlO1xuICAgICAgICByZXR1cm4gZGVjb2RlckVycm9yKGZhdGFsKTtcblxuICAgICAgY2FzZSBzdGF0ZXMuRXNjYXBlU3RhcnQ6XG4gICAgICAgIC8vIEVzY2FwZSBzdGFydFxuXG4gICAgICAgIC8vIDEuIElmIGJ5dGUgaXMgZWl0aGVyIDB4MjQgb3IgMHgyOCwgc2V0IGlzby0yMDIyLWpwIGxlYWQgdG9cbiAgICAgICAgLy8gYnl0ZSwgaXNvLTIwMjItanAgZGVjb2RlciBzdGF0ZSB0byBlc2NhcGUsIGFuZCByZXR1cm5cbiAgICAgICAgLy8gY29udGludWUuXG4gICAgICAgIGlmIChiaXRlID09PSAweDI0IHx8IGJpdGUgPT09IDB4MjgpIHtcbiAgICAgICAgICBpc28yMDIyanBfbGVhZCA9IGJpdGU7XG4gICAgICAgICAgaXNvMjAyMmpwX2RlY29kZXJfc3RhdGUgPSBzdGF0ZXMuRXNjYXBlO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gMi4gUHJlcGVuZCBieXRlIHRvIHN0cmVhbS5cbiAgICAgICAgc3RyZWFtLnByZXBlbmQoYml0ZSk7XG5cbiAgICAgICAgLy8gMy4gVW5zZXQgdGhlIGlzby0yMDIyLWpwIG91dHB1dCBmbGFnLCBzZXQgaXNvLTIwMjItanBcbiAgICAgICAgLy8gZGVjb2RlciBzdGF0ZSB0byBpc28tMjAyMi1qcCBkZWNvZGVyIG91dHB1dCBzdGF0ZSwgYW5kXG4gICAgICAgIC8vIHJldHVybiBlcnJvci5cbiAgICAgICAgaXNvMjAyMmpwX291dHB1dF9mbGFnID0gZmFsc2U7XG4gICAgICAgIGlzbzIwMjJqcF9kZWNvZGVyX3N0YXRlID0gaXNvMjAyMmpwX2RlY29kZXJfb3V0cHV0X3N0YXRlO1xuICAgICAgICByZXR1cm4gZGVjb2RlckVycm9yKGZhdGFsKTtcblxuICAgICAgY2FzZSBzdGF0ZXMuRXNjYXBlOlxuICAgICAgICAvLyBFc2NhcGVcblxuICAgICAgICAvLyAxLiBMZXQgbGVhZCBiZSBpc28tMjAyMi1qcCBsZWFkIGFuZCBzZXQgaXNvLTIwMjItanAgbGVhZCB0b1xuICAgICAgICAvLyAweDAwLlxuICAgICAgICB2YXIgbGVhZCA9IGlzbzIwMjJqcF9sZWFkO1xuICAgICAgICBpc28yMDIyanBfbGVhZCA9IDB4MDA7XG5cbiAgICAgICAgLy8gMi4gTGV0IHN0YXRlIGJlIG51bGwuXG4gICAgICAgIHZhciBzdGF0ZSA9IG51bGw7XG5cbiAgICAgICAgLy8gMy4gSWYgbGVhZCBpcyAweDI4IGFuZCBieXRlIGlzIDB4NDIsIHNldCBzdGF0ZSB0byBBU0NJSS5cbiAgICAgICAgaWYgKGxlYWQgPT09IDB4MjggJiYgYml0ZSA9PT0gMHg0MilcbiAgICAgICAgICBzdGF0ZSA9IHN0YXRlcy5BU0NJSTtcblxuICAgICAgICAvLyA0LiBJZiBsZWFkIGlzIDB4MjggYW5kIGJ5dGUgaXMgMHg0QSwgc2V0IHN0YXRlIHRvIFJvbWFuLlxuICAgICAgICBpZiAobGVhZCA9PT0gMHgyOCAmJiBiaXRlID09PSAweDRBKVxuICAgICAgICAgIHN0YXRlID0gc3RhdGVzLlJvbWFuO1xuXG4gICAgICAgIC8vIDUuIElmIGxlYWQgaXMgMHgyOCBhbmQgYnl0ZSBpcyAweDQ5LCBzZXQgc3RhdGUgdG8gS2F0YWthbmEuXG4gICAgICAgIGlmIChsZWFkID09PSAweDI4ICYmIGJpdGUgPT09IDB4NDkpXG4gICAgICAgICAgc3RhdGUgPSBzdGF0ZXMuS2F0YWthbmE7XG5cbiAgICAgICAgLy8gNi4gSWYgbGVhZCBpcyAweDI0IGFuZCBieXRlIGlzIGVpdGhlciAweDQwIG9yIDB4NDIsIHNldFxuICAgICAgICAvLyBzdGF0ZSB0byBsZWFkIGJ5dGUuXG4gICAgICAgIGlmIChsZWFkID09PSAweDI0ICYmIChiaXRlID09PSAweDQwIHx8IGJpdGUgPT09IDB4NDIpKVxuICAgICAgICAgIHN0YXRlID0gc3RhdGVzLkxlYWRCeXRlO1xuXG4gICAgICAgIC8vIDcuIElmIHN0YXRlIGlzIG5vbi1udWxsLCBydW4gdGhlc2Ugc3Vic3RlcHM6XG4gICAgICAgIGlmIChzdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIDEuIFNldCBpc28tMjAyMi1qcCBkZWNvZGVyIHN0YXRlIGFuZCBpc28tMjAyMi1qcCBkZWNvZGVyXG4gICAgICAgICAgLy8gb3V0cHV0IHN0YXRlIHRvIHN0YXRlcy5cbiAgICAgICAgICBpc28yMDIyanBfZGVjb2Rlcl9zdGF0ZSA9IGlzbzIwMjJqcF9kZWNvZGVyX3N0YXRlID0gc3RhdGU7XG5cbiAgICAgICAgICAvLyAyLiBMZXQgb3V0cHV0IGZsYWcgYmUgdGhlIGlzby0yMDIyLWpwIG91dHB1dCBmbGFnLlxuICAgICAgICAgIHZhciBvdXRwdXRfZmxhZyA9IGlzbzIwMjJqcF9vdXRwdXRfZmxhZztcblxuICAgICAgICAgIC8vIDMuIFNldCB0aGUgaXNvLTIwMjItanAgb3V0cHV0IGZsYWcuXG4gICAgICAgICAgaXNvMjAyMmpwX291dHB1dF9mbGFnID0gdHJ1ZTtcblxuICAgICAgICAgIC8vIDQuIFJldHVybiBjb250aW51ZSwgaWYgb3V0cHV0IGZsYWcgaXMgdW5zZXQsIGFuZCBlcnJvclxuICAgICAgICAgIC8vIG90aGVyd2lzZS5cbiAgICAgICAgICByZXR1cm4gIW91dHB1dF9mbGFnID8gbnVsbCA6IGRlY29kZXJFcnJvcihmYXRhbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyA4LiBQcmVwZW5kIGxlYWQgYW5kIGJ5dGUgdG8gc3RyZWFtLlxuICAgICAgICBzdHJlYW0ucHJlcGVuZChbbGVhZCwgYml0ZV0pO1xuXG4gICAgICAgIC8vIDkuIFVuc2V0IHRoZSBpc28tMjAyMi1qcCBvdXRwdXQgZmxhZywgc2V0IGlzby0yMDIyLWpwXG4gICAgICAgIC8vIGRlY29kZXIgc3RhdGUgdG8gaXNvLTIwMjItanAgZGVjb2RlciBvdXRwdXQgc3RhdGUgYW5kXG4gICAgICAgIC8vIHJldHVybiBlcnJvci5cbiAgICAgICAgaXNvMjAyMmpwX291dHB1dF9mbGFnID0gZmFsc2U7XG4gICAgICAgIGlzbzIwMjJqcF9kZWNvZGVyX3N0YXRlID0gaXNvMjAyMmpwX2RlY29kZXJfb3V0cHV0X3N0YXRlO1xuICAgICAgICByZXR1cm4gZGVjb2RlckVycm9yKGZhdGFsKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gMTMuMi4yIGlzby0yMDIyLWpwIGVuY29kZXJcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAaW1wbGVtZW50cyB7RW5jb2Rlcn1cbiAgICogQHBhcmFtIHt7ZmF0YWw6IGJvb2xlYW59fSBvcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBJU08yMDIySlBFbmNvZGVyKG9wdGlvbnMpIHtcbiAgICB2YXIgZmF0YWwgPSBvcHRpb25zLmZhdGFsO1xuICAgIC8vIGlzby0yMDIyLWpwJ3MgZW5jb2RlciBoYXMgYW4gYXNzb2NpYXRlZCBpc28tMjAyMi1qcCBlbmNvZGVyXG4gICAgLy8gc3RhdGUgd2hpY2ggaXMgb25lIG9mIEFTQ0lJLCBSb21hbiwgYW5kIGppczAyMDggKGluaXRpYWxseVxuICAgIC8vIEFTQ0lJKS5cbiAgICAvKiogQGVudW0gKi9cbiAgICB2YXIgc3RhdGVzID0ge1xuICAgICAgQVNDSUk6IDAsXG4gICAgICBSb21hbjogMSxcbiAgICAgIGppczAyMDg6IDJcbiAgICB9O1xuICAgIHZhciAvKiogQHR5cGUge251bWJlcn0gKi8gaXNvMjAyMmpwX3N0YXRlID0gc3RhdGVzLkFTQ0lJO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyZWFtfSBzdHJlYW0gSW5wdXQgc3RyZWFtLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlX3BvaW50IE5leHQgY29kZSBwb2ludCByZWFkIGZyb20gdGhlIHN0cmVhbS5cbiAgICAgKiBAcmV0dXJuIHsobnVtYmVyfCFBcnJheS48bnVtYmVyPil9IEJ5dGUocykgdG8gZW1pdC5cbiAgICAgKi9cbiAgICB0aGlzLmhhbmRsZXIgPSBmdW5jdGlvbihzdHJlYW0sIGNvZGVfcG9pbnQpIHtcbiAgICAgIC8vIDEuIElmIGNvZGUgcG9pbnQgaXMgZW5kLW9mLXN0cmVhbSBhbmQgaXNvLTIwMjItanAgZW5jb2RlclxuICAgICAgLy8gc3RhdGUgaXMgbm90IEFTQ0lJLCBwcmVwZW5kIGNvZGUgcG9pbnQgdG8gc3RyZWFtLCBzZXRcbiAgICAgIC8vIGlzby0yMDIyLWpwIGVuY29kZXIgc3RhdGUgdG8gQVNDSUksIGFuZCByZXR1cm4gdGhyZWUgYnl0ZXNcbiAgICAgIC8vIDB4MUIgMHgyOCAweDQyLlxuICAgICAgaWYgKGNvZGVfcG9pbnQgPT09IGVuZF9vZl9zdHJlYW0gJiZcbiAgICAgICAgICBpc28yMDIyanBfc3RhdGUgIT09IHN0YXRlcy5BU0NJSSkge1xuICAgICAgICBzdHJlYW0ucHJlcGVuZChjb2RlX3BvaW50KTtcbiAgICAgICAgaXNvMjAyMmpwX3N0YXRlID0gc3RhdGVzLkFTQ0lJO1xuICAgICAgICByZXR1cm4gWzB4MUIsIDB4MjgsIDB4NDJdO1xuICAgICAgfVxuXG4gICAgICAvLyAyLiBJZiBjb2RlIHBvaW50IGlzIGVuZC1vZi1zdHJlYW0gYW5kIGlzby0yMDIyLWpwIGVuY29kZXJcbiAgICAgIC8vIHN0YXRlIGlzIEFTQ0lJLCByZXR1cm4gZmluaXNoZWQuXG4gICAgICBpZiAoY29kZV9wb2ludCA9PT0gZW5kX29mX3N0cmVhbSAmJiBpc28yMDIyanBfc3RhdGUgPT09IHN0YXRlcy5BU0NJSSlcbiAgICAgICAgcmV0dXJuIGZpbmlzaGVkO1xuXG4gICAgICAvLyAzLiBJZiBJU08tMjAyMi1KUCBlbmNvZGVyIHN0YXRlIGlzIEFTQ0lJIG9yIFJvbWFuLCBhbmQgY29kZVxuICAgICAgLy8gcG9pbnQgaXMgVSswMDBFLCBVKzAwMEYsIG9yIFUrMDAxQiwgcmV0dXJuIGVycm9yIHdpdGggVStGRkZELlxuICAgICAgaWYgKChpc28yMDIyanBfc3RhdGUgPT09IHN0YXRlcy5BU0NJSSB8fFxuICAgICAgICAgICBpc28yMDIyanBfc3RhdGUgPT09IHN0YXRlcy5Sb21hbikgJiZcbiAgICAgICAgICAoY29kZV9wb2ludCA9PT0gMHgwMDBFIHx8IGNvZGVfcG9pbnQgPT09IDB4MDAwRiB8fFxuICAgICAgICAgICBjb2RlX3BvaW50ID09PSAweDAwMUIpKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVyRXJyb3IoMHhGRkZEKTtcbiAgICAgIH1cblxuICAgICAgLy8gNC4gSWYgaXNvLTIwMjItanAgZW5jb2RlciBzdGF0ZSBpcyBBU0NJSSBhbmQgY29kZSBwb2ludCBpcyBhblxuICAgICAgLy8gQVNDSUkgY29kZSBwb2ludCwgcmV0dXJuIGEgYnl0ZSB3aG9zZSB2YWx1ZSBpcyBjb2RlIHBvaW50LlxuICAgICAgaWYgKGlzbzIwMjJqcF9zdGF0ZSA9PT0gc3RhdGVzLkFTQ0lJICYmXG4gICAgICAgICAgaXNBU0NJSUNvZGVQb2ludChjb2RlX3BvaW50KSlcbiAgICAgICAgcmV0dXJuIGNvZGVfcG9pbnQ7XG5cbiAgICAgIC8vIDUuIElmIGlzby0yMDIyLWpwIGVuY29kZXIgc3RhdGUgaXMgUm9tYW4gYW5kIGNvZGUgcG9pbnQgaXMgYW5cbiAgICAgIC8vIEFTQ0lJIGNvZGUgcG9pbnQsIGV4Y2x1ZGluZyBVKzAwNUMgYW5kIFUrMDA3RSwgb3IgaXMgVSswMEE1XG4gICAgICAvLyBvciBVKzIwM0UsIHJ1biB0aGVzZSBzdWJzdGVwczpcbiAgICAgIGlmIChpc28yMDIyanBfc3RhdGUgPT09IHN0YXRlcy5Sb21hbiAmJlxuICAgICAgICAgICgoaXNBU0NJSUNvZGVQb2ludChjb2RlX3BvaW50KSAmJlxuICAgICAgICAgICBjb2RlX3BvaW50ICE9PSAweDAwNUMgJiYgY29kZV9wb2ludCAhPT0gMHgwMDdFKSB8fFxuICAgICAgICAgIChjb2RlX3BvaW50ID09IDB4MDBBNSB8fCBjb2RlX3BvaW50ID09IDB4MjAzRSkpKSB7XG5cbiAgICAgICAgLy8gMS4gSWYgY29kZSBwb2ludCBpcyBhbiBBU0NJSSBjb2RlIHBvaW50LCByZXR1cm4gYSBieXRlXG4gICAgICAgIC8vIHdob3NlIHZhbHVlIGlzIGNvZGUgcG9pbnQuXG4gICAgICAgIGlmIChpc0FTQ0lJQ29kZVBvaW50KGNvZGVfcG9pbnQpKVxuICAgICAgICAgIHJldHVybiBjb2RlX3BvaW50O1xuXG4gICAgICAgIC8vIDIuIElmIGNvZGUgcG9pbnQgaXMgVSswMEE1LCByZXR1cm4gYnl0ZSAweDVDLlxuICAgICAgICBpZiAoY29kZV9wb2ludCA9PT0gMHgwMEE1KVxuICAgICAgICAgIHJldHVybiAweDVDO1xuXG4gICAgICAgIC8vIDMuIElmIGNvZGUgcG9pbnQgaXMgVSsyMDNFLCByZXR1cm4gYnl0ZSAweDdFLlxuICAgICAgICBpZiAoY29kZV9wb2ludCA9PT0gMHgyMDNFKVxuICAgICAgICAgIHJldHVybiAweDdFO1xuICAgICAgfVxuXG4gICAgICAvLyA2LiBJZiBjb2RlIHBvaW50IGlzIGFuIEFTQ0lJIGNvZGUgcG9pbnQsIGFuZCBpc28tMjAyMi1qcFxuICAgICAgLy8gZW5jb2RlciBzdGF0ZSBpcyBub3QgQVNDSUksIHByZXBlbmQgY29kZSBwb2ludCB0byBzdHJlYW0sIHNldFxuICAgICAgLy8gaXNvLTIwMjItanAgZW5jb2RlciBzdGF0ZSB0byBBU0NJSSwgYW5kIHJldHVybiB0aHJlZSBieXRlc1xuICAgICAgLy8gMHgxQiAweDI4IDB4NDIuXG4gICAgICBpZiAoaXNBU0NJSUNvZGVQb2ludChjb2RlX3BvaW50KSAmJlxuICAgICAgICAgIGlzbzIwMjJqcF9zdGF0ZSAhPT0gc3RhdGVzLkFTQ0lJKSB7XG4gICAgICAgIHN0cmVhbS5wcmVwZW5kKGNvZGVfcG9pbnQpO1xuICAgICAgICBpc28yMDIyanBfc3RhdGUgPSBzdGF0ZXMuQVNDSUk7XG4gICAgICAgIHJldHVybiBbMHgxQiwgMHgyOCwgMHg0Ml07XG4gICAgICB9XG5cbiAgICAgIC8vIDcuIElmIGNvZGUgcG9pbnQgaXMgZWl0aGVyIFUrMDBBNSBvciBVKzIwM0UsIGFuZCBpc28tMjAyMi1qcFxuICAgICAgLy8gZW5jb2RlciBzdGF0ZSBpcyBub3QgUm9tYW4sIHByZXBlbmQgY29kZSBwb2ludCB0byBzdHJlYW0sIHNldFxuICAgICAgLy8gaXNvLTIwMjItanAgZW5jb2RlciBzdGF0ZSB0byBSb21hbiwgYW5kIHJldHVybiB0aHJlZSBieXRlc1xuICAgICAgLy8gMHgxQiAweDI4IDB4NEEuXG4gICAgICBpZiAoKGNvZGVfcG9pbnQgPT09IDB4MDBBNSB8fCBjb2RlX3BvaW50ID09PSAweDIwM0UpICYmXG4gICAgICAgICAgaXNvMjAyMmpwX3N0YXRlICE9PSBzdGF0ZXMuUm9tYW4pIHtcbiAgICAgICAgc3RyZWFtLnByZXBlbmQoY29kZV9wb2ludCk7XG4gICAgICAgIGlzbzIwMjJqcF9zdGF0ZSA9IHN0YXRlcy5Sb21hbjtcbiAgICAgICAgcmV0dXJuIFsweDFCLCAweDI4LCAweDRBXTtcbiAgICAgIH1cblxuICAgICAgLy8gOC4gSWYgY29kZSBwb2ludCBpcyBVKzIyMTIsIHNldCBpdCB0byBVK0ZGMEQuXG4gICAgICBpZiAoY29kZV9wb2ludCA9PT0gMHgyMjEyKVxuICAgICAgICBjb2RlX3BvaW50ID0gMHhGRjBEO1xuXG4gICAgICAvLyA5LiBMZXQgcG9pbnRlciBiZSB0aGUgaW5kZXggcG9pbnRlciBmb3IgY29kZSBwb2ludCBpbiBpbmRleFxuICAgICAgLy8gamlzMDIwOC5cbiAgICAgIHZhciBwb2ludGVyID0gaW5kZXhQb2ludGVyRm9yKGNvZGVfcG9pbnQsIGluZGV4KCdqaXMwMjA4JykpO1xuXG4gICAgICAvLyAxMC4gSWYgcG9pbnRlciBpcyBudWxsLCByZXR1cm4gZXJyb3Igd2l0aCBjb2RlIHBvaW50LlxuICAgICAgaWYgKHBvaW50ZXIgPT09IG51bGwpXG4gICAgICAgIHJldHVybiBlbmNvZGVyRXJyb3IoY29kZV9wb2ludCk7XG5cbiAgICAgIC8vIDExLiBJZiBpc28tMjAyMi1qcCBlbmNvZGVyIHN0YXRlIGlzIG5vdCBqaXMwMjA4LCBwcmVwZW5kIGNvZGVcbiAgICAgIC8vIHBvaW50IHRvIHN0cmVhbSwgc2V0IGlzby0yMDIyLWpwIGVuY29kZXIgc3RhdGUgdG8gamlzMDIwOCxcbiAgICAgIC8vIGFuZCByZXR1cm4gdGhyZWUgYnl0ZXMgMHgxQiAweDI0IDB4NDIuXG4gICAgICBpZiAoaXNvMjAyMmpwX3N0YXRlICE9PSBzdGF0ZXMuamlzMDIwOCkge1xuICAgICAgICBzdHJlYW0ucHJlcGVuZChjb2RlX3BvaW50KTtcbiAgICAgICAgaXNvMjAyMmpwX3N0YXRlID0gc3RhdGVzLmppczAyMDg7XG4gICAgICAgIHJldHVybiBbMHgxQiwgMHgyNCwgMHg0Ml07XG4gICAgICB9XG5cbiAgICAgIC8vIDEyLiBMZXQgbGVhZCBiZSBmbG9vcihwb2ludGVyIC8gOTQpICsgMHgyMS5cbiAgICAgIHZhciBsZWFkID0gZmxvb3IocG9pbnRlciAvIDk0KSArIDB4MjE7XG5cbiAgICAgIC8vIDEzLiBMZXQgdHJhaWwgYmUgcG9pbnRlciAlIDk0ICsgMHgyMS5cbiAgICAgIHZhciB0cmFpbCA9IHBvaW50ZXIgJSA5NCArIDB4MjE7XG5cbiAgICAgIC8vIDE0LiBSZXR1cm4gdHdvIGJ5dGVzIHdob3NlIHZhbHVlcyBhcmUgbGVhZCBhbmQgdHJhaWwuXG4gICAgICByZXR1cm4gW2xlYWQsIHRyYWlsXTtcbiAgICB9O1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7e2ZhdGFsOiBib29sZWFufX0gb3B0aW9ucyAqL1xuICBlbmNvZGVyc1snSVNPLTIwMjItSlAnXSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IElTTzIwMjJKUEVuY29kZXIob3B0aW9ucyk7XG4gIH07XG4gIC8qKiBAcGFyYW0ge3tmYXRhbDogYm9vbGVhbn19IG9wdGlvbnMgKi9cbiAgZGVjb2RlcnNbJ0lTTy0yMDIyLUpQJ10gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBJU08yMDIySlBEZWNvZGVyKG9wdGlvbnMpO1xuICB9O1xuXG4gIC8vIDEzLjMgU2hpZnRfSklTXG5cbiAgLy8gMTMuMy4xIFNoaWZ0X0pJUyBkZWNvZGVyXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGltcGxlbWVudHMge0RlY29kZXJ9XG4gICAqIEBwYXJhbSB7e2ZhdGFsOiBib29sZWFufX0gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gU2hpZnRKSVNEZWNvZGVyKG9wdGlvbnMpIHtcbiAgICB2YXIgZmF0YWwgPSBvcHRpb25zLmZhdGFsO1xuICAgIC8vIFNoaWZ0X0pJUydzIGRlY29kZXIgaGFzIGFuIGFzc29jaWF0ZWQgU2hpZnRfSklTIGxlYWQgKGluaXRpYWxseVxuICAgIC8vIDB4MDApLlxuICAgIHZhciAvKiogQHR5cGUge251bWJlcn0gKi8gU2hpZnRfSklTX2xlYWQgPSAweDAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyZWFtfSBzdHJlYW0gVGhlIHN0cmVhbSBvZiBieXRlcyBiZWluZyBkZWNvZGVkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRlIFRoZSBuZXh0IGJ5dGUgcmVhZCBmcm9tIHRoZSBzdHJlYW0uXG4gICAgICogQHJldHVybiB7PyhudW1iZXJ8IUFycmF5LjxudW1iZXI+KX0gVGhlIG5leHQgY29kZSBwb2ludChzKVxuICAgICAqICAgICBkZWNvZGVkLCBvciBudWxsIGlmIG5vdCBlbm91Z2ggZGF0YSBleGlzdHMgaW4gdGhlIGlucHV0XG4gICAgICogICAgIHN0cmVhbSB0byBkZWNvZGUgYSBjb21wbGV0ZSBjb2RlIHBvaW50LlxuICAgICAqL1xuICAgIHRoaXMuaGFuZGxlciA9IGZ1bmN0aW9uKHN0cmVhbSwgYml0ZSkge1xuICAgICAgLy8gMS4gSWYgYnl0ZSBpcyBlbmQtb2Ytc3RyZWFtIGFuZCBTaGlmdF9KSVMgbGVhZCBpcyBub3QgMHgwMCxcbiAgICAgIC8vIHNldCBTaGlmdF9KSVMgbGVhZCB0byAweDAwIGFuZCByZXR1cm4gZXJyb3IuXG4gICAgICBpZiAoYml0ZSA9PT0gZW5kX29mX3N0cmVhbSAmJiBTaGlmdF9KSVNfbGVhZCAhPT0gMHgwMCkge1xuICAgICAgICBTaGlmdF9KSVNfbGVhZCA9IDB4MDA7XG4gICAgICAgIHJldHVybiBkZWNvZGVyRXJyb3IoZmF0YWwpO1xuICAgICAgfVxuXG4gICAgICAvLyAyLiBJZiBieXRlIGlzIGVuZC1vZi1zdHJlYW0gYW5kIFNoaWZ0X0pJUyBsZWFkIGlzIDB4MDAsXG4gICAgICAvLyByZXR1cm4gZmluaXNoZWQuXG4gICAgICBpZiAoYml0ZSA9PT0gZW5kX29mX3N0cmVhbSAmJiBTaGlmdF9KSVNfbGVhZCA9PT0gMHgwMClcbiAgICAgICAgcmV0dXJuIGZpbmlzaGVkO1xuXG4gICAgICAvLyAzLiBJZiBTaGlmdF9KSVMgbGVhZCBpcyBub3QgMHgwMCwgbGV0IGxlYWQgYmUgU2hpZnRfSklTIGxlYWQsXG4gICAgICAvLyBsZXQgcG9pbnRlciBiZSBudWxsLCBzZXQgU2hpZnRfSklTIGxlYWQgdG8gMHgwMCwgYW5kIHRoZW4gcnVuXG4gICAgICAvLyB0aGVzZSBzdWJzdGVwczpcbiAgICAgIGlmIChTaGlmdF9KSVNfbGVhZCAhPT0gMHgwMCkge1xuICAgICAgICB2YXIgbGVhZCA9IFNoaWZ0X0pJU19sZWFkO1xuICAgICAgICB2YXIgcG9pbnRlciA9IG51bGw7XG4gICAgICAgIFNoaWZ0X0pJU19sZWFkID0gMHgwMDtcblxuICAgICAgICAvLyAxLiBMZXQgb2Zmc2V0IGJlIDB4NDAsIGlmIGJ5dGUgaXMgbGVzcyB0aGFuIDB4N0YsIGFuZCAweDQxXG4gICAgICAgIC8vIG90aGVyd2lzZS5cbiAgICAgICAgdmFyIG9mZnNldCA9IChiaXRlIDwgMHg3RikgPyAweDQwIDogMHg0MTtcblxuICAgICAgICAvLyAyLiBMZXQgbGVhZCBvZmZzZXQgYmUgMHg4MSwgaWYgbGVhZCBpcyBsZXNzIHRoYW4gMHhBMCwgYW5kXG4gICAgICAgIC8vIDB4QzEgb3RoZXJ3aXNlLlxuICAgICAgICB2YXIgbGVhZF9vZmZzZXQgPSAobGVhZCA8IDB4QTApID8gMHg4MSA6IDB4QzE7XG5cbiAgICAgICAgLy8gMy4gSWYgYnl0ZSBpcyBpbiB0aGUgcmFuZ2UgMHg0MCB0byAweDdFLCBpbmNsdXNpdmUsIG9yIDB4ODBcbiAgICAgICAgLy8gdG8gMHhGQywgaW5jbHVzaXZlLCBzZXQgcG9pbnRlciB0byAobGVhZCDiiJIgbGVhZCBvZmZzZXQpIMOXXG4gICAgICAgIC8vIDE4OCArIGJ5dGUg4oiSIG9mZnNldC5cbiAgICAgICAgaWYgKGluUmFuZ2UoYml0ZSwgMHg0MCwgMHg3RSkgfHwgaW5SYW5nZShiaXRlLCAweDgwLCAweEZDKSlcbiAgICAgICAgICBwb2ludGVyID0gKGxlYWQgLSBsZWFkX29mZnNldCkgKiAxODggKyBiaXRlIC0gb2Zmc2V0O1xuXG4gICAgICAgIC8vIDQuIElmIHBvaW50ZXIgaXMgaW4gdGhlIHJhbmdlIDg4MzYgdG8gMTA3MTUsIGluY2x1c2l2ZSxcbiAgICAgICAgLy8gcmV0dXJuIGEgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSBpcyAweEUwMDAg4oiSIDg4MzYgKyBwb2ludGVyLlxuICAgICAgICBpZiAoaW5SYW5nZShwb2ludGVyLCA4ODM2LCAxMDcxNSkpXG4gICAgICAgICAgcmV0dXJuIDB4RTAwMCAtIDg4MzYgKyBwb2ludGVyO1xuXG4gICAgICAgIC8vIDUuIExldCBjb2RlIHBvaW50IGJlIG51bGwsIGlmIHBvaW50ZXIgaXMgbnVsbCwgYW5kIHRoZVxuICAgICAgICAvLyBpbmRleCBjb2RlIHBvaW50IGZvciBwb2ludGVyIGluIGluZGV4IGppczAyMDggb3RoZXJ3aXNlLlxuICAgICAgICB2YXIgY29kZV9wb2ludCA9IChwb2ludGVyID09PSBudWxsKSA/IG51bGwgOlxuICAgICAgICAgICAgICBpbmRleENvZGVQb2ludEZvcihwb2ludGVyLCBpbmRleCgnamlzMDIwOCcpKTtcblxuICAgICAgICAvLyA2LiBJZiBjb2RlIHBvaW50IGlzIG51bGwgYW5kIGJ5dGUgaXMgYW4gQVNDSUkgYnl0ZSwgcHJlcGVuZFxuICAgICAgICAvLyBieXRlIHRvIHN0cmVhbS5cbiAgICAgICAgaWYgKGNvZGVfcG9pbnQgPT09IG51bGwgJiYgaXNBU0NJSUJ5dGUoYml0ZSkpXG4gICAgICAgICAgc3RyZWFtLnByZXBlbmQoYml0ZSk7XG5cbiAgICAgICAgLy8gNy4gSWYgY29kZSBwb2ludCBpcyBudWxsLCByZXR1cm4gZXJyb3IuXG4gICAgICAgIGlmIChjb2RlX3BvaW50ID09PSBudWxsKVxuICAgICAgICAgIHJldHVybiBkZWNvZGVyRXJyb3IoZmF0YWwpO1xuXG4gICAgICAgIC8vIDguIFJldHVybiBhIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgaXMgY29kZSBwb2ludC5cbiAgICAgICAgcmV0dXJuIGNvZGVfcG9pbnQ7XG4gICAgICB9XG5cbiAgICAgIC8vIDQuIElmIGJ5dGUgaXMgYW4gQVNDSUkgYnl0ZSBvciAweDgwLCByZXR1cm4gYSBjb2RlIHBvaW50XG4gICAgICAvLyB3aG9zZSB2YWx1ZSBpcyBieXRlLlxuICAgICAgaWYgKGlzQVNDSUlCeXRlKGJpdGUpIHx8IGJpdGUgPT09IDB4ODApXG4gICAgICAgIHJldHVybiBiaXRlO1xuXG4gICAgICAvLyA1LiBJZiBieXRlIGlzIGluIHRoZSByYW5nZSAweEExIHRvIDB4REYsIGluY2x1c2l2ZSwgcmV0dXJuIGFcbiAgICAgIC8vIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgaXMgMHhGRjYxIOKIkiAweEExICsgYnl0ZS5cbiAgICAgIGlmIChpblJhbmdlKGJpdGUsIDB4QTEsIDB4REYpKVxuICAgICAgICByZXR1cm4gMHhGRjYxIC0gMHhBMSArIGJpdGU7XG5cbiAgICAgIC8vIDYuIElmIGJ5dGUgaXMgaW4gdGhlIHJhbmdlIDB4ODEgdG8gMHg5RiwgaW5jbHVzaXZlLCBvciAweEUwXG4gICAgICAvLyB0byAweEZDLCBpbmNsdXNpdmUsIHNldCBTaGlmdF9KSVMgbGVhZCB0byBieXRlIGFuZCByZXR1cm5cbiAgICAgIC8vIGNvbnRpbnVlLlxuICAgICAgaWYgKGluUmFuZ2UoYml0ZSwgMHg4MSwgMHg5RikgfHwgaW5SYW5nZShiaXRlLCAweEUwLCAweEZDKSkge1xuICAgICAgICBTaGlmdF9KSVNfbGVhZCA9IGJpdGU7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyA3LiBSZXR1cm4gZXJyb3IuXG4gICAgICByZXR1cm4gZGVjb2RlckVycm9yKGZhdGFsKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gMTMuMy4yIFNoaWZ0X0pJUyBlbmNvZGVyXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGltcGxlbWVudHMge0VuY29kZXJ9XG4gICAqIEBwYXJhbSB7e2ZhdGFsOiBib29sZWFufX0gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gU2hpZnRKSVNFbmNvZGVyKG9wdGlvbnMpIHtcbiAgICB2YXIgZmF0YWwgPSBvcHRpb25zLmZhdGFsO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyZWFtfSBzdHJlYW0gSW5wdXQgc3RyZWFtLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlX3BvaW50IE5leHQgY29kZSBwb2ludCByZWFkIGZyb20gdGhlIHN0cmVhbS5cbiAgICAgKiBAcmV0dXJuIHsobnVtYmVyfCFBcnJheS48bnVtYmVyPil9IEJ5dGUocykgdG8gZW1pdC5cbiAgICAgKi9cbiAgICB0aGlzLmhhbmRsZXIgPSBmdW5jdGlvbihzdHJlYW0sIGNvZGVfcG9pbnQpIHtcbiAgICAgIC8vIDEuIElmIGNvZGUgcG9pbnQgaXMgZW5kLW9mLXN0cmVhbSwgcmV0dXJuIGZpbmlzaGVkLlxuICAgICAgaWYgKGNvZGVfcG9pbnQgPT09IGVuZF9vZl9zdHJlYW0pXG4gICAgICAgIHJldHVybiBmaW5pc2hlZDtcblxuICAgICAgLy8gMi4gSWYgY29kZSBwb2ludCBpcyBhbiBBU0NJSSBjb2RlIHBvaW50IG9yIFUrMDA4MCwgcmV0dXJuIGFcbiAgICAgIC8vIGJ5dGUgd2hvc2UgdmFsdWUgaXMgY29kZSBwb2ludC5cbiAgICAgIGlmIChpc0FTQ0lJQ29kZVBvaW50KGNvZGVfcG9pbnQpIHx8IGNvZGVfcG9pbnQgPT09IDB4MDA4MClcbiAgICAgICAgcmV0dXJuIGNvZGVfcG9pbnQ7XG5cbiAgICAgIC8vIDMuIElmIGNvZGUgcG9pbnQgaXMgVSswMEE1LCByZXR1cm4gYnl0ZSAweDVDLlxuICAgICAgaWYgKGNvZGVfcG9pbnQgPT09IDB4MDBBNSlcbiAgICAgICAgcmV0dXJuIDB4NUM7XG5cbiAgICAgIC8vIDQuIElmIGNvZGUgcG9pbnQgaXMgVSsyMDNFLCByZXR1cm4gYnl0ZSAweDdFLlxuICAgICAgaWYgKGNvZGVfcG9pbnQgPT09IDB4MjAzRSlcbiAgICAgICAgcmV0dXJuIDB4N0U7XG5cbiAgICAgIC8vIDUuIElmIGNvZGUgcG9pbnQgaXMgaW4gdGhlIHJhbmdlIFUrRkY2MSB0byBVK0ZGOUYsIGluY2x1c2l2ZSxcbiAgICAgIC8vIHJldHVybiBhIGJ5dGUgd2hvc2UgdmFsdWUgaXMgY29kZSBwb2ludCDiiJIgMHhGRjYxICsgMHhBMS5cbiAgICAgIGlmIChpblJhbmdlKGNvZGVfcG9pbnQsIDB4RkY2MSwgMHhGRjlGKSlcbiAgICAgICAgcmV0dXJuIGNvZGVfcG9pbnQgLSAweEZGNjEgKyAweEExO1xuXG4gICAgICAvLyA2LiBJZiBjb2RlIHBvaW50IGlzIFUrMjIxMiwgc2V0IGl0IHRvIFUrRkYwRC5cbiAgICAgIGlmIChjb2RlX3BvaW50ID09PSAweDIyMTIpXG4gICAgICAgIGNvZGVfcG9pbnQgPSAweEZGMEQ7XG5cbiAgICAgIC8vIDcuIExldCBwb2ludGVyIGJlIHRoZSBpbmRleCBTaGlmdF9KSVMgcG9pbnRlciBmb3IgY29kZSBwb2ludC5cbiAgICAgIHZhciBwb2ludGVyID0gaW5kZXhTaGlmdEpJU1BvaW50ZXJGb3IoY29kZV9wb2ludCk7XG5cbiAgICAgIC8vIDguIElmIHBvaW50ZXIgaXMgbnVsbCwgcmV0dXJuIGVycm9yIHdpdGggY29kZSBwb2ludC5cbiAgICAgIGlmIChwb2ludGVyID09PSBudWxsKVxuICAgICAgICByZXR1cm4gZW5jb2RlckVycm9yKGNvZGVfcG9pbnQpO1xuXG4gICAgICAvLyA5LiBMZXQgbGVhZCBiZSBmbG9vcihwb2ludGVyIC8gMTg4KS5cbiAgICAgIHZhciBsZWFkID0gZmxvb3IocG9pbnRlciAvIDE4OCk7XG5cbiAgICAgIC8vIDEwLiBMZXQgbGVhZCBvZmZzZXQgYmUgMHg4MSwgaWYgbGVhZCBpcyBsZXNzIHRoYW4gMHgxRiwgYW5kXG4gICAgICAvLyAweEMxIG90aGVyd2lzZS5cbiAgICAgIHZhciBsZWFkX29mZnNldCA9IChsZWFkIDwgMHgxRikgPyAweDgxIDogMHhDMTtcblxuICAgICAgLy8gMTEuIExldCB0cmFpbCBiZSBwb2ludGVyICUgMTg4LlxuICAgICAgdmFyIHRyYWlsID0gcG9pbnRlciAlIDE4ODtcblxuICAgICAgLy8gMTIuIExldCBvZmZzZXQgYmUgMHg0MCwgaWYgdHJhaWwgaXMgbGVzcyB0aGFuIDB4M0YsIGFuZCAweDQxXG4gICAgICAvLyBvdGhlcndpc2UuXG4gICAgICB2YXIgb2Zmc2V0ID0gKHRyYWlsIDwgMHgzRikgPyAweDQwIDogMHg0MTtcblxuICAgICAgLy8gMTMuIFJldHVybiB0d28gYnl0ZXMgd2hvc2UgdmFsdWVzIGFyZSBsZWFkICsgbGVhZCBvZmZzZXQgYW5kXG4gICAgICAvLyB0cmFpbCArIG9mZnNldC5cbiAgICAgIHJldHVybiBbbGVhZCArIGxlYWRfb2Zmc2V0LCB0cmFpbCArIG9mZnNldF07XG4gICAgfTtcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge3tmYXRhbDogYm9vbGVhbn19IG9wdGlvbnMgKi9cbiAgZW5jb2RlcnNbJ1NoaWZ0X0pJUyddID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU2hpZnRKSVNFbmNvZGVyKG9wdGlvbnMpO1xuICB9O1xuICAvKiogQHBhcmFtIHt7ZmF0YWw6IGJvb2xlYW59fSBvcHRpb25zICovXG4gIGRlY29kZXJzWydTaGlmdF9KSVMnXSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFNoaWZ0SklTRGVjb2RlcihvcHRpb25zKTtcbiAgfTtcblxuICAvL1xuICAvLyAxNC4gTGVnYWN5IG11bHRpLWJ5dGUgS29yZWFuIGVuY29kaW5nc1xuICAvL1xuXG4gIC8vIDE0LjEgZXVjLWtyXG5cbiAgLy8gMTQuMS4xIGV1Yy1rciBkZWNvZGVyXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGltcGxlbWVudHMge0RlY29kZXJ9XG4gICAqIEBwYXJhbSB7e2ZhdGFsOiBib29sZWFufX0gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gRVVDS1JEZWNvZGVyKG9wdGlvbnMpIHtcbiAgICB2YXIgZmF0YWwgPSBvcHRpb25zLmZhdGFsO1xuXG4gICAgLy8gZXVjLWtyJ3MgZGVjb2RlciBoYXMgYW4gYXNzb2NpYXRlZCBldWMta3IgbGVhZCAoaW5pdGlhbGx5IDB4MDApLlxuICAgIHZhciAvKiogQHR5cGUge251bWJlcn0gKi8gZXVja3JfbGVhZCA9IDB4MDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJlYW19IHN0cmVhbSBUaGUgc3RyZWFtIG9mIGJ5dGVzIGJlaW5nIGRlY29kZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdGUgVGhlIG5leHQgYnl0ZSByZWFkIGZyb20gdGhlIHN0cmVhbS5cbiAgICAgKiBAcmV0dXJuIHs/KG51bWJlcnwhQXJyYXkuPG51bWJlcj4pfSBUaGUgbmV4dCBjb2RlIHBvaW50KHMpXG4gICAgICogICAgIGRlY29kZWQsIG9yIG51bGwgaWYgbm90IGVub3VnaCBkYXRhIGV4aXN0cyBpbiB0aGUgaW5wdXRcbiAgICAgKiAgICAgc3RyZWFtIHRvIGRlY29kZSBhIGNvbXBsZXRlIGNvZGUgcG9pbnQuXG4gICAgICovXG4gICAgdGhpcy5oYW5kbGVyID0gZnVuY3Rpb24oc3RyZWFtLCBiaXRlKSB7XG4gICAgICAvLyAxLiBJZiBieXRlIGlzIGVuZC1vZi1zdHJlYW0gYW5kIGV1Yy1rciBsZWFkIGlzIG5vdCAweDAwLCBzZXRcbiAgICAgIC8vIGV1Yy1rciBsZWFkIHRvIDB4MDAgYW5kIHJldHVybiBlcnJvci5cbiAgICAgIGlmIChiaXRlID09PSBlbmRfb2Zfc3RyZWFtICYmIGV1Y2tyX2xlYWQgIT09IDApIHtcbiAgICAgICAgZXVja3JfbGVhZCA9IDB4MDA7XG4gICAgICAgIHJldHVybiBkZWNvZGVyRXJyb3IoZmF0YWwpO1xuICAgICAgfVxuXG4gICAgICAvLyAyLiBJZiBieXRlIGlzIGVuZC1vZi1zdHJlYW0gYW5kIGV1Yy1rciBsZWFkIGlzIDB4MDAsIHJldHVyblxuICAgICAgLy8gZmluaXNoZWQuXG4gICAgICBpZiAoYml0ZSA9PT0gZW5kX29mX3N0cmVhbSAmJiBldWNrcl9sZWFkID09PSAwKVxuICAgICAgICByZXR1cm4gZmluaXNoZWQ7XG5cbiAgICAgIC8vIDMuIElmIGV1Yy1rciBsZWFkIGlzIG5vdCAweDAwLCBsZXQgbGVhZCBiZSBldWMta3IgbGVhZCwgbGV0XG4gICAgICAvLyBwb2ludGVyIGJlIG51bGwsIHNldCBldWMta3IgbGVhZCB0byAweDAwLCBhbmQgdGhlbiBydW4gdGhlc2VcbiAgICAgIC8vIHN1YnN0ZXBzOlxuICAgICAgaWYgKGV1Y2tyX2xlYWQgIT09IDB4MDApIHtcbiAgICAgICAgdmFyIGxlYWQgPSBldWNrcl9sZWFkO1xuICAgICAgICB2YXIgcG9pbnRlciA9IG51bGw7XG4gICAgICAgIGV1Y2tyX2xlYWQgPSAweDAwO1xuXG4gICAgICAgIC8vIDEuIElmIGJ5dGUgaXMgaW4gdGhlIHJhbmdlIDB4NDEgdG8gMHhGRSwgaW5jbHVzaXZlLCBzZXRcbiAgICAgICAgLy8gcG9pbnRlciB0byAobGVhZCDiiJIgMHg4MSkgw5cgMTkwICsgKGJ5dGUg4oiSIDB4NDEpLlxuICAgICAgICBpZiAoaW5SYW5nZShiaXRlLCAweDQxLCAweEZFKSlcbiAgICAgICAgICBwb2ludGVyID0gKGxlYWQgLSAweDgxKSAqIDE5MCArIChiaXRlIC0gMHg0MSk7XG5cbiAgICAgICAgLy8gMi4gTGV0IGNvZGUgcG9pbnQgYmUgbnVsbCwgaWYgcG9pbnRlciBpcyBudWxsLCBhbmQgdGhlXG4gICAgICAgIC8vIGluZGV4IGNvZGUgcG9pbnQgZm9yIHBvaW50ZXIgaW4gaW5kZXggZXVjLWtyIG90aGVyd2lzZS5cbiAgICAgICAgdmFyIGNvZGVfcG9pbnQgPSAocG9pbnRlciA9PT0gbnVsbClcbiAgICAgICAgICAgICAgPyBudWxsIDogaW5kZXhDb2RlUG9pbnRGb3IocG9pbnRlciwgaW5kZXgoJ2V1Yy1rcicpKTtcblxuICAgICAgICAvLyAzLiBJZiBjb2RlIHBvaW50IGlzIG51bGwgYW5kIGJ5dGUgaXMgYW4gQVNDSUkgYnl0ZSwgcHJlcGVuZFxuICAgICAgICAvLyBieXRlIHRvIHN0cmVhbS5cbiAgICAgICAgaWYgKHBvaW50ZXIgPT09IG51bGwgJiYgaXNBU0NJSUJ5dGUoYml0ZSkpXG4gICAgICAgICAgc3RyZWFtLnByZXBlbmQoYml0ZSk7XG5cbiAgICAgICAgLy8gNC4gSWYgY29kZSBwb2ludCBpcyBudWxsLCByZXR1cm4gZXJyb3IuXG4gICAgICAgIGlmIChjb2RlX3BvaW50ID09PSBudWxsKVxuICAgICAgICAgIHJldHVybiBkZWNvZGVyRXJyb3IoZmF0YWwpO1xuXG4gICAgICAgIC8vIDUuIFJldHVybiBhIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgaXMgY29kZSBwb2ludC5cbiAgICAgICAgcmV0dXJuIGNvZGVfcG9pbnQ7XG4gICAgICB9XG5cbiAgICAgIC8vIDQuIElmIGJ5dGUgaXMgYW4gQVNDSUkgYnl0ZSwgcmV0dXJuIGEgY29kZSBwb2ludCB3aG9zZSB2YWx1ZVxuICAgICAgLy8gaXMgYnl0ZS5cbiAgICAgIGlmIChpc0FTQ0lJQnl0ZShiaXRlKSlcbiAgICAgICAgcmV0dXJuIGJpdGU7XG5cbiAgICAgIC8vIDUuIElmIGJ5dGUgaXMgaW4gdGhlIHJhbmdlIDB4ODEgdG8gMHhGRSwgaW5jbHVzaXZlLCBzZXRcbiAgICAgIC8vIGV1Yy1rciBsZWFkIHRvIGJ5dGUgYW5kIHJldHVybiBjb250aW51ZS5cbiAgICAgIGlmIChpblJhbmdlKGJpdGUsIDB4ODEsIDB4RkUpKSB7XG4gICAgICAgIGV1Y2tyX2xlYWQgPSBiaXRlO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gNi4gUmV0dXJuIGVycm9yLlxuICAgICAgcmV0dXJuIGRlY29kZXJFcnJvcihmYXRhbCk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIDE0LjEuMiBldWMta3IgZW5jb2RlclxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBpbXBsZW1lbnRzIHtFbmNvZGVyfVxuICAgKiBAcGFyYW0ge3tmYXRhbDogYm9vbGVhbn19IG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIEVVQ0tSRW5jb2RlcihvcHRpb25zKSB7XG4gICAgdmFyIGZhdGFsID0gb3B0aW9ucy5mYXRhbDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmVhbX0gc3RyZWFtIElucHV0IHN0cmVhbS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29kZV9wb2ludCBOZXh0IGNvZGUgcG9pbnQgcmVhZCBmcm9tIHRoZSBzdHJlYW0uXG4gICAgICogQHJldHVybiB7KG51bWJlcnwhQXJyYXkuPG51bWJlcj4pfSBCeXRlKHMpIHRvIGVtaXQuXG4gICAgICovXG4gICAgdGhpcy5oYW5kbGVyID0gZnVuY3Rpb24oc3RyZWFtLCBjb2RlX3BvaW50KSB7XG4gICAgICAvLyAxLiBJZiBjb2RlIHBvaW50IGlzIGVuZC1vZi1zdHJlYW0sIHJldHVybiBmaW5pc2hlZC5cbiAgICAgIGlmIChjb2RlX3BvaW50ID09PSBlbmRfb2Zfc3RyZWFtKVxuICAgICAgICByZXR1cm4gZmluaXNoZWQ7XG5cbiAgICAgIC8vIDIuIElmIGNvZGUgcG9pbnQgaXMgYW4gQVNDSUkgY29kZSBwb2ludCwgcmV0dXJuIGEgYnl0ZSB3aG9zZVxuICAgICAgLy8gdmFsdWUgaXMgY29kZSBwb2ludC5cbiAgICAgIGlmIChpc0FTQ0lJQ29kZVBvaW50KGNvZGVfcG9pbnQpKVxuICAgICAgICByZXR1cm4gY29kZV9wb2ludDtcblxuICAgICAgLy8gMy4gTGV0IHBvaW50ZXIgYmUgdGhlIGluZGV4IHBvaW50ZXIgZm9yIGNvZGUgcG9pbnQgaW4gaW5kZXhcbiAgICAgIC8vIGV1Yy1rci5cbiAgICAgIHZhciBwb2ludGVyID0gaW5kZXhQb2ludGVyRm9yKGNvZGVfcG9pbnQsIGluZGV4KCdldWMta3InKSk7XG5cbiAgICAgIC8vIDQuIElmIHBvaW50ZXIgaXMgbnVsbCwgcmV0dXJuIGVycm9yIHdpdGggY29kZSBwb2ludC5cbiAgICAgIGlmIChwb2ludGVyID09PSBudWxsKVxuICAgICAgICByZXR1cm4gZW5jb2RlckVycm9yKGNvZGVfcG9pbnQpO1xuXG4gICAgICAvLyA1LiBMZXQgbGVhZCBiZSBmbG9vcihwb2ludGVyIC8gMTkwKSArIDB4ODEuXG4gICAgICB2YXIgbGVhZCA9IGZsb29yKHBvaW50ZXIgLyAxOTApICsgMHg4MTtcblxuICAgICAgLy8gNi4gTGV0IHRyYWlsIGJlIHBvaW50ZXIgJSAxOTAgKyAweDQxLlxuICAgICAgdmFyIHRyYWlsID0gKHBvaW50ZXIgJSAxOTApICsgMHg0MTtcblxuICAgICAgLy8gNy4gUmV0dXJuIHR3byBieXRlcyB3aG9zZSB2YWx1ZXMgYXJlIGxlYWQgYW5kIHRyYWlsLlxuICAgICAgcmV0dXJuIFtsZWFkLCB0cmFpbF07XG4gICAgfTtcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge3tmYXRhbDogYm9vbGVhbn19IG9wdGlvbnMgKi9cbiAgZW5jb2RlcnNbJ0VVQy1LUiddID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgRVVDS1JFbmNvZGVyKG9wdGlvbnMpO1xuICB9O1xuICAvKiogQHBhcmFtIHt7ZmF0YWw6IGJvb2xlYW59fSBvcHRpb25zICovXG4gIGRlY29kZXJzWydFVUMtS1InXSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEVVQ0tSRGVjb2RlcihvcHRpb25zKTtcbiAgfTtcblxuXG4gIC8vXG4gIC8vIDE1LiBMZWdhY3kgbWlzY2VsbGFuZW91cyBlbmNvZGluZ3NcbiAgLy9cblxuICAvLyAxNS4xIHJlcGxhY2VtZW50XG5cbiAgLy8gTm90IG5lZWRlZCAtIEFQSSB0aHJvd3MgUmFuZ2VFcnJvclxuXG4gIC8vIDE1LjIgQ29tbW9uIGluZnJhc3RydWN0dXJlIGZvciB1dGYtMTZiZSBhbmQgdXRmLTE2bGVcblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvZGVfdW5pdFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHV0ZjE2YmVcbiAgICogQHJldHVybiB7IUFycmF5LjxudW1iZXI+fSBieXRlc1xuICAgKi9cbiAgZnVuY3Rpb24gY29udmVydENvZGVVbml0VG9CeXRlcyhjb2RlX3VuaXQsIHV0ZjE2YmUpIHtcbiAgICAvLyAxLiBMZXQgYnl0ZTEgYmUgY29kZSB1bml0ID4+IDguXG4gICAgdmFyIGJ5dGUxID0gY29kZV91bml0ID4+IDg7XG5cbiAgICAvLyAyLiBMZXQgYnl0ZTIgYmUgY29kZSB1bml0ICYgMHgwMEZGLlxuICAgIHZhciBieXRlMiA9IGNvZGVfdW5pdCAmIDB4MDBGRjtcblxuICAgIC8vIDMuIFRoZW4gcmV0dXJuIHRoZSBieXRlcyBpbiBvcmRlcjpcbiAgICAgICAgLy8gdXRmLTE2YmUgZmxhZyBpcyBzZXQ6IGJ5dGUxLCB0aGVuIGJ5dGUyLlxuICAgIGlmICh1dGYxNmJlKVxuICAgICAgcmV0dXJuIFtieXRlMSwgYnl0ZTJdO1xuICAgIC8vIHV0Zi0xNmJlIGZsYWcgaXMgdW5zZXQ6IGJ5dGUyLCB0aGVuIGJ5dGUxLlxuICAgIHJldHVybiBbYnl0ZTIsIGJ5dGUxXTtcbiAgfVxuXG4gIC8vIDE1LjIuMSBzaGFyZWQgdXRmLTE2IGRlY29kZXJcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAaW1wbGVtZW50cyB7RGVjb2Rlcn1cbiAgICogQHBhcmFtIHtib29sZWFufSB1dGYxNl9iZSBUcnVlIGlmIGJpZy1lbmRpYW4sIGZhbHNlIGlmIGxpdHRsZS1lbmRpYW4uXG4gICAqIEBwYXJhbSB7e2ZhdGFsOiBib29sZWFufX0gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gVVRGMTZEZWNvZGVyKHV0ZjE2X2JlLCBvcHRpb25zKSB7XG4gICAgdmFyIGZhdGFsID0gb3B0aW9ucy5mYXRhbDtcbiAgICB2YXIgLyoqIEB0eXBlIHs/bnVtYmVyfSAqLyB1dGYxNl9sZWFkX2J5dGUgPSBudWxsLFxuICAgICAgICAvKiogQHR5cGUgez9udW1iZXJ9ICovIHV0ZjE2X2xlYWRfc3Vycm9nYXRlID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmVhbX0gc3RyZWFtIFRoZSBzdHJlYW0gb2YgYnl0ZXMgYmVpbmcgZGVjb2RlZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0ZSBUaGUgbmV4dCBieXRlIHJlYWQgZnJvbSB0aGUgc3RyZWFtLlxuICAgICAqIEByZXR1cm4gez8obnVtYmVyfCFBcnJheS48bnVtYmVyPil9IFRoZSBuZXh0IGNvZGUgcG9pbnQocylcbiAgICAgKiAgICAgZGVjb2RlZCwgb3IgbnVsbCBpZiBub3QgZW5vdWdoIGRhdGEgZXhpc3RzIGluIHRoZSBpbnB1dFxuICAgICAqICAgICBzdHJlYW0gdG8gZGVjb2RlIGEgY29tcGxldGUgY29kZSBwb2ludC5cbiAgICAgKi9cbiAgICB0aGlzLmhhbmRsZXIgPSBmdW5jdGlvbihzdHJlYW0sIGJpdGUpIHtcbiAgICAgIC8vIDEuIElmIGJ5dGUgaXMgZW5kLW9mLXN0cmVhbSBhbmQgZWl0aGVyIHV0Zi0xNiBsZWFkIGJ5dGUgb3JcbiAgICAgIC8vIHV0Zi0xNiBsZWFkIHN1cnJvZ2F0ZSBpcyBub3QgbnVsbCwgc2V0IHV0Zi0xNiBsZWFkIGJ5dGUgYW5kXG4gICAgICAvLyB1dGYtMTYgbGVhZCBzdXJyb2dhdGUgdG8gbnVsbCwgYW5kIHJldHVybiBlcnJvci5cbiAgICAgIGlmIChiaXRlID09PSBlbmRfb2Zfc3RyZWFtICYmICh1dGYxNl9sZWFkX2J5dGUgIT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRmMTZfbGVhZF9zdXJyb2dhdGUgIT09IG51bGwpKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVyRXJyb3IoZmF0YWwpO1xuICAgICAgfVxuXG4gICAgICAvLyAyLiBJZiBieXRlIGlzIGVuZC1vZi1zdHJlYW0gYW5kIHV0Zi0xNiBsZWFkIGJ5dGUgYW5kIHV0Zi0xNlxuICAgICAgLy8gbGVhZCBzdXJyb2dhdGUgYXJlIG51bGwsIHJldHVybiBmaW5pc2hlZC5cbiAgICAgIGlmIChiaXRlID09PSBlbmRfb2Zfc3RyZWFtICYmIHV0ZjE2X2xlYWRfYnl0ZSA9PT0gbnVsbCAmJlxuICAgICAgICAgIHV0ZjE2X2xlYWRfc3Vycm9nYXRlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmaW5pc2hlZDtcbiAgICAgIH1cblxuICAgICAgLy8gMy4gSWYgdXRmLTE2IGxlYWQgYnl0ZSBpcyBudWxsLCBzZXQgdXRmLTE2IGxlYWQgYnl0ZSB0byBieXRlXG4gICAgICAvLyBhbmQgcmV0dXJuIGNvbnRpbnVlLlxuICAgICAgaWYgKHV0ZjE2X2xlYWRfYnl0ZSA9PT0gbnVsbCkge1xuICAgICAgICB1dGYxNl9sZWFkX2J5dGUgPSBiaXRlO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gNC4gTGV0IGNvZGUgdW5pdCBiZSB0aGUgcmVzdWx0IG9mOlxuICAgICAgdmFyIGNvZGVfdW5pdDtcbiAgICAgIGlmICh1dGYxNl9iZSkge1xuICAgICAgICAvLyB1dGYtMTZiZSBkZWNvZGVyIGZsYWcgaXMgc2V0XG4gICAgICAgIC8vICAgKHV0Zi0xNiBsZWFkIGJ5dGUgPDwgOCkgKyBieXRlLlxuICAgICAgICBjb2RlX3VuaXQgPSAodXRmMTZfbGVhZF9ieXRlIDw8IDgpICsgYml0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHV0Zi0xNmJlIGRlY29kZXIgZmxhZyBpcyB1bnNldFxuICAgICAgICAvLyAgIChieXRlIDw8IDgpICsgdXRmLTE2IGxlYWQgYnl0ZS5cbiAgICAgICAgY29kZV91bml0ID0gKGJpdGUgPDwgOCkgKyB1dGYxNl9sZWFkX2J5dGU7XG4gICAgICB9XG4gICAgICAvLyBUaGVuIHNldCB1dGYtMTYgbGVhZCBieXRlIHRvIG51bGwuXG4gICAgICB1dGYxNl9sZWFkX2J5dGUgPSBudWxsO1xuXG4gICAgICAvLyA1LiBJZiB1dGYtMTYgbGVhZCBzdXJyb2dhdGUgaXMgbm90IG51bGwsIGxldCBsZWFkIHN1cnJvZ2F0ZVxuICAgICAgLy8gYmUgdXRmLTE2IGxlYWQgc3Vycm9nYXRlLCBzZXQgdXRmLTE2IGxlYWQgc3Vycm9nYXRlIHRvIG51bGwsXG4gICAgICAvLyBhbmQgdGhlbiBydW4gdGhlc2Ugc3Vic3RlcHM6XG4gICAgICBpZiAodXRmMTZfbGVhZF9zdXJyb2dhdGUgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGxlYWRfc3Vycm9nYXRlID0gdXRmMTZfbGVhZF9zdXJyb2dhdGU7XG4gICAgICAgIHV0ZjE2X2xlYWRfc3Vycm9nYXRlID0gbnVsbDtcblxuICAgICAgICAvLyAxLiBJZiBjb2RlIHVuaXQgaXMgaW4gdGhlIHJhbmdlIFUrREMwMCB0byBVK0RGRkYsXG4gICAgICAgIC8vIGluY2x1c2l2ZSwgcmV0dXJuIGEgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSBpcyAweDEwMDAwICtcbiAgICAgICAgLy8gKChsZWFkIHN1cnJvZ2F0ZSDiiJIgMHhEODAwKSA8PCAxMCkgKyAoY29kZSB1bml0IOKIkiAweERDMDApLlxuICAgICAgICBpZiAoaW5SYW5nZShjb2RlX3VuaXQsIDB4REMwMCwgMHhERkZGKSkge1xuICAgICAgICAgIHJldHVybiAweDEwMDAwICsgKGxlYWRfc3Vycm9nYXRlIC0gMHhEODAwKSAqIDB4NDAwICtcbiAgICAgICAgICAgICAgKGNvZGVfdW5pdCAtIDB4REMwMCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAyLiBQcmVwZW5kIHRoZSBzZXF1ZW5jZSByZXN1bHRpbmcgb2YgY29udmVydGluZyBjb2RlIHVuaXRcbiAgICAgICAgLy8gdG8gYnl0ZXMgdXNpbmcgdXRmLTE2YmUgZGVjb2RlciBmbGFnIHRvIHN0cmVhbSBhbmQgcmV0dXJuXG4gICAgICAgIC8vIGVycm9yLlxuICAgICAgICBzdHJlYW0ucHJlcGVuZChjb252ZXJ0Q29kZVVuaXRUb0J5dGVzKGNvZGVfdW5pdCwgdXRmMTZfYmUpKTtcbiAgICAgICAgcmV0dXJuIGRlY29kZXJFcnJvcihmYXRhbCk7XG4gICAgICB9XG5cbiAgICAgIC8vIDYuIElmIGNvZGUgdW5pdCBpcyBpbiB0aGUgcmFuZ2UgVStEODAwIHRvIFUrREJGRiwgaW5jbHVzaXZlLFxuICAgICAgLy8gc2V0IHV0Zi0xNiBsZWFkIHN1cnJvZ2F0ZSB0byBjb2RlIHVuaXQgYW5kIHJldHVybiBjb250aW51ZS5cbiAgICAgIGlmIChpblJhbmdlKGNvZGVfdW5pdCwgMHhEODAwLCAweERCRkYpKSB7XG4gICAgICAgIHV0ZjE2X2xlYWRfc3Vycm9nYXRlID0gY29kZV91bml0O1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gNy4gSWYgY29kZSB1bml0IGlzIGluIHRoZSByYW5nZSBVK0RDMDAgdG8gVStERkZGLCBpbmNsdXNpdmUsXG4gICAgICAvLyByZXR1cm4gZXJyb3IuXG4gICAgICBpZiAoaW5SYW5nZShjb2RlX3VuaXQsIDB4REMwMCwgMHhERkZGKSlcbiAgICAgICAgcmV0dXJuIGRlY29kZXJFcnJvcihmYXRhbCk7XG5cbiAgICAgIC8vIDguIFJldHVybiBjb2RlIHBvaW50IGNvZGUgdW5pdC5cbiAgICAgIHJldHVybiBjb2RlX3VuaXQ7XG4gICAgfTtcbiAgfVxuXG4gIC8vIDE1LjIuMiBzaGFyZWQgdXRmLTE2IGVuY29kZXJcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAaW1wbGVtZW50cyB7RW5jb2Rlcn1cbiAgICogQHBhcmFtIHtib29sZWFufSB1dGYxNl9iZSBUcnVlIGlmIGJpZy1lbmRpYW4sIGZhbHNlIGlmIGxpdHRsZS1lbmRpYW4uXG4gICAqIEBwYXJhbSB7e2ZhdGFsOiBib29sZWFufX0gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gVVRGMTZFbmNvZGVyKHV0ZjE2X2JlLCBvcHRpb25zKSB7XG4gICAgdmFyIGZhdGFsID0gb3B0aW9ucy5mYXRhbDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmVhbX0gc3RyZWFtIElucHV0IHN0cmVhbS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29kZV9wb2ludCBOZXh0IGNvZGUgcG9pbnQgcmVhZCBmcm9tIHRoZSBzdHJlYW0uXG4gICAgICogQHJldHVybiB7KG51bWJlcnwhQXJyYXkuPG51bWJlcj4pfSBCeXRlKHMpIHRvIGVtaXQuXG4gICAgICovXG4gICAgdGhpcy5oYW5kbGVyID0gZnVuY3Rpb24oc3RyZWFtLCBjb2RlX3BvaW50KSB7XG4gICAgICAvLyAxLiBJZiBjb2RlIHBvaW50IGlzIGVuZC1vZi1zdHJlYW0sIHJldHVybiBmaW5pc2hlZC5cbiAgICAgIGlmIChjb2RlX3BvaW50ID09PSBlbmRfb2Zfc3RyZWFtKVxuICAgICAgICByZXR1cm4gZmluaXNoZWQ7XG5cbiAgICAgIC8vIDIuIElmIGNvZGUgcG9pbnQgaXMgaW4gdGhlIHJhbmdlIFUrMDAwMCB0byBVK0ZGRkYsIGluY2x1c2l2ZSxcbiAgICAgIC8vIHJldHVybiB0aGUgc2VxdWVuY2UgcmVzdWx0aW5nIG9mIGNvbnZlcnRpbmcgY29kZSBwb2ludCB0b1xuICAgICAgLy8gYnl0ZXMgdXNpbmcgdXRmLTE2YmUgZW5jb2RlciBmbGFnLlxuICAgICAgaWYgKGluUmFuZ2UoY29kZV9wb2ludCwgMHgwMDAwLCAweEZGRkYpKVxuICAgICAgICByZXR1cm4gY29udmVydENvZGVVbml0VG9CeXRlcyhjb2RlX3BvaW50LCB1dGYxNl9iZSk7XG5cbiAgICAgIC8vIDMuIExldCBsZWFkIGJlICgoY29kZSBwb2ludCDiiJIgMHgxMDAwMCkgPj4gMTApICsgMHhEODAwLFxuICAgICAgLy8gY29udmVydGVkIHRvIGJ5dGVzIHVzaW5nIHV0Zi0xNmJlIGVuY29kZXIgZmxhZy5cbiAgICAgIHZhciBsZWFkID0gY29udmVydENvZGVVbml0VG9CeXRlcyhcbiAgICAgICAgKChjb2RlX3BvaW50IC0gMHgxMDAwMCkgPj4gMTApICsgMHhEODAwLCB1dGYxNl9iZSk7XG5cbiAgICAgIC8vIDQuIExldCB0cmFpbCBiZSAoKGNvZGUgcG9pbnQg4oiSIDB4MTAwMDApICYgMHgzRkYpICsgMHhEQzAwLFxuICAgICAgLy8gY29udmVydGVkIHRvIGJ5dGVzIHVzaW5nIHV0Zi0xNmJlIGVuY29kZXIgZmxhZy5cbiAgICAgIHZhciB0cmFpbCA9IGNvbnZlcnRDb2RlVW5pdFRvQnl0ZXMoXG4gICAgICAgICgoY29kZV9wb2ludCAtIDB4MTAwMDApICYgMHgzRkYpICsgMHhEQzAwLCB1dGYxNl9iZSk7XG5cbiAgICAgIC8vIDUuIFJldHVybiBhIGJ5dGUgc2VxdWVuY2Ugb2YgbGVhZCBmb2xsb3dlZCBieSB0cmFpbC5cbiAgICAgIHJldHVybiBsZWFkLmNvbmNhdCh0cmFpbCk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIDE1LjMgdXRmLTE2YmVcbiAgLy8gMTUuMy4xIHV0Zi0xNmJlIGRlY29kZXJcbiAgLyoqIEBwYXJhbSB7e2ZhdGFsOiBib29sZWFufX0gb3B0aW9ucyAqL1xuICBlbmNvZGVyc1snVVRGLTE2QkUnXSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFVURjE2RW5jb2Rlcih0cnVlLCBvcHRpb25zKTtcbiAgfTtcbiAgLy8gMTUuMy4yIHV0Zi0xNmJlIGVuY29kZXJcbiAgLyoqIEBwYXJhbSB7e2ZhdGFsOiBib29sZWFufX0gb3B0aW9ucyAqL1xuICBkZWNvZGVyc1snVVRGLTE2QkUnXSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFVURjE2RGVjb2Rlcih0cnVlLCBvcHRpb25zKTtcbiAgfTtcblxuICAvLyAxNS40IHV0Zi0xNmxlXG4gIC8vIDE1LjQuMSB1dGYtMTZsZSBkZWNvZGVyXG4gIC8qKiBAcGFyYW0ge3tmYXRhbDogYm9vbGVhbn19IG9wdGlvbnMgKi9cbiAgZW5jb2RlcnNbJ1VURi0xNkxFJ10gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBVVEYxNkVuY29kZXIoZmFsc2UsIG9wdGlvbnMpO1xuICB9O1xuICAvLyAxNS40LjIgdXRmLTE2bGUgZW5jb2RlclxuICAvKiogQHBhcmFtIHt7ZmF0YWw6IGJvb2xlYW59fSBvcHRpb25zICovXG4gIGRlY29kZXJzWydVVEYtMTZMRSddID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVVRGMTZEZWNvZGVyKGZhbHNlLCBvcHRpb25zKTtcbiAgfTtcblxuICAvLyAxNS41IHgtdXNlci1kZWZpbmVkXG5cbiAgLy8gMTUuNS4xIHgtdXNlci1kZWZpbmVkIGRlY29kZXJcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAaW1wbGVtZW50cyB7RGVjb2Rlcn1cbiAgICogQHBhcmFtIHt7ZmF0YWw6IGJvb2xlYW59fSBvcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBYVXNlckRlZmluZWREZWNvZGVyKG9wdGlvbnMpIHtcbiAgICB2YXIgZmF0YWwgPSBvcHRpb25zLmZhdGFsO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyZWFtfSBzdHJlYW0gVGhlIHN0cmVhbSBvZiBieXRlcyBiZWluZyBkZWNvZGVkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRlIFRoZSBuZXh0IGJ5dGUgcmVhZCBmcm9tIHRoZSBzdHJlYW0uXG4gICAgICogQHJldHVybiB7PyhudW1iZXJ8IUFycmF5LjxudW1iZXI+KX0gVGhlIG5leHQgY29kZSBwb2ludChzKVxuICAgICAqICAgICBkZWNvZGVkLCBvciBudWxsIGlmIG5vdCBlbm91Z2ggZGF0YSBleGlzdHMgaW4gdGhlIGlucHV0XG4gICAgICogICAgIHN0cmVhbSB0byBkZWNvZGUgYSBjb21wbGV0ZSBjb2RlIHBvaW50LlxuICAgICAqL1xuICAgIHRoaXMuaGFuZGxlciA9IGZ1bmN0aW9uKHN0cmVhbSwgYml0ZSkge1xuICAgICAgLy8gMS4gSWYgYnl0ZSBpcyBlbmQtb2Ytc3RyZWFtLCByZXR1cm4gZmluaXNoZWQuXG4gICAgICBpZiAoYml0ZSA9PT0gZW5kX29mX3N0cmVhbSlcbiAgICAgICAgcmV0dXJuIGZpbmlzaGVkO1xuXG4gICAgICAvLyAyLiBJZiBieXRlIGlzIGFuIEFTQ0lJIGJ5dGUsIHJldHVybiBhIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWVcbiAgICAgIC8vIGlzIGJ5dGUuXG4gICAgICBpZiAoaXNBU0NJSUJ5dGUoYml0ZSkpXG4gICAgICAgIHJldHVybiBiaXRlO1xuXG4gICAgICAvLyAzLiBSZXR1cm4gYSBjb2RlIHBvaW50IHdob3NlIHZhbHVlIGlzIDB4Rjc4MCArIGJ5dGUg4oiSIDB4ODAuXG4gICAgICByZXR1cm4gMHhGNzgwICsgYml0ZSAtIDB4ODA7XG4gICAgfTtcbiAgfVxuXG4gIC8vIDE1LjUuMiB4LXVzZXItZGVmaW5lZCBlbmNvZGVyXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGltcGxlbWVudHMge0VuY29kZXJ9XG4gICAqIEBwYXJhbSB7e2ZhdGFsOiBib29sZWFufX0gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gWFVzZXJEZWZpbmVkRW5jb2RlcihvcHRpb25zKSB7XG4gICAgdmFyIGZhdGFsID0gb3B0aW9ucy5mYXRhbDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmVhbX0gc3RyZWFtIElucHV0IHN0cmVhbS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29kZV9wb2ludCBOZXh0IGNvZGUgcG9pbnQgcmVhZCBmcm9tIHRoZSBzdHJlYW0uXG4gICAgICogQHJldHVybiB7KG51bWJlcnwhQXJyYXkuPG51bWJlcj4pfSBCeXRlKHMpIHRvIGVtaXQuXG4gICAgICovXG4gICAgdGhpcy5oYW5kbGVyID0gZnVuY3Rpb24oc3RyZWFtLCBjb2RlX3BvaW50KSB7XG4gICAgICAvLyAxLklmIGNvZGUgcG9pbnQgaXMgZW5kLW9mLXN0cmVhbSwgcmV0dXJuIGZpbmlzaGVkLlxuICAgICAgaWYgKGNvZGVfcG9pbnQgPT09IGVuZF9vZl9zdHJlYW0pXG4gICAgICAgIHJldHVybiBmaW5pc2hlZDtcblxuICAgICAgLy8gMi4gSWYgY29kZSBwb2ludCBpcyBhbiBBU0NJSSBjb2RlIHBvaW50LCByZXR1cm4gYSBieXRlIHdob3NlXG4gICAgICAvLyB2YWx1ZSBpcyBjb2RlIHBvaW50LlxuICAgICAgaWYgKGlzQVNDSUlDb2RlUG9pbnQoY29kZV9wb2ludCkpXG4gICAgICAgIHJldHVybiBjb2RlX3BvaW50O1xuXG4gICAgICAvLyAzLiBJZiBjb2RlIHBvaW50IGlzIGluIHRoZSByYW5nZSBVK0Y3ODAgdG8gVStGN0ZGLCBpbmNsdXNpdmUsXG4gICAgICAvLyByZXR1cm4gYSBieXRlIHdob3NlIHZhbHVlIGlzIGNvZGUgcG9pbnQg4oiSIDB4Rjc4MCArIDB4ODAuXG4gICAgICBpZiAoaW5SYW5nZShjb2RlX3BvaW50LCAweEY3ODAsIDB4RjdGRikpXG4gICAgICAgIHJldHVybiBjb2RlX3BvaW50IC0gMHhGNzgwICsgMHg4MDtcblxuICAgICAgLy8gNC4gUmV0dXJuIGVycm9yIHdpdGggY29kZSBwb2ludC5cbiAgICAgIHJldHVybiBlbmNvZGVyRXJyb3IoY29kZV9wb2ludCk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge3tmYXRhbDogYm9vbGVhbn19IG9wdGlvbnMgKi9cbiAgZW5jb2RlcnNbJ3gtdXNlci1kZWZpbmVkJ10gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBYVXNlckRlZmluZWRFbmNvZGVyKG9wdGlvbnMpO1xuICB9O1xuICAvKiogQHBhcmFtIHt7ZmF0YWw6IGJvb2xlYW59fSBvcHRpb25zICovXG4gIGRlY29kZXJzWyd4LXVzZXItZGVmaW5lZCddID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgWFVzZXJEZWZpbmVkRGVjb2RlcihvcHRpb25zKTtcbiAgfTtcblxuICBpZiAoIWdsb2JhbFsnVGV4dEVuY29kZXInXSlcbiAgICBnbG9iYWxbJ1RleHRFbmNvZGVyJ10gPSBUZXh0RW5jb2RlcjtcbiAgaWYgKCFnbG9iYWxbJ1RleHREZWNvZGVyJ10pXG4gICAgZ2xvYmFsWydUZXh0RGVjb2RlciddID0gVGV4dERlY29kZXI7XG5cbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgIFRleHRFbmNvZGVyOiBnbG9iYWxbJ1RleHRFbmNvZGVyJ10sXG4gICAgICBUZXh0RGVjb2RlcjogZ2xvYmFsWydUZXh0RGVjb2RlciddLFxuICAgICAgRW5jb2RpbmdJbmRleGVzOiBnbG9iYWxbXCJlbmNvZGluZy1pbmRleGVzXCJdXG4gICAgfTtcbiAgfVxuXG4vLyBGb3Igc3RyaWN0IGVudmlyb25tZW50cyB3aGVyZSBgdGhpc2AgaW5zaWRlIHRoZSBnbG9iYWwgc2NvcGVcbi8vIGlzIGB1bmRlZmluZWRgLCB0YWtlIGEgcHVyZSBvYmplY3QgaW5zdGVhZFxufSh0aGlzIHx8IHt9KSk7Il0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQyxXQUFTQSxNQUFNLEVBQUU7RUFDaEIsWUFBWTs7RUFFWjtFQUNBLElBQUksT0FBT0MsTUFBTSxLQUFLLFdBQVcsSUFBSUEsTUFBTSxDQUFDQyxPQUFPLElBQ2pELENBQUNGLE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFO0lBQzdCQSxNQUFNLENBQUMsa0JBQWtCLENBQUMsR0FDeEJHLE9BQU8sQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDLGtCQUFrQixDQUFDO0VBQ3hEOztFQUVBO0VBQ0E7RUFDQTs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRSxTQUFTQyxPQUFPQSxDQUFDQyxDQUFDLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFO0lBQzVCLE9BQU9ELEdBQUcsSUFBSUQsQ0FBQyxJQUFJQSxDQUFDLElBQUlFLEdBQUc7RUFDN0I7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUNFLFNBQVNDLFFBQVFBLENBQUNDLEtBQUssRUFBRUMsSUFBSSxFQUFFO0lBQzdCLE9BQU9ELEtBQUssQ0FBQ0UsT0FBTyxDQUFDRCxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7RUFDbkM7RUFFQSxJQUFJRSxLQUFLLEdBQUdDLElBQUksQ0FBQ0QsS0FBSzs7RUFFdEI7QUFDRjtBQUNBO0FBQ0E7RUFDRSxTQUFTRSxZQUFZQSxDQUFDQyxDQUFDLEVBQUU7SUFDdkIsSUFBSUEsQ0FBQyxLQUFLQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDOUIsSUFBSUQsQ0FBQyxLQUFLRSxNQUFNLENBQUNGLENBQUMsQ0FBQyxF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