238f9db245cb0e16567c0b6f3ecde4db
/**
 * @popperjs/core v2.11.7 - MIT License
 */

'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== '[object Window]') {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  // IE 11 has no ShadowRoot
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
var max = Math.max;
var min = Math.min;
var round = Math.round;
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function (item) {
      return item.brand + "/" + item.version;
    }).join(' ');
  }
  return navigator.userAgent;
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element) ? getWindow(element) : window,
    visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width: width,
    height: height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x: x,
    y: y
  };
}
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft: scrollLeft,
    scrollTop: scrollTop
  };
}
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}
function getNodeName(element) {
  return element ? (element.nodeName || '').toLowerCase() : null;
}
function getDocumentElement(element) {
  // $FlowFixMe[incompatible-return]: assume body is always available
  return ((isElement(element) ? element.ownerDocument :
  // $FlowFixMe[prop-missing]
  element.document) || window.document).documentElement;
}
function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  // Popper 1 is broken in this case and never had a bug report so let's assume
  // it's not an issue. I don't think anyone ever specifies width on <html>
  // anyway.
  // Browsers where the left scrollbar doesn't cause an issue report `0` for
  // this (e.g. Edge 2019, IE11, Safari)
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}
function isScrollParent(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  var _getComputedStyle = getComputedStyle(element),
    overflow = _getComputedStyle.overflow,
    overflowX = _getComputedStyle.overflowX,
    overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
} // Returns the composite rect of an element relative to its offsetParent.
// Composite means it takes into account transforms as well as layout.

function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== 'body' ||
    // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// means it doesn't take into account transforms.

function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
  // Fixes https://github.com/popperjs/popper-core/issues/1223

  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width,
    height: height
  };
}
function getParentNode(element) {
  if (getNodeName(element) === 'html') {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot ||
    // step into the shadow DOM of the parent of a slotted node
    element.parentNode || (
    // DOM Element detected
    isShadowRoot(element) ? element.host : null) ||
    // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element) // fallback
  );
}

function getScrollParent(node) {
  if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

/*
given a DOM element, return the list of all scroll parents, up the list of ancesors
until we get to the top window object. This list is what we attach scroll listeners
to, because if any of these parent elements scroll, we'll need to re-calculate the
reference element's position.
*/

function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList :
  // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
  updatedList.concat(listScrollParents(getParentNode(target)));
}
function isTableElement(element) {
  return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) ||
  // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle(element).position === 'fixed') {
    return null;
  }
  return element.offsetParent;
} // `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block

function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
    var elementCss = getComputedStyle(element);
    if (elementCss.position === 'fixed') {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that
    // create a containing block.
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.

function getOffsetParent(element) {
  var window = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static')) {
    return window;
  }
  return offsetParent || getContainingBlock(element) || window;
}
var top = 'top';
var bottom = 'bottom';
var right = 'right';
var left = 'left';
var auto = 'auto';
var basePlacements = [top, bottom, right, left];
var start = 'start';
var end = 'end';
var clippingParents = 'clippingParents';
var viewport = 'viewport';
var popper = 'popper';
var reference = 'reference';
var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []); // modifiers that need to read the DOM

var beforeRead = 'beforeRead';
var read = 'read';
var afterRead = 'afterRead'; // pure-logic modifiers

var beforeMain = 'beforeMain';
var main = 'main';
var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

var beforeWrite = 'beforeWrite';
var write = 'write';
var afterWrite = 'afterWrite';
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function (modifier) {
    map.set(modifier.name, modifier);
  }); // On visiting object, check for its dependencies and visit them recursively

  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function (dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function (modifier) {
    if (!visited.has(modifier.name)) {
      // check for visited object
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  // order based on dependencies
  var orderedModifiers = order(modifiers); // order based on phase

  return modifierPhases.reduce(function (acc, phase) {
    return acc.concat(orderedModifiers.filter(function (modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce(fn) {
  var pending;
  return function () {
    if (!pending) {
      pending = new Promise(function (resolve) {
        Promise.resolve().then(function () {
          pending = undefined;
          resolve(fn());
        });
      });
    }
    return pending;
  };
}
function format(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return [].concat(args).reduce(function (p, c) {
    return p.replace(/%s/, c);
  }, str);
}
var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ['name', 'enabled', 'phase', 'fn', 'effect', 'requires', 'options'];
function validateModifiers(modifiers) {
  modifiers.forEach(function (modifier) {
    [].concat(Object.keys(modifier), VALID_PROPERTIES) // IE11-compatible replacement for `new Set(iterable)`
    .filter(function (value, index, self) {
      return self.indexOf(value) === index;
    }).forEach(function (key) {
      switch (key) {
        case 'name':
          if (typeof modifier.name !== 'string') {
            console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', "\"" + String(modifier.name) + "\""));
          }
          break;
        case 'enabled':
          if (typeof modifier.enabled !== 'boolean') {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', "\"" + String(modifier.enabled) + "\""));
          }
          break;
        case 'phase':
          if (modifierPhases.indexOf(modifier.phase) < 0) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(', '), "\"" + String(modifier.phase) + "\""));
          }
          break;
        case 'fn':
          if (typeof modifier.fn !== 'function') {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', "\"" + String(modifier.fn) + "\""));
          }
          break;
        case 'effect':
          if (modifier.effect != null && typeof modifier.effect !== 'function') {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', "\"" + String(modifier.fn) + "\""));
          }
          break;
        case 'requires':
          if (modifier.requires != null && !Array.isArray(modifier.requires)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', "\"" + String(modifier.requires) + "\""));
          }
          break;
        case 'requiresIfExists':
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', "\"" + String(modifier.requiresIfExists) + "\""));
          }
          break;
        case 'options':
        case 'data':
          break;
        default:
          console.error("PopperJS: an invalid property has been provided to the \"" + modifier.name + "\" modifier, valid properties are " + VALID_PROPERTIES.map(function (s) {
            return "\"" + s + "\"";
          }).join(', ') + "; but \"" + key + "\" was provided.");
      }
      modifier.requires && modifier.requires.forEach(function (requirement) {
        if (modifiers.find(function (mod) {
          return mod.name === requirement;
        }) == null) {
          console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}
function uniqueBy(arr, fn) {
  var identifiers = new Set();
  return arr.filter(function (item) {
    var identifier = fn(item);
    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}
function getBasePlacement(placement) {
  return placement.split('-')[0];
}
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function (merged, current) {
    var existing = merged[current.name];
    merged[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged;
  }, {}); // IE11 does not support Object.values

  return Object.keys(merged).map(function (key) {
    return merged[key];
  });
}
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width: width,
    height: height,
    x: x + getWindowScrollBarX(element),
    y: y
  };
}

// of the `<html>` and `<body>` rect bounds if horizontally scrollable

function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle(body || html).direction === 'rtl') {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width: width,
    height: height,
    x: x,
    y: y
  };
}
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

  if (parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      } // $FlowFixMe[prop-missing]: need a better way to handle this...

      next = next.parentNode || next.host;
    } while (next);
  } // Give up, the result is false

  return false;
}
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === 'fixed');
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`

function getClippingParents(element) {
  var clippingParents = listScrollParents(getParentNode(element));
  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414

  return clippingParents.filter(function (clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
  });
} // Gets the maximum area that the element is visible in due to any number of
// clipping parents

function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents[0];
  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function getVariation(placement) {
  return placement.split('-')[1];
}
function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
}
function computeOffsets(_ref) {
  var reference = _ref.reference,
    element = _ref.element,
    placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference.x + reference.width / 2 - element.width / 2;
  var commonY = reference.y + reference.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case right:
      offsets = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference.x,
        y: reference.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === 'y' ? 'height' : 'width';
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys) {
  return keys.reduce(function (hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options,
    _options$placement = _options.placement,
    placement = _options$placement === void 0 ? state.placement : _options$placement,
    _options$strategy = _options.strategy,
    strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
    _options$boundary = _options.boundary,
    boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
    _options$rootBoundary = _options.rootBoundary,
    rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
    _options$elementConte = _options.elementContext,
    elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
    _options$altBoundary = _options.altBoundary,
    altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
    _options$padding = _options.padding,
    padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: 'absolute',
    placement: placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
  // 0 or negative = within the clipping rect

  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

  if (elementContext === popper && offsetData) {
    var offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function (key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }
  return overflowOffsets;
}
var INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';
var INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';
var DEFAULT_OPTIONS = {
  placement: 'bottom',
  modifiers: [],
  strategy: 'absolute'
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function (element) {
    return !(element && typeof element.getBoundingClientRect === 'function');
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions,
    _generatorOptions$def = _generatorOptions.defaultModifiers,
    defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
    _generatorOptions$def2 = _generatorOptions.defaultOptions,
    defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: 'bottom',
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference,
        popper: popper
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state,
      setOptions: function setOptions(setOptionsAction) {
        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options);
        state.scrollParents = {
          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
          popper: listScrollParents(popper)
        }; // Orders the modifiers based on their dependencies and `phase`
        // properties

        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

        state.orderedModifiers = orderedModifiers.filter(function (m) {
          return m.enabled;
        }); // Validate the provided modifiers so that the consumer will get warned
        // if one of the modifiers is invalid for any reason

        if (process.env.NODE_ENV !== "production") {
          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function (_ref) {
            var name = _ref.name;
            return name;
          });
          validateModifiers(modifiers);
          if (getBasePlacement(state.options.placement) === auto) {
            var flipModifier = state.orderedModifiers.find(function (_ref2) {
              var name = _ref2.name;
              return name === 'flip';
            });
            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', 'present and enabled to work.'].join(' '));
            }
          }
          var _getComputedStyle = getComputedStyle(popper),
            marginTop = _getComputedStyle.marginTop,
            marginRight = _getComputedStyle.marginRight,
            marginBottom = _getComputedStyle.marginBottom,
            marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can
          // cause bugs with positioning, so we'll warn the consumer

          if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));
          }
        }
        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements,
          reference = _state$elements.reference,
          popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
        // anymore

        if (!areValidElements(reference, popper)) {
          if (process.env.NODE_ENV !== "production") {
            console.error(INVALID_ELEMENT_ERROR);
          }
          return;
        } // Store the reference and popper rects to be read by modifiers

        state.rects = {
          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
          popper: getLayoutRect(popper)
        }; // Modifiers have the ability to reset the current update cycle. The
        // most common use case for this is the `flip` modifier changing the
        // placement, which then needs to re-run all the modifiers, because the
        // logic was previously ran for the previous placement and is therefore
        // stale/incorrect

        state.reset = false;
        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
        // is filled with the initial data specified by the modifier. This means
        // it doesn't persist and is fresh on each update.
        // To ensure persistent data, use `${name}#persistent`

        state.orderedModifiers.forEach(function (modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (process.env.NODE_ENV !== "production") {
            __debug_loops__ += 1;
            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index],
            fn = _state$orderedModifie.fn,
            _state$orderedModifie2 = _state$orderedModifie.options,
            _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
            name = _state$orderedModifie.name;
          if (typeof fn === 'function') {
            state = fn({
              state: state,
              options: _options,
              name: name,
              instance: instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function () {
        return new Promise(function (resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference, popper)) {
      if (process.env.NODE_ENV !== "production") {
        console.error(INVALID_ELEMENT_ERROR);
      }
      return instance;
    }
    instance.setOptions(options).then(function (state) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state);
      }
    }); // Modifiers have the ability to execute arbitrary code before the first
    // update cycle runs. They will be executed in the same order as the update
    // cycle. This is useful when a modifier adds some persistent data that
    // other modifiers need to use, but the modifier is run after the dependent
    // one.

    function runModifierEffects() {
      state.orderedModifiers.forEach(function (_ref3) {
        var name = _ref3.name,
          _ref3$options = _ref3.options,
          options = _ref3$options === void 0 ? {} : _ref3$options,
          effect = _ref3.effect;
        if (typeof effect === 'function') {
          var cleanupFn = effect({
            state: state,
            name: name,
            instance: instance,
            options: options
          });
          var noopFn = function noopFn() {};
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function (fn) {
        return fn();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var passive = {
  passive: true
};
function effect$2(_ref) {
  var state = _ref.state,
    instance = _ref.instance,
    options = _ref.options;
  var _options$scroll = options.scroll,
    scroll = _options$scroll === void 0 ? true : _options$scroll,
    _options$resize = options.resize,
    resize = _options$resize === void 0 ? true : _options$resize;
  var window = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function (scrollParent) {
      scrollParent.addEventListener('scroll', instance.update, passive);
    });
  }
  if (resize) {
    window.addEventListener('resize', instance.update, passive);
  }
  return function () {
    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.removeEventListener('scroll', instance.update, passive);
      });
    }
    if (resize) {
      window.removeEventListener('resize', instance.update, passive);
    }
  };
} // eslint-disable-next-line import/no-unused-modules

var eventListeners = {
  name: 'eventListeners',
  enabled: true,
  phase: 'write',
  fn: function fn() {},
  effect: effect$2,
  data: {}
};
function popperOffsets(_ref) {
  var state = _ref.state,
    name = _ref.name;
  // Offsets are the actual position the popper needs to have to be
  // properly positioned near its reference element
  // This is the most basic placement, and will be adjusted by
  // the modifiers in the next step
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: 'absolute',
    placement: state.placement
  });
} // eslint-disable-next-line import/no-unused-modules

var popperOffsets$1 = {
  name: 'popperOffsets',
  enabled: true,
  phase: 'read',
  fn: popperOffsets,
  data: {}
};
var unsetSides = {
  top: 'auto',
  right: 'auto',
  bottom: 'auto',
  left: 'auto'
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.

function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x,
    y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper = _ref2.popper,
    popperRect = _ref2.popperRect,
    placement = _ref2.placement,
    variation = _ref2.variation,
    offsets = _ref2.offsets,
    position = _ref2.position,
    gpuAcceleration = _ref2.gpuAcceleration,
    adaptive = _ref2.adaptive,
    roundOffsets = _ref2.roundOffsets,
    isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x,
    x = _offsets$x === void 0 ? 0 : _offsets$x,
    _offsets$y = offsets.y,
    y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
    x: x,
    y: y
  }) : {
    x: x,
    y: y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty('x');
  var hasY = offsets.hasOwnProperty('y');
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper);
    var heightProp = 'clientHeight';
    var widthProp = 'clientWidth';
    if (offsetParent === getWindow(popper)) {
      offsetParent = getDocumentElement(popper);
      if (getComputedStyle(offsetParent).position !== 'static' && position === 'absolute') {
        heightProp = 'scrollHeight';
        widthProp = 'scrollWidth';
      }
    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it

    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height :
      // $FlowFixMe[prop-missing]
      offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width :
      // $FlowFixMe[prop-missing]
      offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position: position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x,
    y: y
  }, getWindow(popper)) : {
    x: x,
    y: y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state,
    options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration,
    gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
    _options$adaptive = options.adaptive,
    adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
    _options$roundOffsets = options.roundOffsets,
    roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  if (process.env.NODE_ENV !== "production") {
    var transitionProperty = getComputedStyle(state.elements.popper).transitionProperty || '';
    if (adaptive && ['transform', 'top', 'right', 'bottom', 'left'].some(function (property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: "transform", "top", "right", "bottom", "left".', '\n\n', 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\n\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' '));
    }
  }
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration: gpuAcceleration,
    isFixed: state.options.strategy === 'fixed'
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive: adaptive,
      roundOffsets: roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: 'absolute',
      adaptive: false,
      roundOffsets: roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-placement': state.placement
  });
} // eslint-disable-next-line import/no-unused-modules

var computeStyles$1 = {
  name: 'computeStyles',
  enabled: true,
  phase: 'beforeWrite',
  fn: computeStyles,
  data: {}
};

// and applies them to the HTMLElements such as popper and arrow

function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function (name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name]; // arrow is optional + virtual elements

    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    } // Flow doesn't support to extend this property, but it's the most
    // effective way to apply styles to an HTMLElement
    // $FlowFixMe[cannot-write]

    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function (name) {
      var value = attributes[name];
      if (value === false) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? '' : value);
      }
    });
  });
}
function effect$1(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: '0',
      top: '0',
      margin: '0'
    },
    arrow: {
      position: 'absolute'
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function () {
    Object.keys(state.elements).forEach(function (name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

      var style = styleProperties.reduce(function (style, property) {
        style[property] = '';
        return style;
      }, {}); // arrow is optional + virtual elements

      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
} // eslint-disable-next-line import/no-unused-modules

var applyStyles$1 = {
  name: 'applyStyles',
  enabled: true,
  phase: 'write',
  fn: applyStyles,
  effect: effect$1,
  requires: ['computeStyles']
};
function distanceAndSkiddingToXY(placement, rects, offset) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
      placement: placement
    })) : offset,
    skidding = _ref[0],
    distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state,
    options = _ref2.options,
    name = _ref2.name;
  var _options$offset = options.offset,
    offset = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function (acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement],
    x = _data$state$placement.x,
    y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules

var offset$1 = {
  name: 'offset',
  enabled: true,
  phase: 'main',
  requires: ['popperOffsets'],
  fn: offset
};
var hash$1 = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash$1[matched];
  });
}
var hash = {
  start: 'end',
  end: 'start'
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function (matched) {
    return hash[matched];
  });
}
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options,
    placement = _options.placement,
    boundary = _options.boundary,
    rootBoundary = _options.rootBoundary,
    padding = _options.padding,
    flipVariations = _options.flipVariations,
    _options$allowedAutoP = _options.allowedAutoPlacements,
    allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
    return getVariation(placement) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function (placement) {
    return allowedAutoPlacements.indexOf(placement) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
    if (process.env.NODE_ENV !== "production") {
      console.error(['Popper: The `allowedAutoPlacements` option did not allow any', 'placements. Ensure the `placement` option matches the variation', 'of the allowed placements.', 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(' '));
    }
  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...

  var overflows = allowedPlacements.reduce(function (acc, placement) {
    acc[placement] = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding
    })[getBasePlacement(placement)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function (a, b) {
    return overflows[a] - overflows[b];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state,
    options = _ref.options,
    name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis,
    checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
    _options$altAxis = options.altAxis,
    checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
    specifiedFallbackPlacements = options.fallbackPlacements,
    padding = options.padding,
    boundary = options.boundary,
    rootBoundary = options.rootBoundary,
    altBoundary = options.altBoundary,
    _options$flipVariatio = options.flipVariations,
    flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
    allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      flipVariations: flipVariations,
      allowedAutoPlacements: allowedAutoPlacements
    }) : placement);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements[0];
  for (var i = 0; i < placements.length; i++) {
    var placement = placements[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? 'width' : 'height';
    var overflow = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      altBoundary: altBoundary,
      padding: padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function (check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    // `2` may be desired in some cases – research later
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop(_i) {
      var fittingPlacement = placements.find(function (placement) {
        var checks = checksMap.get(placement);
        if (checks) {
          return checks.slice(0, _i).every(function (check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break") break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
} // eslint-disable-next-line import/no-unused-modules

var flip$1 = {
  name: 'flip',
  enabled: true,
  phase: 'main',
  fn: flip,
  requiresIfExists: ['offset'],
  data: {
    _skip: false
  }
};
function getAltAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}
function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}
function withinMaxClamp(min, value, max) {
  var v = within(min, value, max);
  return v > max ? max : v;
}
function preventOverflow(_ref) {
  var state = _ref.state,
    options = _ref.options,
    name = _ref.name;
  var _options$mainAxis = options.mainAxis,
    checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
    _options$altAxis = options.altAxis,
    checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
    boundary = options.boundary,
    rootBoundary = options.rootBoundary,
    altBoundary = options.altBoundary,
    padding = options.padding,
    _options$tether = options.tether,
    tether = _options$tether === void 0 ? true : _options$tether,
    _options$tetherOffset = options.tetherOffset,
    tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary: boundary,
    rootBoundary: rootBoundary,
    padding: padding,
    altBoundary: altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === 'y' ? top : left;
    var altSide = mainAxis === 'y' ? bottom : right;
    var len = mainAxis === 'y' ? 'height' : 'width';
    var offset = popperOffsets[mainAxis];
    var min$1 = offset + overflow[mainSide];
    var max$1 = offset - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
    // outside the reference bounds

    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
    // to include its full size in the calculation. If the reference is small
    // and near the edge of a boundary, the popper can overflow even if the
    // reference is not overflowing as well (e.g. virtual elements with no
    // width or height)

    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);
    popperOffsets[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === 'x' ? top : left;
    var _altSide = mainAxis === 'x' ? bottom : right;
    var _offset = popperOffsets[altAxis];
    var _len = altAxis === 'y' ? 'height' : 'width';
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules

var preventOverflow$1 = {
  name: 'preventOverflow',
  enabled: true,
  phase: 'main',
  fn: preventOverflow,
  requiresIfExists: ['offset']
};
var toPaddingObject = function toPaddingObject(padding, state) {
  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state,
    name = _ref.name,
    options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? 'height' : 'width';
  if (!arrowElement || !popperOffsets) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === 'y' ? top : left;
  var maxProp = axis === 'y' ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
  // outside of the popper bounds

  var min = paddingObject[minProp];
  var max = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset = within(min, center, max); // Prevents breaking syntax highlighting...

  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}
function effect(_ref2) {
  var state = _ref2.state,
    options = _ref2.options;
  var _options$element = options.element,
    arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;
  if (arrowElement == null) {
    return;
  } // CSS selector

  if (typeof arrowElement === 'string') {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (process.env.NODE_ENV !== "production") {
    if (!isHTMLElement(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', 'To use an SVG arrow, wrap it in an HTMLElement that will be used as', 'the arrow.'].join(' '));
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    if (process.env.NODE_ENV !== "production") {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', 'element.'].join(' '));
    }
    return;
  }
  state.elements.arrow = arrowElement;
} // eslint-disable-next-line import/no-unused-modules

var arrow$1 = {
  name: 'arrow',
  enabled: true,
  phase: 'main',
  fn: arrow,
  effect: effect,
  requires: ['popperOffsets'],
  requiresIfExists: ['preventOverflow']
};
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function (side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state,
    name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: 'reference'
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets: referenceClippingOffsets,
    popperEscapeOffsets: popperEscapeOffsets,
    isReferenceHidden: isReferenceHidden,
    hasPopperEscaped: hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-reference-hidden': isReferenceHidden,
    'data-popper-escaped': hasPopperEscaped
  });
} // eslint-disable-next-line import/no-unused-modules

var hide$1 = {
  name: 'hide',
  enabled: true,
  phase: 'main',
  requiresIfExists: ['preventOverflow'],
  fn: hide
};
var defaultModifiers$1 = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1];
var createPopper$1 = /*#__PURE__*/popperGenerator({
  defaultModifiers: defaultModifiers$1
}); // eslint-disable-next-line import/no-unused-modules

var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /*#__PURE__*/popperGenerator({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

exports.applyStyles = applyStyles$1;
exports.arrow = arrow$1;
exports.computeStyles = computeStyles$1;
exports.createPopper = createPopper;
exports.createPopperLite = createPopper$1;
exports.defaultModifiers = defaultModifiers;
exports.detectOverflow = detectOverflow;
exports.eventListeners = eventListeners;
exports.flip = flip$1;
exports.hide = hide$1;
exports.offset = offset$1;
exports.popperGenerator = popperGenerator;
exports.popperOffsets = popperOffsets$1;
exports.preventOverflow = preventOverflow$1;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJnZXRXaW5kb3ciLCJub2RlIiwid2luZG93IiwidG9TdHJpbmciLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJpc0VsZW1lbnQiLCJPd25FbGVtZW50IiwiRWxlbWVudCIsImlzSFRNTEVsZW1lbnQiLCJIVE1MRWxlbWVudCIsImlzU2hhZG93Um9vdCIsIlNoYWRvd1Jvb3QiLCJtYXgiLCJNYXRoIiwibWluIiwicm91bmQiLCJnZXRVQVN0cmluZyIsInVhRGF0YSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudERhdGEiLCJicmFuZHMiLCJBcnJheSIsImlzQXJyYXkiLCJtYXAiLCJpdGVtIiwiYnJhbmQiLCJ2ZXJzaW9uIiwiam9pbiIsInVzZXJBZ2VudCIsImlzTGF5b3V0Vmlld3BvcnQiLCJ0ZXN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiZWxlbWVudCIsImluY2x1ZGVTY2FsZSIsImlzRml4ZWRTdHJhdGVneSIsImNsaWVudFJlY3QiLCJzY2FsZVgiLCJzY2FsZVkiLCJvZmZzZXRXaWR0aCIsIndpZHRoIiwib2Zmc2V0SGVpZ2h0IiwiaGVpZ2h0IiwiX3JlZiIsInZpc3VhbFZpZXdwb3J0IiwiYWRkVmlzdWFsT2Zmc2V0cyIsIngiLCJsZWZ0Iiwib2Zmc2V0TGVmdCIsInkiLCJ0b3AiLCJvZmZzZXRUb3AiLCJyaWdodCIsImJvdHRvbSIsImdldFdpbmRvd1Njcm9sbCIsIndpbiIsInNjcm9sbExlZnQiLCJwYWdlWE9mZnNldCIsInNjcm9sbFRvcCIsInBhZ2VZT2Zmc2V0IiwiZ2V0SFRNTEVsZW1lbnRTY3JvbGwiLCJnZXROb2RlU2Nyb2xsIiwiZ2V0Tm9kZU5hbWUiLCJub2RlTmFtZSIsInRvTG93ZXJDYXNlIiwiZ2V0RG9jdW1lbnRFbGVtZW50IiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJnZXRXaW5kb3dTY3JvbGxCYXJYIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImlzU2Nyb2xsUGFyZW50IiwiX2dldENvbXB1dGVkU3R5bGUiLCJvdmVyZmxvdyIsIm92ZXJmbG93WCIsIm92ZXJmbG93WSIsImlzRWxlbWVudFNjYWxlZCIsInJlY3QiLCJnZXRDb21wb3NpdGVSZWN0IiwiZWxlbWVudE9yVmlydHVhbEVsZW1lbnQiLCJvZmZzZXRQYXJlbnQiLCJpc0ZpeGVkIiwiaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQiLCJvZmZzZXRQYXJlbnRJc1NjYWxlZCIsInNjcm9sbCIsIm9mZnNldHMiLCJjbGllbnRMZWZ0IiwiY2xpZW50VG9wIiwiZ2V0TGF5b3V0UmVjdCIsImFicyIsImdldFBhcmVudE5vZGUiLCJhc3NpZ25lZFNsb3QiLCJwYXJlbnROb2RlIiwiaG9zdCIsImdldFNjcm9sbFBhcmVudCIsImluZGV4T2YiLCJib2R5IiwibGlzdFNjcm9sbFBhcmVudHMiLCJsaXN0IiwiX2VsZW1lbnQkb3duZXJEb2N1bWVuIiwic2Nyb2xsUGFyZW50IiwiaXNCb2R5IiwidGFyZ2V0IiwiY29uY2F0IiwidXBkYXRlZExpc3QiLCJpc1RhYmxlRWxlbWVudCIsImdldFRydWVPZmZzZXRQYXJlbnQiLCJwb3NpdGlvbiIsImdldENvbnRhaW5pbmdCbG9jayIsImlzRmlyZWZveCIsImlzSUUiLCJlbGVtZW50Q3NzIiwiY3VycmVudE5vZGUiLCJjc3MiLCJ0cmFuc2Zvcm0iLCJwZXJzcGVjdGl2ZSIsImNvbnRhaW4iLCJ3aWxsQ2hhbmdlIiwiZmlsdGVyIiwiZ2V0T2Zmc2V0UGFyZW50IiwiYXV0byIsImJhc2VQbGFjZW1lbnRzIiwic3RhcnQiLCJlbmQiLCJjbGlwcGluZ1BhcmVudHMiLCJ2aWV3cG9ydCIsInBvcHBlciIsInJlZmVyZW5jZSIsInZhcmlhdGlvblBsYWNlbWVudHMiLCJyZWR1Y2UiLCJhY2MiLCJwbGFjZW1lbnQiLCJwbGFjZW1lbnRzIiwiYmVmb3JlUmVhZCIsInJlYWQiLCJhZnRlclJlYWQiLCJiZWZvcmVNYWluIiwibWFpbiIsImFmdGVyTWFpbiIsImJlZm9yZVdyaXRlIiwid3JpdGUiLCJhZnRlcldyaXRlIiwibW9kaWZpZXJQaGFzZXMiLCJvcmRlciIsIm1vZGlmaWVycyIsIk1hcCIsInZpc2l0ZWQiLCJTZXQiLCJyZXN1bHQiLCJmb3JFYWNoIiwibW9kaWZpZXIiLCJzZXQiLCJuYW1lIiwic29ydCIsImFkZCIsInJlcXVpcmVzIiwicmVxdWlyZXNJZkV4aXN0cyIsImRlcCIsImhhcyIsImRlcE1vZGlmaWVyIiwiZ2V0IiwicHVzaCIsIm9yZGVyTW9kaWZpZXJzIiwib3JkZXJlZE1vZGlmaWVycyIsInBoYXNlIiwiZGVib3VuY2UiLCJmbiIsInBlbmRpbmciLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJ1bmRlZmluZWQiLCJmb3JtYXQiLCJzdHIiLCJfbGVuIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiYXJncyIsIl9rZXkiLCJwIiwiYyIsInJlcGxhY2UiLCJJTlZBTElEX01PRElGSUVSX0VSUk9SIiwiTUlTU0lOR19ERVBFTkRFTkNZX0VSUk9SIiwiVkFMSURfUFJPUEVSVElFUyIsInZhbGlkYXRlTW9kaWZpZXJzIiwiT2JqZWN0Iiwia2V5cyIsInZhbHVlIiwiaW5kZXgiLCJzZWxmIiwia2V5IiwiY29uc29sZSIsImVycm9yIiwiU3RyaW5nIiwiZW5hYmxlZCIsImVmZmVjdCIsInMiLCJyZXF1aXJlbWVudCIsImZpbmQiLCJtb2QiLCJ1bmlxdWVCeSIsImFyciIsImlkZW50aWZpZXJzIiwiaWRlbnRpZmllciIsImdldEJhc2VQbGFjZW1lbnQiLCJzcGxpdCIsIm1lcmdlQnlOYW1lIiwibWVyZ2VkIiwiY3VycmVudCIsImV4aXN0aW5nIiwiYXNzaWduIiwib3B0aW9ucyIsImRhdGEiLCJnZXRWaWV3cG9ydFJlY3QiLCJzdHJhdGVneSIsImh0bWwiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsImxheW91dFZpZXdwb3J0IiwiZ2V0RG9jdW1lbnRSZWN0Iiwid2luU2Nyb2xsIiwic2Nyb2xsV2lkdGgiLCJzY3JvbGxIZWlnaHQiLCJkaXJlY3Rpb24iLCJjb250YWlucyIsInBhcmVudCIsImNoaWxkIiwicm9vdE5vZGUiLCJnZXRSb290Tm9kZSIsIm5leHQiLCJpc1NhbWVOb2RlIiwicmVjdFRvQ2xpZW50UmVjdCIsImdldElubmVyQm91bmRpbmdDbGllbnRSZWN0IiwiZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUiLCJjbGlwcGluZ1BhcmVudCIsImdldENsaXBwaW5nUGFyZW50cyIsImNhbkVzY2FwZUNsaXBwaW5nIiwiY2xpcHBlckVsZW1lbnQiLCJnZXRDbGlwcGluZ1JlY3QiLCJib3VuZGFyeSIsInJvb3RCb3VuZGFyeSIsIm1haW5DbGlwcGluZ1BhcmVudHMiLCJmaXJzdENsaXBwaW5nUGFyZW50IiwiY2xpcHBpbmdSZWN0IiwiYWNjUmVjdCIsImdldFZhcmlhdGlvbiIsImdldE1haW5BeGlzRnJvbVBsYWNlbWVudCIsImNvbXB1dGVPZmZzZXRzIiwiYmFzZVBsYWNlbWVudCIsInZhcmlhdGlvbiIsImNvbW1vblgiLCJjb21tb25ZIiwibWFpbkF4aXMiLCJsZW4iLCJnZXRGcmVzaFNpZGVPYmplY3QiLCJtZXJnZVBhZGRpbmdPYmplY3QiLCJwYWRkaW5nT2JqZWN0IiwiZXhwYW5kVG9IYXNoTWFwIiwiaGFzaE1hcCIsImRldGVjdE92ZXJmbG93Iiwic3RhdGUiLCJfb3B0aW9ucyIsIl9vcHRpb25zJHBsYWNlbWVudCIsIl9vcHRpb25zJHN0cmF0ZWd5IiwiX29wdGlvbnMkYm91bmRhcnkiLCJfb3B0aW9ucyRyb290Qm91bmRhcnkiLCJfb3B0aW9ucyRlbGVtZW50Q29udGUiLCJlbGVtZW50Q29udGV4dCIsIl9vcHRpb25zJGFsdEJvdW5kYXJ5IiwiYWx0Qm91bmRhcnkiLCJfb3B0aW9ucyRwYWRkaW5nIiwicGFkZGluZyIsImFsdENvbnRleHQiLCJwb3BwZXJSZWN0IiwicmVjdHMiLCJlbGVtZW50cyIsImNsaXBwaW5nQ2xpZW50UmVjdCIsImNvbnRleHRFbGVtZW50IiwicmVmZXJlbmNlQ2xpZW50UmVjdCIsInBvcHBlck9mZnNldHMiLCJwb3BwZXJDbGllbnRSZWN0IiwiZWxlbWVudENsaWVudFJlY3QiLCJvdmVyZmxvd09mZnNldHMiLCJvZmZzZXREYXRhIiwibW9kaWZpZXJzRGF0YSIsIm9mZnNldCIsIm11bHRpcGx5IiwiYXhpcyIsIklOVkFMSURfRUxFTUVOVF9FUlJPUiIsIklORklOSVRFX0xPT1BfRVJST1IiLCJERUZBVUxUX09QVElPTlMiLCJhcmVWYWxpZEVsZW1lbnRzIiwic29tZSIsInBvcHBlckdlbmVyYXRvciIsImdlbmVyYXRvck9wdGlvbnMiLCJfZ2VuZXJhdG9yT3B0aW9ucyIsIl9nZW5lcmF0b3JPcHRpb25zJGRlZiIsImRlZmF1bHRNb2RpZmllcnMiLCJfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyIiwiZGVmYXVsdE9wdGlvbnMiLCJjcmVhdGVQb3BwZXIiLCJhdHRyaWJ1dGVzIiwic3R5bGVzIiwiZWZmZWN0Q2xlYW51cEZucyIsImlzRGVzdHJveWVkIiwiaW5zdGFuY2UiLCJzZXRPcHRpb25zIiwic2V0T3B0aW9uc0FjdGlvbiIsImNsZWFudXBNb2RpZmllckVmZmVjdHMiLCJzY3JvbGxQYXJlbnRzIiwibSIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImZsaXBNb2RpZmllciIsIl9yZWYyIiwibWFyZ2luVG9wIiwibWFyZ2luUmlnaHQiLCJtYXJnaW5Cb3R0b20iLCJtYXJnaW5MZWZ0IiwibWFyZ2luIiwicGFyc2VGbG9hdCIsIndhcm4iLCJydW5Nb2RpZmllckVmZmVjdHMiLCJ1cGRhdGUiLCJmb3JjZVVwZGF0ZSIsIl9zdGF0ZSRlbGVtZW50cyIsInJlc2V0IiwiX19kZWJ1Z19sb29wc19fIiwiX3N0YXRlJG9yZGVyZWRNb2RpZmllIiwiX3N0YXRlJG9yZGVyZWRNb2RpZmllMiIsImRlc3Ryb3kiLCJvbkZpcnN0VXBkYXRlIiwiX3JlZjMiLCJfcmVmMyRvcHRpb25zIiwiY2xlYW51cEZuIiwibm9vcEZuIiwicGFzc2l2ZSIsImVmZmVjdCQyIiwiX29wdGlvbnMkc2Nyb2xsIiwiX29wdGlvbnMkcmVzaXplIiwicmVzaXplIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJldmVudExpc3RlbmVycyIsInBvcHBlck9mZnNldHMkMSIsInVuc2V0U2lkZXMiLCJyb3VuZE9mZnNldHNCeURQUiIsImRwciIsImRldmljZVBpeGVsUmF0aW8iLCJtYXBUb1N0eWxlcyIsIl9PYmplY3QkYXNzaWduMiIsImdwdUFjY2VsZXJhdGlvbiIsImFkYXB0aXZlIiwicm91bmRPZmZzZXRzIiwiX29mZnNldHMkeCIsIl9vZmZzZXRzJHkiLCJoYXNYIiwiaGFzT3duUHJvcGVydHkiLCJoYXNZIiwic2lkZVgiLCJzaWRlWSIsImhlaWdodFByb3AiLCJ3aWR0aFByb3AiLCJvZmZzZXRZIiwib2Zmc2V0WCIsImNvbW1vblN0eWxlcyIsIl9yZWY0IiwiX09iamVjdCRhc3NpZ24iLCJjb21wdXRlU3R5bGVzIiwiX3JlZjUiLCJfb3B0aW9ucyRncHVBY2NlbGVyYXQiLCJfb3B0aW9ucyRhZGFwdGl2ZSIsIl9vcHRpb25zJHJvdW5kT2Zmc2V0cyIsInRyYW5zaXRpb25Qcm9wZXJ0eSIsInByb3BlcnR5IiwiYXJyb3ciLCJjb21wdXRlU3R5bGVzJDEiLCJhcHBseVN0eWxlcyIsInN0eWxlIiwicmVtb3ZlQXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwiZWZmZWN0JDEiLCJpbml0aWFsU3R5bGVzIiwic3R5bGVQcm9wZXJ0aWVzIiwiYXR0cmlidXRlIiwiYXBwbHlTdHlsZXMkMSIsImRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZIiwiaW52ZXJ0RGlzdGFuY2UiLCJza2lkZGluZyIsImRpc3RhbmNlIiwiX29wdGlvbnMkb2Zmc2V0IiwiX2RhdGEkc3RhdGUkcGxhY2VtZW50Iiwib2Zmc2V0JDEiLCJoYXNoJDEiLCJnZXRPcHBvc2l0ZVBsYWNlbWVudCIsIm1hdGNoZWQiLCJoYXNoIiwiZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQiLCJjb21wdXRlQXV0b1BsYWNlbWVudCIsImZsaXBWYXJpYXRpb25zIiwiX29wdGlvbnMkYWxsb3dlZEF1dG9QIiwiYWxsb3dlZEF1dG9QbGFjZW1lbnRzIiwicGxhY2VtZW50cyQxIiwiYWxsb3dlZFBsYWNlbWVudHMiLCJvdmVyZmxvd3MiLCJhIiwiYiIsImdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzIiwib3Bwb3NpdGVQbGFjZW1lbnQiLCJmbGlwIiwiX3NraXAiLCJfb3B0aW9ucyRtYWluQXhpcyIsImNoZWNrTWFpbkF4aXMiLCJfb3B0aW9ucyRhbHRBeGlzIiwiYWx0QXhpcyIsImNoZWNrQWx0QXhpcyIsInNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyIsImZhbGxiYWNrUGxhY2VtZW50cyIsIl9vcHRpb25zJGZsaXBWYXJpYXRpbyIsInByZWZlcnJlZFBsYWNlbWVudCIsImlzQmFzZVBsYWNlbWVudCIsInJlZmVyZW5jZVJlY3QiLCJjaGVja3NNYXAiLCJtYWtlRmFsbGJhY2tDaGVja3MiLCJmaXJzdEZpdHRpbmdQbGFjZW1lbnQiLCJpIiwiX2Jhc2VQbGFjZW1lbnQiLCJpc1N0YXJ0VmFyaWF0aW9uIiwiaXNWZXJ0aWNhbCIsIm1haW5WYXJpYXRpb25TaWRlIiwiYWx0VmFyaWF0aW9uU2lkZSIsImNoZWNrcyIsImV2ZXJ5IiwiY2hlY2siLCJudW1iZXJPZkNoZWNrcyIsIl9sb29wIiwiX2kiLCJmaXR0aW5nUGxhY2VtZW50Iiwic2xpY2UiLCJfcmV0IiwiZmxpcCQxIiwiZ2V0QWx0QXhpcyIsIndpdGhpbiIsIm1pbiQxIiwibWF4JDEiLCJ3aXRoaW5NYXhDbGFtcCIsInYiLCJwcmV2ZW50T3ZlcmZsb3ciLCJfb3B0aW9ucyR0ZXRoZXIiLCJ0ZXRoZXIiLCJfb3B0aW9ucyR0ZXRoZXJPZmZzZXQiLCJ0ZXRoZXJPZmZzZXQiLCJ0ZXRoZXJPZmZzZXRWYWx1ZSIsIm5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZSIsIm9mZnNldE1vZGlmaWVyU3RhdGUiLCJfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQiLCJtYWluU2lkZSIsImFsdFNpZGUiLCJhZGRpdGl2ZSIsIm1pbkxlbiIsIm1heExlbiIsImFycm93RWxlbWVudCIsImFycm93UmVjdCIsImFycm93UGFkZGluZ09iamVjdCIsImFycm93UGFkZGluZ01pbiIsImFycm93UGFkZGluZ01heCIsImFycm93TGVuIiwibWluT2Zmc2V0IiwibWF4T2Zmc2V0IiwiYXJyb3dPZmZzZXRQYXJlbnQiLCJjbGllbnRPZmZzZXQiLCJvZmZzZXRNb2RpZmllclZhbHVlIiwidGV0aGVyTWluIiwidGV0aGVyTWF4IiwicHJldmVudGVkT2Zmc2V0IiwiX29mZnNldE1vZGlmaWVyU3RhdGUkMiIsIl9tYWluU2lkZSIsIl9hbHRTaWRlIiwiX29mZnNldCIsIl9taW4iLCJfbWF4IiwiaXNPcmlnaW5TaWRlIiwiX29mZnNldE1vZGlmaWVyVmFsdWUiLCJfdGV0aGVyTWluIiwiX3RldGhlck1heCIsIl9wcmV2ZW50ZWRPZmZzZXQiLCJwcmV2ZW50T3ZlcmZsb3ckMSIsInRvUGFkZGluZ09iamVjdCIsIl9zdGF0ZSRtb2RpZmllcnNEYXRhJCIsIm1pblByb3AiLCJtYXhQcm9wIiwiZW5kRGlmZiIsInN0YXJ0RGlmZiIsImNsaWVudFNpemUiLCJjZW50ZXJUb1JlZmVyZW5jZSIsImNlbnRlciIsImF4aXNQcm9wIiwiY2VudGVyT2Zmc2V0IiwiX29wdGlvbnMkZWxlbWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJhcnJvdyQxIiwiZ2V0U2lkZU9mZnNldHMiLCJwcmV2ZW50ZWRPZmZzZXRzIiwiaXNBbnlTaWRlRnVsbHlDbGlwcGVkIiwic2lkZSIsImhpZGUiLCJyZWZlcmVuY2VPdmVyZmxvdyIsInBvcHBlckFsdE92ZXJmbG93IiwicmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzIiwicG9wcGVyRXNjYXBlT2Zmc2V0cyIsImlzUmVmZXJlbmNlSGlkZGVuIiwiaGFzUG9wcGVyRXNjYXBlZCIsImhpZGUkMSIsImRlZmF1bHRNb2RpZmllcnMkMSIsImNyZWF0ZVBvcHBlciQxIl0sInNvdXJjZXMiOlsiLi4vLi4vc3JjL2RvbS11dGlscy9nZXRXaW5kb3cuanMiLCIuLi8uLi9zcmMvZG9tLXV0aWxzL2luc3RhbmNlT2YuanMiLCIuLi8uLi9zcmMvdXRpbHMvbWF0aC5qcyIsIi4uLy4uL3NyYy91dGlscy91c2VyQWdlbnQuanMiLCIuLi8uLi9zcmMvZG9tLXV0aWxzL2lzTGF5b3V0Vmlld3BvcnQuanMiLCIuLi8uLi9zcmMvZG9tLXV0aWxzL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qcyIsIi4uLy4uL3NyYy9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsLmpzIiwiLi4vLi4vc3JjL2RvbS11dGlscy9nZXRIVE1MRWxlbWVudFNjcm9sbC5qcyIsIi4uLy4uL3NyYy9kb20tdXRpbHMvZ2V0Tm9kZVNjcm9sbC5qcyIsIi4uLy4uL3NyYy9kb20tdXRpbHMvZ2V0Tm9kZU5hbWUuanMiLCIuLi8uLi9zcmMvZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qcyIsIi4uLy4uL3NyYy9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsQmFyWC5qcyIsIi4uLy4uL3NyYy9kb20tdXRpbHMvZ2V0Q29tcHV0ZWRTdHlsZS5qcyIsIi4uLy4uL3NyYy9kb20tdXRpbHMvaXNTY3JvbGxQYXJlbnQuanMiLCIuLi8uLi9zcmMvZG9tLXV0aWxzL2dldENvbXBvc2l0ZVJlY3QuanMiLCIuLi8uLi9zcmMvZG9tLXV0aWxzL2dldExheW91dFJlY3QuanMiLCIuLi8uLi9zcmMvZG9tLXV0aWxzL2dldFBhcmVudE5vZGUuanMiLCIuLi8uLi9zcmMvZG9tLXV0aWxzL2dldFNjcm9sbFBhcmVudC5qcyIsIi4uLy4uL3NyYy9kb20tdXRpbHMvbGlzdFNjcm9sbFBhcmVudHMuanMiLCIuLi8uLi9zcmMvZG9tLXV0aWxzL2lzVGFibGVFbGVtZW50LmpzIiwiLi4vLi4vc3JjL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanMiLCIuLi8uLi9zcmMvZW51bXMuanMiLCIuLi8uLi9zcmMvdXRpbHMvb3JkZXJNb2RpZmllcnMuanMiLCIuLi8uLi9zcmMvdXRpbHMvZGVib3VuY2UuanMiLCIuLi8uLi9zcmMvdXRpbHMvZm9ybWF0LmpzIiwiLi4vLi4vc3JjL3V0aWxzL3ZhbGlkYXRlTW9kaWZpZXJzLmpzIiwiLi4vLi4vc3JjL3V0aWxzL3VuaXF1ZUJ5LmpzIiwiLi4vLi4vc3JjL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanMiLCIuLi8uLi9zcmMvdXRpbHMvbWVyZ2VCeU5hbWUuanMiLCIuLi8uLi9zcmMvZG9tLXV0aWxzL2dldFZpZXdwb3J0UmVjdC5qcyIsIi4uLy4uL3NyYy9kb20tdXRpbHMvZ2V0RG9jdW1lbnRSZWN0LmpzIiwiLi4vLi4vc3JjL2RvbS11dGlscy9jb250YWlucy5qcyIsIi4uLy4uL3NyYy91dGlscy9yZWN0VG9DbGllbnRSZWN0LmpzIiwiLi4vLi4vc3JjL2RvbS11dGlscy9nZXRDbGlwcGluZ1JlY3QuanMiLCIuLi8uLi9zcmMvdXRpbHMvZ2V0VmFyaWF0aW9uLmpzIiwiLi4vLi4vc3JjL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qcyIsIi4uLy4uL3NyYy91dGlscy9jb21wdXRlT2Zmc2V0cy5qcyIsIi4uLy4uL3NyYy91dGlscy9nZXRGcmVzaFNpZGVPYmplY3QuanMiLCIuLi8uLi9zcmMvdXRpbHMvbWVyZ2VQYWRkaW5nT2JqZWN0LmpzIiwiLi4vLi4vc3JjL3V0aWxzL2V4cGFuZFRvSGFzaE1hcC5qcyIsIi4uLy4uL3NyYy91dGlscy9kZXRlY3RPdmVyZmxvdy5qcyIsIi4uLy4uL3NyYy9jcmVhdGVQb3BwZXIuanMiLCIuLi8uLi9zcmMvbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzIiwiLi4vLi4vc3JjL21vZGlmaWVycy9wb3BwZXJPZmZzZXRzLmpzIiwiLi4vLi4vc3JjL21vZGlmaWVycy9jb21wdXRlU3R5bGVzLmpzIiwiLi4vLi4vc3JjL21vZGlmaWVycy9hcHBseVN0eWxlcy5qcyIsIi4uLy4uL3NyYy9tb2RpZmllcnMvb2Zmc2V0LmpzIiwiLi4vLi4vc3JjL3V0aWxzL2dldE9wcG9zaXRlUGxhY2VtZW50LmpzIiwiLi4vLi4vc3JjL3V0aWxzL2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50LmpzIiwiLi4vLi4vc3JjL3V0aWxzL2NvbXB1dGVBdXRvUGxhY2VtZW50LmpzIiwiLi4vLi4vc3JjL21vZGlmaWVycy9mbGlwLmpzIiwiLi4vLi4vc3JjL3V0aWxzL2dldEFsdEF4aXMuanMiLCIuLi8uLi9zcmMvdXRpbHMvd2l0aGluLmpzIiwiLi4vLi4vc3JjL21vZGlmaWVycy9wcmV2ZW50T3ZlcmZsb3cuanMiLCIuLi8uLi9zcmMvbW9kaWZpZXJzL2Fycm93LmpzIiwiLi4vLi4vc3JjL21vZGlmaWVycy9oaWRlLmpzIiwiLi4vLi4vc3JjL3BvcHBlci1saXRlLmpzIiwiLi4vLi4vc3JjL3BvcHBlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBXaW5kb3cgfSBmcm9tICcuLi90eXBlcyc7XG5kZWNsYXJlIGZ1bmN0aW9uIGdldFdpbmRvdyhub2RlOiBOb2RlIHwgV2luZG93KTogV2luZG93O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xuICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIGlmIChub2RlLnRvU3RyaW5nKCkgIT09ICdbb2JqZWN0IFdpbmRvd10nKSB7XG4gICAgY29uc3Qgb3duZXJEb2N1bWVudCA9IG5vZGUub3duZXJEb2N1bWVudDtcbiAgICByZXR1cm4gb3duZXJEb2N1bWVudCA/IG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93IDogd2luZG93O1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tICcuL2dldFdpbmRvdyc7XG5cbmRlY2xhcmUgZnVuY3Rpb24gaXNFbGVtZW50KG5vZGU6IG1peGVkKTogYm9vbGVhbiAlY2hlY2tzKG5vZGUgaW5zdGFuY2VvZlxuICBFbGVtZW50KTtcbmZ1bmN0aW9uIGlzRWxlbWVudChub2RlKSB7XG4gIGNvbnN0IE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuRWxlbWVudDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50O1xufVxuXG5kZWNsYXJlIGZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQobm9kZTogbWl4ZWQpOiBib29sZWFuICVjaGVja3Mobm9kZSBpbnN0YW5jZW9mXG4gIEhUTUxFbGVtZW50KTtcbmZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQobm9kZSkge1xuICBjb25zdCBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLkhUTUxFbGVtZW50O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xufVxuXG5kZWNsYXJlIGZ1bmN0aW9uIGlzU2hhZG93Um9vdChub2RlOiBtaXhlZCk6IGJvb2xlYW4gJWNoZWNrcyhub2RlIGluc3RhbmNlb2ZcbiAgU2hhZG93Um9vdCk7XG5mdW5jdGlvbiBpc1NoYWRvd1Jvb3Qobm9kZSkge1xuICAvLyBJRSAxMSBoYXMgbm8gU2hhZG93Um9vdFxuICBpZiAodHlwZW9mIFNoYWRvd1Jvb3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuU2hhZG93Um9vdDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBTaGFkb3dSb290O1xufVxuXG5leHBvcnQgeyBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQsIGlzU2hhZG93Um9vdCB9O1xuIiwiLy8gQGZsb3dcbmV4cG9ydCBjb25zdCBtYXggPSBNYXRoLm1heDtcbmV4cG9ydCBjb25zdCBtaW4gPSBNYXRoLm1pbjtcbmV4cG9ydCBjb25zdCByb3VuZCA9IE1hdGgucm91bmQ7XG4iLCIvLyBAZmxvd1xudHlwZSBOYXZpZ2F0b3IgPSBOYXZpZ2F0b3IgJiB7IHVzZXJBZ2VudERhdGE/OiBOYXZpZ2F0b3JVQURhdGEgfTtcblxuaW50ZXJmYWNlIE5hdmlnYXRvclVBRGF0YSB7XG4gIGJyYW5kczogQXJyYXk8eyBicmFuZDogc3RyaW5nLCB2ZXJzaW9uOiBzdHJpbmcgfT47XG4gIG1vYmlsZTogYm9vbGVhbjtcbiAgcGxhdGZvcm06IHN0cmluZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0VUFTdHJpbmcoKTogc3RyaW5nIHtcbiAgY29uc3QgdWFEYXRhID0gKG5hdmlnYXRvcjogTmF2aWdhdG9yKS51c2VyQWdlbnREYXRhO1xuXG4gIGlmICh1YURhdGE/LmJyYW5kcyAmJiBBcnJheS5pc0FycmF5KHVhRGF0YS5icmFuZHMpKSB7XG4gICAgcmV0dXJuIHVhRGF0YS5icmFuZHNcbiAgICAgIC5tYXAoKGl0ZW0pID0+IGAke2l0ZW0uYnJhbmR9LyR7aXRlbS52ZXJzaW9ufWApXG4gICAgICAuam9pbignICcpO1xuICB9XG5cbiAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQ7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IGdldFVBU3RyaW5nIGZyb20gJy4uL3V0aWxzL3VzZXJBZ2VudCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzTGF5b3V0Vmlld3BvcnQoKSB7XG4gIHJldHVybiAhL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChnZXRVQVN0cmluZygpKTtcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgdHlwZSB7IENsaWVudFJlY3RPYmplY3QsIFZpcnR1YWxFbGVtZW50IH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50IH0gZnJvbSAnLi9pbnN0YW5jZU9mJztcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSAnLi4vdXRpbHMvbWF0aCc7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gJy4vZ2V0V2luZG93JztcbmltcG9ydCBpc0xheW91dFZpZXdwb3J0IGZyb20gJy4vaXNMYXlvdXRWaWV3cG9ydCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChcbiAgZWxlbWVudDogRWxlbWVudCB8IFZpcnR1YWxFbGVtZW50LFxuICBpbmNsdWRlU2NhbGU6IGJvb2xlYW4gPSBmYWxzZSxcbiAgaXNGaXhlZFN0cmF0ZWd5OiBib29sZWFuID0gZmFsc2Vcbik6IENsaWVudFJlY3RPYmplY3Qge1xuICBjb25zdCBjbGllbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgbGV0IHNjYWxlWCA9IDE7XG4gIGxldCBzY2FsZVkgPSAxO1xuXG4gIGlmIChpbmNsdWRlU2NhbGUgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIHNjYWxlWCA9XG4gICAgICAoZWxlbWVudDogSFRNTEVsZW1lbnQpLm9mZnNldFdpZHRoID4gMFxuICAgICAgICA/IHJvdW5kKGNsaWVudFJlY3Qud2lkdGgpIC8gKGVsZW1lbnQ6IEhUTUxFbGVtZW50KS5vZmZzZXRXaWR0aCB8fCAxXG4gICAgICAgIDogMTtcbiAgICBzY2FsZVkgPVxuICAgICAgKGVsZW1lbnQ6IEhUTUxFbGVtZW50KS5vZmZzZXRIZWlnaHQgPiAwXG4gICAgICAgID8gcm91bmQoY2xpZW50UmVjdC5oZWlnaHQpIC8gKGVsZW1lbnQ6IEhUTUxFbGVtZW50KS5vZmZzZXRIZWlnaHQgfHwgMVxuICAgICAgICA6IDE7XG4gIH1cblxuICBjb25zdCB7IHZpc3VhbFZpZXdwb3J0IH0gPSBpc0VsZW1lbnQoZWxlbWVudCkgPyBnZXRXaW5kb3coZWxlbWVudCkgOiB3aW5kb3c7XG4gIGNvbnN0IGFkZFZpc3VhbE9mZnNldHMgPSAhaXNMYXlvdXRWaWV3cG9ydCgpICYmIGlzRml4ZWRTdHJhdGVneTtcblxuICBjb25zdCB4ID1cbiAgICAoY2xpZW50UmVjdC5sZWZ0ICtcbiAgICAgIChhZGRWaXN1YWxPZmZzZXRzICYmIHZpc3VhbFZpZXdwb3J0ID8gdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdCA6IDApKSAvXG4gICAgc2NhbGVYO1xuICBjb25zdCB5ID1cbiAgICAoY2xpZW50UmVjdC50b3AgK1xuICAgICAgKGFkZFZpc3VhbE9mZnNldHMgJiYgdmlzdWFsVmlld3BvcnQgPyB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3AgOiAwKSkgL1xuICAgIHNjYWxlWTtcbiAgY29uc3Qgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoIC8gc2NhbGVYO1xuICBjb25zdCBoZWlnaHQgPSBjbGllbnRSZWN0LmhlaWdodCAvIHNjYWxlWTtcblxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB0b3A6IHksXG4gICAgcmlnaHQ6IHggKyB3aWR0aCxcbiAgICBib3R0b206IHkgKyBoZWlnaHQsXG4gICAgbGVmdDogeCxcbiAgICB4LFxuICAgIHksXG4gIH07XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tICcuL2dldFdpbmRvdyc7XG5pbXBvcnQgdHlwZSB7IFdpbmRvdyB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsKG5vZGU6IE5vZGUgfCBXaW5kb3cpIHtcbiAgY29uc3Qgd2luID0gZ2V0V2luZG93KG5vZGUpO1xuICBjb25zdCBzY3JvbGxMZWZ0ID0gd2luLnBhZ2VYT2Zmc2V0O1xuICBjb25zdCBzY3JvbGxUb3AgPSB3aW4ucGFnZVlPZmZzZXQ7XG5cbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcCxcbiAgfTtcbn1cbiIsIi8vIEBmbG93XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEhUTUxFbGVtZW50U2Nyb2xsKGVsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogZWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcDogZWxlbWVudC5zY3JvbGxUb3AsXG4gIH07XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbCBmcm9tICcuL2dldFdpbmRvd1Njcm9sbCc7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gJy4vZ2V0V2luZG93JztcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tICcuL2luc3RhbmNlT2YnO1xuaW1wb3J0IGdldEhUTUxFbGVtZW50U2Nyb2xsIGZyb20gJy4vZ2V0SFRNTEVsZW1lbnRTY3JvbGwnO1xuaW1wb3J0IHR5cGUgeyBXaW5kb3cgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE5vZGVTY3JvbGwobm9kZTogTm9kZSB8IFdpbmRvdykge1xuICBpZiAobm9kZSA9PT0gZ2V0V2luZG93KG5vZGUpIHx8ICFpc0hUTUxFbGVtZW50KG5vZGUpKSB7XG4gICAgcmV0dXJuIGdldFdpbmRvd1Njcm9sbChub2RlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2V0SFRNTEVsZW1lbnRTY3JvbGwobm9kZSk7XG4gIH1cbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgdHlwZSB7IFdpbmRvdyB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Tm9kZU5hbWUoZWxlbWVudDogP05vZGUgfCBXaW5kb3cpOiA/c3RyaW5nIHtcbiAgcmV0dXJuIGVsZW1lbnQgPyAoZWxlbWVudC5ub2RlTmFtZSB8fCAnJykudG9Mb3dlckNhc2UoKSA6IG51bGw7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHsgaXNFbGVtZW50IH0gZnJvbSAnLi9pbnN0YW5jZU9mJztcbmltcG9ydCB0eXBlIHsgV2luZG93IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXREb2N1bWVudEVsZW1lbnQoXG4gIGVsZW1lbnQ6IEVsZW1lbnQgfCBXaW5kb3dcbik6IEhUTUxFbGVtZW50IHtcbiAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogYXNzdW1lIGJvZHkgaXMgYWx3YXlzIGF2YWlsYWJsZVxuICByZXR1cm4gKFxuICAgIChpc0VsZW1lbnQoZWxlbWVudClcbiAgICAgID8gZWxlbWVudC5vd25lckRvY3VtZW50XG4gICAgICA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgICBlbGVtZW50LmRvY3VtZW50KSB8fCB3aW5kb3cuZG9jdW1lbnRcbiAgKS5kb2N1bWVudEVsZW1lbnQ7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tICcuL2dldEJvdW5kaW5nQ2xpZW50UmVjdCc7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gJy4vZ2V0RG9jdW1lbnRFbGVtZW50JztcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGwgZnJvbSAnLi9nZXRXaW5kb3dTY3JvbGwnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQ6IEVsZW1lbnQpOiBudW1iZXIge1xuICAvLyBJZiA8aHRtbD4gaGFzIGEgQ1NTIHdpZHRoIGdyZWF0ZXIgdGhhbiB0aGUgdmlld3BvcnQsIHRoZW4gdGhpcyB3aWxsIGJlXG4gIC8vIGluY29ycmVjdCBmb3IgUlRMLlxuICAvLyBQb3BwZXIgMSBpcyBicm9rZW4gaW4gdGhpcyBjYXNlIGFuZCBuZXZlciBoYWQgYSBidWcgcmVwb3J0IHNvIGxldCdzIGFzc3VtZVxuICAvLyBpdCdzIG5vdCBhbiBpc3N1ZS4gSSBkb24ndCB0aGluayBhbnlvbmUgZXZlciBzcGVjaWZpZXMgd2lkdGggb24gPGh0bWw+XG4gIC8vIGFueXdheS5cbiAgLy8gQnJvd3NlcnMgd2hlcmUgdGhlIGxlZnQgc2Nyb2xsYmFyIGRvZXNuJ3QgY2F1c2UgYW4gaXNzdWUgcmVwb3J0IGAwYCBmb3JcbiAgLy8gdGhpcyAoZS5nLiBFZGdlIDIwMTksIElFMTEsIFNhZmFyaSlcbiAgcmV0dXJuIChcbiAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKS5sZWZ0ICtcbiAgICBnZXRXaW5kb3dTY3JvbGwoZWxlbWVudCkuc2Nyb2xsTGVmdFxuICApO1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSAnLi9nZXRXaW5kb3cnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlKFxuICBlbGVtZW50OiBFbGVtZW50XG4pOiBDU1NTdHlsZURlY2xhcmF0aW9uIHtcbiAgcmV0dXJuIGdldFdpbmRvdyhlbGVtZW50KS5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gJy4vZ2V0Q29tcHV0ZWRTdHlsZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzU2Nyb2xsUGFyZW50KGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbiB7XG4gIC8vIEZpcmVmb3ggd2FudHMgdXMgdG8gY2hlY2sgYC14YCBhbmQgYC15YCB2YXJpYXRpb25zIGFzIHdlbGxcbiAgY29uc3QgeyBvdmVyZmxvdywgb3ZlcmZsb3dYLCBvdmVyZmxvd1kgfSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW4vLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpO1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCB0eXBlIHsgUmVjdCwgVmlydHVhbEVsZW1lbnQsIFdpbmRvdyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSAnLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QnO1xuaW1wb3J0IGdldE5vZGVTY3JvbGwgZnJvbSAnLi9nZXROb2RlU2Nyb2xsJztcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tICcuL2dldE5vZGVOYW1lJztcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tICcuL2luc3RhbmNlT2YnO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbEJhclggZnJvbSAnLi9nZXRXaW5kb3dTY3JvbGxCYXJYJztcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSAnLi9nZXREb2N1bWVudEVsZW1lbnQnO1xuaW1wb3J0IGlzU2Nyb2xsUGFyZW50IGZyb20gJy4vaXNTY3JvbGxQYXJlbnQnO1xuaW1wb3J0IHsgcm91bmQgfSBmcm9tICcuLi91dGlscy9tYXRoJztcblxuZnVuY3Rpb24gaXNFbGVtZW50U2NhbGVkKGVsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XG4gIGNvbnN0IHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCBzY2FsZVggPSByb3VuZChyZWN0LndpZHRoKSAvIGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMTtcbiAgY29uc3Qgc2NhbGVZID0gcm91bmQocmVjdC5oZWlnaHQpIC8gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMTtcblxuICByZXR1cm4gc2NhbGVYICE9PSAxIHx8IHNjYWxlWSAhPT0gMTtcbn1cblxuLy8gUmV0dXJucyB0aGUgY29tcG9zaXRlIHJlY3Qgb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byBpdHMgb2Zmc2V0UGFyZW50LlxuLy8gQ29tcG9zaXRlIG1lYW5zIGl0IHRha2VzIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zIGFzIHdlbGwgYXMgbGF5b3V0LlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Q29tcG9zaXRlUmVjdChcbiAgZWxlbWVudE9yVmlydHVhbEVsZW1lbnQ6IEVsZW1lbnQgfCBWaXJ0dWFsRWxlbWVudCxcbiAgb2Zmc2V0UGFyZW50OiBFbGVtZW50IHwgV2luZG93LFxuICBpc0ZpeGVkOiBib29sZWFuID0gZmFsc2Vcbik6IFJlY3Qge1xuICBjb25zdCBpc09mZnNldFBhcmVudEFuRWxlbWVudCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgY29uc3Qgb2Zmc2V0UGFyZW50SXNTY2FsZWQgPVxuICAgIGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSAmJiBpc0VsZW1lbnRTY2FsZWQob2Zmc2V0UGFyZW50KTtcbiAgY29uc3QgZG9jdW1lbnRFbGVtZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIGNvbnN0IHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoXG4gICAgZWxlbWVudE9yVmlydHVhbEVsZW1lbnQsXG4gICAgb2Zmc2V0UGFyZW50SXNTY2FsZWQsXG4gICAgaXNGaXhlZFxuICApO1xuXG4gIGxldCBzY3JvbGwgPSB7IHNjcm9sbExlZnQ6IDAsIHNjcm9sbFRvcDogMCB9O1xuICBsZXQgb2Zmc2V0cyA9IHsgeDogMCwgeTogMCB9O1xuXG4gIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCB8fCAoIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkKSkge1xuICAgIGlmIChcbiAgICAgIGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fFxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy8xMDc4XG4gICAgICBpc1Njcm9sbFBhcmVudChkb2N1bWVudEVsZW1lbnQpXG4gICAgKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgb2Zmc2V0cyA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQsIHRydWUpO1xuICAgICAgb2Zmc2V0cy54ICs9IG9mZnNldFBhcmVudC5jbGllbnRMZWZ0O1xuICAgICAgb2Zmc2V0cy55ICs9IG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIG9mZnNldHMueCA9IGdldFdpbmRvd1Njcm9sbEJhclgoZG9jdW1lbnRFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IHJlY3QubGVmdCArIHNjcm9sbC5zY3JvbGxMZWZ0IC0gb2Zmc2V0cy54LFxuICAgIHk6IHJlY3QudG9wICsgc2Nyb2xsLnNjcm9sbFRvcCAtIG9mZnNldHMueSxcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0LFxuICB9O1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCB0eXBlIHsgUmVjdCB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSAnLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QnO1xuXG4vLyBSZXR1cm5zIHRoZSBsYXlvdXQgcmVjdCBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIGl0cyBvZmZzZXRQYXJlbnQuIExheW91dFxuLy8gbWVhbnMgaXQgZG9lc24ndCB0YWtlIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0TGF5b3V0UmVjdChlbGVtZW50OiBIVE1MRWxlbWVudCk6IFJlY3Qge1xuICBjb25zdCBjbGllbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpO1xuXG4gIC8vIFVzZSB0aGUgY2xpZW50UmVjdCBzaXplcyBpZiBpdCdzIG5vdCBiZWVuIHRyYW5zZm9ybWVkLlxuICAvLyBGaXhlcyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEyMjNcbiAgbGV0IHdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgbGV0IGhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuXG4gIGlmIChNYXRoLmFicyhjbGllbnRSZWN0LndpZHRoIC0gd2lkdGgpIDw9IDEpIHtcbiAgICB3aWR0aCA9IGNsaWVudFJlY3Qud2lkdGg7XG4gIH1cblxuICBpZiAoTWF0aC5hYnMoY2xpZW50UmVjdC5oZWlnaHQgLSBoZWlnaHQpIDw9IDEpIHtcbiAgICBoZWlnaHQgPSBjbGllbnRSZWN0LmhlaWdodDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogZWxlbWVudC5vZmZzZXRMZWZ0LFxuICAgIHk6IGVsZW1lbnQub2Zmc2V0VG9wLFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgfTtcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSAnLi9nZXROb2RlTmFtZSc7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gJy4vZ2V0RG9jdW1lbnRFbGVtZW50JztcbmltcG9ydCB7IGlzU2hhZG93Um9vdCB9IGZyb20gJy4vaW5zdGFuY2VPZic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFBhcmVudE5vZGUoZWxlbWVudDogTm9kZSB8IFNoYWRvd1Jvb3QpOiBOb2RlIHtcbiAgaWYgKGdldE5vZGVOYW1lKGVsZW1lbnQpID09PSAnaHRtbCcpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgLy8gdGhpcyBpcyBhIHF1aWNrZXIgKGJ1dCBsZXNzIHR5cGUgc2FmZSkgd2F5IHRvIHNhdmUgcXVpdGUgc29tZSBieXRlcyBmcm9tIHRoZSBidW5kbGVcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG4gICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgZWxlbWVudC5hc3NpZ25lZFNsb3QgfHwgLy8gc3RlcCBpbnRvIHRoZSBzaGFkb3cgRE9NIG9mIHRoZSBwYXJlbnQgb2YgYSBzbG90dGVkIG5vZGVcbiAgICBlbGVtZW50LnBhcmVudE5vZGUgfHwgLy8gRE9NIEVsZW1lbnQgZGV0ZWN0ZWRcbiAgICAoaXNTaGFkb3dSb290KGVsZW1lbnQpID8gZWxlbWVudC5ob3N0IDogbnVsbCkgfHwgLy8gU2hhZG93Um9vdCBkZXRlY3RlZFxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBIVE1MRWxlbWVudCBpcyBhIE5vZGVcbiAgICBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkgLy8gZmFsbGJhY2tcbiAgKTtcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tICcuL2dldFBhcmVudE5vZGUnO1xuaW1wb3J0IGlzU2Nyb2xsUGFyZW50IGZyb20gJy4vaXNTY3JvbGxQYXJlbnQnO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gJy4vZ2V0Tm9kZU5hbWUnO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gJy4vaW5zdGFuY2VPZic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChub2RlOiBOb2RlKTogSFRNTEVsZW1lbnQge1xuICBpZiAoWydodG1sJywgJ2JvZHknLCAnI2RvY3VtZW50J10uaW5kZXhPZihnZXROb2RlTmFtZShub2RlKSkgPj0gMCkge1xuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGFzc3VtZSBib2R5IGlzIGFsd2F5cyBhdmFpbGFibGVcbiAgICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50LmJvZHk7XG4gIH1cblxuICBpZiAoaXNIVE1MRWxlbWVudChub2RlKSAmJiBpc1Njcm9sbFBhcmVudChub2RlKSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcmV0dXJuIGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKG5vZGUpKTtcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgZ2V0U2Nyb2xsUGFyZW50IGZyb20gJy4vZ2V0U2Nyb2xsUGFyZW50JztcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gJy4vZ2V0UGFyZW50Tm9kZSc7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gJy4vZ2V0V2luZG93JztcbmltcG9ydCB0eXBlIHsgV2luZG93LCBWaXN1YWxWaWV3cG9ydCB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCBpc1Njcm9sbFBhcmVudCBmcm9tICcuL2lzU2Nyb2xsUGFyZW50JztcblxuLypcbmdpdmVuIGEgRE9NIGVsZW1lbnQsIHJldHVybiB0aGUgbGlzdCBvZiBhbGwgc2Nyb2xsIHBhcmVudHMsIHVwIHRoZSBsaXN0IG9mIGFuY2Vzb3JzXG51bnRpbCB3ZSBnZXQgdG8gdGhlIHRvcCB3aW5kb3cgb2JqZWN0LiBUaGlzIGxpc3QgaXMgd2hhdCB3ZSBhdHRhY2ggc2Nyb2xsIGxpc3RlbmVyc1xudG8sIGJlY2F1c2UgaWYgYW55IG9mIHRoZXNlIHBhcmVudCBlbGVtZW50cyBzY3JvbGwsIHdlJ2xsIG5lZWQgdG8gcmUtY2FsY3VsYXRlIHRoZVxucmVmZXJlbmNlIGVsZW1lbnQncyBwb3NpdGlvbi5cbiovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsaXN0U2Nyb2xsUGFyZW50cyhcbiAgZWxlbWVudDogTm9kZSxcbiAgbGlzdDogQXJyYXk8RWxlbWVudCB8IFdpbmRvdz4gPSBbXVxuKTogQXJyYXk8RWxlbWVudCB8IFdpbmRvdyB8IFZpc3VhbFZpZXdwb3J0PiB7XG4gIGNvbnN0IHNjcm9sbFBhcmVudCA9IGdldFNjcm9sbFBhcmVudChlbGVtZW50KTtcbiAgY29uc3QgaXNCb2R5ID0gc2Nyb2xsUGFyZW50ID09PSBlbGVtZW50Lm93bmVyRG9jdW1lbnQ/LmJvZHk7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhzY3JvbGxQYXJlbnQpO1xuICBjb25zdCB0YXJnZXQgPSBpc0JvZHlcbiAgICA/IFt3aW5dLmNvbmNhdChcbiAgICAgICAgd2luLnZpc3VhbFZpZXdwb3J0IHx8IFtdLFxuICAgICAgICBpc1Njcm9sbFBhcmVudChzY3JvbGxQYXJlbnQpID8gc2Nyb2xsUGFyZW50IDogW11cbiAgICAgIClcbiAgICA6IHNjcm9sbFBhcmVudDtcbiAgY29uc3QgdXBkYXRlZExpc3QgPSBsaXN0LmNvbmNhdCh0YXJnZXQpO1xuXG4gIHJldHVybiBpc0JvZHlcbiAgICA/IHVwZGF0ZWRMaXN0XG4gICAgOiAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogaXNCb2R5IHRlbGxzIHVzIHRhcmdldCB3aWxsIGJlIGFuIEhUTUxFbGVtZW50IGhlcmVcbiAgICAgIHVwZGF0ZWRMaXN0LmNvbmNhdChsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKHRhcmdldCkpKTtcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSAnLi9nZXROb2RlTmFtZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzVGFibGVFbGVtZW50KGVsZW1lbnQ6IEVsZW1lbnQpOiBib29sZWFuIHtcbiAgcmV0dXJuIFsndGFibGUnLCAndGQnLCAndGgnXS5pbmRleE9mKGdldE5vZGVOYW1lKGVsZW1lbnQpKSA+PSAwO1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSAnLi9nZXRXaW5kb3cnO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gJy4vZ2V0Tm9kZU5hbWUnO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSAnLi9nZXRDb21wdXRlZFN0eWxlJztcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQsIGlzU2hhZG93Um9vdCB9IGZyb20gJy4vaW5zdGFuY2VPZic7XG5pbXBvcnQgaXNUYWJsZUVsZW1lbnQgZnJvbSAnLi9pc1RhYmxlRWxlbWVudCc7XG5pbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tICcuL2dldFBhcmVudE5vZGUnO1xuaW1wb3J0IGdldFVBU3RyaW5nIGZyb20gJy4uL3V0aWxzL3VzZXJBZ2VudCc7XG5cbmZ1bmN0aW9uIGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudDogRWxlbWVudCk6ID9FbGVtZW50IHtcbiAgaWYgKFxuICAgICFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy84MzdcbiAgICBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09PSAnZml4ZWQnXG4gICkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQub2Zmc2V0UGFyZW50O1xufVxuXG4vLyBgLm9mZnNldFBhcmVudGAgcmVwb3J0cyBgbnVsbGAgZm9yIGZpeGVkIGVsZW1lbnRzLCB3aGlsZSBhYnNvbHV0ZSBlbGVtZW50c1xuLy8gcmV0dXJuIHRoZSBjb250YWluaW5nIGJsb2NrXG5mdW5jdGlvbiBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudDogRWxlbWVudCkge1xuICBjb25zdCBpc0ZpcmVmb3ggPSAvZmlyZWZveC9pLnRlc3QoZ2V0VUFTdHJpbmcoKSk7XG4gIGNvbnN0IGlzSUUgPSAvVHJpZGVudC9pLnRlc3QoZ2V0VUFTdHJpbmcoKSk7XG5cbiAgaWYgKGlzSUUgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIC8vIEluIElFIDksIDEwIGFuZCAxMSBmaXhlZCBlbGVtZW50cyBjb250YWluaW5nIGJsb2NrIGlzIGFsd2F5cyBlc3RhYmxpc2hlZCBieSB0aGUgdmlld3BvcnRcbiAgICBjb25zdCBlbGVtZW50Q3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgICBpZiAoZWxlbWVudENzcy5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgbGV0IGN1cnJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcblxuICBpZiAoaXNTaGFkb3dSb290KGN1cnJlbnROb2RlKSkge1xuICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUuaG9zdDtcbiAgfVxuXG4gIHdoaWxlIChcbiAgICBpc0hUTUxFbGVtZW50KGN1cnJlbnROb2RlKSAmJlxuICAgIFsnaHRtbCcsICdib2R5J10uaW5kZXhPZihnZXROb2RlTmFtZShjdXJyZW50Tm9kZSkpIDwgMFxuICApIHtcbiAgICBjb25zdCBjc3MgPSBnZXRDb21wdXRlZFN0eWxlKGN1cnJlbnROb2RlKTtcblxuICAgIC8vIFRoaXMgaXMgbm9uLWV4aGF1c3RpdmUgYnV0IGNvdmVycyB0aGUgbW9zdCBjb21tb24gQ1NTIHByb3BlcnRpZXMgdGhhdFxuICAgIC8vIGNyZWF0ZSBhIGNvbnRhaW5pbmcgYmxvY2suXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NvbnRhaW5pbmdfYmxvY2sjaWRlbnRpZnlpbmdfdGhlX2NvbnRhaW5pbmdfYmxvY2tcbiAgICBpZiAoXG4gICAgICBjc3MudHJhbnNmb3JtICE9PSAnbm9uZScgfHxcbiAgICAgIGNzcy5wZXJzcGVjdGl2ZSAhPT0gJ25vbmUnIHx8XG4gICAgICBjc3MuY29udGFpbiA9PT0gJ3BhaW50JyB8fFxuICAgICAgWyd0cmFuc2Zvcm0nLCAncGVyc3BlY3RpdmUnXS5pbmRleE9mKGNzcy53aWxsQ2hhbmdlKSAhPT0gLTEgfHxcbiAgICAgIChpc0ZpcmVmb3ggJiYgY3NzLndpbGxDaGFuZ2UgPT09ICdmaWx0ZXInKSB8fFxuICAgICAgKGlzRmlyZWZveCAmJiBjc3MuZmlsdGVyICYmIGNzcy5maWx0ZXIgIT09ICdub25lJylcbiAgICApIHtcbiAgICAgIHJldHVybiBjdXJyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBHZXRzIHRoZSBjbG9zZXN0IGFuY2VzdG9yIHBvc2l0aW9uZWQgZWxlbWVudC4gSGFuZGxlcyBzb21lIGVkZ2UgY2FzZXMsXG4vLyBzdWNoIGFzIHRhYmxlIGFuY2VzdG9ycyBhbmQgY3Jvc3MgYnJvd3NlciBidWdzLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQ6IEVsZW1lbnQpIHtcbiAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuXG4gIGxldCBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQpO1xuXG4gIHdoaWxlIChcbiAgICBvZmZzZXRQYXJlbnQgJiZcbiAgICBpc1RhYmxlRWxlbWVudChvZmZzZXRQYXJlbnQpICYmXG4gICAgZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJ1xuICApIHtcbiAgICBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCk7XG4gIH1cblxuICBpZiAoXG4gICAgb2Zmc2V0UGFyZW50ICYmXG4gICAgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdodG1sJyB8fFxuICAgICAgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdib2R5JyAmJlxuICAgICAgICBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnKSlcbiAgKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHx8IHdpbmRvdztcbn1cbiIsIi8vIEBmbG93XG5leHBvcnQgY29uc3QgdG9wOiAndG9wJyA9ICd0b3AnO1xuZXhwb3J0IGNvbnN0IGJvdHRvbTogJ2JvdHRvbScgPSAnYm90dG9tJztcbmV4cG9ydCBjb25zdCByaWdodDogJ3JpZ2h0JyA9ICdyaWdodCc7XG5leHBvcnQgY29uc3QgbGVmdDogJ2xlZnQnID0gJ2xlZnQnO1xuZXhwb3J0IGNvbnN0IGF1dG86ICdhdXRvJyA9ICdhdXRvJztcbmV4cG9ydCB0eXBlIEJhc2VQbGFjZW1lbnQgPVxuICB8IHR5cGVvZiB0b3BcbiAgfCB0eXBlb2YgYm90dG9tXG4gIHwgdHlwZW9mIHJpZ2h0XG4gIHwgdHlwZW9mIGxlZnQ7XG5leHBvcnQgY29uc3QgYmFzZVBsYWNlbWVudHM6IEFycmF5PEJhc2VQbGFjZW1lbnQ+ID0gW3RvcCwgYm90dG9tLCByaWdodCwgbGVmdF07XG5cbmV4cG9ydCBjb25zdCBzdGFydDogJ3N0YXJ0JyA9ICdzdGFydCc7XG5leHBvcnQgY29uc3QgZW5kOiAnZW5kJyA9ICdlbmQnO1xuZXhwb3J0IHR5cGUgVmFyaWF0aW9uID0gdHlwZW9mIHN0YXJ0IHwgdHlwZW9mIGVuZDtcblxuZXhwb3J0IGNvbnN0IGNsaXBwaW5nUGFyZW50czogJ2NsaXBwaW5nUGFyZW50cycgPSAnY2xpcHBpbmdQYXJlbnRzJztcbmV4cG9ydCBjb25zdCB2aWV3cG9ydDogJ3ZpZXdwb3J0JyA9ICd2aWV3cG9ydCc7XG5leHBvcnQgdHlwZSBCb3VuZGFyeSA9IEVsZW1lbnQgfCBBcnJheTxFbGVtZW50PiB8IHR5cGVvZiBjbGlwcGluZ1BhcmVudHM7XG5leHBvcnQgdHlwZSBSb290Qm91bmRhcnkgPSB0eXBlb2Ygdmlld3BvcnQgfCAnZG9jdW1lbnQnO1xuXG5leHBvcnQgY29uc3QgcG9wcGVyOiAncG9wcGVyJyA9ICdwb3BwZXInO1xuZXhwb3J0IGNvbnN0IHJlZmVyZW5jZTogJ3JlZmVyZW5jZScgPSAncmVmZXJlbmNlJztcbmV4cG9ydCB0eXBlIENvbnRleHQgPSB0eXBlb2YgcG9wcGVyIHwgdHlwZW9mIHJlZmVyZW5jZTtcblxuZXhwb3J0IHR5cGUgVmFyaWF0aW9uUGxhY2VtZW50ID1cbiAgfCAndG9wLXN0YXJ0J1xuICB8ICd0b3AtZW5kJ1xuICB8ICdib3R0b20tc3RhcnQnXG4gIHwgJ2JvdHRvbS1lbmQnXG4gIHwgJ3JpZ2h0LXN0YXJ0J1xuICB8ICdyaWdodC1lbmQnXG4gIHwgJ2xlZnQtc3RhcnQnXG4gIHwgJ2xlZnQtZW5kJztcbmV4cG9ydCB0eXBlIEF1dG9QbGFjZW1lbnQgPSAnYXV0bycgfCAnYXV0by1zdGFydCcgfCAnYXV0by1lbmQnO1xuZXhwb3J0IHR5cGUgQ29tcHV0ZWRQbGFjZW1lbnQgPSBWYXJpYXRpb25QbGFjZW1lbnQgfCBCYXNlUGxhY2VtZW50O1xuZXhwb3J0IHR5cGUgUGxhY2VtZW50ID0gQXV0b1BsYWNlbWVudCB8IEJhc2VQbGFjZW1lbnQgfCBWYXJpYXRpb25QbGFjZW1lbnQ7XG5cbmV4cG9ydCBjb25zdCB2YXJpYXRpb25QbGFjZW1lbnRzOiBBcnJheTxWYXJpYXRpb25QbGFjZW1lbnQ+ID0gYmFzZVBsYWNlbWVudHMucmVkdWNlKFxuICAoYWNjOiBBcnJheTxWYXJpYXRpb25QbGFjZW1lbnQ+LCBwbGFjZW1lbnQ6IEJhc2VQbGFjZW1lbnQpID0+XG4gICAgYWNjLmNvbmNhdChbKGAke3BsYWNlbWVudH0tJHtzdGFydH1gOiBhbnkpLCAoYCR7cGxhY2VtZW50fS0ke2VuZH1gOiBhbnkpXSksXG4gIFtdXG4pO1xuZXhwb3J0IGNvbnN0IHBsYWNlbWVudHM6IEFycmF5PFBsYWNlbWVudD4gPSBbLi4uYmFzZVBsYWNlbWVudHMsIGF1dG9dLnJlZHVjZShcbiAgKFxuICAgIGFjYzogQXJyYXk8UGxhY2VtZW50PixcbiAgICBwbGFjZW1lbnQ6IEJhc2VQbGFjZW1lbnQgfCB0eXBlb2YgYXV0b1xuICApOiBBcnJheTxQbGFjZW1lbnQ+ID0+XG4gICAgYWNjLmNvbmNhdChbXG4gICAgICBwbGFjZW1lbnQsXG4gICAgICAoYCR7cGxhY2VtZW50fS0ke3N0YXJ0fWA6IGFueSksXG4gICAgICAoYCR7cGxhY2VtZW50fS0ke2VuZH1gOiBhbnkpLFxuICAgIF0pLFxuICBbXVxuKTtcblxuLy8gbW9kaWZpZXJzIHRoYXQgbmVlZCB0byByZWFkIHRoZSBET01cbmV4cG9ydCBjb25zdCBiZWZvcmVSZWFkOiAnYmVmb3JlUmVhZCcgPSAnYmVmb3JlUmVhZCc7XG5leHBvcnQgY29uc3QgcmVhZDogJ3JlYWQnID0gJ3JlYWQnO1xuZXhwb3J0IGNvbnN0IGFmdGVyUmVhZDogJ2FmdGVyUmVhZCcgPSAnYWZ0ZXJSZWFkJztcbi8vIHB1cmUtbG9naWMgbW9kaWZpZXJzXG5leHBvcnQgY29uc3QgYmVmb3JlTWFpbjogJ2JlZm9yZU1haW4nID0gJ2JlZm9yZU1haW4nO1xuZXhwb3J0IGNvbnN0IG1haW46ICdtYWluJyA9ICdtYWluJztcbmV4cG9ydCBjb25zdCBhZnRlck1haW46ICdhZnRlck1haW4nID0gJ2FmdGVyTWFpbic7XG4vLyBtb2RpZmllciB3aXRoIHRoZSBwdXJwb3NlIHRvIHdyaXRlIHRvIHRoZSBET00gKG9yIHdyaXRlIGludG8gYSBmcmFtZXdvcmsgc3RhdGUpXG5leHBvcnQgY29uc3QgYmVmb3JlV3JpdGU6ICdiZWZvcmVXcml0ZScgPSAnYmVmb3JlV3JpdGUnO1xuZXhwb3J0IGNvbnN0IHdyaXRlOiAnd3JpdGUnID0gJ3dyaXRlJztcbmV4cG9ydCBjb25zdCBhZnRlcldyaXRlOiAnYWZ0ZXJXcml0ZScgPSAnYWZ0ZXJXcml0ZSc7XG5leHBvcnQgY29uc3QgbW9kaWZpZXJQaGFzZXM6IEFycmF5PE1vZGlmaWVyUGhhc2VzPiA9IFtcbiAgYmVmb3JlUmVhZCxcbiAgcmVhZCxcbiAgYWZ0ZXJSZWFkLFxuICBiZWZvcmVNYWluLFxuICBtYWluLFxuICBhZnRlck1haW4sXG4gIGJlZm9yZVdyaXRlLFxuICB3cml0ZSxcbiAgYWZ0ZXJXcml0ZSxcbl07XG5cbmV4cG9ydCB0eXBlIE1vZGlmaWVyUGhhc2VzID1cbiAgfCB0eXBlb2YgYmVmb3JlUmVhZFxuICB8IHR5cGVvZiByZWFkXG4gIHwgdHlwZW9mIGFmdGVyUmVhZFxuICB8IHR5cGVvZiBiZWZvcmVNYWluXG4gIHwgdHlwZW9mIG1haW5cbiAgfCB0eXBlb2YgYWZ0ZXJNYWluXG4gIHwgdHlwZW9mIGJlZm9yZVdyaXRlXG4gIHwgdHlwZW9mIHdyaXRlXG4gIHwgdHlwZW9mIGFmdGVyV3JpdGU7XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBNb2RpZmllciB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IG1vZGlmaWVyUGhhc2VzIH0gZnJvbSAnLi4vZW51bXMnO1xuXG4vLyBzb3VyY2U6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ5ODc1MjU1XG5mdW5jdGlvbiBvcmRlcihtb2RpZmllcnMpIHtcbiAgY29uc3QgbWFwID0gbmV3IE1hcCgpO1xuICBjb25zdCB2aXNpdGVkID0gbmV3IFNldCgpO1xuICBjb25zdCByZXN1bHQgPSBbXTtcblxuICBtb2RpZmllcnMuZm9yRWFjaChtb2RpZmllciA9PiB7XG4gICAgbWFwLnNldChtb2RpZmllci5uYW1lLCBtb2RpZmllcik7XG4gIH0pO1xuXG4gIC8vIE9uIHZpc2l0aW5nIG9iamVjdCwgY2hlY2sgZm9yIGl0cyBkZXBlbmRlbmNpZXMgYW5kIHZpc2l0IHRoZW0gcmVjdXJzaXZlbHlcbiAgZnVuY3Rpb24gc29ydChtb2RpZmllcjogTW9kaWZpZXI8YW55LCBhbnk+KSB7XG4gICAgdmlzaXRlZC5hZGQobW9kaWZpZXIubmFtZSk7XG5cbiAgICBjb25zdCByZXF1aXJlcyA9IFtcbiAgICAgIC4uLihtb2RpZmllci5yZXF1aXJlcyB8fCBbXSksXG4gICAgICAuLi4obW9kaWZpZXIucmVxdWlyZXNJZkV4aXN0cyB8fCBbXSksXG4gICAgXTtcblxuICAgIHJlcXVpcmVzLmZvckVhY2goZGVwID0+IHtcbiAgICAgIGlmICghdmlzaXRlZC5oYXMoZGVwKSkge1xuICAgICAgICBjb25zdCBkZXBNb2RpZmllciA9IG1hcC5nZXQoZGVwKTtcblxuICAgICAgICBpZiAoZGVwTW9kaWZpZXIpIHtcbiAgICAgICAgICBzb3J0KGRlcE1vZGlmaWVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmVzdWx0LnB1c2gobW9kaWZpZXIpO1xuICB9XG5cbiAgbW9kaWZpZXJzLmZvckVhY2gobW9kaWZpZXIgPT4ge1xuICAgIGlmICghdmlzaXRlZC5oYXMobW9kaWZpZXIubmFtZSkpIHtcbiAgICAgIC8vIGNoZWNrIGZvciB2aXNpdGVkIG9iamVjdFxuICAgICAgc29ydChtb2RpZmllcik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBvcmRlck1vZGlmaWVycyhcbiAgbW9kaWZpZXJzOiBBcnJheTxNb2RpZmllcjxhbnksIGFueT4+XG4pOiBBcnJheTxNb2RpZmllcjxhbnksIGFueT4+IHtcbiAgLy8gb3JkZXIgYmFzZWQgb24gZGVwZW5kZW5jaWVzXG4gIGNvbnN0IG9yZGVyZWRNb2RpZmllcnMgPSBvcmRlcihtb2RpZmllcnMpO1xuXG4gIC8vIG9yZGVyIGJhc2VkIG9uIHBoYXNlXG4gIHJldHVybiBtb2RpZmllclBoYXNlcy5yZWR1Y2UoKGFjYywgcGhhc2UpID0+IHtcbiAgICByZXR1cm4gYWNjLmNvbmNhdChcbiAgICAgIG9yZGVyZWRNb2RpZmllcnMuZmlsdGVyKG1vZGlmaWVyID0+IG1vZGlmaWVyLnBoYXNlID09PSBwaGFzZSlcbiAgICApO1xuICB9LCBbXSk7XG59XG4iLCIvLyBAZmxvd1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZWJvdW5jZTxUPihmbjogRnVuY3Rpb24pOiAoKSA9PiBQcm9taXNlPFQ+IHtcbiAgbGV0IHBlbmRpbmc7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICBwZW5kaW5nID0gbmV3IFByb21pc2U8VD4ocmVzb2x2ZSA9PiB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHBlbmRpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgcmVzb2x2ZShmbigpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGVuZGluZztcbiAgfTtcbn1cbiIsIi8vIEBmbG93XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZvcm1hdChzdHI6IHN0cmluZywgLi4uYXJnczogQXJyYXk8c3RyaW5nPikge1xuICByZXR1cm4gWy4uLmFyZ3NdLnJlZHVjZSgocCwgYykgPT4gcC5yZXBsYWNlKC8lcy8sIGMpLCBzdHIpO1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCBmb3JtYXQgZnJvbSAnLi9mb3JtYXQnO1xuaW1wb3J0IHsgbW9kaWZpZXJQaGFzZXMgfSBmcm9tICcuLi9lbnVtcyc7XG5cbmNvbnN0IElOVkFMSURfTU9ESUZJRVJfRVJST1IgPVxuICAnUG9wcGVyOiBtb2RpZmllciBcIiVzXCIgcHJvdmlkZWQgYW4gaW52YWxpZCAlcyBwcm9wZXJ0eSwgZXhwZWN0ZWQgJXMgYnV0IGdvdCAlcyc7XG5jb25zdCBNSVNTSU5HX0RFUEVOREVOQ1lfRVJST1IgPVxuICAnUG9wcGVyOiBtb2RpZmllciBcIiVzXCIgcmVxdWlyZXMgXCIlc1wiLCBidXQgXCIlc1wiIG1vZGlmaWVyIGlzIG5vdCBhdmFpbGFibGUnO1xuY29uc3QgVkFMSURfUFJPUEVSVElFUyA9IFtcbiAgJ25hbWUnLFxuICAnZW5hYmxlZCcsXG4gICdwaGFzZScsXG4gICdmbicsXG4gICdlZmZlY3QnLFxuICAncmVxdWlyZXMnLFxuICAnb3B0aW9ucycsXG5dO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB2YWxpZGF0ZU1vZGlmaWVycyhtb2RpZmllcnM6IEFycmF5PGFueT4pOiB2b2lkIHtcbiAgbW9kaWZpZXJzLmZvckVhY2goKG1vZGlmaWVyKSA9PiB7XG4gICAgWy4uLk9iamVjdC5rZXlzKG1vZGlmaWVyKSwgLi4uVkFMSURfUFJPUEVSVElFU11cbiAgICAgIC8vIElFMTEtY29tcGF0aWJsZSByZXBsYWNlbWVudCBmb3IgYG5ldyBTZXQoaXRlcmFibGUpYFxuICAgICAgLmZpbHRlcigodmFsdWUsIGluZGV4LCBzZWxmKSA9PiBzZWxmLmluZGV4T2YodmFsdWUpID09PSBpbmRleClcbiAgICAgIC5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICBjYXNlICduYW1lJzpcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbW9kaWZpZXIubmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBmb3JtYXQoXG4gICAgICAgICAgICAgICAgICBJTlZBTElEX01PRElGSUVSX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgU3RyaW5nKG1vZGlmaWVyLm5hbWUpLFxuICAgICAgICAgICAgICAgICAgJ1wibmFtZVwiJyxcbiAgICAgICAgICAgICAgICAgICdcInN0cmluZ1wiJyxcbiAgICAgICAgICAgICAgICAgIGBcIiR7U3RyaW5nKG1vZGlmaWVyLm5hbWUpfVwiYFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2VuYWJsZWQnOlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtb2RpZmllci5lbmFibGVkICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBmb3JtYXQoXG4gICAgICAgICAgICAgICAgICBJTlZBTElEX01PRElGSUVSX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgbW9kaWZpZXIubmFtZSxcbiAgICAgICAgICAgICAgICAgICdcImVuYWJsZWRcIicsXG4gICAgICAgICAgICAgICAgICAnXCJib29sZWFuXCInLFxuICAgICAgICAgICAgICAgICAgYFwiJHtTdHJpbmcobW9kaWZpZXIuZW5hYmxlZCl9XCJgXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAncGhhc2UnOlxuICAgICAgICAgICAgaWYgKG1vZGlmaWVyUGhhc2VzLmluZGV4T2YobW9kaWZpZXIucGhhc2UpIDwgMCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIGZvcm1hdChcbiAgICAgICAgICAgICAgICAgIElOVkFMSURfTU9ESUZJRVJfRVJST1IsXG4gICAgICAgICAgICAgICAgICBtb2RpZmllci5uYW1lLFxuICAgICAgICAgICAgICAgICAgJ1wicGhhc2VcIicsXG4gICAgICAgICAgICAgICAgICBgZWl0aGVyICR7bW9kaWZpZXJQaGFzZXMuam9pbignLCAnKX1gLFxuICAgICAgICAgICAgICAgICAgYFwiJHtTdHJpbmcobW9kaWZpZXIucGhhc2UpfVwiYFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2ZuJzpcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbW9kaWZpZXIuZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBmb3JtYXQoXG4gICAgICAgICAgICAgICAgICBJTlZBTElEX01PRElGSUVSX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgbW9kaWZpZXIubmFtZSxcbiAgICAgICAgICAgICAgICAgICdcImZuXCInLFxuICAgICAgICAgICAgICAgICAgJ1wiZnVuY3Rpb25cIicsXG4gICAgICAgICAgICAgICAgICBgXCIke1N0cmluZyhtb2RpZmllci5mbil9XCJgXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZWZmZWN0JzpcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgbW9kaWZpZXIuZWZmZWN0ICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIG1vZGlmaWVyLmVmZmVjdCAhPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgZm9ybWF0KFxuICAgICAgICAgICAgICAgICAgSU5WQUxJRF9NT0RJRklFUl9FUlJPUixcbiAgICAgICAgICAgICAgICAgIG1vZGlmaWVyLm5hbWUsXG4gICAgICAgICAgICAgICAgICAnXCJlZmZlY3RcIicsXG4gICAgICAgICAgICAgICAgICAnXCJmdW5jdGlvblwiJyxcbiAgICAgICAgICAgICAgICAgIGBcIiR7U3RyaW5nKG1vZGlmaWVyLmZuKX1cImBcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdyZXF1aXJlcyc6XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIG1vZGlmaWVyLnJlcXVpcmVzICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkobW9kaWZpZXIucmVxdWlyZXMpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBmb3JtYXQoXG4gICAgICAgICAgICAgICAgICBJTlZBTElEX01PRElGSUVSX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgbW9kaWZpZXIubmFtZSxcbiAgICAgICAgICAgICAgICAgICdcInJlcXVpcmVzXCInLFxuICAgICAgICAgICAgICAgICAgJ1wiYXJyYXlcIicsXG4gICAgICAgICAgICAgICAgICBgXCIke1N0cmluZyhtb2RpZmllci5yZXF1aXJlcyl9XCJgXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAncmVxdWlyZXNJZkV4aXN0cyc6XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobW9kaWZpZXIucmVxdWlyZXNJZkV4aXN0cykpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBmb3JtYXQoXG4gICAgICAgICAgICAgICAgICBJTlZBTElEX01PRElGSUVSX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgbW9kaWZpZXIubmFtZSxcbiAgICAgICAgICAgICAgICAgICdcInJlcXVpcmVzSWZFeGlzdHNcIicsXG4gICAgICAgICAgICAgICAgICAnXCJhcnJheVwiJyxcbiAgICAgICAgICAgICAgICAgIGBcIiR7U3RyaW5nKG1vZGlmaWVyLnJlcXVpcmVzSWZFeGlzdHMpfVwiYFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ29wdGlvbnMnOlxuICAgICAgICAgIGNhc2UgJ2RhdGEnOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIGBQb3BwZXJKUzogYW4gaW52YWxpZCBwcm9wZXJ0eSBoYXMgYmVlbiBwcm92aWRlZCB0byB0aGUgXCIke1xuICAgICAgICAgICAgICAgIG1vZGlmaWVyLm5hbWVcbiAgICAgICAgICAgICAgfVwiIG1vZGlmaWVyLCB2YWxpZCBwcm9wZXJ0aWVzIGFyZSAke1ZBTElEX1BST1BFUlRJRVMubWFwKFxuICAgICAgICAgICAgICAgIChzKSA9PiBgXCIke3N9XCJgXG4gICAgICAgICAgICAgICkuam9pbignLCAnKX07IGJ1dCBcIiR7a2V5fVwiIHdhcyBwcm92aWRlZC5gXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgbW9kaWZpZXIucmVxdWlyZXMgJiZcbiAgICAgICAgICBtb2RpZmllci5yZXF1aXJlcy5mb3JFYWNoKChyZXF1aXJlbWVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKG1vZGlmaWVycy5maW5kKChtb2QpID0+IG1vZC5uYW1lID09PSByZXF1aXJlbWVudCkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIGZvcm1hdChcbiAgICAgICAgICAgICAgICAgIE1JU1NJTkdfREVQRU5ERU5DWV9FUlJPUixcbiAgICAgICAgICAgICAgICAgIFN0cmluZyhtb2RpZmllci5uYW1lKSxcbiAgICAgICAgICAgICAgICAgIHJlcXVpcmVtZW50LFxuICAgICAgICAgICAgICAgICAgcmVxdWlyZW1lbnRcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgfSk7XG59XG4iLCIvLyBAZmxvd1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1bmlxdWVCeTxUPihhcnI6IEFycmF5PFQ+LCBmbjogVCA9PiBhbnkpOiBBcnJheTxUPiB7XG4gIGNvbnN0IGlkZW50aWZpZXJzID0gbmV3IFNldCgpO1xuXG4gIHJldHVybiBhcnIuZmlsdGVyKGl0ZW0gPT4ge1xuICAgIGNvbnN0IGlkZW50aWZpZXIgPSBmbihpdGVtKTtcblxuICAgIGlmICghaWRlbnRpZmllcnMuaGFzKGlkZW50aWZpZXIpKSB7XG4gICAgICBpZGVudGlmaWVycy5hZGQoaWRlbnRpZmllcik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCB7IHR5cGUgQmFzZVBsYWNlbWVudCwgdHlwZSBQbGFjZW1lbnQsIGF1dG8gfSBmcm9tICcuLi9lbnVtcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEJhc2VQbGFjZW1lbnQoXG4gIHBsYWNlbWVudDogUGxhY2VtZW50IHwgdHlwZW9mIGF1dG9cbik6IEJhc2VQbGFjZW1lbnQge1xuICByZXR1cm4gKHBsYWNlbWVudC5zcGxpdCgnLScpWzBdOiBhbnkpO1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCB0eXBlIHsgTW9kaWZpZXIgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlQnlOYW1lKFxuICBtb2RpZmllcnM6IEFycmF5PCRTaGFwZTxNb2RpZmllcjxhbnksIGFueT4+PlxuKTogQXJyYXk8JFNoYXBlPE1vZGlmaWVyPGFueSwgYW55Pj4+IHtcbiAgY29uc3QgbWVyZ2VkID0gbW9kaWZpZXJzLnJlZHVjZSgobWVyZ2VkLCBjdXJyZW50KSA9PiB7XG4gICAgY29uc3QgZXhpc3RpbmcgPSBtZXJnZWRbY3VycmVudC5uYW1lXTtcbiAgICBtZXJnZWRbY3VycmVudC5uYW1lXSA9IGV4aXN0aW5nXG4gICAgICA/IHtcbiAgICAgICAgICAuLi5leGlzdGluZyxcbiAgICAgICAgICAuLi5jdXJyZW50LFxuICAgICAgICAgIG9wdGlvbnM6IHsgLi4uZXhpc3Rpbmcub3B0aW9ucywgLi4uY3VycmVudC5vcHRpb25zIH0sXG4gICAgICAgICAgZGF0YTogeyAuLi5leGlzdGluZy5kYXRhLCAuLi5jdXJyZW50LmRhdGEgfSxcbiAgICAgICAgfVxuICAgICAgOiBjdXJyZW50O1xuICAgIHJldHVybiBtZXJnZWQ7XG4gIH0sIHt9KTtcblxuICAvLyBJRTExIGRvZXMgbm90IHN1cHBvcnQgT2JqZWN0LnZhbHVlc1xuICByZXR1cm4gT2JqZWN0LmtleXMobWVyZ2VkKS5tYXAoa2V5ID0+IG1lcmdlZFtrZXldKTtcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gJy4vZ2V0V2luZG93JztcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSAnLi9nZXREb2N1bWVudEVsZW1lbnQnO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbEJhclggZnJvbSAnLi9nZXRXaW5kb3dTY3JvbGxCYXJYJztcbmltcG9ydCBpc0xheW91dFZpZXdwb3J0IGZyb20gJy4vaXNMYXlvdXRWaWV3cG9ydCc7XG5pbXBvcnQgdHlwZSB7IFBvc2l0aW9uaW5nU3RyYXRlZ3kgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFZpZXdwb3J0UmVjdChcbiAgZWxlbWVudDogRWxlbWVudCxcbiAgc3RyYXRlZ3k6IFBvc2l0aW9uaW5nU3RyYXRlZ3lcbikge1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIGNvbnN0IGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIGNvbnN0IHZpc3VhbFZpZXdwb3J0ID0gd2luLnZpc3VhbFZpZXdwb3J0O1xuXG4gIGxldCB3aWR0aCA9IGh0bWwuY2xpZW50V2lkdGg7XG4gIGxldCBoZWlnaHQgPSBodG1sLmNsaWVudEhlaWdodDtcbiAgbGV0IHggPSAwO1xuICBsZXQgeSA9IDA7XG5cbiAgaWYgKHZpc3VhbFZpZXdwb3J0KSB7XG4gICAgd2lkdGggPSB2aXN1YWxWaWV3cG9ydC53aWR0aDtcbiAgICBoZWlnaHQgPSB2aXN1YWxWaWV3cG9ydC5oZWlnaHQ7XG5cbiAgICBjb25zdCBsYXlvdXRWaWV3cG9ydCA9IGlzTGF5b3V0Vmlld3BvcnQoKTtcblxuICAgIGlmIChsYXlvdXRWaWV3cG9ydCB8fCAoIWxheW91dFZpZXdwb3J0ICYmIHN0cmF0ZWd5ID09PSAnZml4ZWQnKSkge1xuICAgICAgeCA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQ7XG4gICAgICB5ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHg6IHggKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpLFxuICAgIHksXG4gIH07XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBSZWN0IH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tICcuL2dldERvY3VtZW50RWxlbWVudCc7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tICcuL2dldENvbXB1dGVkU3R5bGUnO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbEJhclggZnJvbSAnLi9nZXRXaW5kb3dTY3JvbGxCYXJYJztcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGwgZnJvbSAnLi9nZXRXaW5kb3dTY3JvbGwnO1xuaW1wb3J0IHsgbWF4IH0gZnJvbSAnLi4vdXRpbHMvbWF0aCc7XG5cbi8vIEdldHMgdGhlIGVudGlyZSBzaXplIG9mIHRoZSBzY3JvbGxhYmxlIGRvY3VtZW50IGFyZWEsIGV2ZW4gZXh0ZW5kaW5nIG91dHNpZGVcbi8vIG9mIHRoZSBgPGh0bWw+YCBhbmQgYDxib2R5PmAgcmVjdCBib3VuZHMgaWYgaG9yaXpvbnRhbGx5IHNjcm9sbGFibGVcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldERvY3VtZW50UmVjdChlbGVtZW50OiBIVE1MRWxlbWVudCk6IFJlY3Qge1xuICBjb25zdCBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICBjb25zdCB3aW5TY3JvbGwgPSBnZXRXaW5kb3dTY3JvbGwoZWxlbWVudCk7XG4gIGNvbnN0IGJvZHkgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQ/LmJvZHk7XG5cbiAgY29uc3Qgd2lkdGggPSBtYXgoXG4gICAgaHRtbC5zY3JvbGxXaWR0aCxcbiAgICBodG1sLmNsaWVudFdpZHRoLFxuICAgIGJvZHkgPyBib2R5LnNjcm9sbFdpZHRoIDogMCxcbiAgICBib2R5ID8gYm9keS5jbGllbnRXaWR0aCA6IDBcbiAgKTtcbiAgY29uc3QgaGVpZ2h0ID0gbWF4KFxuICAgIGh0bWwuc2Nyb2xsSGVpZ2h0LFxuICAgIGh0bWwuY2xpZW50SGVpZ2h0LFxuICAgIGJvZHkgPyBib2R5LnNjcm9sbEhlaWdodCA6IDAsXG4gICAgYm9keSA/IGJvZHkuY2xpZW50SGVpZ2h0IDogMFxuICApO1xuXG4gIGxldCB4ID0gLXdpblNjcm9sbC5zY3JvbGxMZWZ0ICsgZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KTtcbiAgY29uc3QgeSA9IC13aW5TY3JvbGwuc2Nyb2xsVG9wO1xuXG4gIGlmIChnZXRDb21wdXRlZFN0eWxlKGJvZHkgfHwgaHRtbCkuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgIHggKz0gbWF4KGh0bWwuY2xpZW50V2lkdGgsIGJvZHkgPyBib2R5LmNsaWVudFdpZHRoIDogMCkgLSB3aWR0aDtcbiAgfVxuXG4gIHJldHVybiB7IHdpZHRoLCBoZWlnaHQsIHgsIHkgfTtcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgeyBpc1NoYWRvd1Jvb3QgfSBmcm9tICcuL2luc3RhbmNlT2YnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb250YWlucyhwYXJlbnQ6IEVsZW1lbnQsIGNoaWxkOiBFbGVtZW50KSB7XG4gIGNvbnN0IHJvb3ROb2RlID0gY2hpbGQuZ2V0Um9vdE5vZGUgJiYgY2hpbGQuZ2V0Um9vdE5vZGUoKTtcblxuICAvLyBGaXJzdCwgYXR0ZW1wdCB3aXRoIGZhc3RlciBuYXRpdmUgbWV0aG9kXG4gIGlmIChwYXJlbnQuY29udGFpbnMoY2hpbGQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gdGhlbiBmYWxsYmFjayB0byBjdXN0b20gaW1wbGVtZW50YXRpb24gd2l0aCBTaGFkb3cgRE9NIHN1cHBvcnRcbiAgZWxzZSBpZiAocm9vdE5vZGUgJiYgaXNTaGFkb3dSb290KHJvb3ROb2RlKSkge1xuICAgIGxldCBuZXh0ID0gY2hpbGQ7XG4gICAgZG8ge1xuICAgICAgaWYgKG5leHQgJiYgcGFyZW50LmlzU2FtZU5vZGUobmV4dCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ106IG5lZWQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzLi4uXG4gICAgICBuZXh0ID0gbmV4dC5wYXJlbnROb2RlIHx8IG5leHQuaG9zdDtcbiAgICB9IHdoaWxlIChuZXh0KTtcbiAgfVxuXG4gIC8vIEdpdmUgdXAsIHRoZSByZXN1bHQgaXMgZmFsc2VcbiAgcmV0dXJuIGZhbHNlO1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCB0eXBlIHsgUmVjdCwgQ2xpZW50UmVjdE9iamVjdCB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVjdFRvQ2xpZW50UmVjdChyZWN0OiBSZWN0KTogQ2xpZW50UmVjdE9iamVjdCB7XG4gIHJldHVybiB7XG4gICAgLi4ucmVjdCxcbiAgICBsZWZ0OiByZWN0LngsXG4gICAgdG9wOiByZWN0LnksXG4gICAgcmlnaHQ6IHJlY3QueCArIHJlY3Qud2lkdGgsXG4gICAgYm90dG9tOiByZWN0LnkgKyByZWN0LmhlaWdodCxcbiAgfTtcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgdHlwZSB7IENsaWVudFJlY3RPYmplY3QsIFBvc2l0aW9uaW5nU3RyYXRlZ3kgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgdHlwZSB7IEJvdW5kYXJ5LCBSb290Qm91bmRhcnkgfSBmcm9tICcuLi9lbnVtcyc7XG5pbXBvcnQgeyB2aWV3cG9ydCB9IGZyb20gJy4uL2VudW1zJztcbmltcG9ydCBnZXRWaWV3cG9ydFJlY3QgZnJvbSAnLi9nZXRWaWV3cG9ydFJlY3QnO1xuaW1wb3J0IGdldERvY3VtZW50UmVjdCBmcm9tICcuL2dldERvY3VtZW50UmVjdCc7XG5pbXBvcnQgbGlzdFNjcm9sbFBhcmVudHMgZnJvbSAnLi9saXN0U2Nyb2xsUGFyZW50cyc7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gJy4vZ2V0T2Zmc2V0UGFyZW50JztcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSAnLi9nZXREb2N1bWVudEVsZW1lbnQnO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSAnLi9nZXRDb21wdXRlZFN0eWxlJztcbmltcG9ydCB7IGlzRWxlbWVudCwgaXNIVE1MRWxlbWVudCB9IGZyb20gJy4vaW5zdGFuY2VPZic7XG5pbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gJy4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0JztcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gJy4vZ2V0UGFyZW50Tm9kZSc7XG5pbXBvcnQgY29udGFpbnMgZnJvbSAnLi9jb250YWlucyc7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSAnLi9nZXROb2RlTmFtZSc7XG5pbXBvcnQgcmVjdFRvQ2xpZW50UmVjdCBmcm9tICcuLi91dGlscy9yZWN0VG9DbGllbnRSZWN0JztcbmltcG9ydCB7IG1heCwgbWluIH0gZnJvbSAnLi4vdXRpbHMvbWF0aCc7XG5cbmZ1bmN0aW9uIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KFxuICBlbGVtZW50OiBFbGVtZW50LFxuICBzdHJhdGVneTogUG9zaXRpb25pbmdTdHJhdGVneVxuKSB7XG4gIGNvbnN0IHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgZmFsc2UsIHN0cmF0ZWd5ID09PSAnZml4ZWQnKTtcblxuICByZWN0LnRvcCA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRUb3A7XG4gIHJlY3QubGVmdCA9IHJlY3QubGVmdCArIGVsZW1lbnQuY2xpZW50TGVmdDtcbiAgcmVjdC5ib3R0b20gPSByZWN0LnRvcCArIGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICByZWN0LnJpZ2h0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgcmVjdC53aWR0aCA9IGVsZW1lbnQuY2xpZW50V2lkdGg7XG4gIHJlY3QuaGVpZ2h0ID0gZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIHJlY3QueCA9IHJlY3QubGVmdDtcbiAgcmVjdC55ID0gcmVjdC50b3A7XG5cbiAgcmV0dXJuIHJlY3Q7XG59XG5cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKFxuICBlbGVtZW50OiBFbGVtZW50LFxuICBjbGlwcGluZ1BhcmVudDogRWxlbWVudCB8IFJvb3RCb3VuZGFyeSxcbiAgc3RyYXRlZ3k6IFBvc2l0aW9uaW5nU3RyYXRlZ3lcbik6IENsaWVudFJlY3RPYmplY3Qge1xuICByZXR1cm4gY2xpcHBpbmdQYXJlbnQgPT09IHZpZXdwb3J0XG4gICAgPyByZWN0VG9DbGllbnRSZWN0KGdldFZpZXdwb3J0UmVjdChlbGVtZW50LCBzdHJhdGVneSkpXG4gICAgOiBpc0VsZW1lbnQoY2xpcHBpbmdQYXJlbnQpXG4gICAgPyBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpXG4gICAgOiByZWN0VG9DbGllbnRSZWN0KGdldERvY3VtZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpKTtcbn1cblxuLy8gQSBcImNsaXBwaW5nIHBhcmVudFwiIGlzIGFuIG92ZXJmbG93YWJsZSBjb250YWluZXIgd2l0aCB0aGUgY2hhcmFjdGVyaXN0aWMgb2Zcbi8vIGNsaXBwaW5nIChvciBoaWRpbmcpIG92ZXJmbG93aW5nIGVsZW1lbnRzIHdpdGggYSBwb3NpdGlvbiBkaWZmZXJlbnQgZnJvbVxuLy8gYGluaXRpYWxgXG5mdW5jdGlvbiBnZXRDbGlwcGluZ1BhcmVudHMoZWxlbWVudDogRWxlbWVudCk6IEFycmF5PEVsZW1lbnQ+IHtcbiAgY29uc3QgY2xpcHBpbmdQYXJlbnRzID0gbGlzdFNjcm9sbFBhcmVudHMoZ2V0UGFyZW50Tm9kZShlbGVtZW50KSk7XG4gIGNvbnN0IGNhbkVzY2FwZUNsaXBwaW5nID1cbiAgICBbJ2Fic29sdXRlJywgJ2ZpeGVkJ10uaW5kZXhPZihnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uKSA+PSAwO1xuICBjb25zdCBjbGlwcGVyRWxlbWVudCA9XG4gICAgY2FuRXNjYXBlQ2xpcHBpbmcgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KVxuICAgICAgPyBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudClcbiAgICAgIDogZWxlbWVudDtcblxuICBpZiAoIWlzRWxlbWVudChjbGlwcGVyRWxlbWVudCkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMTQxNFxuICByZXR1cm4gY2xpcHBpbmdQYXJlbnRzLmZpbHRlcihcbiAgICAoY2xpcHBpbmdQYXJlbnQpID0+XG4gICAgICBpc0VsZW1lbnQoY2xpcHBpbmdQYXJlbnQpICYmXG4gICAgICBjb250YWlucyhjbGlwcGluZ1BhcmVudCwgY2xpcHBlckVsZW1lbnQpICYmXG4gICAgICBnZXROb2RlTmFtZShjbGlwcGluZ1BhcmVudCkgIT09ICdib2R5J1xuICApO1xufVxuXG4vLyBHZXRzIHRoZSBtYXhpbXVtIGFyZWEgdGhhdCB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIGluIGR1ZSB0byBhbnkgbnVtYmVyIG9mXG4vLyBjbGlwcGluZyBwYXJlbnRzXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRDbGlwcGluZ1JlY3QoXG4gIGVsZW1lbnQ6IEVsZW1lbnQsXG4gIGJvdW5kYXJ5OiBCb3VuZGFyeSxcbiAgcm9vdEJvdW5kYXJ5OiBSb290Qm91bmRhcnksXG4gIHN0cmF0ZWd5OiBQb3NpdGlvbmluZ1N0cmF0ZWd5XG4pOiBDbGllbnRSZWN0T2JqZWN0IHtcbiAgY29uc3QgbWFpbkNsaXBwaW5nUGFyZW50cyA9XG4gICAgYm91bmRhcnkgPT09ICdjbGlwcGluZ1BhcmVudHMnXG4gICAgICA/IGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KVxuICAgICAgOiBbXS5jb25jYXQoYm91bmRhcnkpO1xuICBjb25zdCBjbGlwcGluZ1BhcmVudHMgPSBbLi4ubWFpbkNsaXBwaW5nUGFyZW50cywgcm9vdEJvdW5kYXJ5XTtcbiAgY29uc3QgZmlyc3RDbGlwcGluZ1BhcmVudCA9IGNsaXBwaW5nUGFyZW50c1swXTtcblxuICBjb25zdCBjbGlwcGluZ1JlY3QgPSBjbGlwcGluZ1BhcmVudHMucmVkdWNlKChhY2NSZWN0LCBjbGlwcGluZ1BhcmVudCkgPT4ge1xuICAgIGNvbnN0IHJlY3QgPSBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpO1xuXG4gICAgYWNjUmVjdC50b3AgPSBtYXgocmVjdC50b3AsIGFjY1JlY3QudG9wKTtcbiAgICBhY2NSZWN0LnJpZ2h0ID0gbWluKHJlY3QucmlnaHQsIGFjY1JlY3QucmlnaHQpO1xuICAgIGFjY1JlY3QuYm90dG9tID0gbWluKHJlY3QuYm90dG9tLCBhY2NSZWN0LmJvdHRvbSk7XG4gICAgYWNjUmVjdC5sZWZ0ID0gbWF4KHJlY3QubGVmdCwgYWNjUmVjdC5sZWZ0KTtcblxuICAgIHJldHVybiBhY2NSZWN0O1xuICB9LCBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBmaXJzdENsaXBwaW5nUGFyZW50LCBzdHJhdGVneSkpO1xuXG4gIGNsaXBwaW5nUmVjdC53aWR0aCA9IGNsaXBwaW5nUmVjdC5yaWdodCAtIGNsaXBwaW5nUmVjdC5sZWZ0O1xuICBjbGlwcGluZ1JlY3QuaGVpZ2h0ID0gY2xpcHBpbmdSZWN0LmJvdHRvbSAtIGNsaXBwaW5nUmVjdC50b3A7XG4gIGNsaXBwaW5nUmVjdC54ID0gY2xpcHBpbmdSZWN0LmxlZnQ7XG4gIGNsaXBwaW5nUmVjdC55ID0gY2xpcHBpbmdSZWN0LnRvcDtcblxuICByZXR1cm4gY2xpcHBpbmdSZWN0O1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCB7IHR5cGUgVmFyaWF0aW9uLCB0eXBlIFBsYWNlbWVudCB9IGZyb20gJy4uL2VudW1zJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudDogUGxhY2VtZW50KTogP1ZhcmlhdGlvbiB7XG4gIHJldHVybiAocGxhY2VtZW50LnNwbGl0KCctJylbMV06IGFueSk7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBQbGFjZW1lbnQgfSBmcm9tICcuLi9lbnVtcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChcbiAgcGxhY2VtZW50OiBQbGFjZW1lbnRcbik6ICd4JyB8ICd5JyB7XG4gIHJldHVybiBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHBsYWNlbWVudCkgPj0gMCA/ICd4JyA6ICd5Jztcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tICcuL2dldEJhc2VQbGFjZW1lbnQnO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tICcuL2dldFZhcmlhdGlvbic7XG5pbXBvcnQgZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50IGZyb20gJy4vZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50JztcbmltcG9ydCB0eXBlIHtcbiAgUmVjdCxcbiAgUG9zaXRpb25pbmdTdHJhdGVneSxcbiAgT2Zmc2V0cyxcbiAgQ2xpZW50UmVjdE9iamVjdCxcbn0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LCBzdGFydCwgZW5kLCB0eXBlIFBsYWNlbWVudCB9IGZyb20gJy4uL2VudW1zJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcHV0ZU9mZnNldHMoe1xuICByZWZlcmVuY2UsXG4gIGVsZW1lbnQsXG4gIHBsYWNlbWVudCxcbn06IHtcbiAgcmVmZXJlbmNlOiBSZWN0IHwgQ2xpZW50UmVjdE9iamVjdCxcbiAgZWxlbWVudDogUmVjdCB8IENsaWVudFJlY3RPYmplY3QsXG4gIHN0cmF0ZWd5OiBQb3NpdGlvbmluZ1N0cmF0ZWd5LFxuICBwbGFjZW1lbnQ/OiBQbGFjZW1lbnQsXG59KTogT2Zmc2V0cyB7XG4gIGNvbnN0IGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQgPyBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgOiBudWxsO1xuICBjb25zdCB2YXJpYXRpb24gPSBwbGFjZW1lbnQgPyBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA6IG51bGw7XG4gIGNvbnN0IGNvbW1vblggPSByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCAvIDIgLSBlbGVtZW50LndpZHRoIC8gMjtcbiAgY29uc3QgY29tbW9uWSA9IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodCAvIDIgLSBlbGVtZW50LmhlaWdodCAvIDI7XG5cbiAgbGV0IG9mZnNldHM7XG4gIHN3aXRjaCAoYmFzZVBsYWNlbWVudCkge1xuICAgIGNhc2UgdG9wOlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgLSBlbGVtZW50LmhlaWdodCxcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlIGJvdHRvbTpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodCxcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlIHJpZ2h0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vblksXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBsZWZ0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggLSBlbGVtZW50LndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZLFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnksXG4gICAgICB9O1xuICB9XG5cbiAgY29uc3QgbWFpbkF4aXMgPSBiYXNlUGxhY2VtZW50XG4gICAgPyBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudClcbiAgICA6IG51bGw7XG5cbiAgaWYgKG1haW5BeGlzICE9IG51bGwpIHtcbiAgICBjb25zdCBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gICAgc3dpdGNoICh2YXJpYXRpb24pIHtcbiAgICAgIGNhc2Ugc3RhcnQ6XG4gICAgICAgIG9mZnNldHNbbWFpbkF4aXNdID1cbiAgICAgICAgICBvZmZzZXRzW21haW5BeGlzXSAtIChyZWZlcmVuY2VbbGVuXSAvIDIgLSBlbGVtZW50W2xlbl0gLyAyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGVuZDpcbiAgICAgICAgb2Zmc2V0c1ttYWluQXhpc10gPVxuICAgICAgICAgIG9mZnNldHNbbWFpbkF4aXNdICsgKHJlZmVyZW5jZVtsZW5dIC8gMiAtIGVsZW1lbnRbbGVuXSAvIDIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9mZnNldHM7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBTaWRlT2JqZWN0IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRGcmVzaFNpZGVPYmplY3QoKTogU2lkZU9iamVjdCB7XG4gIHJldHVybiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwLFxuICB9O1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCB0eXBlIHsgU2lkZU9iamVjdCB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCBnZXRGcmVzaFNpZGVPYmplY3QgZnJvbSAnLi9nZXRGcmVzaFNpZGVPYmplY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZXJnZVBhZGRpbmdPYmplY3QoXG4gIHBhZGRpbmdPYmplY3Q6ICRTaGFwZTxTaWRlT2JqZWN0PlxuKTogU2lkZU9iamVjdCB7XG4gIHJldHVybiB7XG4gICAgLi4uZ2V0RnJlc2hTaWRlT2JqZWN0KCksXG4gICAgLi4ucGFkZGluZ09iamVjdCxcbiAgfTtcbn1cbiIsIi8vIEBmbG93XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGV4cGFuZFRvSGFzaE1hcDxcbiAgVDogbnVtYmVyIHwgc3RyaW5nIHwgYm9vbGVhbixcbiAgSzogc3RyaW5nXG4+KHZhbHVlOiBULCBrZXlzOiBBcnJheTxLPik6IHsgW2tleTogc3RyaW5nXTogVCB9IHtcbiAgcmV0dXJuIGtleXMucmVkdWNlKChoYXNoTWFwLCBrZXkpID0+IHtcbiAgICBoYXNoTWFwW2tleV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gaGFzaE1hcDtcbiAgfSwge30pO1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCB0eXBlIHsgU3RhdGUsIFNpZGVPYmplY3QsIFBhZGRpbmcsIFBvc2l0aW9uaW5nU3RyYXRlZ3kgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgdHlwZSB7IFBsYWNlbWVudCwgQm91bmRhcnksIFJvb3RCb3VuZGFyeSwgQ29udGV4dCB9IGZyb20gJy4uL2VudW1zJztcbmltcG9ydCBnZXRDbGlwcGluZ1JlY3QgZnJvbSAnLi4vZG9tLXV0aWxzL2dldENsaXBwaW5nUmVjdCc7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gJy4uL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQnO1xuaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tICcuLi9kb20tdXRpbHMvZ2V0Qm91bmRpbmdDbGllbnRSZWN0JztcbmltcG9ydCBjb21wdXRlT2Zmc2V0cyBmcm9tICcuL2NvbXB1dGVPZmZzZXRzJztcbmltcG9ydCByZWN0VG9DbGllbnRSZWN0IGZyb20gJy4vcmVjdFRvQ2xpZW50UmVjdCc7XG5pbXBvcnQge1xuICBjbGlwcGluZ1BhcmVudHMsXG4gIHJlZmVyZW5jZSxcbiAgcG9wcGVyLFxuICBib3R0b20sXG4gIHRvcCxcbiAgcmlnaHQsXG4gIGJhc2VQbGFjZW1lbnRzLFxuICB2aWV3cG9ydCxcbn0gZnJvbSAnLi4vZW51bXMnO1xuaW1wb3J0IHsgaXNFbGVtZW50IH0gZnJvbSAnLi4vZG9tLXV0aWxzL2luc3RhbmNlT2YnO1xuaW1wb3J0IG1lcmdlUGFkZGluZ09iamVjdCBmcm9tICcuL21lcmdlUGFkZGluZ09iamVjdCc7XG5pbXBvcnQgZXhwYW5kVG9IYXNoTWFwIGZyb20gJy4vZXhwYW5kVG9IYXNoTWFwJztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuZXhwb3J0IHR5cGUgT3B0aW9ucyA9IHtcbiAgcGxhY2VtZW50OiBQbGFjZW1lbnQsXG4gIHN0cmF0ZWd5OiBQb3NpdGlvbmluZ1N0cmF0ZWd5LFxuICBib3VuZGFyeTogQm91bmRhcnksXG4gIHJvb3RCb3VuZGFyeTogUm9vdEJvdW5kYXJ5LFxuICBlbGVtZW50Q29udGV4dDogQ29udGV4dCxcbiAgYWx0Qm91bmRhcnk6IGJvb2xlYW4sXG4gIHBhZGRpbmc6IFBhZGRpbmcsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZXRlY3RPdmVyZmxvdyhcbiAgc3RhdGU6IFN0YXRlLFxuICBvcHRpb25zOiAkU2hhcGU8T3B0aW9ucz4gPSB7fVxuKTogU2lkZU9iamVjdCB7XG4gIGNvbnN0IHtcbiAgICBwbGFjZW1lbnQgPSBzdGF0ZS5wbGFjZW1lbnQsXG4gICAgc3RyYXRlZ3kgPSBzdGF0ZS5zdHJhdGVneSxcbiAgICBib3VuZGFyeSA9IGNsaXBwaW5nUGFyZW50cyxcbiAgICByb290Qm91bmRhcnkgPSB2aWV3cG9ydCxcbiAgICBlbGVtZW50Q29udGV4dCA9IHBvcHBlcixcbiAgICBhbHRCb3VuZGFyeSA9IGZhbHNlLFxuICAgIHBhZGRpbmcgPSAwLFxuICB9ID0gb3B0aW9ucztcblxuICBjb25zdCBwYWRkaW5nT2JqZWN0ID0gbWVyZ2VQYWRkaW5nT2JqZWN0KFxuICAgIHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJ1xuICAgICAgPyBwYWRkaW5nXG4gICAgICA6IGV4cGFuZFRvSGFzaE1hcChwYWRkaW5nLCBiYXNlUGxhY2VtZW50cylcbiAgKTtcblxuICBjb25zdCBhbHRDb250ZXh0ID0gZWxlbWVudENvbnRleHQgPT09IHBvcHBlciA/IHJlZmVyZW5jZSA6IHBvcHBlcjtcblxuICBjb25zdCBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICBjb25zdCBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbYWx0Qm91bmRhcnkgPyBhbHRDb250ZXh0IDogZWxlbWVudENvbnRleHRdO1xuXG4gIGNvbnN0IGNsaXBwaW5nQ2xpZW50UmVjdCA9IGdldENsaXBwaW5nUmVjdChcbiAgICBpc0VsZW1lbnQoZWxlbWVudClcbiAgICAgID8gZWxlbWVudFxuICAgICAgOiBlbGVtZW50LmNvbnRleHRFbGVtZW50IHx8IGdldERvY3VtZW50RWxlbWVudChzdGF0ZS5lbGVtZW50cy5wb3BwZXIpLFxuICAgIGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeSxcbiAgICBzdHJhdGVneVxuICApO1xuXG4gIGNvbnN0IHJlZmVyZW5jZUNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qoc3RhdGUuZWxlbWVudHMucmVmZXJlbmNlKTtcblxuICBjb25zdCBwb3BwZXJPZmZzZXRzID0gY29tcHV0ZU9mZnNldHMoe1xuICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlQ2xpZW50UmVjdCxcbiAgICBlbGVtZW50OiBwb3BwZXJSZWN0LFxuICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxuICAgIHBsYWNlbWVudCxcbiAgfSk7XG5cbiAgY29uc3QgcG9wcGVyQ2xpZW50UmVjdCA9IHJlY3RUb0NsaWVudFJlY3Qoe1xuICAgIC4uLnBvcHBlclJlY3QsXG4gICAgLi4ucG9wcGVyT2Zmc2V0cyxcbiAgfSk7XG5cbiAgY29uc3QgZWxlbWVudENsaWVudFJlY3QgPVxuICAgIGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgPyBwb3BwZXJDbGllbnRSZWN0IDogcmVmZXJlbmNlQ2xpZW50UmVjdDtcblxuICAvLyBwb3NpdGl2ZSA9IG92ZXJmbG93aW5nIHRoZSBjbGlwcGluZyByZWN0XG4gIC8vIDAgb3IgbmVnYXRpdmUgPSB3aXRoaW4gdGhlIGNsaXBwaW5nIHJlY3RcbiAgY29uc3Qgb3ZlcmZsb3dPZmZzZXRzID0ge1xuICAgIHRvcDogY2xpcHBpbmdDbGllbnRSZWN0LnRvcCAtIGVsZW1lbnRDbGllbnRSZWN0LnRvcCArIHBhZGRpbmdPYmplY3QudG9wLFxuICAgIGJvdHRvbTpcbiAgICAgIGVsZW1lbnRDbGllbnRSZWN0LmJvdHRvbSAtXG4gICAgICBjbGlwcGluZ0NsaWVudFJlY3QuYm90dG9tICtcbiAgICAgIHBhZGRpbmdPYmplY3QuYm90dG9tLFxuICAgIGxlZnQ6IGNsaXBwaW5nQ2xpZW50UmVjdC5sZWZ0IC0gZWxlbWVudENsaWVudFJlY3QubGVmdCArIHBhZGRpbmdPYmplY3QubGVmdCxcbiAgICByaWdodDpcbiAgICAgIGVsZW1lbnRDbGllbnRSZWN0LnJpZ2h0IC0gY2xpcHBpbmdDbGllbnRSZWN0LnJpZ2h0ICsgcGFkZGluZ09iamVjdC5yaWdodCxcbiAgfTtcblxuICBjb25zdCBvZmZzZXREYXRhID0gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXQ7XG5cbiAgLy8gT2Zmc2V0cyBjYW4gYmUgYXBwbGllZCBvbmx5IHRvIHRoZSBwb3BwZXIgZWxlbWVudFxuICBpZiAoZWxlbWVudENvbnRleHQgPT09IHBvcHBlciAmJiBvZmZzZXREYXRhKSB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gb2Zmc2V0RGF0YVtwbGFjZW1lbnRdO1xuXG4gICAgT2JqZWN0LmtleXMob3ZlcmZsb3dPZmZzZXRzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNvbnN0IG11bHRpcGx5ID0gW3JpZ2h0LCBib3R0b21dLmluZGV4T2Yoa2V5KSA+PSAwID8gMSA6IC0xO1xuICAgICAgY29uc3QgYXhpcyA9IFt0b3AsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAneScgOiAneCc7XG4gICAgICBvdmVyZmxvd09mZnNldHNba2V5XSArPSBvZmZzZXRbYXhpc10gKiBtdWx0aXBseTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBvdmVyZmxvd09mZnNldHM7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUge1xuICBTdGF0ZSxcbiAgT3B0aW9uc0dlbmVyaWMsXG4gIE1vZGlmaWVyLFxuICBJbnN0YW5jZSxcbiAgVmlydHVhbEVsZW1lbnQsXG59IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IGdldENvbXBvc2l0ZVJlY3QgZnJvbSAnLi9kb20tdXRpbHMvZ2V0Q29tcG9zaXRlUmVjdCc7XG5pbXBvcnQgZ2V0TGF5b3V0UmVjdCBmcm9tICcuL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0JztcbmltcG9ydCBsaXN0U2Nyb2xsUGFyZW50cyBmcm9tICcuL2RvbS11dGlscy9saXN0U2Nyb2xsUGFyZW50cyc7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gJy4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudCc7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tICcuL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlJztcbmltcG9ydCBvcmRlck1vZGlmaWVycyBmcm9tICcuL3V0aWxzL29yZGVyTW9kaWZpZXJzJztcbmltcG9ydCBkZWJvdW5jZSBmcm9tICcuL3V0aWxzL2RlYm91bmNlJztcbmltcG9ydCB2YWxpZGF0ZU1vZGlmaWVycyBmcm9tICcuL3V0aWxzL3ZhbGlkYXRlTW9kaWZpZXJzJztcbmltcG9ydCB1bmlxdWVCeSBmcm9tICcuL3V0aWxzL3VuaXF1ZUJ5JztcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gJy4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudCc7XG5pbXBvcnQgbWVyZ2VCeU5hbWUgZnJvbSAnLi91dGlscy9tZXJnZUJ5TmFtZSc7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSAnLi91dGlscy9kZXRlY3RPdmVyZmxvdyc7XG5pbXBvcnQgeyBpc0VsZW1lbnQgfSBmcm9tICcuL2RvbS11dGlscy9pbnN0YW5jZU9mJztcbmltcG9ydCB7IGF1dG8gfSBmcm9tICcuL2VudW1zJztcblxuY29uc3QgSU5WQUxJRF9FTEVNRU5UX0VSUk9SID1cbiAgJ1BvcHBlcjogSW52YWxpZCByZWZlcmVuY2Ugb3IgcG9wcGVyIGFyZ3VtZW50IHByb3ZpZGVkLiBUaGV5IG11c3QgYmUgZWl0aGVyIGEgRE9NIGVsZW1lbnQgb3IgdmlydHVhbCBlbGVtZW50Lic7XG5jb25zdCBJTkZJTklURV9MT09QX0VSUk9SID1cbiAgJ1BvcHBlcjogQW4gaW5maW5pdGUgbG9vcCBpbiB0aGUgbW9kaWZpZXJzIGN5Y2xlIGhhcyBiZWVuIGRldGVjdGVkISBUaGUgY3ljbGUgaGFzIGJlZW4gaW50ZXJydXB0ZWQgdG8gcHJldmVudCBhIGJyb3dzZXIgY3Jhc2guJztcblxuY29uc3QgREVGQVVMVF9PUFRJT05TOiBPcHRpb25zR2VuZXJpYzxhbnk+ID0ge1xuICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICBtb2RpZmllcnM6IFtdLFxuICBzdHJhdGVneTogJ2Fic29sdXRlJyxcbn07XG5cbnR5cGUgUG9wcGVyR2VuZXJhdG9yQXJncyA9IHtcbiAgZGVmYXVsdE1vZGlmaWVycz86IEFycmF5PE1vZGlmaWVyPGFueSwgYW55Pj4sXG4gIGRlZmF1bHRPcHRpb25zPzogJFNoYXBlPE9wdGlvbnNHZW5lcmljPGFueT4+LFxufTtcblxuZnVuY3Rpb24gYXJlVmFsaWRFbGVtZW50cyguLi5hcmdzOiBBcnJheTxhbnk+KTogYm9vbGVhbiB7XG4gIHJldHVybiAhYXJncy5zb21lKFxuICAgIChlbGVtZW50KSA9PlxuICAgICAgIShlbGVtZW50ICYmIHR5cGVvZiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCA9PT0gJ2Z1bmN0aW9uJylcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvcHBlckdlbmVyYXRvcihnZW5lcmF0b3JPcHRpb25zOiBQb3BwZXJHZW5lcmF0b3JBcmdzID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGRlZmF1bHRNb2RpZmllcnMgPSBbXSxcbiAgICBkZWZhdWx0T3B0aW9ucyA9IERFRkFVTFRfT1BUSU9OUyxcbiAgfSA9IGdlbmVyYXRvck9wdGlvbnM7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZVBvcHBlcjxUTW9kaWZpZXI6ICRTaGFwZTxNb2RpZmllcjxhbnksIGFueT4+PihcbiAgICByZWZlcmVuY2U6IEVsZW1lbnQgfCBWaXJ0dWFsRWxlbWVudCxcbiAgICBwb3BwZXI6IEhUTUxFbGVtZW50LFxuICAgIG9wdGlvbnM6ICRTaGFwZTxPcHRpb25zR2VuZXJpYzxUTW9kaWZpZXI+PiA9IGRlZmF1bHRPcHRpb25zXG4gICk6IEluc3RhbmNlIHtcbiAgICBsZXQgc3RhdGU6ICRTaGFwZTxTdGF0ZT4gPSB7XG4gICAgICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICAgICAgb3JkZXJlZE1vZGlmaWVyczogW10sXG4gICAgICBvcHRpb25zOiB7IC4uLkRFRkFVTFRfT1BUSU9OUywgLi4uZGVmYXVsdE9wdGlvbnMgfSxcbiAgICAgIG1vZGlmaWVyc0RhdGE6IHt9LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgcmVmZXJlbmNlLFxuICAgICAgICBwb3BwZXIsXG4gICAgICB9LFxuICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICBzdHlsZXM6IHt9LFxuICAgIH07XG5cbiAgICBsZXQgZWZmZWN0Q2xlYW51cEZuczogQXJyYXk8KCkgPT4gdm9pZD4gPSBbXTtcbiAgICBsZXQgaXNEZXN0cm95ZWQgPSBmYWxzZTtcblxuICAgIGNvbnN0IGluc3RhbmNlID0ge1xuICAgICAgc3RhdGUsXG4gICAgICBzZXRPcHRpb25zKHNldE9wdGlvbnNBY3Rpb24pIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9XG4gICAgICAgICAgdHlwZW9mIHNldE9wdGlvbnNBY3Rpb24gPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gc2V0T3B0aW9uc0FjdGlvbihzdGF0ZS5vcHRpb25zKVxuICAgICAgICAgICAgOiBzZXRPcHRpb25zQWN0aW9uO1xuXG4gICAgICAgIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKTtcblxuICAgICAgICBzdGF0ZS5vcHRpb25zID0ge1xuICAgICAgICAgIC8vICRGbG93Rml4TWVbZXhwb25lbnRpYWwtc3ByZWFkXVxuICAgICAgICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgICAgICAgIC4uLnN0YXRlLm9wdGlvbnMsXG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfTtcblxuICAgICAgICBzdGF0ZS5zY3JvbGxQYXJlbnRzID0ge1xuICAgICAgICAgIHJlZmVyZW5jZTogaXNFbGVtZW50KHJlZmVyZW5jZSlcbiAgICAgICAgICAgID8gbGlzdFNjcm9sbFBhcmVudHMocmVmZXJlbmNlKVxuICAgICAgICAgICAgOiByZWZlcmVuY2UuY29udGV4dEVsZW1lbnRcbiAgICAgICAgICAgID8gbGlzdFNjcm9sbFBhcmVudHMocmVmZXJlbmNlLmNvbnRleHRFbGVtZW50KVxuICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgICBwb3BwZXI6IGxpc3RTY3JvbGxQYXJlbnRzKHBvcHBlciksXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gT3JkZXJzIHRoZSBtb2RpZmllcnMgYmFzZWQgb24gdGhlaXIgZGVwZW5kZW5jaWVzIGFuZCBgcGhhc2VgXG4gICAgICAgIC8vIHByb3BlcnRpZXNcbiAgICAgICAgY29uc3Qgb3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyTW9kaWZpZXJzKFxuICAgICAgICAgIG1lcmdlQnlOYW1lKFsuLi5kZWZhdWx0TW9kaWZpZXJzLCAuLi5zdGF0ZS5vcHRpb25zLm1vZGlmaWVyc10pXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gU3RyaXAgb3V0IGRpc2FibGVkIG1vZGlmaWVyc1xuICAgICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzID0gb3JkZXJlZE1vZGlmaWVycy5maWx0ZXIoKG0pID0+IG0uZW5hYmxlZCk7XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgdGhlIHByb3ZpZGVkIG1vZGlmaWVycyBzbyB0aGF0IHRoZSBjb25zdW1lciB3aWxsIGdldCB3YXJuZWRcbiAgICAgICAgLy8gaWYgb25lIG9mIHRoZSBtb2RpZmllcnMgaXMgaW52YWxpZCBmb3IgYW55IHJlYXNvblxuICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgIGNvbnN0IG1vZGlmaWVycyA9IHVuaXF1ZUJ5KFxuICAgICAgICAgICAgWy4uLm9yZGVyZWRNb2RpZmllcnMsIC4uLnN0YXRlLm9wdGlvbnMubW9kaWZpZXJzXSxcbiAgICAgICAgICAgICh7IG5hbWUgfSkgPT4gbmFtZVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICB2YWxpZGF0ZU1vZGlmaWVycyhtb2RpZmllcnMpO1xuXG4gICAgICAgICAgaWYgKGdldEJhc2VQbGFjZW1lbnQoc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQpID09PSBhdXRvKSB7XG4gICAgICAgICAgICBjb25zdCBmbGlwTW9kaWZpZXIgPSBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZpbmQoXG4gICAgICAgICAgICAgICh7IG5hbWUgfSkgPT4gbmFtZSA9PT0gJ2ZsaXAnXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAoIWZsaXBNb2RpZmllcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICdQb3BwZXI6IFwiYXV0b1wiIHBsYWNlbWVudHMgcmVxdWlyZSB0aGUgXCJmbGlwXCIgbW9kaWZpZXIgYmUnLFxuICAgICAgICAgICAgICAgICAgJ3ByZXNlbnQgYW5kIGVuYWJsZWQgdG8gd29yay4nLFxuICAgICAgICAgICAgICAgIF0uam9pbignICcpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgbWFyZ2luVG9wLFxuICAgICAgICAgICAgbWFyZ2luUmlnaHQsXG4gICAgICAgICAgICBtYXJnaW5Cb3R0b20sXG4gICAgICAgICAgICBtYXJnaW5MZWZ0LFxuICAgICAgICAgIH0gPSBnZXRDb21wdXRlZFN0eWxlKHBvcHBlcik7XG5cbiAgICAgICAgICAvLyBXZSBubyBsb25nZXIgdGFrZSBpbnRvIGFjY291bnQgYG1hcmdpbnNgIG9uIHRoZSBwb3BwZXIsIGFuZCBpdCBjYW5cbiAgICAgICAgICAvLyBjYXVzZSBidWdzIHdpdGggcG9zaXRpb25pbmcsIHNvIHdlJ2xsIHdhcm4gdGhlIGNvbnN1bWVyXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgW21hcmdpblRvcCwgbWFyZ2luUmlnaHQsIG1hcmdpbkJvdHRvbSwgbWFyZ2luTGVmdF0uc29tZSgobWFyZ2luKSA9PlxuICAgICAgICAgICAgICBwYXJzZUZsb2F0KG1hcmdpbilcbiAgICAgICAgICAgIClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdQb3BwZXI6IENTUyBcIm1hcmdpblwiIHN0eWxlcyBjYW5ub3QgYmUgdXNlZCB0byBhcHBseSBwYWRkaW5nJyxcbiAgICAgICAgICAgICAgICAnYmV0d2VlbiB0aGUgcG9wcGVyIGFuZCBpdHMgcmVmZXJlbmNlIGVsZW1lbnQgb3IgYm91bmRhcnkuJyxcbiAgICAgICAgICAgICAgICAnVG8gcmVwbGljYXRlIG1hcmdpbiwgdXNlIHRoZSBgb2Zmc2V0YCBtb2RpZmllciwgYXMgd2VsbCBhcycsXG4gICAgICAgICAgICAgICAgJ3RoZSBgcGFkZGluZ2Agb3B0aW9uIGluIHRoZSBgcHJldmVudE92ZXJmbG93YCBhbmQgYGZsaXBgJyxcbiAgICAgICAgICAgICAgICAnbW9kaWZpZXJzLicsXG4gICAgICAgICAgICAgIF0uam9pbignICcpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJ1bk1vZGlmaWVyRWZmZWN0cygpO1xuXG4gICAgICAgIHJldHVybiBpbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgIH0sXG5cbiAgICAgIC8vIFN5bmMgdXBkYXRlIOKAkyBpdCB3aWxsIGFsd2F5cyBiZSBleGVjdXRlZCwgZXZlbiBpZiBub3QgbmVjZXNzYXJ5LiBUaGlzXG4gICAgICAvLyBpcyB1c2VmdWwgZm9yIGxvdyBmcmVxdWVuY3kgdXBkYXRlcyB3aGVyZSBzeW5jIGJlaGF2aW9yIHNpbXBsaWZpZXMgdGhlXG4gICAgICAvLyBsb2dpYy5cbiAgICAgIC8vIEZvciBoaWdoIGZyZXF1ZW5jeSB1cGRhdGVzIChlLmcuIGByZXNpemVgIGFuZCBgc2Nyb2xsYCBldmVudHMpLCBhbHdheXNcbiAgICAgIC8vIHByZWZlciB0aGUgYXN5bmMgUG9wcGVyI3VwZGF0ZSBtZXRob2RcbiAgICAgIGZvcmNlVXBkYXRlKCkge1xuICAgICAgICBpZiAoaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IHJlZmVyZW5jZSwgcG9wcGVyIH0gPSBzdGF0ZS5lbGVtZW50cztcblxuICAgICAgICAvLyBEb24ndCBwcm9jZWVkIGlmIGByZWZlcmVuY2VgIG9yIGBwb3BwZXJgIGFyZSBub3QgdmFsaWQgZWxlbWVudHNcbiAgICAgICAgLy8gYW55bW9yZVxuICAgICAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XG4gICAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoSU5WQUxJRF9FTEVNRU5UX0VSUk9SKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RvcmUgdGhlIHJlZmVyZW5jZSBhbmQgcG9wcGVyIHJlY3RzIHRvIGJlIHJlYWQgYnkgbW9kaWZpZXJzXG4gICAgICAgIHN0YXRlLnJlY3RzID0ge1xuICAgICAgICAgIHJlZmVyZW5jZTogZ2V0Q29tcG9zaXRlUmVjdChcbiAgICAgICAgICAgIHJlZmVyZW5jZSxcbiAgICAgICAgICAgIGdldE9mZnNldFBhcmVudChwb3BwZXIpLFxuICAgICAgICAgICAgc3RhdGUub3B0aW9ucy5zdHJhdGVneSA9PT0gJ2ZpeGVkJ1xuICAgICAgICAgICksXG4gICAgICAgICAgcG9wcGVyOiBnZXRMYXlvdXRSZWN0KHBvcHBlciksXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gTW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gcmVzZXQgdGhlIGN1cnJlbnQgdXBkYXRlIGN5Y2xlLiBUaGVcbiAgICAgICAgLy8gbW9zdCBjb21tb24gdXNlIGNhc2UgZm9yIHRoaXMgaXMgdGhlIGBmbGlwYCBtb2RpZmllciBjaGFuZ2luZyB0aGVcbiAgICAgICAgLy8gcGxhY2VtZW50LCB3aGljaCB0aGVuIG5lZWRzIHRvIHJlLXJ1biBhbGwgdGhlIG1vZGlmaWVycywgYmVjYXVzZSB0aGVcbiAgICAgICAgLy8gbG9naWMgd2FzIHByZXZpb3VzbHkgcmFuIGZvciB0aGUgcHJldmlvdXMgcGxhY2VtZW50IGFuZCBpcyB0aGVyZWZvcmVcbiAgICAgICAgLy8gc3RhbGUvaW5jb3JyZWN0XG4gICAgICAgIHN0YXRlLnJlc2V0ID0gZmFsc2U7XG5cbiAgICAgICAgc3RhdGUucGxhY2VtZW50ID0gc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQ7XG5cbiAgICAgICAgLy8gT24gZWFjaCB1cGRhdGUgY3ljbGUsIHRoZSBgbW9kaWZpZXJzRGF0YWAgcHJvcGVydHkgZm9yIGVhY2ggbW9kaWZpZXJcbiAgICAgICAgLy8gaXMgZmlsbGVkIHdpdGggdGhlIGluaXRpYWwgZGF0YSBzcGVjaWZpZWQgYnkgdGhlIG1vZGlmaWVyLiBUaGlzIG1lYW5zXG4gICAgICAgIC8vIGl0IGRvZXNuJ3QgcGVyc2lzdCBhbmQgaXMgZnJlc2ggb24gZWFjaCB1cGRhdGUuXG4gICAgICAgIC8vIFRvIGVuc3VyZSBwZXJzaXN0ZW50IGRhdGEsIHVzZSBgJHtuYW1lfSNwZXJzaXN0ZW50YFxuICAgICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goXG4gICAgICAgICAgKG1vZGlmaWVyKSA9PlxuICAgICAgICAgICAgKHN0YXRlLm1vZGlmaWVyc0RhdGFbbW9kaWZpZXIubmFtZV0gPSB7XG4gICAgICAgICAgICAgIC4uLm1vZGlmaWVyLmRhdGEsXG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICAgIGxldCBfX2RlYnVnX2xvb3BzX18gPSAwO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgX19kZWJ1Z19sb29wc19fICs9IDE7XG4gICAgICAgICAgICBpZiAoX19kZWJ1Z19sb29wc19fID4gMTAwKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoSU5GSU5JVEVfTE9PUF9FUlJPUik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdGF0ZS5yZXNldCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgc3RhdGUucmVzZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB7IGZuLCBvcHRpb25zID0ge30sIG5hbWUgfSA9IHN0YXRlLm9yZGVyZWRNb2RpZmllcnNbaW5kZXhdO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc3RhdGUgPSBmbih7IHN0YXRlLCBvcHRpb25zLCBuYW1lLCBpbnN0YW5jZSB9KSB8fCBzdGF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8vIEFzeW5jIGFuZCBvcHRpbWlzdGljYWxseSBvcHRpbWl6ZWQgdXBkYXRlIOKAkyBpdCB3aWxsIG5vdCBiZSBleGVjdXRlZCBpZlxuICAgICAgLy8gbm90IG5lY2Vzc2FyeSAoZGVib3VuY2VkIHRvIHJ1biBhdCBtb3N0IG9uY2UtcGVyLXRpY2spXG4gICAgICB1cGRhdGU6IGRlYm91bmNlPCRTaGFwZTxTdGF0ZT4+KFxuICAgICAgICAoKSA9PlxuICAgICAgICAgIG5ldyBQcm9taXNlPCRTaGFwZTxTdGF0ZT4+KChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBpbnN0YW5jZS5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgICAgcmVzb2x2ZShzdGF0ZSk7XG4gICAgICAgICAgfSlcbiAgICAgICksXG5cbiAgICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgaXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgfSxcbiAgICB9O1xuXG4gICAgaWYgKCFhcmVWYWxpZEVsZW1lbnRzKHJlZmVyZW5jZSwgcG9wcGVyKSkge1xuICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihJTlZBTElEX0VMRU1FTlRfRVJST1IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cblxuICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucykudGhlbigoc3RhdGUpID0+IHtcbiAgICAgIGlmICghaXNEZXN0cm95ZWQgJiYgb3B0aW9ucy5vbkZpcnN0VXBkYXRlKSB7XG4gICAgICAgIG9wdGlvbnMub25GaXJzdFVwZGF0ZShzdGF0ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBNb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byBleGVjdXRlIGFyYml0cmFyeSBjb2RlIGJlZm9yZSB0aGUgZmlyc3RcbiAgICAvLyB1cGRhdGUgY3ljbGUgcnVucy4gVGhleSB3aWxsIGJlIGV4ZWN1dGVkIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSB1cGRhdGVcbiAgICAvLyBjeWNsZS4gVGhpcyBpcyB1c2VmdWwgd2hlbiBhIG1vZGlmaWVyIGFkZHMgc29tZSBwZXJzaXN0ZW50IGRhdGEgdGhhdFxuICAgIC8vIG90aGVyIG1vZGlmaWVycyBuZWVkIHRvIHVzZSwgYnV0IHRoZSBtb2RpZmllciBpcyBydW4gYWZ0ZXIgdGhlIGRlcGVuZGVudFxuICAgIC8vIG9uZS5cbiAgICBmdW5jdGlvbiBydW5Nb2RpZmllckVmZmVjdHMoKSB7XG4gICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goKHsgbmFtZSwgb3B0aW9ucyA9IHt9LCBlZmZlY3QgfSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGVmZmVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNvbnN0IGNsZWFudXBGbiA9IGVmZmVjdCh7IHN0YXRlLCBuYW1lLCBpbnN0YW5jZSwgb3B0aW9ucyB9KTtcbiAgICAgICAgICBjb25zdCBub29wRm4gPSAoKSA9PiB7fTtcbiAgICAgICAgICBlZmZlY3RDbGVhbnVwRm5zLnB1c2goY2xlYW51cEZuIHx8IG5vb3BGbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKSB7XG4gICAgICBlZmZlY3RDbGVhbnVwRm5zLmZvckVhY2goKGZuKSA9PiBmbigpKTtcbiAgICAgIGVmZmVjdENsZWFudXBGbnMgPSBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVQb3BwZXIgPSBwb3BwZXJHZW5lcmF0b3IoKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuZXhwb3J0IHsgZGV0ZWN0T3ZlcmZsb3cgfTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgdHlwZSB7IE1vZGlmaWVyQXJndW1lbnRzLCBNb2RpZmllciB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSAnLi4vZG9tLXV0aWxzL2dldFdpbmRvdyc7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcbmV4cG9ydCB0eXBlIE9wdGlvbnMgPSB7XG4gIHNjcm9sbDogYm9vbGVhbixcbiAgcmVzaXplOiBib29sZWFuLFxufTtcblxuY29uc3QgcGFzc2l2ZSA9IHsgcGFzc2l2ZTogdHJ1ZSB9O1xuXG5mdW5jdGlvbiBlZmZlY3QoeyBzdGF0ZSwgaW5zdGFuY2UsIG9wdGlvbnMgfTogTW9kaWZpZXJBcmd1bWVudHM8T3B0aW9ucz4pIHtcbiAgY29uc3QgeyBzY3JvbGwgPSB0cnVlLCByZXNpemUgPSB0cnVlIH0gPSBvcHRpb25zO1xuXG4gIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdyhzdGF0ZS5lbGVtZW50cy5wb3BwZXIpO1xuICBjb25zdCBzY3JvbGxQYXJlbnRzID0gW1xuICAgIC4uLnN0YXRlLnNjcm9sbFBhcmVudHMucmVmZXJlbmNlLFxuICAgIC4uLnN0YXRlLnNjcm9sbFBhcmVudHMucG9wcGVyLFxuICBdO1xuXG4gIGlmIChzY3JvbGwpIHtcbiAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goc2Nyb2xsUGFyZW50ID0+IHtcbiAgICAgIHNjcm9sbFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHJlc2l6ZSkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICB9XG5cbiAgcmV0dXJuICgpID0+IHtcbiAgICBpZiAoc2Nyb2xsKSB7XG4gICAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goc2Nyb2xsUGFyZW50ID0+IHtcbiAgICAgICAgc2Nyb2xsUGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocmVzaXplKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcbmV4cG9ydCB0eXBlIEV2ZW50TGlzdGVuZXJzTW9kaWZpZXIgPSBNb2RpZmllcjwnZXZlbnRMaXN0ZW5lcnMnLCBPcHRpb25zPjtcbmV4cG9ydCBkZWZhdWx0ICh7XG4gIG5hbWU6ICdldmVudExpc3RlbmVycycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnd3JpdGUnLFxuICBmbjogKCkgPT4ge30sXG4gIGVmZmVjdCxcbiAgZGF0YToge30sXG59OiBFdmVudExpc3RlbmVyc01vZGlmaWVyKTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgdHlwZSB7IE1vZGlmaWVyQXJndW1lbnRzLCBNb2RpZmllciB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCBjb21wdXRlT2Zmc2V0cyBmcm9tICcuLi91dGlscy9jb21wdXRlT2Zmc2V0cyc7XG5cbmZ1bmN0aW9uIHBvcHBlck9mZnNldHMoeyBzdGF0ZSwgbmFtZSB9OiBNb2RpZmllckFyZ3VtZW50czx7fHx9Pikge1xuICAvLyBPZmZzZXRzIGFyZSB0aGUgYWN0dWFsIHBvc2l0aW9uIHRoZSBwb3BwZXIgbmVlZHMgdG8gaGF2ZSB0byBiZVxuICAvLyBwcm9wZXJseSBwb3NpdGlvbmVkIG5lYXIgaXRzIHJlZmVyZW5jZSBlbGVtZW50XG4gIC8vIFRoaXMgaXMgdGhlIG1vc3QgYmFzaWMgcGxhY2VtZW50LCBhbmQgd2lsbCBiZSBhZGp1c3RlZCBieVxuICAvLyB0aGUgbW9kaWZpZXJzIGluIHRoZSBuZXh0IHN0ZXBcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGNvbXB1dGVPZmZzZXRzKHtcbiAgICByZWZlcmVuY2U6IHN0YXRlLnJlY3RzLnJlZmVyZW5jZSxcbiAgICBlbGVtZW50OiBzdGF0ZS5yZWN0cy5wb3BwZXIsXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnQsXG4gIH0pO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgdHlwZSBQb3BwZXJPZmZzZXRzTW9kaWZpZXIgPSBNb2RpZmllcjwncG9wcGVyT2Zmc2V0cycsIHt8fH0+O1xuZXhwb3J0IGRlZmF1bHQgKHtcbiAgbmFtZTogJ3BvcHBlck9mZnNldHMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ3JlYWQnLFxuICBmbjogcG9wcGVyT2Zmc2V0cyxcbiAgZGF0YToge30sXG59OiBQb3BwZXJPZmZzZXRzTW9kaWZpZXIpO1xuIiwiLy8gQGZsb3dcbmltcG9ydCB0eXBlIHtcbiAgUG9zaXRpb25pbmdTdHJhdGVneSxcbiAgT2Zmc2V0cyxcbiAgTW9kaWZpZXIsXG4gIE1vZGlmaWVyQXJndW1lbnRzLFxuICBSZWN0LFxuICBXaW5kb3csXG59IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7XG4gIHR5cGUgQmFzZVBsYWNlbWVudCxcbiAgdHlwZSBWYXJpYXRpb24sXG4gIHRvcCxcbiAgbGVmdCxcbiAgcmlnaHQsXG4gIGJvdHRvbSxcbiAgZW5kLFxufSBmcm9tICcuLi9lbnVtcyc7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gJy4uL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQnO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tICcuLi9kb20tdXRpbHMvZ2V0V2luZG93JztcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSAnLi4vZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudCc7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tICcuLi9kb20tdXRpbHMvZ2V0Q29tcHV0ZWRTdHlsZSc7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tICcuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50JztcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSAnLi4vdXRpbHMvZ2V0VmFyaWF0aW9uJztcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSAnLi4vdXRpbHMvbWF0aCc7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcbmV4cG9ydCB0eXBlIFJvdW5kT2Zmc2V0cyA9IChcbiAgb2Zmc2V0czogJFNoYXBlPHsgeDogbnVtYmVyLCB5OiBudW1iZXIsIGNlbnRlck9mZnNldDogbnVtYmVyIH0+XG4pID0+IE9mZnNldHM7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcbmV4cG9ydCB0eXBlIE9wdGlvbnMgPSB7XG4gIGdwdUFjY2VsZXJhdGlvbjogYm9vbGVhbixcbiAgYWRhcHRpdmU6IGJvb2xlYW4sXG4gIHJvdW5kT2Zmc2V0cz86IGJvb2xlYW4gfCBSb3VuZE9mZnNldHMsXG59O1xuXG5jb25zdCB1bnNldFNpZGVzID0ge1xuICB0b3A6ICdhdXRvJyxcbiAgcmlnaHQ6ICdhdXRvJyxcbiAgYm90dG9tOiAnYXV0bycsXG4gIGxlZnQ6ICdhdXRvJyxcbn07XG5cbi8vIFJvdW5kIHRoZSBvZmZzZXRzIHRvIHRoZSBuZWFyZXN0IHN1aXRhYmxlIHN1YnBpeGVsIGJhc2VkIG9uIHRoZSBEUFIuXG4vLyBab29taW5nIGNhbiBjaGFuZ2UgdGhlIERQUiwgYnV0IGl0IHNlZW1zIHRvIHJlcG9ydCBhIHZhbHVlIHRoYXQgd2lsbFxuLy8gY2xlYW5seSBkaXZpZGUgdGhlIHZhbHVlcyBpbnRvIHRoZSBhcHByb3ByaWF0ZSBzdWJwaXhlbHMuXG5mdW5jdGlvbiByb3VuZE9mZnNldHNCeURQUih7IHgsIHkgfSwgd2luOiBXaW5kb3cpOiBPZmZzZXRzIHtcbiAgY29uc3QgZHByID0gd2luLmRldmljZVBpeGVsUmF0aW8gfHwgMTtcblxuICByZXR1cm4ge1xuICAgIHg6IHJvdW5kKHggKiBkcHIpIC8gZHByIHx8IDAsXG4gICAgeTogcm91bmQoeSAqIGRwcikgLyBkcHIgfHwgMCxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hcFRvU3R5bGVzKHtcbiAgcG9wcGVyLFxuICBwb3BwZXJSZWN0LFxuICBwbGFjZW1lbnQsXG4gIHZhcmlhdGlvbixcbiAgb2Zmc2V0cyxcbiAgcG9zaXRpb24sXG4gIGdwdUFjY2VsZXJhdGlvbixcbiAgYWRhcHRpdmUsXG4gIHJvdW5kT2Zmc2V0cyxcbiAgaXNGaXhlZCxcbn06IHtcbiAgcG9wcGVyOiBIVE1MRWxlbWVudCxcbiAgcG9wcGVyUmVjdDogUmVjdCxcbiAgcGxhY2VtZW50OiBCYXNlUGxhY2VtZW50LFxuICB2YXJpYXRpb246ID9WYXJpYXRpb24sXG4gIG9mZnNldHM6ICRTaGFwZTx7IHg6IG51bWJlciwgeTogbnVtYmVyLCBjZW50ZXJPZmZzZXQ6IG51bWJlciB9PixcbiAgcG9zaXRpb246IFBvc2l0aW9uaW5nU3RyYXRlZ3ksXG4gIGdwdUFjY2VsZXJhdGlvbjogYm9vbGVhbixcbiAgYWRhcHRpdmU6IGJvb2xlYW4sXG4gIHJvdW5kT2Zmc2V0czogYm9vbGVhbiB8IFJvdW5kT2Zmc2V0cyxcbiAgaXNGaXhlZDogYm9vbGVhbixcbn0pIHtcbiAgbGV0IHsgeCA9IDAsIHkgPSAwIH0gPSBvZmZzZXRzO1xuXG4gICh7IHgsIHkgfSA9XG4gICAgdHlwZW9mIHJvdW5kT2Zmc2V0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyByb3VuZE9mZnNldHMoeyB4LCB5IH0pXG4gICAgICA6IHsgeCwgeSB9KTtcblxuICBjb25zdCBoYXNYID0gb2Zmc2V0cy5oYXNPd25Qcm9wZXJ0eSgneCcpO1xuICBjb25zdCBoYXNZID0gb2Zmc2V0cy5oYXNPd25Qcm9wZXJ0eSgneScpO1xuXG4gIGxldCBzaWRlWDogc3RyaW5nID0gbGVmdDtcbiAgbGV0IHNpZGVZOiBzdHJpbmcgPSB0b3A7XG5cbiAgY29uc3Qgd2luOiBXaW5kb3cgPSB3aW5kb3c7XG5cbiAgaWYgKGFkYXB0aXZlKSB7XG4gICAgbGV0IG9mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChwb3BwZXIpO1xuICAgIGxldCBoZWlnaHRQcm9wID0gJ2NsaWVudEhlaWdodCc7XG4gICAgbGV0IHdpZHRoUHJvcCA9ICdjbGllbnRXaWR0aCc7XG5cbiAgICBpZiAob2Zmc2V0UGFyZW50ID09PSBnZXRXaW5kb3cocG9wcGVyKSkge1xuICAgICAgb2Zmc2V0UGFyZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KHBvcHBlcik7XG5cbiAgICAgIGlmIChcbiAgICAgICAgZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uICE9PSAnc3RhdGljJyAmJlxuICAgICAgICBwb3NpdGlvbiA9PT0gJ2Fic29sdXRlJ1xuICAgICAgKSB7XG4gICAgICAgIGhlaWdodFByb3AgPSAnc2Nyb2xsSGVpZ2h0JztcbiAgICAgICAgd2lkdGhQcm9wID0gJ3Njcm9sbFdpZHRoJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYXN0XTogZm9yY2UgdHlwZSByZWZpbmVtZW50LCB3ZSBjb21wYXJlIG9mZnNldFBhcmVudCB3aXRoIHdpbmRvdyBhYm92ZSwgYnV0IEZsb3cgZG9lc24ndCBkZXRlY3QgaXRcbiAgICBvZmZzZXRQYXJlbnQgPSAob2Zmc2V0UGFyZW50OiBFbGVtZW50KTtcblxuICAgIGlmIChcbiAgICAgIHBsYWNlbWVudCA9PT0gdG9wIHx8XG4gICAgICAoKHBsYWNlbWVudCA9PT0gbGVmdCB8fCBwbGFjZW1lbnQgPT09IHJpZ2h0KSAmJiB2YXJpYXRpb24gPT09IGVuZClcbiAgICApIHtcbiAgICAgIHNpZGVZID0gYm90dG9tO1xuICAgICAgY29uc3Qgb2Zmc2V0WSA9XG4gICAgICAgIGlzRml4ZWQgJiYgb2Zmc2V0UGFyZW50ID09PSB3aW4gJiYgd2luLnZpc3VhbFZpZXdwb3J0XG4gICAgICAgICAgPyB3aW4udmlzdWFsVmlld3BvcnQuaGVpZ2h0XG4gICAgICAgICAgOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgICAgICAgIG9mZnNldFBhcmVudFtoZWlnaHRQcm9wXTtcbiAgICAgIHkgLT0gb2Zmc2V0WSAtIHBvcHBlclJlY3QuaGVpZ2h0O1xuICAgICAgeSAqPSBncHVBY2NlbGVyYXRpb24gPyAxIDogLTE7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgcGxhY2VtZW50ID09PSBsZWZ0IHx8XG4gICAgICAoKHBsYWNlbWVudCA9PT0gdG9wIHx8IHBsYWNlbWVudCA9PT0gYm90dG9tKSAmJiB2YXJpYXRpb24gPT09IGVuZClcbiAgICApIHtcbiAgICAgIHNpZGVYID0gcmlnaHQ7XG4gICAgICBjb25zdCBvZmZzZXRYID1cbiAgICAgICAgaXNGaXhlZCAmJiBvZmZzZXRQYXJlbnQgPT09IHdpbiAmJiB3aW4udmlzdWFsVmlld3BvcnRcbiAgICAgICAgICA/IHdpbi52aXN1YWxWaWV3cG9ydC53aWR0aFxuICAgICAgICAgIDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICAgICAgICBvZmZzZXRQYXJlbnRbd2lkdGhQcm9wXTtcbiAgICAgIHggLT0gb2Zmc2V0WCAtIHBvcHBlclJlY3Qud2lkdGg7XG4gICAgICB4ICo9IGdwdUFjY2VsZXJhdGlvbiA/IDEgOiAtMTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBjb21tb25TdHlsZXMgPSB7XG4gICAgcG9zaXRpb24sXG4gICAgLi4uKGFkYXB0aXZlICYmIHVuc2V0U2lkZXMpLFxuICB9O1xuXG4gICh7IHgsIHkgfSA9XG4gICAgcm91bmRPZmZzZXRzID09PSB0cnVlXG4gICAgICA/IHJvdW5kT2Zmc2V0c0J5RFBSKHsgeCwgeSB9LCBnZXRXaW5kb3cocG9wcGVyKSlcbiAgICAgIDogeyB4LCB5IH0pO1xuXG4gIGlmIChncHVBY2NlbGVyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uY29tbW9uU3R5bGVzLFxuICAgICAgW3NpZGVZXTogaGFzWSA/ICcwJyA6ICcnLFxuICAgICAgW3NpZGVYXTogaGFzWCA/ICcwJyA6ICcnLFxuICAgICAgLy8gTGF5ZXIgYWNjZWxlcmF0aW9uIGNhbiBkaXNhYmxlIHN1YnBpeGVsIHJlbmRlcmluZyB3aGljaCBjYXVzZXMgc2xpZ2h0bHlcbiAgICAgIC8vIGJsdXJyeSB0ZXh0IG9uIGxvdyBQUEkgZGlzcGxheXMsIHNvIHdlIHdhbnQgdG8gdXNlIDJEIHRyYW5zZm9ybXNcbiAgICAgIC8vIGluc3RlYWRcbiAgICAgIHRyYW5zZm9ybTpcbiAgICAgICAgKHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIDw9IDFcbiAgICAgICAgICA/IGB0cmFuc2xhdGUoJHt4fXB4LCAke3l9cHgpYFxuICAgICAgICAgIDogYHRyYW5zbGF0ZTNkKCR7eH1weCwgJHt5fXB4LCAwKWAsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4uY29tbW9uU3R5bGVzLFxuICAgIFtzaWRlWV06IGhhc1kgPyBgJHt5fXB4YCA6ICcnLFxuICAgIFtzaWRlWF06IGhhc1ggPyBgJHt4fXB4YCA6ICcnLFxuICAgIHRyYW5zZm9ybTogJycsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVTdHlsZXMoeyBzdGF0ZSwgb3B0aW9ucyB9OiBNb2RpZmllckFyZ3VtZW50czxPcHRpb25zPikge1xuICBjb25zdCB7XG4gICAgZ3B1QWNjZWxlcmF0aW9uID0gdHJ1ZSxcbiAgICBhZGFwdGl2ZSA9IHRydWUsXG4gICAgLy8gZGVmYXVsdHMgdG8gdXNlIGJ1aWx0aW4gYHJvdW5kT2Zmc2V0c0J5RFBSYFxuICAgIHJvdW5kT2Zmc2V0cyA9IHRydWUsXG4gIH0gPSBvcHRpb25zO1xuXG4gIGlmIChfX0RFVl9fKSB7XG4gICAgY29uc3QgdHJhbnNpdGlvblByb3BlcnR5ID1cbiAgICAgIGdldENvbXB1dGVkU3R5bGUoc3RhdGUuZWxlbWVudHMucG9wcGVyKS50cmFuc2l0aW9uUHJvcGVydHkgfHwgJyc7XG5cbiAgICBpZiAoXG4gICAgICBhZGFwdGl2ZSAmJlxuICAgICAgWyd0cmFuc2Zvcm0nLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10uc29tZShcbiAgICAgICAgKHByb3BlcnR5KSA9PiB0cmFuc2l0aW9uUHJvcGVydHkuaW5kZXhPZihwcm9wZXJ0eSkgPj0gMFxuICAgICAgKVxuICAgICkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBbXG4gICAgICAgICAgJ1BvcHBlcjogRGV0ZWN0ZWQgQ1NTIHRyYW5zaXRpb25zIG9uIGF0IGxlYXN0IG9uZSBvZiB0aGUgZm9sbG93aW5nJyxcbiAgICAgICAgICAnQ1NTIHByb3BlcnRpZXM6IFwidHJhbnNmb3JtXCIsIFwidG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCIuJyxcbiAgICAgICAgICAnXFxuXFxuJyxcbiAgICAgICAgICAnRGlzYWJsZSB0aGUgXCJjb21wdXRlU3R5bGVzXCIgbW9kaWZpZXJcXCdzIGBhZGFwdGl2ZWAgb3B0aW9uIHRvIGFsbG93JyxcbiAgICAgICAgICAnZm9yIHNtb290aCB0cmFuc2l0aW9ucywgb3IgcmVtb3ZlIHRoZXNlIHByb3BlcnRpZXMgZnJvbSB0aGUgQ1NTJyxcbiAgICAgICAgICAndHJhbnNpdGlvbiBkZWNsYXJhdGlvbiBvbiB0aGUgcG9wcGVyIGVsZW1lbnQgaWYgb25seSB0cmFuc2l0aW9uaW5nJyxcbiAgICAgICAgICAnb3BhY2l0eSBvciBiYWNrZ3JvdW5kLWNvbG9yIGZvciBleGFtcGxlLicsXG4gICAgICAgICAgJ1xcblxcbicsXG4gICAgICAgICAgJ1dlIHJlY29tbWVuZCB1c2luZyB0aGUgcG9wcGVyIGVsZW1lbnQgYXMgYSB3cmFwcGVyIGFyb3VuZCBhbiBpbm5lcicsXG4gICAgICAgICAgJ2VsZW1lbnQgdGhhdCBjYW4gaGF2ZSBhbnkgQ1NTIHByb3BlcnR5IHRyYW5zaXRpb25lZCBmb3IgYW5pbWF0aW9ucy4nLFxuICAgICAgICBdLmpvaW4oJyAnKVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBjb21tb25TdHlsZXMgPSB7XG4gICAgcGxhY2VtZW50OiBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCksXG4gICAgdmFyaWF0aW9uOiBnZXRWYXJpYXRpb24oc3RhdGUucGxhY2VtZW50KSxcbiAgICBwb3BwZXI6IHN0YXRlLmVsZW1lbnRzLnBvcHBlcixcbiAgICBwb3BwZXJSZWN0OiBzdGF0ZS5yZWN0cy5wb3BwZXIsXG4gICAgZ3B1QWNjZWxlcmF0aW9uLFxuICAgIGlzRml4ZWQ6IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3kgPT09ICdmaXhlZCcsXG4gIH07XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyAhPSBudWxsKSB7XG4gICAgc3RhdGUuc3R5bGVzLnBvcHBlciA9IHtcbiAgICAgIC4uLnN0YXRlLnN0eWxlcy5wb3BwZXIsXG4gICAgICAuLi5tYXBUb1N0eWxlcyh7XG4gICAgICAgIC4uLmNvbW1vblN0eWxlcyxcbiAgICAgICAgb2Zmc2V0czogc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLFxuICAgICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgICAgYWRhcHRpdmUsXG4gICAgICAgIHJvdW5kT2Zmc2V0cyxcbiAgICAgIH0pLFxuICAgIH07XG4gIH1cblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5hcnJvdyAhPSBudWxsKSB7XG4gICAgc3RhdGUuc3R5bGVzLmFycm93ID0ge1xuICAgICAgLi4uc3RhdGUuc3R5bGVzLmFycm93LFxuICAgICAgLi4ubWFwVG9TdHlsZXMoe1xuICAgICAgICAuLi5jb21tb25TdHlsZXMsXG4gICAgICAgIG9mZnNldHM6IHN0YXRlLm1vZGlmaWVyc0RhdGEuYXJyb3csXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICBhZGFwdGl2ZTogZmFsc2UsXG4gICAgICAgIHJvdW5kT2Zmc2V0cyxcbiAgICAgIH0pLFxuICAgIH07XG4gIH1cblxuICBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciA9IHtcbiAgICAuLi5zdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlcixcbiAgICAnZGF0YS1wb3BwZXItcGxhY2VtZW50Jzogc3RhdGUucGxhY2VtZW50LFxuICB9O1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgdHlwZSBDb21wdXRlU3R5bGVzTW9kaWZpZXIgPSBNb2RpZmllcjwnY29tcHV0ZVN0eWxlcycsIE9wdGlvbnM+O1xuZXhwb3J0IGRlZmF1bHQgKHtcbiAgbmFtZTogJ2NvbXB1dGVTdHlsZXMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ2JlZm9yZVdyaXRlJyxcbiAgZm46IGNvbXB1dGVTdHlsZXMsXG4gIGRhdGE6IHt9LFxufTogQ29tcHV0ZVN0eWxlc01vZGlmaWVyKTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgdHlwZSB7IE1vZGlmaWVyLCBNb2RpZmllckFyZ3VtZW50cyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tICcuLi9kb20tdXRpbHMvZ2V0Tm9kZU5hbWUnO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gJy4uL2RvbS11dGlscy9pbnN0YW5jZU9mJztcblxuLy8gVGhpcyBtb2RpZmllciB0YWtlcyB0aGUgc3R5bGVzIHByZXBhcmVkIGJ5IHRoZSBgY29tcHV0ZVN0eWxlc2AgbW9kaWZpZXJcbi8vIGFuZCBhcHBsaWVzIHRoZW0gdG8gdGhlIEhUTUxFbGVtZW50cyBzdWNoIGFzIHBvcHBlciBhbmQgYXJyb3dcblxuZnVuY3Rpb24gYXBwbHlTdHlsZXMoeyBzdGF0ZSB9OiBNb2RpZmllckFyZ3VtZW50czx7fHx9Pikge1xuICBPYmplY3Qua2V5cyhzdGF0ZS5lbGVtZW50cykuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgIGNvbnN0IHN0eWxlID0gc3RhdGUuc3R5bGVzW25hbWVdIHx8IHt9O1xuXG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG4gICAgY29uc3QgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdO1xuXG4gICAgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXG4gICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8ICFnZXROb2RlTmFtZShlbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEZsb3cgZG9lc24ndCBzdXBwb3J0IHRvIGV4dGVuZCB0aGlzIHByb3BlcnR5LCBidXQgaXQncyB0aGUgbW9zdFxuICAgIC8vIGVmZmVjdGl2ZSB3YXkgdG8gYXBwbHkgc3R5bGVzIHRvIGFuIEhUTUxFbGVtZW50XG4gICAgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdXG4gICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSk7XG5cbiAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUgPT09IHRydWUgPyAnJyA6IHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGVmZmVjdCh7IHN0YXRlIH06IE1vZGlmaWVyQXJndW1lbnRzPHt8fH0+KSB7XG4gIGNvbnN0IGluaXRpYWxTdHlsZXMgPSB7XG4gICAgcG9wcGVyOiB7XG4gICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgIGxlZnQ6ICcwJyxcbiAgICAgIHRvcDogJzAnLFxuICAgICAgbWFyZ2luOiAnMCcsXG4gICAgfSxcbiAgICBhcnJvdzoge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgfSxcbiAgICByZWZlcmVuY2U6IHt9LFxuICB9O1xuXG4gIE9iamVjdC5hc3NpZ24oc3RhdGUuZWxlbWVudHMucG9wcGVyLnN0eWxlLCBpbml0aWFsU3R5bGVzLnBvcHBlcik7XG4gIHN0YXRlLnN0eWxlcyA9IGluaXRpYWxTdHlsZXM7XG5cbiAgaWYgKHN0YXRlLmVsZW1lbnRzLmFycm93KSB7XG4gICAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5hcnJvdy5zdHlsZSwgaW5pdGlhbFN0eWxlcy5hcnJvdyk7XG4gIH1cblxuICByZXR1cm4gKCkgPT4ge1xuICAgIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbbmFtZV07XG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gc3RhdGUuYXR0cmlidXRlc1tuYW1lXSB8fCB7fTtcblxuICAgICAgY29uc3Qgc3R5bGVQcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMoXG4gICAgICAgIHN0YXRlLnN0eWxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKVxuICAgICAgICAgID8gc3RhdGUuc3R5bGVzW25hbWVdXG4gICAgICAgICAgOiBpbml0aWFsU3R5bGVzW25hbWVdXG4gICAgICApO1xuXG4gICAgICAvLyBTZXQgYWxsIHZhbHVlcyB0byBhbiBlbXB0eSBzdHJpbmcgdG8gdW5zZXQgdGhlbVxuICAgICAgY29uc3Qgc3R5bGUgPSBzdHlsZVByb3BlcnRpZXMucmVkdWNlKChzdHlsZSwgcHJvcGVydHkpID0+IHtcbiAgICAgICAgc3R5bGVbcHJvcGVydHldID0gJyc7XG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgIH0sIHt9KTtcblxuICAgICAgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXG4gICAgICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgIWdldE5vZGVOYW1lKGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSk7XG5cbiAgICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goKGF0dHJpYnV0ZSkgPT4ge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcbmV4cG9ydCB0eXBlIEFwcGx5U3R5bGVzTW9kaWZpZXIgPSBNb2RpZmllcjwnYXBwbHlTdHlsZXMnLCB7fHx9PjtcbmV4cG9ydCBkZWZhdWx0ICh7XG4gIG5hbWU6ICdhcHBseVN0eWxlcycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnd3JpdGUnLFxuICBmbjogYXBwbHlTdHlsZXMsXG4gIGVmZmVjdCxcbiAgcmVxdWlyZXM6IFsnY29tcHV0ZVN0eWxlcyddLFxufTogQXBwbHlTdHlsZXNNb2RpZmllcik7XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBQbGFjZW1lbnQgfSBmcm9tICcuLi9lbnVtcyc7XG5pbXBvcnQgdHlwZSB7IE1vZGlmaWVyQXJndW1lbnRzLCBNb2RpZmllciwgUmVjdCwgT2Zmc2V0cyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gJy4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQnO1xuaW1wb3J0IHsgdG9wLCBsZWZ0LCByaWdodCwgcGxhY2VtZW50cyB9IGZyb20gJy4uL2VudW1zJztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuZXhwb3J0IHR5cGUgT2Zmc2V0c0Z1bmN0aW9uID0gKHtcbiAgcG9wcGVyOiBSZWN0LFxuICByZWZlcmVuY2U6IFJlY3QsXG4gIHBsYWNlbWVudDogUGxhY2VtZW50LFxufSkgPT4gWz9udW1iZXIsID9udW1iZXJdO1xuXG50eXBlIE9mZnNldCA9IE9mZnNldHNGdW5jdGlvbiB8IFs/bnVtYmVyLCA/bnVtYmVyXTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuZXhwb3J0IHR5cGUgT3B0aW9ucyA9IHtcbiAgb2Zmc2V0OiBPZmZzZXQsXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkoXG4gIHBsYWNlbWVudDogUGxhY2VtZW50LFxuICByZWN0czogeyBwb3BwZXI6IFJlY3QsIHJlZmVyZW5jZTogUmVjdCB9LFxuICBvZmZzZXQ6IE9mZnNldFxuKTogT2Zmc2V0cyB7XG4gIGNvbnN0IGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIGNvbnN0IGludmVydERpc3RhbmNlID0gW2xlZnQsIHRvcF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwID8gLTEgOiAxO1xuXG4gIGxldCBbc2tpZGRpbmcsIGRpc3RhbmNlXSA9XG4gICAgdHlwZW9mIG9mZnNldCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBvZmZzZXQoe1xuICAgICAgICAgIC4uLnJlY3RzLFxuICAgICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgfSlcbiAgICAgIDogb2Zmc2V0O1xuXG4gIHNraWRkaW5nID0gc2tpZGRpbmcgfHwgMDtcbiAgZGlzdGFuY2UgPSAoZGlzdGFuY2UgfHwgMCkgKiBpbnZlcnREaXN0YW5jZTtcblxuICByZXR1cm4gW2xlZnQsIHJpZ2h0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDBcbiAgICA/IHsgeDogZGlzdGFuY2UsIHk6IHNraWRkaW5nIH1cbiAgICA6IHsgeDogc2tpZGRpbmcsIHk6IGRpc3RhbmNlIH07XG59XG5cbmZ1bmN0aW9uIG9mZnNldCh7IHN0YXRlLCBvcHRpb25zLCBuYW1lIH06IE1vZGlmaWVyQXJndW1lbnRzPE9wdGlvbnM+KSB7XG4gIGNvbnN0IHsgb2Zmc2V0ID0gWzAsIDBdIH0gPSBvcHRpb25zO1xuXG4gIGNvbnN0IGRhdGEgPSBwbGFjZW1lbnRzLnJlZHVjZSgoYWNjLCBwbGFjZW1lbnQpID0+IHtcbiAgICBhY2NbcGxhY2VtZW50XSA9IGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZKHBsYWNlbWVudCwgc3RhdGUucmVjdHMsIG9mZnNldCk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuXG4gIGNvbnN0IHsgeCwgeSB9ID0gZGF0YVtzdGF0ZS5wbGFjZW1lbnRdO1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy54ICs9IHg7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnkgKz0geTtcbiAgfVxuXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBkYXRhO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgdHlwZSBPZmZzZXRNb2RpZmllciA9IE1vZGlmaWVyPCdvZmZzZXQnLCBPcHRpb25zPjtcbmV4cG9ydCBkZWZhdWx0ICh7XG4gIG5hbWU6ICdvZmZzZXQnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICByZXF1aXJlczogWydwb3BwZXJPZmZzZXRzJ10sXG4gIGZuOiBvZmZzZXQsXG59OiBPZmZzZXRNb2RpZmllcik7XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBQbGFjZW1lbnQgfSBmcm9tICcuLi9lbnVtcyc7XG5cbmNvbnN0IGhhc2ggPSB7IGxlZnQ6ICdyaWdodCcsIHJpZ2h0OiAnbGVmdCcsIGJvdHRvbTogJ3RvcCcsIHRvcDogJ2JvdHRvbScgfTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50OiBQbGFjZW1lbnQpOiBQbGFjZW1lbnQge1xuICByZXR1cm4gKHBsYWNlbWVudC5yZXBsYWNlKFxuICAgIC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZyxcbiAgICBtYXRjaGVkID0+IGhhc2hbbWF0Y2hlZF1cbiAgKTogYW55KTtcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgdHlwZSB7IFBsYWNlbWVudCB9IGZyb20gJy4uL2VudW1zJztcblxuY29uc3QgaGFzaCA9IHsgc3RhcnQ6ICdlbmQnLCBlbmQ6ICdzdGFydCcgfTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQoXG4gIHBsYWNlbWVudDogUGxhY2VtZW50XG4pOiBQbGFjZW1lbnQge1xuICByZXR1cm4gKHBsYWNlbWVudC5yZXBsYWNlKC9zdGFydHxlbmQvZywgbWF0Y2hlZCA9PiBoYXNoW21hdGNoZWRdKTogYW55KTtcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgdHlwZSB7IFN0YXRlLCBQYWRkaW5nIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHR5cGUge1xuICBQbGFjZW1lbnQsXG4gIENvbXB1dGVkUGxhY2VtZW50LFxuICBCb3VuZGFyeSxcbiAgUm9vdEJvdW5kYXJ5LFxufSBmcm9tICcuLi9lbnVtcyc7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gJy4vZ2V0VmFyaWF0aW9uJztcbmltcG9ydCB7XG4gIHZhcmlhdGlvblBsYWNlbWVudHMsXG4gIGJhc2VQbGFjZW1lbnRzLFxuICBwbGFjZW1lbnRzIGFzIGFsbFBsYWNlbWVudHMsXG59IGZyb20gJy4uL2VudW1zJztcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tICcuL2RldGVjdE92ZXJmbG93JztcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gJy4vZ2V0QmFzZVBsYWNlbWVudCc7XG5cbnR5cGUgT3B0aW9ucyA9IHtcbiAgcGxhY2VtZW50OiBQbGFjZW1lbnQsXG4gIHBhZGRpbmc6IFBhZGRpbmcsXG4gIGJvdW5kYXJ5OiBCb3VuZGFyeSxcbiAgcm9vdEJvdW5kYXJ5OiBSb290Qm91bmRhcnksXG4gIGZsaXBWYXJpYXRpb25zOiBib29sZWFuLFxuICBhbGxvd2VkQXV0b1BsYWNlbWVudHM/OiBBcnJheTxQbGFjZW1lbnQ+LFxufTtcblxudHlwZSBPdmVyZmxvd3NNYXAgPSB7IFtDb21wdXRlZFBsYWNlbWVudF06IG51bWJlciB9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wdXRlQXV0b1BsYWNlbWVudChcbiAgc3RhdGU6ICRTaGFwZTxTdGF0ZT4sXG4gIG9wdGlvbnM6IE9wdGlvbnMgPSB7fVxuKTogQXJyYXk8Q29tcHV0ZWRQbGFjZW1lbnQ+IHtcbiAgY29uc3Qge1xuICAgIHBsYWNlbWVudCxcbiAgICBib3VuZGFyeSxcbiAgICByb290Qm91bmRhcnksXG4gICAgcGFkZGluZyxcbiAgICBmbGlwVmFyaWF0aW9ucyxcbiAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHMgPSBhbGxQbGFjZW1lbnRzLFxuICB9ID0gb3B0aW9ucztcblxuICBjb25zdCB2YXJpYXRpb24gPSBnZXRWYXJpYXRpb24ocGxhY2VtZW50KTtcblxuICBjb25zdCBwbGFjZW1lbnRzID0gdmFyaWF0aW9uXG4gICAgPyBmbGlwVmFyaWF0aW9uc1xuICAgICAgPyB2YXJpYXRpb25QbGFjZW1lbnRzXG4gICAgICA6IHZhcmlhdGlvblBsYWNlbWVudHMuZmlsdGVyKFxuICAgICAgICAgIChwbGFjZW1lbnQpID0+IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpID09PSB2YXJpYXRpb25cbiAgICAgICAgKVxuICAgIDogYmFzZVBsYWNlbWVudHM7XG5cbiAgbGV0IGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cy5maWx0ZXIoXG4gICAgKHBsYWNlbWVudCkgPT4gYWxsb3dlZEF1dG9QbGFjZW1lbnRzLmluZGV4T2YocGxhY2VtZW50KSA+PSAwXG4gICk7XG5cbiAgaWYgKGFsbG93ZWRQbGFjZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cztcblxuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBbXG4gICAgICAgICAgJ1BvcHBlcjogVGhlIGBhbGxvd2VkQXV0b1BsYWNlbWVudHNgIG9wdGlvbiBkaWQgbm90IGFsbG93IGFueScsXG4gICAgICAgICAgJ3BsYWNlbWVudHMuIEVuc3VyZSB0aGUgYHBsYWNlbWVudGAgb3B0aW9uIG1hdGNoZXMgdGhlIHZhcmlhdGlvbicsXG4gICAgICAgICAgJ29mIHRoZSBhbGxvd2VkIHBsYWNlbWVudHMuJyxcbiAgICAgICAgICAnRm9yIGV4YW1wbGUsIFwiYXV0b1wiIGNhbm5vdCBiZSB1c2VkIHRvIGFsbG93IFwiYm90dG9tLXN0YXJ0XCIuJyxcbiAgICAgICAgICAnVXNlIFwiYXV0by1zdGFydFwiIGluc3RlYWQuJyxcbiAgICAgICAgXS5qb2luKCcgJylcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV06IEZsb3cgc2VlbXMgdG8gaGF2ZSBwcm9ibGVtcyB3aXRoIHR3byBhcnJheSB1bmlvbnMuLi5cbiAgY29uc3Qgb3ZlcmZsb3dzOiBPdmVyZmxvd3NNYXAgPSBhbGxvd2VkUGxhY2VtZW50cy5yZWR1Y2UoKGFjYywgcGxhY2VtZW50KSA9PiB7XG4gICAgYWNjW3BsYWNlbWVudF0gPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nLFxuICAgIH0pW2dldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KV07XG5cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKG92ZXJmbG93cykuc29ydCgoYSwgYikgPT4gb3ZlcmZsb3dzW2FdIC0gb3ZlcmZsb3dzW2JdKTtcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgdHlwZSB7IFBsYWNlbWVudCwgQm91bmRhcnksIFJvb3RCb3VuZGFyeSB9IGZyb20gJy4uL2VudW1zJztcbmltcG9ydCB0eXBlIHsgTW9kaWZpZXJBcmd1bWVudHMsIE1vZGlmaWVyLCBQYWRkaW5nIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IGdldE9wcG9zaXRlUGxhY2VtZW50IGZyb20gJy4uL3V0aWxzL2dldE9wcG9zaXRlUGxhY2VtZW50JztcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gJy4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQnO1xuaW1wb3J0IGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50IGZyb20gJy4uL3V0aWxzL2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50JztcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tICcuLi91dGlscy9kZXRlY3RPdmVyZmxvdyc7XG5pbXBvcnQgY29tcHV0ZUF1dG9QbGFjZW1lbnQgZnJvbSAnLi4vdXRpbHMvY29tcHV0ZUF1dG9QbGFjZW1lbnQnO1xuaW1wb3J0IHsgYm90dG9tLCB0b3AsIHN0YXJ0LCByaWdodCwgbGVmdCwgYXV0byB9IGZyb20gJy4uL2VudW1zJztcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSAnLi4vdXRpbHMvZ2V0VmFyaWF0aW9uJztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuZXhwb3J0IHR5cGUgT3B0aW9ucyA9IHtcbiAgbWFpbkF4aXM6IGJvb2xlYW4sXG4gIGFsdEF4aXM6IGJvb2xlYW4sXG4gIGZhbGxiYWNrUGxhY2VtZW50czogQXJyYXk8UGxhY2VtZW50PixcbiAgcGFkZGluZzogUGFkZGluZyxcbiAgYm91bmRhcnk6IEJvdW5kYXJ5LFxuICByb290Qm91bmRhcnk6IFJvb3RCb3VuZGFyeSxcbiAgYWx0Qm91bmRhcnk6IGJvb2xlYW4sXG4gIGZsaXBWYXJpYXRpb25zOiBib29sZWFuLFxuICBhbGxvd2VkQXV0b1BsYWNlbWVudHM6IEFycmF5PFBsYWNlbWVudD4sXG59O1xuXG5mdW5jdGlvbiBnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyhwbGFjZW1lbnQ6IFBsYWNlbWVudCk6IEFycmF5PFBsYWNlbWVudD4ge1xuICBpZiAoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3Qgb3Bwb3NpdGVQbGFjZW1lbnQgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuXG4gIHJldHVybiBbXG4gICAgZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQocGxhY2VtZW50KSxcbiAgICBvcHBvc2l0ZVBsYWNlbWVudCxcbiAgICBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChvcHBvc2l0ZVBsYWNlbWVudCksXG4gIF07XG59XG5cbmZ1bmN0aW9uIGZsaXAoeyBzdGF0ZSwgb3B0aW9ucywgbmFtZSB9OiBNb2RpZmllckFyZ3VtZW50czxPcHRpb25zPikge1xuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBtYWluQXhpczogY2hlY2tNYWluQXhpcyA9IHRydWUsXG4gICAgYWx0QXhpczogY2hlY2tBbHRBeGlzID0gdHJ1ZSxcbiAgICBmYWxsYmFja1BsYWNlbWVudHM6IHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyxcbiAgICBwYWRkaW5nLFxuICAgIGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeSxcbiAgICBhbHRCb3VuZGFyeSxcbiAgICBmbGlwVmFyaWF0aW9ucyA9IHRydWUsXG4gICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzLFxuICB9ID0gb3B0aW9ucztcblxuICBjb25zdCBwcmVmZXJyZWRQbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDtcbiAgY29uc3QgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocHJlZmVycmVkUGxhY2VtZW50KTtcbiAgY29uc3QgaXNCYXNlUGxhY2VtZW50ID0gYmFzZVBsYWNlbWVudCA9PT0gcHJlZmVycmVkUGxhY2VtZW50O1xuXG4gIGNvbnN0IGZhbGxiYWNrUGxhY2VtZW50cyA9XG4gICAgc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzIHx8XG4gICAgKGlzQmFzZVBsYWNlbWVudCB8fCAhZmxpcFZhcmlhdGlvbnNcbiAgICAgID8gW2dldE9wcG9zaXRlUGxhY2VtZW50KHByZWZlcnJlZFBsYWNlbWVudCldXG4gICAgICA6IGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHByZWZlcnJlZFBsYWNlbWVudCkpO1xuXG4gIGNvbnN0IHBsYWNlbWVudHMgPSBbcHJlZmVycmVkUGxhY2VtZW50LCAuLi5mYWxsYmFja1BsYWNlbWVudHNdLnJlZHVjZShcbiAgICAoYWNjLCBwbGFjZW1lbnQpID0+IHtcbiAgICAgIHJldHVybiBhY2MuY29uY2F0KFxuICAgICAgICBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgPT09IGF1dG9cbiAgICAgICAgICA/IGNvbXB1dGVBdXRvUGxhY2VtZW50KHN0YXRlLCB7XG4gICAgICAgICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgICAgICAgYm91bmRhcnksXG4gICAgICAgICAgICAgIHJvb3RCb3VuZGFyeSxcbiAgICAgICAgICAgICAgcGFkZGluZyxcbiAgICAgICAgICAgICAgZmxpcFZhcmlhdGlvbnMsXG4gICAgICAgICAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50cyxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgOiBwbGFjZW1lbnRcbiAgICAgICk7XG4gICAgfSxcbiAgICBbXVxuICApO1xuXG4gIGNvbnN0IHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIGNvbnN0IHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG5cbiAgY29uc3QgY2hlY2tzTWFwID0gbmV3IE1hcCgpO1xuICBsZXQgbWFrZUZhbGxiYWNrQ2hlY2tzID0gdHJ1ZTtcbiAgbGV0IGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudHNbMF07XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbGFjZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcGxhY2VtZW50ID0gcGxhY2VtZW50c1tpXTtcbiAgICBjb25zdCBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICAgIGNvbnN0IGlzU3RhcnRWYXJpYXRpb24gPSBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA9PT0gc3RhcnQ7XG4gICAgY29uc3QgaXNWZXJ0aWNhbCA9IFt0b3AsIGJvdHRvbV0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwO1xuICAgIGNvbnN0IGxlbiA9IGlzVmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG5cbiAgICBjb25zdCBvdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZyxcbiAgICB9KTtcblxuICAgIGxldCBtYWluVmFyaWF0aW9uU2lkZTogYW55ID0gaXNWZXJ0aWNhbFxuICAgICAgPyBpc1N0YXJ0VmFyaWF0aW9uXG4gICAgICAgID8gcmlnaHRcbiAgICAgICAgOiBsZWZ0XG4gICAgICA6IGlzU3RhcnRWYXJpYXRpb25cbiAgICAgID8gYm90dG9tXG4gICAgICA6IHRvcDtcblxuICAgIGlmIChyZWZlcmVuY2VSZWN0W2xlbl0gPiBwb3BwZXJSZWN0W2xlbl0pIHtcbiAgICAgIG1haW5WYXJpYXRpb25TaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpblZhcmlhdGlvblNpZGUpO1xuICAgIH1cblxuICAgIGNvbnN0IGFsdFZhcmlhdGlvblNpZGU6IGFueSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5WYXJpYXRpb25TaWRlKTtcblxuICAgIGNvbnN0IGNoZWNrcyA9IFtdO1xuXG4gICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgIGNoZWNrcy5wdXNoKG92ZXJmbG93W2Jhc2VQbGFjZW1lbnRdIDw9IDApO1xuICAgIH1cblxuICAgIGlmIChjaGVja0FsdEF4aXMpIHtcbiAgICAgIGNoZWNrcy5wdXNoKFxuICAgICAgICBvdmVyZmxvd1ttYWluVmFyaWF0aW9uU2lkZV0gPD0gMCxcbiAgICAgICAgb3ZlcmZsb3dbYWx0VmFyaWF0aW9uU2lkZV0gPD0gMFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tzLmV2ZXJ5KChjaGVjaykgPT4gY2hlY2spKSB7XG4gICAgICBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gICAgICBtYWtlRmFsbGJhY2tDaGVja3MgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNoZWNrc01hcC5zZXQocGxhY2VtZW50LCBjaGVja3MpO1xuICB9XG5cbiAgaWYgKG1ha2VGYWxsYmFja0NoZWNrcykge1xuICAgIC8vIGAyYCBtYXkgYmUgZGVzaXJlZCBpbiBzb21lIGNhc2VzIOKAkyByZXNlYXJjaCBsYXRlclxuICAgIGNvbnN0IG51bWJlck9mQ2hlY2tzID0gZmxpcFZhcmlhdGlvbnMgPyAzIDogMTtcblxuICAgIGZvciAobGV0IGkgPSBudW1iZXJPZkNoZWNrczsgaSA+IDA7IGktLSkge1xuICAgICAgY29uc3QgZml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudHMuZmluZCgocGxhY2VtZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGNoZWNrcyA9IGNoZWNrc01hcC5nZXQocGxhY2VtZW50KTtcbiAgICAgICAgaWYgKGNoZWNrcykge1xuICAgICAgICAgIHJldHVybiBjaGVja3Muc2xpY2UoMCwgaSkuZXZlcnkoKGNoZWNrKSA9PiBjaGVjayk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZml0dGluZ1BsYWNlbWVudCkge1xuICAgICAgICBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBmaXR0aW5nUGxhY2VtZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoc3RhdGUucGxhY2VtZW50ICE9PSBmaXJzdEZpdHRpbmdQbGFjZW1lbnQpIHtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdLl9za2lwID0gdHJ1ZTtcbiAgICBzdGF0ZS5wbGFjZW1lbnQgPSBmaXJzdEZpdHRpbmdQbGFjZW1lbnQ7XG4gICAgc3RhdGUucmVzZXQgPSB0cnVlO1xuICB9XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcbmV4cG9ydCB0eXBlIEZsaXBNb2RpZmllciA9IE1vZGlmaWVyPCdmbGlwJywgT3B0aW9ucz47XG5leHBvcnQgZGVmYXVsdCAoe1xuICBuYW1lOiAnZmxpcCcsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBmbGlwLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ29mZnNldCddLFxuICBkYXRhOiB7IF9za2lwOiBmYWxzZSB9LFxufTogRmxpcE1vZGlmaWVyKTtcbiIsIi8vIEBmbG93XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEFsdEF4aXMoYXhpczogJ3gnIHwgJ3knKTogJ3gnIHwgJ3knIHtcbiAgcmV0dXJuIGF4aXMgPT09ICd4JyA/ICd5JyA6ICd4Jztcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgeyBtYXggYXMgbWF0aE1heCwgbWluIGFzIG1hdGhNaW4gfSBmcm9tICcuL21hdGgnO1xuXG5leHBvcnQgZnVuY3Rpb24gd2l0aGluKG1pbjogbnVtYmVyLCB2YWx1ZTogbnVtYmVyLCBtYXg6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiBtYXRoTWF4KG1pbiwgbWF0aE1pbih2YWx1ZSwgbWF4KSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3aXRoaW5NYXhDbGFtcChtaW46IG51bWJlciwgdmFsdWU6IG51bWJlciwgbWF4OiBudW1iZXIpIHtcbiAgY29uc3QgdiA9IHdpdGhpbihtaW4sIHZhbHVlLCBtYXgpO1xuICByZXR1cm4gdiA+IG1heCA/IG1heCA6IHY7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHsgdG9wLCBsZWZ0LCByaWdodCwgYm90dG9tLCBzdGFydCB9IGZyb20gJy4uL2VudW1zJztcbmltcG9ydCB0eXBlIHsgUGxhY2VtZW50LCBCb3VuZGFyeSwgUm9vdEJvdW5kYXJ5IH0gZnJvbSAnLi4vZW51bXMnO1xuaW1wb3J0IHR5cGUgeyBSZWN0LCBNb2RpZmllckFyZ3VtZW50cywgTW9kaWZpZXIsIFBhZGRpbmcgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tICcuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50JztcbmltcG9ydCBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQgZnJvbSAnLi4vdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50JztcbmltcG9ydCBnZXRBbHRBeGlzIGZyb20gJy4uL3V0aWxzL2dldEFsdEF4aXMnO1xuaW1wb3J0IHsgd2l0aGluLCB3aXRoaW5NYXhDbGFtcCB9IGZyb20gJy4uL3V0aWxzL3dpdGhpbic7XG5pbXBvcnQgZ2V0TGF5b3V0UmVjdCBmcm9tICcuLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdCc7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gJy4uL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQnO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gJy4uL3V0aWxzL2RldGVjdE92ZXJmbG93JztcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSAnLi4vdXRpbHMvZ2V0VmFyaWF0aW9uJztcbmltcG9ydCBnZXRGcmVzaFNpZGVPYmplY3QgZnJvbSAnLi4vdXRpbHMvZ2V0RnJlc2hTaWRlT2JqZWN0JztcbmltcG9ydCB7IG1pbiBhcyBtYXRoTWluLCBtYXggYXMgbWF0aE1heCB9IGZyb20gJy4uL3V0aWxzL21hdGgnO1xuXG50eXBlIFRldGhlck9mZnNldCA9XG4gIHwgKCh7XG4gICAgICBwb3BwZXI6IFJlY3QsXG4gICAgICByZWZlcmVuY2U6IFJlY3QsXG4gICAgICBwbGFjZW1lbnQ6IFBsYWNlbWVudCxcbiAgICB9KSA9PiBudW1iZXIgfCB7IG1haW5BeGlzOiBudW1iZXIsIGFsdEF4aXM6IG51bWJlciB9KVxuICB8IG51bWJlclxuICB8IHsgbWFpbkF4aXM6IG51bWJlciwgYWx0QXhpczogbnVtYmVyIH07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcbmV4cG9ydCB0eXBlIE9wdGlvbnMgPSB7XG4gIC8qIFByZXZlbnRzIGJvdW5kYXJpZXMgb3ZlcmZsb3cgb24gdGhlIG1haW4gYXhpcyAqL1xuICBtYWluQXhpczogYm9vbGVhbixcbiAgLyogUHJldmVudHMgYm91bmRhcmllcyBvdmVyZmxvdyBvbiB0aGUgYWx0ZXJuYXRlIGF4aXMgKi9cbiAgYWx0QXhpczogYm9vbGVhbixcbiAgLyogVGhlIGFyZWEgdG8gY2hlY2sgdGhlIHBvcHBlciBpcyBvdmVyZmxvd2luZyBpbiAqL1xuICBib3VuZGFyeTogQm91bmRhcnksXG4gIC8qIElmIHRoZSBwb3BwZXIgaXMgbm90IG92ZXJmbG93aW5nIHRoZSBtYWluIGFyZWEsIGZhbGxiYWNrIHRvIHRoaXMgb25lICovXG4gIHJvb3RCb3VuZGFyeTogUm9vdEJvdW5kYXJ5LFxuICAvKiBVc2UgdGhlIHJlZmVyZW5jZSdzIFwiY2xpcHBpbmdQYXJlbnRzXCIgYm91bmRhcnkgY29udGV4dCAqL1xuICBhbHRCb3VuZGFyeTogYm9vbGVhbixcbiAgLyoqXG4gICAqIEFsbG93cyB0aGUgcG9wcGVyIHRvIG92ZXJmbG93IGZyb20gaXRzIGJvdW5kYXJpZXMgdG8ga2VlcCBpdCBuZWFyIGl0c1xuICAgKiByZWZlcmVuY2UgZWxlbWVudFxuICAgKi9cbiAgdGV0aGVyOiBib29sZWFuLFxuICAvKiBPZmZzZXRzIHdoZW4gdGhlIGB0ZXRoZXJgIG9wdGlvbiBzaG91bGQgYWN0aXZhdGUgKi9cbiAgdGV0aGVyT2Zmc2V0OiBUZXRoZXJPZmZzZXQsXG4gIC8qIFNldHMgYSBwYWRkaW5nIHRvIHRoZSBwcm92aWRlZCBib3VuZGFyeSAqL1xuICBwYWRkaW5nOiBQYWRkaW5nLFxufTtcblxuZnVuY3Rpb24gcHJldmVudE92ZXJmbG93KHsgc3RhdGUsIG9wdGlvbnMsIG5hbWUgfTogTW9kaWZpZXJBcmd1bWVudHM8T3B0aW9ucz4pIHtcbiAgY29uc3Qge1xuICAgIG1haW5BeGlzOiBjaGVja01haW5BeGlzID0gdHJ1ZSxcbiAgICBhbHRBeGlzOiBjaGVja0FsdEF4aXMgPSBmYWxzZSxcbiAgICBib3VuZGFyeSxcbiAgICByb290Qm91bmRhcnksXG4gICAgYWx0Qm91bmRhcnksXG4gICAgcGFkZGluZyxcbiAgICB0ZXRoZXIgPSB0cnVlLFxuICAgIHRldGhlck9mZnNldCA9IDAsXG4gIH0gPSBvcHRpb25zO1xuXG4gIGNvbnN0IG92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBib3VuZGFyeSxcbiAgICByb290Qm91bmRhcnksXG4gICAgcGFkZGluZyxcbiAgICBhbHRCb3VuZGFyeSxcbiAgfSk7XG4gIGNvbnN0IGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCk7XG4gIGNvbnN0IHZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihzdGF0ZS5wbGFjZW1lbnQpO1xuICBjb25zdCBpc0Jhc2VQbGFjZW1lbnQgPSAhdmFyaWF0aW9uO1xuICBjb25zdCBtYWluQXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KTtcbiAgY29uc3QgYWx0QXhpcyA9IGdldEFsdEF4aXMobWFpbkF4aXMpO1xuICBjb25zdCBwb3BwZXJPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzO1xuICBjb25zdCByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICBjb25zdCBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICBjb25zdCB0ZXRoZXJPZmZzZXRWYWx1ZSA9XG4gICAgdHlwZW9mIHRldGhlck9mZnNldCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyB0ZXRoZXJPZmZzZXQoe1xuICAgICAgICAgIC4uLnN0YXRlLnJlY3RzLFxuICAgICAgICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50LFxuICAgICAgICB9KVxuICAgICAgOiB0ZXRoZXJPZmZzZXQ7XG4gIGNvbnN0IG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZSA9XG4gICAgdHlwZW9mIHRldGhlck9mZnNldFZhbHVlID09PSAnbnVtYmVyJ1xuICAgICAgPyB7IG1haW5BeGlzOiB0ZXRoZXJPZmZzZXRWYWx1ZSwgYWx0QXhpczogdGV0aGVyT2Zmc2V0VmFsdWUgfVxuICAgICAgOiB7IG1haW5BeGlzOiAwLCBhbHRBeGlzOiAwLCAuLi50ZXRoZXJPZmZzZXRWYWx1ZSB9O1xuICBjb25zdCBvZmZzZXRNb2RpZmllclN0YXRlID0gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXRcbiAgICA/IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0W3N0YXRlLnBsYWNlbWVudF1cbiAgICA6IG51bGw7XG5cbiAgY29uc3QgZGF0YSA9IHsgeDogMCwgeTogMCB9O1xuXG4gIGlmICghcG9wcGVyT2Zmc2V0cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgY29uc3QgbWFpblNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gdG9wIDogbGVmdDtcbiAgICBjb25zdCBhbHRTaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/IGJvdHRvbSA6IHJpZ2h0O1xuICAgIGNvbnN0IGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgY29uc3Qgb2Zmc2V0ID0gcG9wcGVyT2Zmc2V0c1ttYWluQXhpc107XG5cbiAgICBjb25zdCBtaW4gPSBvZmZzZXQgKyBvdmVyZmxvd1ttYWluU2lkZV07XG4gICAgY29uc3QgbWF4ID0gb2Zmc2V0IC0gb3ZlcmZsb3dbYWx0U2lkZV07XG5cbiAgICBjb25zdCBhZGRpdGl2ZSA9IHRldGhlciA/IC1wb3BwZXJSZWN0W2xlbl0gLyAyIDogMDtcblxuICAgIGNvbnN0IG1pbkxlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gOiBwb3BwZXJSZWN0W2xlbl07XG4gICAgY29uc3QgbWF4TGVuID0gdmFyaWF0aW9uID09PSBzdGFydCA/IC1wb3BwZXJSZWN0W2xlbl0gOiAtcmVmZXJlbmNlUmVjdFtsZW5dO1xuXG4gICAgLy8gV2UgbmVlZCB0byBpbmNsdWRlIHRoZSBhcnJvdyBpbiB0aGUgY2FsY3VsYXRpb24gc28gdGhlIGFycm93IGRvZXNuJ3QgZ29cbiAgICAvLyBvdXRzaWRlIHRoZSByZWZlcmVuY2UgYm91bmRzXG4gICAgY29uc3QgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XG4gICAgY29uc3QgYXJyb3dSZWN0ID1cbiAgICAgIHRldGhlciAmJiBhcnJvd0VsZW1lbnRcbiAgICAgICAgPyBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudClcbiAgICAgICAgOiB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcbiAgICBjb25zdCBhcnJvd1BhZGRpbmdPYmplY3QgPSBzdGF0ZS5tb2RpZmllcnNEYXRhWydhcnJvdyNwZXJzaXN0ZW50J11cbiAgICAgID8gc3RhdGUubW9kaWZpZXJzRGF0YVsnYXJyb3cjcGVyc2lzdGVudCddLnBhZGRpbmdcbiAgICAgIDogZ2V0RnJlc2hTaWRlT2JqZWN0KCk7XG4gICAgY29uc3QgYXJyb3dQYWRkaW5nTWluID0gYXJyb3dQYWRkaW5nT2JqZWN0W21haW5TaWRlXTtcbiAgICBjb25zdCBhcnJvd1BhZGRpbmdNYXggPSBhcnJvd1BhZGRpbmdPYmplY3RbYWx0U2lkZV07XG5cbiAgICAvLyBJZiB0aGUgcmVmZXJlbmNlIGxlbmd0aCBpcyBzbWFsbGVyIHRoYW4gdGhlIGFycm93IGxlbmd0aCwgd2UgZG9uJ3Qgd2FudFxuICAgIC8vIHRvIGluY2x1ZGUgaXRzIGZ1bGwgc2l6ZSBpbiB0aGUgY2FsY3VsYXRpb24uIElmIHRoZSByZWZlcmVuY2UgaXMgc21hbGxcbiAgICAvLyBhbmQgbmVhciB0aGUgZWRnZSBvZiBhIGJvdW5kYXJ5LCB0aGUgcG9wcGVyIGNhbiBvdmVyZmxvdyBldmVuIGlmIHRoZVxuICAgIC8vIHJlZmVyZW5jZSBpcyBub3Qgb3ZlcmZsb3dpbmcgYXMgd2VsbCAoZS5nLiB2aXJ0dWFsIGVsZW1lbnRzIHdpdGggbm9cbiAgICAvLyB3aWR0aCBvciBoZWlnaHQpXG4gICAgY29uc3QgYXJyb3dMZW4gPSB3aXRoaW4oMCwgcmVmZXJlbmNlUmVjdFtsZW5dLCBhcnJvd1JlY3RbbGVuXSk7XG5cbiAgICBjb25zdCBtaW5PZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnRcbiAgICAgID8gcmVmZXJlbmNlUmVjdFtsZW5dIC8gMiAtXG4gICAgICAgIGFkZGl0aXZlIC1cbiAgICAgICAgYXJyb3dMZW4gLVxuICAgICAgICBhcnJvd1BhZGRpbmdNaW4gLVxuICAgICAgICBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXNcbiAgICAgIDogbWluTGVuIC1cbiAgICAgICAgYXJyb3dMZW4gLVxuICAgICAgICBhcnJvd1BhZGRpbmdNaW4gLVxuICAgICAgICBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXM7XG4gICAgY29uc3QgbWF4T2Zmc2V0ID0gaXNCYXNlUGxhY2VtZW50XG4gICAgICA/IC1yZWZlcmVuY2VSZWN0W2xlbl0gLyAyICtcbiAgICAgICAgYWRkaXRpdmUgK1xuICAgICAgICBhcnJvd0xlbiArXG4gICAgICAgIGFycm93UGFkZGluZ01heCArXG4gICAgICAgIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpc1xuICAgICAgOiBtYXhMZW4gK1xuICAgICAgICBhcnJvd0xlbiArXG4gICAgICAgIGFycm93UGFkZGluZ01heCArXG4gICAgICAgIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcztcblxuICAgIGNvbnN0IGFycm93T2Zmc2V0UGFyZW50ID1cbiAgICAgIHN0YXRlLmVsZW1lbnRzLmFycm93ICYmIGdldE9mZnNldFBhcmVudChzdGF0ZS5lbGVtZW50cy5hcnJvdyk7XG4gICAgY29uc3QgY2xpZW50T2Zmc2V0ID0gYXJyb3dPZmZzZXRQYXJlbnRcbiAgICAgID8gbWFpbkF4aXMgPT09ICd5J1xuICAgICAgICA/IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudFRvcCB8fCAwXG4gICAgICAgIDogYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50TGVmdCB8fCAwXG4gICAgICA6IDA7XG5cbiAgICBjb25zdCBvZmZzZXRNb2RpZmllclZhbHVlID0gb2Zmc2V0TW9kaWZpZXJTdGF0ZT8uW21haW5BeGlzXSA/PyAwO1xuICAgIGNvbnN0IHRldGhlck1pbiA9IG9mZnNldCArIG1pbk9mZnNldCAtIG9mZnNldE1vZGlmaWVyVmFsdWUgLSBjbGllbnRPZmZzZXQ7XG4gICAgY29uc3QgdGV0aGVyTWF4ID0gb2Zmc2V0ICsgbWF4T2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZTtcblxuICAgIGNvbnN0IHByZXZlbnRlZE9mZnNldCA9IHdpdGhpbihcbiAgICAgIHRldGhlciA/IG1hdGhNaW4obWluLCB0ZXRoZXJNaW4pIDogbWluLFxuICAgICAgb2Zmc2V0LFxuICAgICAgdGV0aGVyID8gbWF0aE1heChtYXgsIHRldGhlck1heCkgOiBtYXhcbiAgICApO1xuXG4gICAgcG9wcGVyT2Zmc2V0c1ttYWluQXhpc10gPSBwcmV2ZW50ZWRPZmZzZXQ7XG4gICAgZGF0YVttYWluQXhpc10gPSBwcmV2ZW50ZWRPZmZzZXQgLSBvZmZzZXQ7XG4gIH1cblxuICBpZiAoY2hlY2tBbHRBeGlzKSB7XG4gICAgY29uc3QgbWFpblNpZGUgPSBtYWluQXhpcyA9PT0gJ3gnID8gdG9wIDogbGVmdDtcbiAgICBjb25zdCBhbHRTaWRlID0gbWFpbkF4aXMgPT09ICd4JyA/IGJvdHRvbSA6IHJpZ2h0O1xuICAgIGNvbnN0IG9mZnNldCA9IHBvcHBlck9mZnNldHNbYWx0QXhpc107XG5cbiAgICBjb25zdCBsZW4gPSBhbHRBeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgICBjb25zdCBtaW4gPSBvZmZzZXQgKyBvdmVyZmxvd1ttYWluU2lkZV07XG4gICAgY29uc3QgbWF4ID0gb2Zmc2V0IC0gb3ZlcmZsb3dbYWx0U2lkZV07XG5cbiAgICBjb25zdCBpc09yaWdpblNpZGUgPSBbdG9wLCBsZWZ0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICAgIGNvbnN0IG9mZnNldE1vZGlmaWVyVmFsdWUgPSBvZmZzZXRNb2RpZmllclN0YXRlPy5bYWx0QXhpc10gPz8gMDtcbiAgICBjb25zdCB0ZXRoZXJNaW4gPSBpc09yaWdpblNpZGVcbiAgICAgID8gbWluXG4gICAgICA6IG9mZnNldCAtXG4gICAgICAgIHJlZmVyZW5jZVJlY3RbbGVuXSAtXG4gICAgICAgIHBvcHBlclJlY3RbbGVuXSAtXG4gICAgICAgIG9mZnNldE1vZGlmaWVyVmFsdWUgK1xuICAgICAgICBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUuYWx0QXhpcztcbiAgICBjb25zdCB0ZXRoZXJNYXggPSBpc09yaWdpblNpZGVcbiAgICAgID8gb2Zmc2V0ICtcbiAgICAgICAgcmVmZXJlbmNlUmVjdFtsZW5dICtcbiAgICAgICAgcG9wcGVyUmVjdFtsZW5dIC1cbiAgICAgICAgb2Zmc2V0TW9kaWZpZXJWYWx1ZSAtXG4gICAgICAgIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5hbHRBeGlzXG4gICAgICA6IG1heDtcblxuICAgIGNvbnN0IHByZXZlbnRlZE9mZnNldCA9XG4gICAgICB0ZXRoZXIgJiYgaXNPcmlnaW5TaWRlXG4gICAgICAgID8gd2l0aGluTWF4Q2xhbXAodGV0aGVyTWluLCBvZmZzZXQsIHRldGhlck1heClcbiAgICAgICAgOiB3aXRoaW4odGV0aGVyID8gdGV0aGVyTWluIDogbWluLCBvZmZzZXQsIHRldGhlciA/IHRldGhlck1heCA6IG1heCk7XG5cbiAgICBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdID0gcHJldmVudGVkT2Zmc2V0O1xuICAgIGRhdGFbYWx0QXhpc10gPSBwcmV2ZW50ZWRPZmZzZXQgLSBvZmZzZXQ7XG4gIH1cblxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gZGF0YTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuZXhwb3J0IHR5cGUgUHJldmVudE92ZXJmbG93TW9kaWZpZXIgPSBNb2RpZmllcjwncHJldmVudE92ZXJmbG93JywgT3B0aW9ucz47XG5leHBvcnQgZGVmYXVsdCAoe1xuICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IHByZXZlbnRPdmVyZmxvdyxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydvZmZzZXQnXSxcbn06IFByZXZlbnRPdmVyZmxvd01vZGlmaWVyKTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgdHlwZSB7IE1vZGlmaWVyLCBNb2RpZmllckFyZ3VtZW50cywgUGFkZGluZywgUmVjdCB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB0eXBlIHsgUGxhY2VtZW50IH0gZnJvbSAnLi4vZW51bXMnO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSAnLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudCc7XG5pbXBvcnQgZ2V0TGF5b3V0UmVjdCBmcm9tICcuLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdCc7XG5pbXBvcnQgY29udGFpbnMgZnJvbSAnLi4vZG9tLXV0aWxzL2NvbnRhaW5zJztcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSAnLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudCc7XG5pbXBvcnQgZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50IGZyb20gJy4uL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudCc7XG5pbXBvcnQgeyB3aXRoaW4gfSBmcm9tICcuLi91dGlscy93aXRoaW4nO1xuaW1wb3J0IG1lcmdlUGFkZGluZ09iamVjdCBmcm9tICcuLi91dGlscy9tZXJnZVBhZGRpbmdPYmplY3QnO1xuaW1wb3J0IGV4cGFuZFRvSGFzaE1hcCBmcm9tICcuLi91dGlscy9leHBhbmRUb0hhc2hNYXAnO1xuaW1wb3J0IHsgbGVmdCwgcmlnaHQsIGJhc2VQbGFjZW1lbnRzLCB0b3AsIGJvdHRvbSB9IGZyb20gJy4uL2VudW1zJztcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tICcuLi9kb20tdXRpbHMvaW5zdGFuY2VPZic7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcbmV4cG9ydCB0eXBlIE9wdGlvbnMgPSB7XG4gIGVsZW1lbnQ6IEhUTUxFbGVtZW50IHwgc3RyaW5nIHwgbnVsbCxcbiAgcGFkZGluZzpcbiAgICB8IFBhZGRpbmdcbiAgICB8ICgoe3xcbiAgICAgICAgcG9wcGVyOiBSZWN0LFxuICAgICAgICByZWZlcmVuY2U6IFJlY3QsXG4gICAgICAgIHBsYWNlbWVudDogUGxhY2VtZW50LFxuICAgICAgfH0pID0+IFBhZGRpbmcpLFxufTtcblxuY29uc3QgdG9QYWRkaW5nT2JqZWN0ID0gKHBhZGRpbmcsIHN0YXRlKSA9PiB7XG4gIHBhZGRpbmcgPVxuICAgIHR5cGVvZiBwYWRkaW5nID09PSAnZnVuY3Rpb24nXG4gICAgICA/IHBhZGRpbmcoeyAuLi5zdGF0ZS5yZWN0cywgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnQgfSlcbiAgICAgIDogcGFkZGluZztcblxuICByZXR1cm4gbWVyZ2VQYWRkaW5nT2JqZWN0KFxuICAgIHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJ1xuICAgICAgPyBwYWRkaW5nXG4gICAgICA6IGV4cGFuZFRvSGFzaE1hcChwYWRkaW5nLCBiYXNlUGxhY2VtZW50cylcbiAgKTtcbn07XG5cbmZ1bmN0aW9uIGFycm93KHsgc3RhdGUsIG5hbWUsIG9wdGlvbnMgfTogTW9kaWZpZXJBcmd1bWVudHM8T3B0aW9ucz4pIHtcbiAgY29uc3QgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XG4gIGNvbnN0IHBvcHBlck9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHM7XG4gIGNvbnN0IGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCk7XG4gIGNvbnN0IGF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCk7XG4gIGNvbnN0IGlzVmVydGljYWwgPSBbbGVmdCwgcmlnaHRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMDtcbiAgY29uc3QgbGVuID0gaXNWZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICBpZiAoIWFycm93RWxlbWVudCB8fCAhcG9wcGVyT2Zmc2V0cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHBhZGRpbmdPYmplY3QgPSB0b1BhZGRpbmdPYmplY3Qob3B0aW9ucy5wYWRkaW5nLCBzdGF0ZSk7XG4gIGNvbnN0IGFycm93UmVjdCA9IGdldExheW91dFJlY3QoYXJyb3dFbGVtZW50KTtcbiAgY29uc3QgbWluUHJvcCA9IGF4aXMgPT09ICd5JyA/IHRvcCA6IGxlZnQ7XG4gIGNvbnN0IG1heFByb3AgPSBheGlzID09PSAneScgPyBib3R0b20gOiByaWdodDtcblxuICBjb25zdCBlbmREaWZmID1cbiAgICBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbbGVuXSArXG4gICAgc3RhdGUucmVjdHMucmVmZXJlbmNlW2F4aXNdIC1cbiAgICBwb3BwZXJPZmZzZXRzW2F4aXNdIC1cbiAgICBzdGF0ZS5yZWN0cy5wb3BwZXJbbGVuXTtcbiAgY29uc3Qgc3RhcnREaWZmID0gcG9wcGVyT2Zmc2V0c1theGlzXSAtIHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtheGlzXTtcblxuICBjb25zdCBhcnJvd09mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChhcnJvd0VsZW1lbnQpO1xuICBjb25zdCBjbGllbnRTaXplID0gYXJyb3dPZmZzZXRQYXJlbnRcbiAgICA/IGF4aXMgPT09ICd5J1xuICAgICAgPyBhcnJvd09mZnNldFBhcmVudC5jbGllbnRIZWlnaHQgfHwgMFxuICAgICAgOiBhcnJvd09mZnNldFBhcmVudC5jbGllbnRXaWR0aCB8fCAwXG4gICAgOiAwO1xuXG4gIGNvbnN0IGNlbnRlclRvUmVmZXJlbmNlID0gZW5kRGlmZiAvIDIgLSBzdGFydERpZmYgLyAyO1xuXG4gIC8vIE1ha2Ugc3VyZSB0aGUgYXJyb3cgZG9lc24ndCBvdmVyZmxvdyB0aGUgcG9wcGVyIGlmIHRoZSBjZW50ZXIgcG9pbnQgaXNcbiAgLy8gb3V0c2lkZSBvZiB0aGUgcG9wcGVyIGJvdW5kc1xuICBjb25zdCBtaW4gPSBwYWRkaW5nT2JqZWN0W21pblByb3BdO1xuICBjb25zdCBtYXggPSBjbGllbnRTaXplIC0gYXJyb3dSZWN0W2xlbl0gLSBwYWRkaW5nT2JqZWN0W21heFByb3BdO1xuICBjb25zdCBjZW50ZXIgPSBjbGllbnRTaXplIC8gMiAtIGFycm93UmVjdFtsZW5dIC8gMiArIGNlbnRlclRvUmVmZXJlbmNlO1xuICBjb25zdCBvZmZzZXQgPSB3aXRoaW4obWluLCBjZW50ZXIsIG1heCk7XG5cbiAgLy8gUHJldmVudHMgYnJlYWtpbmcgc3ludGF4IGhpZ2hsaWdodGluZy4uLlxuICBjb25zdCBheGlzUHJvcDogc3RyaW5nID0gYXhpcztcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IHtcbiAgICBbYXhpc1Byb3BdOiBvZmZzZXQsXG4gICAgY2VudGVyT2Zmc2V0OiBvZmZzZXQgLSBjZW50ZXIsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGVmZmVjdCh7IHN0YXRlLCBvcHRpb25zIH06IE1vZGlmaWVyQXJndW1lbnRzPE9wdGlvbnM+KSB7XG4gIGxldCB7IGVsZW1lbnQ6IGFycm93RWxlbWVudCA9ICdbZGF0YS1wb3BwZXItYXJyb3ddJyB9ID0gb3B0aW9ucztcblxuICBpZiAoYXJyb3dFbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBDU1Mgc2VsZWN0b3JcbiAgaWYgKHR5cGVvZiBhcnJvd0VsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMucG9wcGVyLnF1ZXJ5U2VsZWN0b3IoYXJyb3dFbGVtZW50KTtcblxuICAgIGlmICghYXJyb3dFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKF9fREVWX18pIHtcbiAgICBpZiAoIWlzSFRNTEVsZW1lbnQoYXJyb3dFbGVtZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgW1xuICAgICAgICAgICdQb3BwZXI6IFwiYXJyb3dcIiBlbGVtZW50IG11c3QgYmUgYW4gSFRNTEVsZW1lbnQgKG5vdCBhbiBTVkdFbGVtZW50KS4nLFxuICAgICAgICAgICdUbyB1c2UgYW4gU1ZHIGFycm93LCB3cmFwIGl0IGluIGFuIEhUTUxFbGVtZW50IHRoYXQgd2lsbCBiZSB1c2VkIGFzJyxcbiAgICAgICAgICAndGhlIGFycm93LicsXG4gICAgICAgIF0uam9pbignICcpXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29udGFpbnMoc3RhdGUuZWxlbWVudHMucG9wcGVyLCBhcnJvd0VsZW1lbnQpKSB7XG4gICAgaWYgKF9fREVWX18pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFtcbiAgICAgICAgICAnUG9wcGVyOiBcImFycm93XCIgbW9kaWZpZXJcXCdzIGBlbGVtZW50YCBtdXN0IGJlIGEgY2hpbGQgb2YgdGhlIHBvcHBlcicsXG4gICAgICAgICAgJ2VsZW1lbnQuJyxcbiAgICAgICAgXS5qb2luKCcgJylcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3RhdGUuZWxlbWVudHMuYXJyb3cgPSBhcnJvd0VsZW1lbnQ7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcbmV4cG9ydCB0eXBlIEFycm93TW9kaWZpZXIgPSBNb2RpZmllcjwnYXJyb3cnLCBPcHRpb25zPjtcbmV4cG9ydCBkZWZhdWx0ICh7XG4gIG5hbWU6ICdhcnJvdycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBhcnJvdyxcbiAgZWZmZWN0LFxuICByZXF1aXJlczogWydwb3BwZXJPZmZzZXRzJ10sXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsncHJldmVudE92ZXJmbG93J10sXG59OiBBcnJvd01vZGlmaWVyKTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgdHlwZSB7XG4gIE1vZGlmaWVyQXJndW1lbnRzLFxuICBNb2RpZmllcixcbiAgUmVjdCxcbiAgU2lkZU9iamVjdCxcbiAgT2Zmc2V0cyxcbn0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgdG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0IH0gZnJvbSAnLi4vZW51bXMnO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gJy4uL3V0aWxzL2RldGVjdE92ZXJmbG93JztcblxuZnVuY3Rpb24gZ2V0U2lkZU9mZnNldHMoXG4gIG92ZXJmbG93OiBTaWRlT2JqZWN0LFxuICByZWN0OiBSZWN0LFxuICBwcmV2ZW50ZWRPZmZzZXRzOiBPZmZzZXRzID0geyB4OiAwLCB5OiAwIH1cbik6IFNpZGVPYmplY3Qge1xuICByZXR1cm4ge1xuICAgIHRvcDogb3ZlcmZsb3cudG9wIC0gcmVjdC5oZWlnaHQgLSBwcmV2ZW50ZWRPZmZzZXRzLnksXG4gICAgcmlnaHQ6IG92ZXJmbG93LnJpZ2h0IC0gcmVjdC53aWR0aCArIHByZXZlbnRlZE9mZnNldHMueCxcbiAgICBib3R0b206IG92ZXJmbG93LmJvdHRvbSAtIHJlY3QuaGVpZ2h0ICsgcHJldmVudGVkT2Zmc2V0cy55LFxuICAgIGxlZnQ6IG92ZXJmbG93LmxlZnQgLSByZWN0LndpZHRoIC0gcHJldmVudGVkT2Zmc2V0cy54LFxuICB9O1xufVxuXG5mdW5jdGlvbiBpc0FueVNpZGVGdWxseUNsaXBwZWQob3ZlcmZsb3c6IFNpZGVPYmplY3QpOiBib29sZWFuIHtcbiAgcmV0dXJuIFt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRdLnNvbWUoKHNpZGUpID0+IG92ZXJmbG93W3NpZGVdID49IDApO1xufVxuXG5mdW5jdGlvbiBoaWRlKHsgc3RhdGUsIG5hbWUgfTogTW9kaWZpZXJBcmd1bWVudHM8e3x8fT4pIHtcbiAgY29uc3QgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgY29uc3QgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgY29uc3QgcHJldmVudGVkT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucHJldmVudE92ZXJmbG93O1xuXG4gIGNvbnN0IHJlZmVyZW5jZU92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBlbGVtZW50Q29udGV4dDogJ3JlZmVyZW5jZScsXG4gIH0pO1xuICBjb25zdCBwb3BwZXJBbHRPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgYWx0Qm91bmRhcnk6IHRydWUsXG4gIH0pO1xuXG4gIGNvbnN0IHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKFxuICAgIHJlZmVyZW5jZU92ZXJmbG93LFxuICAgIHJlZmVyZW5jZVJlY3RcbiAgKTtcbiAgY29uc3QgcG9wcGVyRXNjYXBlT2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKFxuICAgIHBvcHBlckFsdE92ZXJmbG93LFxuICAgIHBvcHBlclJlY3QsXG4gICAgcHJldmVudGVkT2Zmc2V0c1xuICApO1xuXG4gIGNvbnN0IGlzUmVmZXJlbmNlSGlkZGVuID0gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyk7XG4gIGNvbnN0IGhhc1BvcHBlckVzY2FwZWQgPSBpc0FueVNpZGVGdWxseUNsaXBwZWQocG9wcGVyRXNjYXBlT2Zmc2V0cyk7XG5cbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IHtcbiAgICByZWZlcmVuY2VDbGlwcGluZ09mZnNldHMsXG4gICAgcG9wcGVyRXNjYXBlT2Zmc2V0cyxcbiAgICBpc1JlZmVyZW5jZUhpZGRlbixcbiAgICBoYXNQb3BwZXJFc2NhcGVkLFxuICB9O1xuXG4gIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0ge1xuICAgIC4uLnN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyLFxuICAgICdkYXRhLXBvcHBlci1yZWZlcmVuY2UtaGlkZGVuJzogaXNSZWZlcmVuY2VIaWRkZW4sXG4gICAgJ2RhdGEtcG9wcGVyLWVzY2FwZWQnOiBoYXNQb3BwZXJFc2NhcGVkLFxuICB9O1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgdHlwZSBIaWRlTW9kaWZpZXIgPSBNb2RpZmllcjwnaGlkZScsIHt8fH0+O1xuZXhwb3J0IGRlZmF1bHQgKHtcbiAgbmFtZTogJ2hpZGUnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddLFxuICBmbjogaGlkZSxcbn06IEhpZGVNb2RpZmllcik7XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHsgcG9wcGVyR2VuZXJhdG9yLCBkZXRlY3RPdmVyZmxvdyB9IGZyb20gJy4vY3JlYXRlUG9wcGVyJztcblxuaW1wb3J0IGV2ZW50TGlzdGVuZXJzIGZyb20gJy4vbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzJztcbmltcG9ydCBwb3BwZXJPZmZzZXRzIGZyb20gJy4vbW9kaWZpZXJzL3BvcHBlck9mZnNldHMnO1xuaW1wb3J0IGNvbXB1dGVTdHlsZXMgZnJvbSAnLi9tb2RpZmllcnMvY29tcHV0ZVN0eWxlcyc7XG5pbXBvcnQgYXBwbHlTdHlsZXMgZnJvbSAnLi9tb2RpZmllcnMvYXBwbHlTdHlsZXMnO1xuXG5leHBvcnQgdHlwZSAqIGZyb20gJy4vdHlwZXMnO1xuXG5jb25zdCBkZWZhdWx0TW9kaWZpZXJzID0gW1xuICBldmVudExpc3RlbmVycyxcbiAgcG9wcGVyT2Zmc2V0cyxcbiAgY29tcHV0ZVN0eWxlcyxcbiAgYXBwbHlTdHlsZXMsXG5dO1xuXG5jb25zdCBjcmVhdGVQb3BwZXIgPSBwb3BwZXJHZW5lcmF0b3IoeyBkZWZhdWx0TW9kaWZpZXJzIH0pO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgeyBjcmVhdGVQb3BwZXIsIHBvcHBlckdlbmVyYXRvciwgZGVmYXVsdE1vZGlmaWVycywgZGV0ZWN0T3ZlcmZsb3cgfTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgeyBwb3BwZXJHZW5lcmF0b3IsIGRldGVjdE92ZXJmbG93IH0gZnJvbSAnLi9jcmVhdGVQb3BwZXInO1xuXG5pbXBvcnQgZXZlbnRMaXN0ZW5lcnMgZnJvbSAnLi9tb2RpZmllcnMvZXZlbnRMaXN0ZW5lcnMnO1xuaW1wb3J0IHBvcHBlck9mZnNldHMgZnJvbSAnLi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cyc7XG5pbXBvcnQgY29tcHV0ZVN0eWxlcyBmcm9tICcuL21vZGlmaWVycy9jb21wdXRlU3R5bGVzJztcbmltcG9ydCBhcHBseVN0eWxlcyBmcm9tICcuL21vZGlmaWVycy9hcHBseVN0eWxlcyc7XG5pbXBvcnQgb2Zmc2V0IGZyb20gJy4vbW9kaWZpZXJzL29mZnNldCc7XG5pbXBvcnQgZmxpcCBmcm9tICcuL21vZGlmaWVycy9mbGlwJztcbmltcG9ydCBwcmV2ZW50T3ZlcmZsb3cgZnJvbSAnLi9tb2RpZmllcnMvcHJldmVudE92ZXJmbG93JztcbmltcG9ydCBhcnJvdyBmcm9tICcuL21vZGlmaWVycy9hcnJvdyc7XG5pbXBvcnQgaGlkZSBmcm9tICcuL21vZGlmaWVycy9oaWRlJztcblxuZXhwb3J0IHR5cGUgKiBmcm9tICcuL3R5cGVzJztcblxuY29uc3QgZGVmYXVsdE1vZGlmaWVycyA9IFtcbiAgZXZlbnRMaXN0ZW5lcnMsXG4gIHBvcHBlck9mZnNldHMsXG4gIGNvbXB1dGVTdHlsZXMsXG4gIGFwcGx5U3R5bGVzLFxuICBvZmZzZXQsXG4gIGZsaXAsXG4gIHByZXZlbnRPdmVyZmxvdyxcbiAgYXJyb3csXG4gIGhpZGUsXG5dO1xuXG5jb25zdCBjcmVhdGVQb3BwZXIgPSBwb3BwZXJHZW5lcmF0b3IoeyBkZWZhdWx0TW9kaWZpZXJzIH0pO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgeyBjcmVhdGVQb3BwZXIsIHBvcHBlckdlbmVyYXRvciwgZGVmYXVsdE1vZGlmaWVycywgZGV0ZWN0T3ZlcmZsb3cgfTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcbmV4cG9ydCB7IGNyZWF0ZVBvcHBlciBhcyBjcmVhdGVQb3BwZXJMaXRlIH0gZnJvbSAnLi9wb3BwZXItbGl0ZSc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgKiBmcm9tICcuL21vZGlmaWVycyc7XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUllLFNBQVNBLFNBQVRBLENBQW1CQyxJQUFuQixFQUF5QjtFQUN0QyxJQUFJQSxJQUFJLElBQUksSUFBWixFQUFrQjtJQUNoQixPQUFPQyxNQUFQO0VBQ0Q7RUFFRCxJQUFJRCxJQUFJLENBQUNFLFFBQUwsT0FBb0IsaUJBQXhCLEVBQTJDO0lBQ3pDLElBQU1DLGFBQWEsR0FBR0gsSUFBSSxDQUFDRyxhQUEzQjtJQUNBLE9BQU9BLGFBQWEsR0FBR0EsYUFBYSxDQUFDQyxXQUFkLElBQTZCSCxNQUFoQyxHQUF5Q0EsTUFBN0Q7RUFDRDtFQUVELE9BQU9ELElBQVA7QUFDRDtBQ1ZELFNBQVNLLFNBQVRBLENBQW1CTCxJQUFuQixFQUF5QjtFQUN2QixJQUFNTSxVQUFVLEdBQUdQLFNBQVMsQ0FBQ0MsSUFBRCxDQUFULENBQWdCTyxPQUFuQztFQUNBLE9BQU9QLElBQUksWUFBWU0sVUFBaEIsSUFBOEJOLElBQUksWUFBWU8sT0FBckQ7QUFDRDtBQUlELFNBQVNDLGFBQVRBLENBQXVCUixJQUF2QixFQUE2QjtFQUMzQixJQUFNTSxVQUFVLEdBQUdQLFNBQVMsQ0FBQ0MsSUFBRCxDQUFULENBQWdCUyxXQUFuQztFQUNBLE9BQU9U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