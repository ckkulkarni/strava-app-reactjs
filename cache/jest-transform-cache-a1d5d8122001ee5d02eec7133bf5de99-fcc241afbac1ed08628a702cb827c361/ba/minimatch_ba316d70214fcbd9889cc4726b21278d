1b9348973d442bc960fbc0c6467c7d6d
"use strict";

module.exports = minimatch;
minimatch.Minimatch = Minimatch;
var path = function () {
  try {
    return require('path');
  } catch (e) {}
}() || {
  sep: '/'
};
minimatch.sep = path.sep;
var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
var expand = require('brace-expansion');
var plTypes = {
  '!': {
    open: '(?:(?!(?:',
    close: '))[^/]*?)'
  },
  '?': {
    open: '(?:',
    close: ')?'
  },
  '+': {
    open: '(?:',
    close: ')+'
  },
  '*': {
    open: '(?:',
    close: ')*'
  },
  '@': {
    open: '(?:',
    close: ')'
  }
};

// any single thing other than /
// don't need to escape / when using new RegExp()
var qmark = '[^/]';

// * => any number of characters
var star = qmark + '*?';

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?';

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?';

// characters that need to be escaped in RegExp.
var reSpecials = charSet('().*{}+?[]^$\\!');

// "abc" -> { a:true, b:true, c:true }
function charSet(s) {
  return s.split('').reduce(function (set, c) {
    set[c] = true;
    return set;
  }, {});
}

// normalizes slashes.
var slashSplit = /\/+/;
minimatch.filter = filter;
function filter(pattern, options) {
  options = options || {};
  return function (p, i, list) {
    return minimatch(p, pattern, options);
  };
}
function ext(a, b) {
  b = b || {};
  var t = {};
  Object.keys(a).forEach(function (k) {
    t[k] = a[k];
  });
  Object.keys(b).forEach(function (k) {
    t[k] = b[k];
  });
  return t;
}
minimatch.defaults = function (def) {
  if (!def || typeof def !== 'object' || !Object.keys(def).length) {
    return minimatch;
  }
  var orig = minimatch;
  var m = function minimatch(p, pattern, options) {
    return orig(p, pattern, ext(def, options));
  };
  m.Minimatch = function Minimatch(pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options));
  };
  m.Minimatch.defaults = function defaults(options) {
    return orig.defaults(ext(def, options)).Minimatch;
  };
  m.filter = function filter(pattern, options) {
    return orig.filter(pattern, ext(def, options));
  };
  m.defaults = function defaults(options) {
    return orig.defaults(ext(def, options));
  };
  m.makeRe = function makeRe(pattern, options) {
    return orig.makeRe(pattern, ext(def, options));
  };
  m.braceExpand = function braceExpand(pattern, options) {
    return orig.braceExpand(pattern, ext(def, options));
  };
  m.match = function (list, pattern, options) {
    return orig.match(list, pattern, ext(def, options));
  };
  return m;
};
Minimatch.defaults = function (def) {
  return minimatch.defaults(def).Minimatch;
};
function minimatch(p, pattern, options) {
  assertValidPattern(pattern);
  if (!options) options = {};

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false;
  }
  return new Minimatch(pattern, options).match(p);
}
function Minimatch(pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options);
  }
  assertValidPattern(pattern);
  if (!options) options = {};
  pattern = pattern.trim();

  // windows support: need to use /, not \
  if (!options.allowWindowsEscape && path.sep !== '/') {
    pattern = pattern.split(path.sep).join('/');
  }
  this.options = options;
  this.set = [];
  this.pattern = pattern;
  this.regexp = null;
  this.negate = false;
  this.comment = false;
  this.empty = false;
  this.partial = !!options.partial;

  // make the set of regexps etc.
  this.make();
}
Minimatch.prototype.debug = function () {};
Minimatch.prototype.make = make;
function make() {
  var pattern = this.pattern;
  var options = this.options;

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true;
    return;
  }
  if (!pattern) {
    this.empty = true;
    return;
  }

  // step 1: figure out negation, etc.
  this.parseNegate();

  // step 2: expand braces
  var set = this.globSet = this.braceExpand();
  if (options.debug) this.debug = function debug() {
    console.error.apply(console, arguments);
  };
  this.debug(this.pattern, set);

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit);
  });
  this.debug(this.pattern, set);

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this);
  }, this);
  this.debug(this.pattern, set);

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1;
  });
  this.debug(this.pattern, set);
  this.set = set;
}
Minimatch.prototype.parseNegate = parseNegate;
function parseNegate() {
  var pattern = this.pattern;
  var negate = false;
  var options = this.options;
  var negateOffset = 0;
  if (options.nonegate) return;
  for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === '!'; i++) {
    negate = !negate;
    negateOffset++;
  }
  if (negateOffset) this.pattern = pattern.substr(negateOffset);
  this.negate = negate;
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options);
};
Minimatch.prototype.braceExpand = braceExpand;
function braceExpand(pattern, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options;
    } else {
      options = {};
    }
  }
  pattern = typeof pattern === 'undefined' ? this.pattern : pattern;
  assertValidPattern(pattern);

  // Thanks to Yeting Li <https://github.com/yetingli> for
  // improving this regexp to avoid a ReDOS vulnerability.
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    // shortcut. no need to expand.
    return [pattern];
  }
  return expand(pattern);
}
var MAX_PATTERN_LENGTH = 1024 * 64;
var assertValidPattern = function (pattern) {
  if (typeof pattern !== 'string') {
    throw new TypeError('invalid pattern');
  }
  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError('pattern is too long');
  }
};

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse;
var SUBPARSE = {};
function parse(pattern, isSub) {
  assertValidPattern(pattern);
  var options = this.options;

  // shortcuts
  if (pattern === '**') {
    if (!options.noglobstar) return GLOBSTAR;else pattern = '*';
  }
  if (pattern === '') return '';
  var re = '';
  var hasMagic = !!options.nocase;
  var escaping = false;
  // ? => one single character
  var patternListStack = [];
  var negativeLists = [];
  var stateChar;
  var inClass = false;
  var reClassStart = -1;
  var classStart = -1;
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))' : '(?!\\.)';
  var self = this;
  function clearStateChar() {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case '*':
          re += star;
          hasMagic = true;
          break;
        case '?':
          re += qmark;
          hasMagic = true;
          break;
        default:
          re += '\\' + stateChar;
          break;
      }
      self.debug('clearStateChar %j %j', stateChar, re);
      stateChar = false;
    }
  }
  for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
    this.debug('%s\t%s %s %j', pattern, i, re, c);

    // skip over any that are escaped.
    if (escaping && reSpecials[c]) {
      re += '\\' + c;
      escaping = false;
      continue;
    }
    switch (c) {
      /* istanbul ignore next */
      case '/':
        {
          // completely not allowed, even escaped.
          // Should already be path-split by now.
          return false;
        }
      case '\\':
        clearStateChar();
        escaping = true;
        continue;

      // the various stateChar values
      // for the "extglob" stuff.
      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c);

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug('  in class');
          if (c === '!' && i === classStart + 1) c = '^';
          re += c;
          continue;
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar);
        clearStateChar();
        stateChar = c;
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar();
        continue;
      case '(':
        if (inClass) {
          re += '(';
          continue;
        }
        if (!stateChar) {
          re += '\\(';
          continue;
        }
        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        });
        // negation is (?:(?!js)[^/]*)
        re += stateChar === '!' ? '(?:(?!(?:' : '(?:';
        this.debug('plType %j %j', stateChar, re);
        stateChar = false;
        continue;
      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\)';
          continue;
        }
        clearStateChar();
        hasMagic = true;
        var pl = patternListStack.pop();
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        re += pl.close;
        if (pl.type === '!') {
          negativeLists.push(pl);
        }
        pl.reEnd = re.length;
        continue;
      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\|';
          escaping = false;
          continue;
        }
        clearStateChar();
        re += '|';
        continue;

      // these are mostly the same in regexp and glob
      case '[':
        // swallow any state-tracking char before the [
        clearStateChar();
        if (inClass) {
          re += '\\' + c;
          continue;
        }
        inClass = true;
        classStart = i;
        reClassStart = re.length;
        re += c;
        continue;
      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += '\\' + c;
          escaping = false;
          continue;
        }

        // handle the case where we left a class open.
        // "[z-a]" is valid, equivalent to "\[z-a\]"
        // split where the last [ was, make sure we don't have
        // an invalid re. if so, re-walk the contents of the
        // would-be class to re-translate any characters that
        // were passed through as-is
        // TODO: It would probably be faster to determine this
        // without a try/catch and a new RegExp, but it's tricky
        // to do safely.  For now, this is safe and works.
        var cs = pattern.substring(classStart + 1, i);
        try {
          RegExp('[' + cs + ']');
        } catch (er) {
          // not a valid class!
          var sp = this.parse(cs, SUBPARSE);
          re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]';
          hasMagic = hasMagic || sp[1];
          inClass = false;
          continue;
        }

        // finish up the class.
        hasMagic = true;
        inClass = false;
        re += c;
        continue;
      default:
        // swallow any state char that wasn't consumed
        clearStateChar();
        if (escaping) {
          // no need
          escaping = false;
        } else if (reSpecials[c] && !(c === '^' && inClass)) {
          re += '\\';
        }
        re += c;
    } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1);
    sp = this.parse(cs, SUBPARSE);
    re = re.substr(0, reClassStart) + '\\[' + sp[0];
    hasMagic = hasMagic || sp[1];
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length);
    this.debug('setting tail', re, pl);
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\';
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|';
    });
    this.debug('tail=%j\n   %s', tail, tail, pl, re);
    var t = pl.type === '*' ? star : pl.type === '?' ? qmark : '\\' + pl.type;
    hasMagic = true;
    re = re.slice(0, pl.reStart) + t + '\\(' + tail;
  }

  // handle trailing things that only matter at the very end.
  clearStateChar();
  if (escaping) {
    // trailing \\
    re += '\\\\';
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false;
  switch (re.charAt(0)) {
    case '[':
    case '.':
    case '(':
      addPatternStart = true;
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n];
    var nlBefore = re.slice(0, nl.reStart);
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
    var nlAfter = re.slice(nl.reEnd);
    nlLast += nlAfter;

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // "after" the negated section.
    var openParensBefore = nlBefore.split('(').length - 1;
    var cleanAfter = nlAfter;
    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '');
    }
    nlAfter = cleanAfter;
    var dollar = '';
    if (nlAfter === '' && isSub !== SUBPARSE) {
      dollar = '$';
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
    re = newRe;
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) {
    re = '(?=.)' + re;
  }
  if (addPatternStart) {
    re = patternStart + re;
  }

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [re, hasMagic];
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern);
  }
  var flags = options.nocase ? 'i' : '';
  try {
    var regExp = new RegExp('^' + re + '$', flags);
  } catch (er) /* istanbul ignore next - should be impossible */{
    // If it was an invalid regular expression, then it can't match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it's not a /m regex.
    return new RegExp('$.');
  }
  regExp._glob = pattern;
  regExp._src = re;
  return regExp;
}
minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe();
};
Minimatch.prototype.makeRe = makeRe;
function makeRe() {
  if (this.regexp || this.regexp === false) return this.regexp;

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set;
  if (!set.length) {
    this.regexp = false;
    return this.regexp;
  }
  var options = this.options;
  var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
  var flags = options.nocase ? 'i' : '';
  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return p === GLOBSTAR ? twoStar : typeof p === 'string' ? regExpEscape(p) : p._src;
    }).join('\\\/');
  }).join('|');

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$';

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$';
  try {
    this.regexp = new RegExp(re, flags);
  } catch (ex) /* istanbul ignore next - should be impossible */{
    this.regexp = false;
  }
  return this.regexp;
}
minimatch.match = function (list, pattern, options) {
  options = options || {};
  var mm = new Minimatch(pattern, options);
  list = list.filter(function (f) {
    return mm.match(f);
  });
  if (mm.options.nonull && !list.length) {
    list.push(pattern);
  }
  return list;
};
Minimatch.prototype.match = function match(f, partial) {
  if (typeof partial === 'undefined') partial = this.partial;
  this.debug('match', f, this.pattern);
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false;
  if (this.empty) return f === '';
  if (f === '/' && partial) return true;
  var options = this.options;

  // windows: need to use /, not \
  if (path.sep !== '/') {
    f = f.split(path.sep).join('/');
  }

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit);
  this.debug(this.pattern, 'split', f);

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set;
  this.debug(this.pattern, 'set', set);

  // Find the basename of the path by looking for the last non-empty segment
  var filename;
  var i;
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i];
    if (filename) break;
  }
  for (i = 0; i < set.length; i++) {
    var pattern = set[i];
    var file = f;
    if (options.matchBase && pattern.length === 1) {
      file = [filename];
    }
    var hit = this.matchOne(file, pattern, partial);
    if (hit) {
      if (options.flipNegate) return true;
      return !this.negate;
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false;
  return this.negate;
};

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options;
  this.debug('matchOne', {
    'this': this,
    file: file,
    pattern: pattern
  });
  this.debug('matchOne', file.length, pattern.length);
  for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
    this.debug('matchOne loop');
    var p = pattern[pi];
    var f = file[fi];
    this.debug(pattern, p, f);

    // should be impossible.
    // some invalid regexp stuff in the set.
    /* istanbul ignore if */
    if (p === false) return false;
    if (p === GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f]);

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi;
      var pr = pi + 1;
      if (pr === pl) {
        this.debug('** at the end');
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi < fl; fi++) {
          if (file[fi] === '.' || file[fi] === '..' || !options.dot && file[fi].charAt(0) === '.') return false;
        }
        return true;
      }

      // ok, let's see if we can swallow whatever we can.
      while (fr < fl) {
        var swallowee = file[fr];
        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee);
          // found a match.
          return true;
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' || !options.dot && swallowee.charAt(0) === '.') {
            this.debug('dot detected!', file, fr, pattern, pr);
            break;
          }

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue');
          fr++;
        }
      }

      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      /* istanbul ignore if */
      if (partial) {
        // ran out of file
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
        if (fr === fl) return true;
      }
      return false;
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit;
    if (typeof p === 'string') {
      hit = f === p;
      this.debug('string match', p, f, hit);
    } else {
      hit = f.match(p);
      this.debug('pattern match', p, f, hit);
    }
    if (!hit) return false;
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true;
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial;
  } else /* istanbul ignore else */if (pi === pl) {
      // ran out of pattern, still have file left.
      // this is only acceptable if we're on the very last
      // empty segment of a file with a trailing slash.
      // a/* should match a/b/
      return fi === fl - 1 && file[fi] === '';
    }

  // should be unreachable.
  /* istanbul ignore next */
  throw new Error('wtf?');
};

// replace stuff like \* with *
function globUnescape(s) {
  return s.replace(/\\(.)/g, '$1');
}
function regExpEscape(s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwibWluaW1hdGNoIiwiTWluaW1hdGNoIiwicGF0aCIsInJlcXVpcmUiLCJlIiwic2VwIiwiR0xPQlNUQVIiLCJleHBhbmQiLCJwbFR5cGVzIiwib3BlbiIsImNsb3NlIiwicW1hcmsiLCJzdGFyIiwidHdvU3RhckRvdCIsInR3b1N0YXJOb0RvdCIsInJlU3BlY2lhbHMiLCJjaGFyU2V0IiwicyIsInNwbGl0IiwicmVkdWNlIiwic2V0IiwiYyIsInNsYXNoU3BsaXQiLCJmaWx0ZXIiLCJwYXR0ZXJuIiwib3B0aW9ucyIsInAiLCJpIiwibGlzdCIsImV4dCIsImEiLCJiIiwidCIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwiayIsImRlZmF1bHRzIiwiZGVmIiwibGVuZ3RoIiwib3JpZyIsIm0iLCJtYWtlUmUiLCJicmFjZUV4cGFuZCIsIm1hdGNoIiwiYXNzZXJ0VmFsaWRQYXR0ZXJuIiwibm9jb21tZW50IiwiY2hhckF0IiwidHJpbSIsImFsbG93V2luZG93c0VzY2FwZSIsImpvaW4iLCJyZWdleHAiLCJuZWdhdGUiLCJjb21tZW50IiwiZW1wdHkiLCJwYXJ0aWFsIiwibWFrZSIsInByb3RvdHlwZSIsImRlYnVnIiwicGFyc2VOZWdhdGUiLCJnbG9iU2V0IiwiY29uc29sZSIsImVycm9yIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJnbG9iUGFydHMiLCJtYXAiLCJzaSIsInBhcnNlIiwiaW5kZXhPZiIsIm5lZ2F0ZU9mZnNldCIsIm5vbmVnYXRlIiwibCIsInN1YnN0ciIsIm5vYnJhY2UiLCJ0ZXN0IiwiTUFYX1BBVFRFUk5fTEVOR1RIIiwiVHlwZUVycm9yIiwiU1VCUEFSU0UiLCJpc1N1YiIsIm5vZ2xvYnN0YXIiLCJyZSIsImhhc01hZ2ljIiwibm9jYXNlIiwiZXNjYXBpbmciLCJwYXR0ZXJuTGlzdFN0YWNrIiwibmVnYXRpdmVMaXN0cyIsInN0YXRlQ2hhciIsImluQ2xhc3MiLCJyZUNsYXNzU3RhcnQiLCJjbGFzc1N0YXJ0IiwicGF0dGVyblN0YXJ0IiwiZG90Iiwic2VsZiIsImNsZWFyU3RhdGVDaGFyIiwibGVuIiwibm9leHQiLCJwdXNoIiwidHlwZSIsInN0YXJ0IiwicmVTdGFydCIsInBsIiwicG9wIiwicmVFbmQiLCJjcyIsInN1YnN0cmluZyIsIlJlZ0V4cCIsImVyIiwic3AiLCJ0YWlsIiwic2xpY2UiLCJyZXBsYWNlIiwiXyIsIiQxIiwiJDIiLCJhZGRQYXR0ZXJuU3RhcnQiLCJuIiwibmwiLCJubEJlZm9yZSIsIm5sRmlyc3QiLCJubExhc3QiLCJubEFmdGVyIiwib3BlblBhcmVuc0JlZm9yZSIsImNsZWFuQWZ0ZXIiLCJkb2xsYXIiLCJuZXdSZSIsImdsb2JVbmVzY2FwZSIsImZsYWdzIiwicmVnRXhwIiwiX2dsb2IiLCJfc3JjIiwidHdvU3RhciIsInJlZ0V4cEVzY2FwZSIsImV4IiwibW0iLCJmIiwibm9udWxsIiwiZmlsZW5hbWUiLCJmaWxlIiwibWF0Y2hCYXNlIiwiaGl0IiwibWF0Y2hPbmUiLCJmbGlwTmVnYXRlIiwiZmkiLCJwaSIsImZsIiwiZnIiLCJwciIsInN3YWxsb3dlZSIsIkVycm9yIl0sInNvdXJjZXMiOlsibWluaW1hdGNoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gbWluaW1hdGNoXG5taW5pbWF0Y2guTWluaW1hdGNoID0gTWluaW1hdGNoXG5cbnZhciBwYXRoID0gKGZ1bmN0aW9uICgpIHsgdHJ5IHsgcmV0dXJuIHJlcXVpcmUoJ3BhdGgnKSB9IGNhdGNoIChlKSB7fX0oKSkgfHwge1xuICBzZXA6ICcvJ1xufVxubWluaW1hdGNoLnNlcCA9IHBhdGguc2VwXG5cbnZhciBHTE9CU1RBUiA9IG1pbmltYXRjaC5HTE9CU1RBUiA9IE1pbmltYXRjaC5HTE9CU1RBUiA9IHt9XG52YXIgZXhwYW5kID0gcmVxdWlyZSgnYnJhY2UtZXhwYW5zaW9uJylcblxudmFyIHBsVHlwZXMgPSB7XG4gICchJzogeyBvcGVuOiAnKD86KD8hKD86JywgY2xvc2U6ICcpKVteL10qPyknfSxcbiAgJz8nOiB7IG9wZW46ICcoPzonLCBjbG9zZTogJyk/JyB9LFxuICAnKyc6IHsgb3BlbjogJyg/OicsIGNsb3NlOiAnKSsnIH0sXG4gICcqJzogeyBvcGVuOiAnKD86JywgY2xvc2U6ICcpKicgfSxcbiAgJ0AnOiB7IG9wZW46ICcoPzonLCBjbG9zZTogJyknIH1cbn1cblxuLy8gYW55IHNpbmdsZSB0aGluZyBvdGhlciB0aGFuIC9cbi8vIGRvbid0IG5lZWQgdG8gZXNjYXBlIC8gd2hlbiB1c2luZyBuZXcgUmVnRXhwKClcbnZhciBxbWFyayA9ICdbXi9dJ1xuXG4vLyAqID0+IGFueSBudW1iZXIgb2YgY2hhcmFjdGVyc1xudmFyIHN0YXIgPSBxbWFyayArICcqPydcblxuLy8gKiogd2hlbiBkb3RzIGFyZSBhbGxvd2VkLiAgQW55dGhpbmcgZ29lcywgZXhjZXB0IC4uIGFuZCAuXG4vLyBub3QgKF4gb3IgLyBmb2xsb3dlZCBieSBvbmUgb3IgdHdvIGRvdHMgZm9sbG93ZWQgYnkgJCBvciAvKSxcbi8vIGZvbGxvd2VkIGJ5IGFueXRoaW5nLCBhbnkgbnVtYmVyIG9mIHRpbWVzLlxudmFyIHR3b1N0YXJEb3QgPSAnKD86KD8hKD86XFxcXFxcL3xeKSg/OlxcXFwuezEsMn0pKCR8XFxcXFxcLykpLikqPydcblxuLy8gbm90IGEgXiBvciAvIGZvbGxvd2VkIGJ5IGEgZG90LFxuLy8gZm9sbG93ZWQgYnkgYW55dGhpbmcsIGFueSBudW1iZXIgb2YgdGltZXMuXG52YXIgdHdvU3Rhck5vRG90ID0gJyg/Oig/ISg/OlxcXFxcXC98XilcXFxcLikuKSo/J1xuXG4vLyBjaGFyYWN0ZXJzIHRoYXQgbmVlZCB0byBiZSBlc2NhcGVkIGluIFJlZ0V4cC5cbnZhciByZVNwZWNpYWxzID0gY2hhclNldCgnKCkuKnt9Kz9bXV4kXFxcXCEnKVxuXG4vLyBcImFiY1wiIC0+IHsgYTp0cnVlLCBiOnRydWUsIGM6dHJ1ZSB9XG5mdW5jdGlvbiBjaGFyU2V0IChzKSB7XG4gIHJldHVybiBzLnNwbGl0KCcnKS5yZWR1Y2UoZnVuY3Rpb24gKHNldCwgYykge1xuICAgIHNldFtjXSA9IHRydWVcbiAgICByZXR1cm4gc2V0XG4gIH0sIHt9KVxufVxuXG4vLyBub3JtYWxpemVzIHNsYXNoZXMuXG52YXIgc2xhc2hTcGxpdCA9IC9cXC8rL1xuXG5taW5pbWF0Y2guZmlsdGVyID0gZmlsdGVyXG5mdW5jdGlvbiBmaWx0ZXIgKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgcmV0dXJuIGZ1bmN0aW9uIChwLCBpLCBsaXN0KSB7XG4gICAgcmV0dXJuIG1pbmltYXRjaChwLCBwYXR0ZXJuLCBvcHRpb25zKVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dCAoYSwgYikge1xuICBiID0gYiB8fCB7fVxuICB2YXIgdCA9IHt9XG4gIE9iamVjdC5rZXlzKGEpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICB0W2tdID0gYVtrXVxuICB9KVxuICBPYmplY3Qua2V5cyhiKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgdFtrXSA9IGJba11cbiAgfSlcbiAgcmV0dXJuIHRcbn1cblxubWluaW1hdGNoLmRlZmF1bHRzID0gZnVuY3Rpb24gKGRlZikge1xuICBpZiAoIWRlZiB8fCB0eXBlb2YgZGVmICE9PSAnb2JqZWN0JyB8fCAhT2JqZWN0LmtleXMoZGVmKS5sZW5ndGgpIHtcbiAgICByZXR1cm4gbWluaW1hdGNoXG4gIH1cblxuICB2YXIgb3JpZyA9IG1pbmltYXRjaFxuXG4gIHZhciBtID0gZnVuY3Rpb24gbWluaW1hdGNoIChwLCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9yaWcocCwgcGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpXG4gIH1cblxuICBtLk1pbmltYXRjaCA9IGZ1bmN0aW9uIE1pbmltYXRjaCAocGF0dGVybiwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgb3JpZy5NaW5pbWF0Y2gocGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpXG4gIH1cbiAgbS5NaW5pbWF0Y2guZGVmYXVsdHMgPSBmdW5jdGlvbiBkZWZhdWx0cyAob3B0aW9ucykge1xuICAgIHJldHVybiBvcmlnLmRlZmF1bHRzKGV4dChkZWYsIG9wdGlvbnMpKS5NaW5pbWF0Y2hcbiAgfVxuXG4gIG0uZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9yaWcuZmlsdGVyKHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKVxuICB9XG5cbiAgbS5kZWZhdWx0cyA9IGZ1bmN0aW9uIGRlZmF1bHRzIChvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9yaWcuZGVmYXVsdHMoZXh0KGRlZiwgb3B0aW9ucykpXG4gIH1cblxuICBtLm1ha2VSZSA9IGZ1bmN0aW9uIG1ha2VSZSAocGF0dGVybiwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcmlnLm1ha2VSZShwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSlcbiAgfVxuXG4gIG0uYnJhY2VFeHBhbmQgPSBmdW5jdGlvbiBicmFjZUV4cGFuZCAocGF0dGVybiwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcmlnLmJyYWNlRXhwYW5kKHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKVxuICB9XG5cbiAgbS5tYXRjaCA9IGZ1bmN0aW9uIChsaXN0LCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9yaWcubWF0Y2gobGlzdCwgcGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpXG4gIH1cblxuICByZXR1cm4gbVxufVxuXG5NaW5pbWF0Y2guZGVmYXVsdHMgPSBmdW5jdGlvbiAoZGVmKSB7XG4gIHJldHVybiBtaW5pbWF0Y2guZGVmYXVsdHMoZGVmKS5NaW5pbWF0Y2hcbn1cblxuZnVuY3Rpb24gbWluaW1hdGNoIChwLCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGFzc2VydFZhbGlkUGF0dGVybihwYXR0ZXJuKVxuXG4gIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9XG5cbiAgLy8gc2hvcnRjdXQ6IGNvbW1lbnRzIG1hdGNoIG5vdGhpbmcuXG4gIGlmICghb3B0aW9ucy5ub2NvbW1lbnQgJiYgcGF0dGVybi5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucykubWF0Y2gocClcbn1cblxuZnVuY3Rpb24gTWluaW1hdGNoIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNaW5pbWF0Y2gpKSB7XG4gICAgcmV0dXJuIG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucylcbiAgfVxuXG4gIGFzc2VydFZhbGlkUGF0dGVybihwYXR0ZXJuKVxuXG4gIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9XG5cbiAgcGF0dGVybiA9IHBhdHRlcm4udHJpbSgpXG5cbiAgLy8gd2luZG93cyBzdXBwb3J0OiBuZWVkIHRvIHVzZSAvLCBub3QgXFxcbiAgaWYgKCFvcHRpb25zLmFsbG93V2luZG93c0VzY2FwZSAmJiBwYXRoLnNlcCAhPT0gJy8nKSB7XG4gICAgcGF0dGVybiA9IHBhdHRlcm4uc3BsaXQocGF0aC5zZXApLmpvaW4oJy8nKVxuICB9XG5cbiAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICB0aGlzLnNldCA9IFtdXG4gIHRoaXMucGF0dGVybiA9IHBhdHRlcm5cbiAgdGhpcy5yZWdleHAgPSBudWxsXG4gIHRoaXMubmVnYXRlID0gZmFsc2VcbiAgdGhpcy5jb21tZW50ID0gZmFsc2VcbiAgdGhpcy5lbXB0eSA9IGZhbHNlXG4gIHRoaXMucGFydGlhbCA9ICEhb3B0aW9ucy5wYXJ0aWFsXG5cbiAgLy8gbWFrZSB0aGUgc2V0IG9mIHJlZ2V4cHMgZXRjLlxuICB0aGlzLm1ha2UoKVxufVxuXG5NaW5pbWF0Y2gucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24gKCkge31cblxuTWluaW1hdGNoLnByb3RvdHlwZS5tYWtlID0gbWFrZVxuZnVuY3Rpb24gbWFrZSAoKSB7XG4gIHZhciBwYXR0ZXJuID0gdGhpcy5wYXR0ZXJuXG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zXG5cbiAgLy8gZW1wdHkgcGF0dGVybnMgYW5kIGNvbW1lbnRzIG1hdGNoIG5vdGhpbmcuXG4gIGlmICghb3B0aW9ucy5ub2NvbW1lbnQgJiYgcGF0dGVybi5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgIHRoaXMuY29tbWVudCA9IHRydWVcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIXBhdHRlcm4pIHtcbiAgICB0aGlzLmVtcHR5ID0gdHJ1ZVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gc3RlcCAxOiBmaWd1cmUgb3V0IG5lZ2F0aW9uLCBldGMuXG4gIHRoaXMucGFyc2VOZWdhdGUoKVxuXG4gIC8vIHN0ZXAgMjogZXhwYW5kIGJyYWNlc1xuICB2YXIgc2V0ID0gdGhpcy5nbG9iU2V0ID0gdGhpcy5icmFjZUV4cGFuZCgpXG5cbiAgaWYgKG9wdGlvbnMuZGVidWcpIHRoaXMuZGVidWcgPSBmdW5jdGlvbiBkZWJ1ZygpIHsgY29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpIH1cblxuICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgc2V0KVxuXG4gIC8vIHN0ZXAgMzogbm93IHdlIGhhdmUgYSBzZXQsIHNvIHR1cm4gZWFjaCBvbmUgaW50byBhIHNlcmllcyBvZiBwYXRoLXBvcnRpb25cbiAgLy8gbWF0Y2hpbmcgcGF0dGVybnMuXG4gIC8vIFRoZXNlIHdpbGwgYmUgcmVnZXhwcywgZXhjZXB0IGluIHRoZSBjYXNlIG9mIFwiKipcIiwgd2hpY2ggaXNcbiAgLy8gc2V0IHRvIHRoZSBHTE9CU1RBUiBvYmplY3QgZm9yIGdsb2JzdGFyIGJlaGF2aW9yLFxuICAvLyBhbmQgd2lsbCBub3QgY29udGFpbiBhbnkgLyBjaGFyYWN0ZXJzXG4gIHNldCA9IHRoaXMuZ2xvYlBhcnRzID0gc2V0Lm1hcChmdW5jdGlvbiAocykge1xuICAgIHJldHVybiBzLnNwbGl0KHNsYXNoU3BsaXQpXG4gIH0pXG5cbiAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sIHNldClcblxuICAvLyBnbG9iIC0tPiByZWdleHBzXG4gIHNldCA9IHNldC5tYXAoZnVuY3Rpb24gKHMsIHNpLCBzZXQpIHtcbiAgICByZXR1cm4gcy5tYXAodGhpcy5wYXJzZSwgdGhpcylcbiAgfSwgdGhpcylcblxuICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgc2V0KVxuXG4gIC8vIGZpbHRlciBvdXQgZXZlcnl0aGluZyB0aGF0IGRpZG4ndCBjb21waWxlIHByb3Blcmx5LlxuICBzZXQgPSBzZXQuZmlsdGVyKGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIHMuaW5kZXhPZihmYWxzZSkgPT09IC0xXG4gIH0pXG5cbiAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sIHNldClcblxuICB0aGlzLnNldCA9IHNldFxufVxuXG5NaW5pbWF0Y2gucHJvdG90eXBlLnBhcnNlTmVnYXRlID0gcGFyc2VOZWdhdGVcbmZ1bmN0aW9uIHBhcnNlTmVnYXRlICgpIHtcbiAgdmFyIHBhdHRlcm4gPSB0aGlzLnBhdHRlcm5cbiAgdmFyIG5lZ2F0ZSA9IGZhbHNlXG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zXG4gIHZhciBuZWdhdGVPZmZzZXQgPSAwXG5cbiAgaWYgKG9wdGlvbnMubm9uZWdhdGUpIHJldHVyblxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gcGF0dGVybi5sZW5ndGhcbiAgICA7IGkgPCBsICYmIHBhdHRlcm4uY2hhckF0KGkpID09PSAnISdcbiAgICA7IGkrKykge1xuICAgIG5lZ2F0ZSA9ICFuZWdhdGVcbiAgICBuZWdhdGVPZmZzZXQrK1xuICB9XG5cbiAgaWYgKG5lZ2F0ZU9mZnNldCkgdGhpcy5wYXR0ZXJuID0gcGF0dGVybi5zdWJzdHIobmVnYXRlT2Zmc2V0KVxuICB0aGlzLm5lZ2F0ZSA9IG5lZ2F0ZVxufVxuXG4vLyBCcmFjZSBleHBhbnNpb246XG4vLyBhe2IsY31kIC0+IGFiZCBhY2Rcbi8vIGF7Yix9YyAtPiBhYmMgYWNcbi8vIGF7MC4uM31kIC0+IGEwZCBhMWQgYTJkIGEzZFxuLy8gYXtiLGN7ZCxlfWZ9ZyAtPiBhYmcgYWNkZmcgYWNlZmdcbi8vIGF7YixjfWR7ZSxmfWcgLT4gYWJkZWcgYWNkZWcgYWJkZWcgYWJkZmdcbi8vXG4vLyBJbnZhbGlkIHNldHMgYXJlIG5vdCBleHBhbmRlZC5cbi8vIGF7Mi4ufWIgLT4gYXsyLi59YlxuLy8gYXtifWMgLT4gYXtifWNcbm1pbmltYXRjaC5icmFjZUV4cGFuZCA9IGZ1bmN0aW9uIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIHJldHVybiBicmFjZUV4cGFuZChwYXR0ZXJuLCBvcHRpb25zKVxufVxuXG5NaW5pbWF0Y2gucHJvdG90eXBlLmJyYWNlRXhwYW5kID0gYnJhY2VFeHBhbmRcblxuZnVuY3Rpb24gYnJhY2VFeHBhbmQgKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBNaW5pbWF0Y2gpIHtcbiAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IHt9XG4gICAgfVxuICB9XG5cbiAgcGF0dGVybiA9IHR5cGVvZiBwYXR0ZXJuID09PSAndW5kZWZpbmVkJ1xuICAgID8gdGhpcy5wYXR0ZXJuIDogcGF0dGVyblxuXG4gIGFzc2VydFZhbGlkUGF0dGVybihwYXR0ZXJuKVxuXG4gIC8vIFRoYW5rcyB0byBZZXRpbmcgTGkgPGh0dHBzOi8vZ2l0aHViLmNvbS95ZXRpbmdsaT4gZm9yXG4gIC8vIGltcHJvdmluZyB0aGlzIHJlZ2V4cCB0byBhdm9pZCBhIFJlRE9TIHZ1bG5lcmFiaWxpdHkuXG4gIGlmIChvcHRpb25zLm5vYnJhY2UgfHwgIS9cXHsoPzooPyFcXHspLikqXFx9Ly50ZXN0KHBhdHRlcm4pKSB7XG4gICAgLy8gc2hvcnRjdXQuIG5vIG5lZWQgdG8gZXhwYW5kLlxuICAgIHJldHVybiBbcGF0dGVybl1cbiAgfVxuXG4gIHJldHVybiBleHBhbmQocGF0dGVybilcbn1cblxudmFyIE1BWF9QQVRURVJOX0xFTkdUSCA9IDEwMjQgKiA2NFxudmFyIGFzc2VydFZhbGlkUGF0dGVybiA9IGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHBhdHRlcm4nKVxuICB9XG5cbiAgaWYgKHBhdHRlcm4ubGVuZ3RoID4gTUFYX1BBVFRFUk5fTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGF0dGVybiBpcyB0b28gbG9uZycpXG4gIH1cbn1cblxuLy8gcGFyc2UgYSBjb21wb25lbnQgb2YgdGhlIGV4cGFuZGVkIHNldC5cbi8vIEF0IHRoaXMgcG9pbnQsIG5vIHBhdHRlcm4gbWF5IGNvbnRhaW4gXCIvXCIgaW4gaXRcbi8vIHNvIHdlJ3JlIGdvaW5nIHRvIHJldHVybiBhIDJkIGFycmF5LCB3aGVyZSBlYWNoIGVudHJ5IGlzIHRoZSBmdWxsXG4vLyBwYXR0ZXJuLCBzcGxpdCBvbiAnLycsIGFuZCB0aGVuIHR1cm5lZCBpbnRvIGEgcmVndWxhciBleHByZXNzaW9uLlxuLy8gQSByZWdleHAgaXMgbWFkZSBhdCB0aGUgZW5kIHdoaWNoIGpvaW5zIGVhY2ggYXJyYXkgd2l0aCBhblxuLy8gZXNjYXBlZCAvLCBhbmQgYW5vdGhlciBmdWxsIG9uZSB3aGljaCBqb2lucyBlYWNoIHJlZ2V4cCB3aXRoIHwuXG4vL1xuLy8gRm9sbG93aW5nIHRoZSBsZWFkIG9mIEJhc2ggNC4xLCBub3RlIHRoYXQgXCIqKlwiIG9ubHkgaGFzIHNwZWNpYWwgbWVhbmluZ1xuLy8gd2hlbiBpdCBpcyB0aGUgKm9ubHkqIHRoaW5nIGluIGEgcGF0aCBwb3J0aW9uLiAgT3RoZXJ3aXNlLCBhbnkgc2VyaWVzXG4vLyBvZiAqIGlzIGVxdWl2YWxlbnQgdG8gYSBzaW5nbGUgKi4gIEdsb2JzdGFyIGJlaGF2aW9yIGlzIGVuYWJsZWQgYnlcbi8vIGRlZmF1bHQsIGFuZCBjYW4gYmUgZGlzYWJsZWQgYnkgc2V0dGluZyBvcHRpb25zLm5vZ2xvYnN0YXIuXG5NaW5pbWF0Y2gucHJvdG90eXBlLnBhcnNlID0gcGFyc2VcbnZhciBTVUJQQVJTRSA9IHt9XG5mdW5jdGlvbiBwYXJzZSAocGF0dGVybiwgaXNTdWIpIHtcbiAgYXNzZXJ0VmFsaWRQYXR0ZXJuKHBhdHRlcm4pXG5cbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcblxuICAvLyBzaG9ydGN1dHNcbiAgaWYgKHBhdHRlcm4gPT09ICcqKicpIHtcbiAgICBpZiAoIW9wdGlvbnMubm9nbG9ic3RhcilcbiAgICAgIHJldHVybiBHTE9CU1RBUlxuICAgIGVsc2VcbiAgICAgIHBhdHRlcm4gPSAnKidcbiAgfVxuICBpZiAocGF0dGVybiA9PT0gJycpIHJldHVybiAnJ1xuXG4gIHZhciByZSA9ICcnXG4gIHZhciBoYXNNYWdpYyA9ICEhb3B0aW9ucy5ub2Nhc2VcbiAgdmFyIGVzY2FwaW5nID0gZmFsc2VcbiAgLy8gPyA9PiBvbmUgc2luZ2xlIGNoYXJhY3RlclxuICB2YXIgcGF0dGVybkxpc3RTdGFjayA9IFtdXG4gIHZhciBuZWdhdGl2ZUxpc3RzID0gW11cbiAgdmFyIHN0YXRlQ2hhclxuICB2YXIgaW5DbGFzcyA9IGZhbHNlXG4gIHZhciByZUNsYXNzU3RhcnQgPSAtMVxuICB2YXIgY2xhc3NTdGFydCA9IC0xXG4gIC8vIC4gYW5kIC4uIG5ldmVyIG1hdGNoIGFueXRoaW5nIHRoYXQgZG9lc24ndCBzdGFydCB3aXRoIC4sXG4gIC8vIGV2ZW4gd2hlbiBvcHRpb25zLmRvdCBpcyBzZXQuXG4gIHZhciBwYXR0ZXJuU3RhcnQgPSBwYXR0ZXJuLmNoYXJBdCgwKSA9PT0gJy4nID8gJycgLy8gYW55dGhpbmdcbiAgLy8gbm90IChzdGFydCBvciAvIGZvbGxvd2VkIGJ5IC4gb3IgLi4gZm9sbG93ZWQgYnkgLyBvciBlbmQpXG4gIDogb3B0aW9ucy5kb3QgPyAnKD8hKD86XnxcXFxcXFwvKVxcXFwuezEsMn0oPzokfFxcXFxcXC8pKSdcbiAgOiAnKD8hXFxcXC4pJ1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBmdW5jdGlvbiBjbGVhclN0YXRlQ2hhciAoKSB7XG4gICAgaWYgKHN0YXRlQ2hhcikge1xuICAgICAgLy8gd2UgaGFkIHNvbWUgc3RhdGUtdHJhY2tpbmcgY2hhcmFjdGVyXG4gICAgICAvLyB0aGF0IHdhc24ndCBjb25zdW1lZCBieSB0aGlzIHBhc3MuXG4gICAgICBzd2l0Y2ggKHN0YXRlQ2hhcikge1xuICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICByZSArPSBzdGFyXG4gICAgICAgICAgaGFzTWFnaWMgPSB0cnVlXG4gICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJz8nOlxuICAgICAgICAgIHJlICs9IHFtYXJrXG4gICAgICAgICAgaGFzTWFnaWMgPSB0cnVlXG4gICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmUgKz0gJ1xcXFwnICsgc3RhdGVDaGFyXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBzZWxmLmRlYnVnKCdjbGVhclN0YXRlQ2hhciAlaiAlaicsIHN0YXRlQ2hhciwgcmUpXG4gICAgICBzdGF0ZUNoYXIgPSBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXR0ZXJuLmxlbmd0aCwgY1xuICAgIDsgKGkgPCBsZW4pICYmIChjID0gcGF0dGVybi5jaGFyQXQoaSkpXG4gICAgOyBpKyspIHtcbiAgICB0aGlzLmRlYnVnKCclc1xcdCVzICVzICVqJywgcGF0dGVybiwgaSwgcmUsIGMpXG5cbiAgICAvLyBza2lwIG92ZXIgYW55IHRoYXQgYXJlIGVzY2FwZWQuXG4gICAgaWYgKGVzY2FwaW5nICYmIHJlU3BlY2lhbHNbY10pIHtcbiAgICAgIHJlICs9ICdcXFxcJyArIGNcbiAgICAgIGVzY2FwaW5nID0gZmFsc2VcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgc3dpdGNoIChjKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgY2FzZSAnLyc6IHtcbiAgICAgICAgLy8gY29tcGxldGVseSBub3QgYWxsb3dlZCwgZXZlbiBlc2NhcGVkLlxuICAgICAgICAvLyBTaG91bGQgYWxyZWFkeSBiZSBwYXRoLXNwbGl0IGJ5IG5vdy5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGNhc2UgJ1xcXFwnOlxuICAgICAgICBjbGVhclN0YXRlQ2hhcigpXG4gICAgICAgIGVzY2FwaW5nID0gdHJ1ZVxuICAgICAgY29udGludWVcblxuICAgICAgLy8gdGhlIHZhcmlvdXMgc3RhdGVDaGFyIHZhbHVlc1xuICAgICAgLy8gZm9yIHRoZSBcImV4dGdsb2JcIiBzdHVmZi5cbiAgICAgIGNhc2UgJz8nOlxuICAgICAgY2FzZSAnKic6XG4gICAgICBjYXNlICcrJzpcbiAgICAgIGNhc2UgJ0AnOlxuICAgICAgY2FzZSAnISc6XG4gICAgICAgIHRoaXMuZGVidWcoJyVzXFx0JXMgJXMgJWogPC0tIHN0YXRlQ2hhcicsIHBhdHRlcm4sIGksIHJlLCBjKVxuXG4gICAgICAgIC8vIGFsbCBvZiB0aG9zZSBhcmUgbGl0ZXJhbHMgaW5zaWRlIGEgY2xhc3MsIGV4Y2VwdCB0aGF0XG4gICAgICAgIC8vIHRoZSBnbG9iIFshYV0gbWVhbnMgW15hXSBpbiByZWdleHBcbiAgICAgICAgaWYgKGluQ2xhc3MpIHtcbiAgICAgICAgICB0aGlzLmRlYnVnKCcgIGluIGNsYXNzJylcbiAgICAgICAgICBpZiAoYyA9PT0gJyEnICYmIGkgPT09IGNsYXNzU3RhcnQgKyAxKSBjID0gJ14nXG4gICAgICAgICAgcmUgKz0gY1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBzdGF0ZUNoYXIsIHRoZW4gaXQgbWVhbnNcbiAgICAgICAgLy8gdGhhdCB0aGVyZSB3YXMgc29tZXRoaW5nIGxpa2UgKiogb3IgKz8gaW4gdGhlcmUuXG4gICAgICAgIC8vIEhhbmRsZSB0aGUgc3RhdGVDaGFyLCB0aGVuIHByb2NlZWQgd2l0aCB0aGlzIG9uZS5cbiAgICAgICAgc2VsZi5kZWJ1ZygnY2FsbCBjbGVhclN0YXRlQ2hhciAlaicsIHN0YXRlQ2hhcilcbiAgICAgICAgY2xlYXJTdGF0ZUNoYXIoKVxuICAgICAgICBzdGF0ZUNoYXIgPSBjXG4gICAgICAgIC8vIGlmIGV4dGdsb2IgaXMgZGlzYWJsZWQsIHRoZW4gKyhhc2RmfGZvbykgaXNuJ3QgYSB0aGluZy5cbiAgICAgICAgLy8ganVzdCBjbGVhciB0aGUgc3RhdGVjaGFyICpub3cqLCByYXRoZXIgdGhhbiBldmVuIGRpdmluZyBpbnRvXG4gICAgICAgIC8vIHRoZSBwYXR0ZXJuTGlzdCBzdHVmZi5cbiAgICAgICAgaWYgKG9wdGlvbnMubm9leHQpIGNsZWFyU3RhdGVDaGFyKClcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAgIGNhc2UgJygnOlxuICAgICAgICBpZiAoaW5DbGFzcykge1xuICAgICAgICAgIHJlICs9ICcoJ1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXN0YXRlQ2hhcikge1xuICAgICAgICAgIHJlICs9ICdcXFxcKCdcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgcGF0dGVybkxpc3RTdGFjay5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBzdGF0ZUNoYXIsXG4gICAgICAgICAgc3RhcnQ6IGkgLSAxLFxuICAgICAgICAgIHJlU3RhcnQ6IHJlLmxlbmd0aCxcbiAgICAgICAgICBvcGVuOiBwbFR5cGVzW3N0YXRlQ2hhcl0ub3BlbixcbiAgICAgICAgICBjbG9zZTogcGxUeXBlc1tzdGF0ZUNoYXJdLmNsb3NlXG4gICAgICAgIH0pXG4gICAgICAgIC8vIG5lZ2F0aW9uIGlzICg/Oig/IWpzKVteL10qKVxuICAgICAgICByZSArPSBzdGF0ZUNoYXIgPT09ICchJyA/ICcoPzooPyEoPzonIDogJyg/OidcbiAgICAgICAgdGhpcy5kZWJ1ZygncGxUeXBlICVqICVqJywgc3RhdGVDaGFyLCByZSlcbiAgICAgICAgc3RhdGVDaGFyID0gZmFsc2VcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAgIGNhc2UgJyknOlxuICAgICAgICBpZiAoaW5DbGFzcyB8fCAhcGF0dGVybkxpc3RTdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICByZSArPSAnXFxcXCknXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIGNsZWFyU3RhdGVDaGFyKClcbiAgICAgICAgaGFzTWFnaWMgPSB0cnVlXG4gICAgICAgIHZhciBwbCA9IHBhdHRlcm5MaXN0U3RhY2sucG9wKClcbiAgICAgICAgLy8gbmVnYXRpb24gaXMgKD86KD8hanMpW14vXSopXG4gICAgICAgIC8vIFRoZSBvdGhlcnMgYXJlICg/OjxwYXR0ZXJuPik8dHlwZT5cbiAgICAgICAgcmUgKz0gcGwuY2xvc2VcbiAgICAgICAgaWYgKHBsLnR5cGUgPT09ICchJykge1xuICAgICAgICAgIG5lZ2F0aXZlTGlzdHMucHVzaChwbClcbiAgICAgICAgfVxuICAgICAgICBwbC5yZUVuZCA9IHJlLmxlbmd0aFxuICAgICAgY29udGludWVcblxuICAgICAgY2FzZSAnfCc6XG4gICAgICAgIGlmIChpbkNsYXNzIHx8ICFwYXR0ZXJuTGlzdFN0YWNrLmxlbmd0aCB8fCBlc2NhcGluZykge1xuICAgICAgICAgIHJlICs9ICdcXFxcfCdcbiAgICAgICAgICBlc2NhcGluZyA9IGZhbHNlXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIGNsZWFyU3RhdGVDaGFyKClcbiAgICAgICAgcmUgKz0gJ3wnXG4gICAgICBjb250aW51ZVxuXG4gICAgICAvLyB0aGVzZSBhcmUgbW9zdGx5IHRoZSBzYW1lIGluIHJlZ2V4cCBhbmQgZ2xvYlxuICAgICAgY2FzZSAnWyc6XG4gICAgICAgIC8vIHN3YWxsb3cgYW55IHN0YXRlLXRyYWNraW5nIGNoYXIgYmVmb3JlIHRoZSBbXG4gICAgICAgIGNsZWFyU3RhdGVDaGFyKClcblxuICAgICAgICBpZiAoaW5DbGFzcykge1xuICAgICAgICAgIHJlICs9ICdcXFxcJyArIGNcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgaW5DbGFzcyA9IHRydWVcbiAgICAgICAgY2xhc3NTdGFydCA9IGlcbiAgICAgICAgcmVDbGFzc1N0YXJ0ID0gcmUubGVuZ3RoXG4gICAgICAgIHJlICs9IGNcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAgIGNhc2UgJ10nOlxuICAgICAgICAvLyAgYSByaWdodCBicmFja2V0IHNoYWxsIGxvc2UgaXRzIHNwZWNpYWxcbiAgICAgICAgLy8gIG1lYW5pbmcgYW5kIHJlcHJlc2VudCBpdHNlbGYgaW5cbiAgICAgICAgLy8gIGEgYnJhY2tldCBleHByZXNzaW9uIGlmIGl0IG9jY3Vyc1xuICAgICAgICAvLyAgZmlyc3QgaW4gdGhlIGxpc3QuICAtLSBQT1NJWC4yIDIuOC4zLjJcbiAgICAgICAgaWYgKGkgPT09IGNsYXNzU3RhcnQgKyAxIHx8ICFpbkNsYXNzKSB7XG4gICAgICAgICAgcmUgKz0gJ1xcXFwnICsgY1xuICAgICAgICAgIGVzY2FwaW5nID0gZmFsc2VcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHdlIGxlZnQgYSBjbGFzcyBvcGVuLlxuICAgICAgICAvLyBcIlt6LWFdXCIgaXMgdmFsaWQsIGVxdWl2YWxlbnQgdG8gXCJcXFt6LWFcXF1cIlxuICAgICAgICAvLyBzcGxpdCB3aGVyZSB0aGUgbGFzdCBbIHdhcywgbWFrZSBzdXJlIHdlIGRvbid0IGhhdmVcbiAgICAgICAgLy8gYW4gaW52YWxpZCByZS4gaWYgc28sIHJlLXdhbGsgdGhlIGNvbnRlbnRzIG9mIHRoZVxuICAgICAgICAvLyB3b3VsZC1iZSBjbGFzcyB0byByZS10cmFuc2xhdGUgYW55IGNoYXJhY3RlcnMgdGhhdFxuICAgICAgICAvLyB3ZXJlIHBhc3NlZCB0aHJvdWdoIGFzLWlzXG4gICAgICAgIC8vIFRPRE86IEl0IHdvdWxkIHByb2JhYmx5IGJlIGZhc3RlciB0byBkZXRlcm1pbmUgdGhpc1xuICAgICAgICAvLyB3aXRob3V0IGEgdHJ5L2NhdGNoIGFuZCBhIG5ldyBSZWdFeHAsIGJ1dCBpdCdzIHRyaWNreVxuICAgICAgICAvLyB0byBkbyBzYWZlbHkuICBGb3Igbm93LCB0aGlzIGlzIHNhZmUgYW5kIHdvcmtzLlxuICAgICAgICB2YXIgY3MgPSBwYXR0ZXJuLnN1YnN0cmluZyhjbGFzc1N0YXJ0ICsgMSwgaSlcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWdFeHAoJ1snICsgY3MgKyAnXScpXG4gICAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgICAgLy8gbm90IGEgdmFsaWQgY2xhc3MhXG4gICAgICAgICAgdmFyIHNwID0gdGhpcy5wYXJzZShjcywgU1VCUEFSU0UpXG4gICAgICAgICAgcmUgPSByZS5zdWJzdHIoMCwgcmVDbGFzc1N0YXJ0KSArICdcXFxcWycgKyBzcFswXSArICdcXFxcXSdcbiAgICAgICAgICBoYXNNYWdpYyA9IGhhc01hZ2ljIHx8IHNwWzFdXG4gICAgICAgICAgaW5DbGFzcyA9IGZhbHNlXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmlzaCB1cCB0aGUgY2xhc3MuXG4gICAgICAgIGhhc01hZ2ljID0gdHJ1ZVxuICAgICAgICBpbkNsYXNzID0gZmFsc2VcbiAgICAgICAgcmUgKz0gY1xuICAgICAgY29udGludWVcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gc3dhbGxvdyBhbnkgc3RhdGUgY2hhciB0aGF0IHdhc24ndCBjb25zdW1lZFxuICAgICAgICBjbGVhclN0YXRlQ2hhcigpXG5cbiAgICAgICAgaWYgKGVzY2FwaW5nKSB7XG4gICAgICAgICAgLy8gbm8gbmVlZFxuICAgICAgICAgIGVzY2FwaW5nID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIGlmIChyZVNwZWNpYWxzW2NdXG4gICAgICAgICAgJiYgIShjID09PSAnXicgJiYgaW5DbGFzcykpIHtcbiAgICAgICAgICByZSArPSAnXFxcXCdcbiAgICAgICAgfVxuXG4gICAgICAgIHJlICs9IGNcblxuICAgIH0gLy8gc3dpdGNoXG4gIH0gLy8gZm9yXG5cbiAgLy8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHdlIGxlZnQgYSBjbGFzcyBvcGVuLlxuICAvLyBcIlthYmNcIiBpcyB2YWxpZCwgZXF1aXZhbGVudCB0byBcIlxcW2FiY1wiXG4gIGlmIChpbkNsYXNzKSB7XG4gICAgLy8gc3BsaXQgd2hlcmUgdGhlIGxhc3QgWyB3YXMsIGFuZCBlc2NhcGUgaXRcbiAgICAvLyB0aGlzIGlzIGEgaHVnZSBwaXRhLiAgV2Ugbm93IGhhdmUgdG8gcmUtd2Fsa1xuICAgIC8vIHRoZSBjb250ZW50cyBvZiB0aGUgd291bGQtYmUgY2xhc3MgdG8gcmUtdHJhbnNsYXRlXG4gICAgLy8gYW55IGNoYXJhY3RlcnMgdGhhdCB3ZXJlIHBhc3NlZCB0aHJvdWdoIGFzLWlzXG4gICAgY3MgPSBwYXR0ZXJuLnN1YnN0cihjbGFzc1N0YXJ0ICsgMSlcbiAgICBzcCA9IHRoaXMucGFyc2UoY3MsIFNVQlBBUlNFKVxuICAgIHJlID0gcmUuc3Vic3RyKDAsIHJlQ2xhc3NTdGFydCkgKyAnXFxcXFsnICsgc3BbMF1cbiAgICBoYXNNYWdpYyA9IGhhc01hZ2ljIHx8IHNwWzFdXG4gIH1cblxuICAvLyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgd2UgaGFkIGEgKyggdGhpbmcgYXQgdGhlICplbmQqXG4gIC8vIG9mIHRoZSBwYXR0ZXJuLlxuICAvLyBlYWNoIHBhdHRlcm4gbGlzdCBzdGFjayBhZGRzIDMgY2hhcnMsIGFuZCB3ZSBuZWVkIHRvIGdvIHRocm91Z2hcbiAgLy8gYW5kIGVzY2FwZSBhbnkgfCBjaGFycyB0aGF0IHdlcmUgcGFzc2VkIHRocm91Z2ggYXMtaXMgZm9yIHRoZSByZWdleHAuXG4gIC8vIEdvIHRocm91Z2ggYW5kIGVzY2FwZSB0aGVtLCB0YWtpbmcgY2FyZSBub3QgdG8gZG91YmxlLWVzY2FwZSBhbnlcbiAgLy8gfCBjaGFycyB0aGF0IHdlcmUgYWxyZWFkeSBlc2NhcGVkLlxuICBmb3IgKHBsID0gcGF0dGVybkxpc3RTdGFjay5wb3AoKTsgcGw7IHBsID0gcGF0dGVybkxpc3RTdGFjay5wb3AoKSkge1xuICAgIHZhciB0YWlsID0gcmUuc2xpY2UocGwucmVTdGFydCArIHBsLm9wZW4ubGVuZ3RoKVxuICAgIHRoaXMuZGVidWcoJ3NldHRpbmcgdGFpbCcsIHJlLCBwbClcbiAgICAvLyBtYXliZSBzb21lIGV2ZW4gbnVtYmVyIG9mIFxcLCB0aGVuIG1heWJlIDEgXFwsIGZvbGxvd2VkIGJ5IGEgfFxuICAgIHRhaWwgPSB0YWlsLnJlcGxhY2UoLygoPzpcXFxcezJ9KXswLDY0fSkoXFxcXD8pXFx8L2csIGZ1bmN0aW9uIChfLCAkMSwgJDIpIHtcbiAgICAgIGlmICghJDIpIHtcbiAgICAgICAgLy8gdGhlIHwgaXNuJ3QgYWxyZWFkeSBlc2NhcGVkLCBzbyBlc2NhcGUgaXQuXG4gICAgICAgICQyID0gJ1xcXFwnXG4gICAgICB9XG5cbiAgICAgIC8vIG5lZWQgdG8gZXNjYXBlIGFsbCB0aG9zZSBzbGFzaGVzICphZ2FpbiosIHdpdGhvdXQgZXNjYXBpbmcgdGhlXG4gICAgICAvLyBvbmUgdGhhdCB3ZSBuZWVkIGZvciBlc2NhcGluZyB0aGUgfCBjaGFyYWN0ZXIuICBBcyBpdCB3b3JrcyBvdXQsXG4gICAgICAvLyBlc2NhcGluZyBhbiBldmVuIG51bWJlciBvZiBzbGFzaGVzIGNhbiBiZSBkb25lIGJ5IHNpbXBseSByZXBlYXRpbmdcbiAgICAgIC8vIGl0IGV4YWN0bHkgYWZ0ZXIgaXRzZWxmLiAgVGhhdCdzIHdoeSB0aGlzIHRyaWNrIHdvcmtzLlxuICAgICAgLy9cbiAgICAgIC8vIEkgYW0gc29ycnkgdGhhdCB5b3UgaGF2ZSB0byBzZWUgdGhpcy5cbiAgICAgIHJldHVybiAkMSArICQxICsgJDIgKyAnfCdcbiAgICB9KVxuXG4gICAgdGhpcy5kZWJ1ZygndGFpbD0lalxcbiAgICVzJywgdGFpbCwgdGFpbCwgcGwsIHJlKVxuICAgIHZhciB0ID0gcGwudHlwZSA9PT0gJyonID8gc3RhclxuICAgICAgOiBwbC50eXBlID09PSAnPycgPyBxbWFya1xuICAgICAgOiAnXFxcXCcgKyBwbC50eXBlXG5cbiAgICBoYXNNYWdpYyA9IHRydWVcbiAgICByZSA9IHJlLnNsaWNlKDAsIHBsLnJlU3RhcnQpICsgdCArICdcXFxcKCcgKyB0YWlsXG4gIH1cblxuICAvLyBoYW5kbGUgdHJhaWxpbmcgdGhpbmdzIHRoYXQgb25seSBtYXR0ZXIgYXQgdGhlIHZlcnkgZW5kLlxuICBjbGVhclN0YXRlQ2hhcigpXG4gIGlmIChlc2NhcGluZykge1xuICAgIC8vIHRyYWlsaW5nIFxcXFxcbiAgICByZSArPSAnXFxcXFxcXFwnXG4gIH1cblxuICAvLyBvbmx5IG5lZWQgdG8gYXBwbHkgdGhlIG5vZG90IHN0YXJ0IGlmIHRoZSByZSBzdGFydHMgd2l0aFxuICAvLyBzb21ldGhpbmcgdGhhdCBjb3VsZCBjb25jZWl2YWJseSBjYXB0dXJlIGEgZG90XG4gIHZhciBhZGRQYXR0ZXJuU3RhcnQgPSBmYWxzZVxuICBzd2l0Y2ggKHJlLmNoYXJBdCgwKSkge1xuICAgIGNhc2UgJ1snOiBjYXNlICcuJzogY2FzZSAnKCc6IGFkZFBhdHRlcm5TdGFydCA9IHRydWVcbiAgfVxuXG4gIC8vIEhhY2sgdG8gd29yayBhcm91bmQgbGFjayBvZiBuZWdhdGl2ZSBsb29rYmVoaW5kIGluIEpTXG4gIC8vIEEgcGF0dGVybiBsaWtlOiAqLiEoeCkuISh5fHopIG5lZWRzIHRvIGVuc3VyZSB0aGF0IGEgbmFtZVxuICAvLyBsaWtlICdhLnh5ei55eicgZG9lc24ndCBtYXRjaC4gIFNvLCB0aGUgZmlyc3QgbmVnYXRpdmVcbiAgLy8gbG9va2FoZWFkLCBoYXMgdG8gbG9vayBBTEwgdGhlIHdheSBhaGVhZCwgdG8gdGhlIGVuZCBvZlxuICAvLyB0aGUgcGF0dGVybi5cbiAgZm9yICh2YXIgbiA9IG5lZ2F0aXZlTGlzdHMubGVuZ3RoIC0gMTsgbiA+IC0xOyBuLS0pIHtcbiAgICB2YXIgbmwgPSBuZWdhdGl2ZUxpc3RzW25dXG5cbiAgICB2YXIgbmxCZWZvcmUgPSByZS5zbGljZSgwLCBubC5yZVN0YXJ0KVxuICAgIHZhciBubEZpcnN0ID0gcmUuc2xpY2UobmwucmVTdGFydCwgbmwucmVFbmQgLSA4KVxuICAgIHZhciBubExhc3QgPSByZS5zbGljZShubC5yZUVuZCAtIDgsIG5sLnJlRW5kKVxuICAgIHZhciBubEFmdGVyID0gcmUuc2xpY2UobmwucmVFbmQpXG5cbiAgICBubExhc3QgKz0gbmxBZnRlclxuXG4gICAgLy8gSGFuZGxlIG5lc3RlZCBzdHVmZiBsaWtlICooKi5qc3whKCouanNvbikpLCB3aGVyZSBvcGVuIHBhcmVuc1xuICAgIC8vIG1lYW4gdGhhdCB3ZSBzaG91bGQgKm5vdCogaW5jbHVkZSB0aGUgKSBpbiB0aGUgYml0IHRoYXQgaXMgY29uc2lkZXJlZFxuICAgIC8vIFwiYWZ0ZXJcIiB0aGUgbmVnYXRlZCBzZWN0aW9uLlxuICAgIHZhciBvcGVuUGFyZW5zQmVmb3JlID0gbmxCZWZvcmUuc3BsaXQoJygnKS5sZW5ndGggLSAxXG4gICAgdmFyIGNsZWFuQWZ0ZXIgPSBubEFmdGVyXG4gICAgZm9yIChpID0gMDsgaSA8IG9wZW5QYXJlbnNCZWZvcmU7IGkrKykge1xuICAgICAgY2xlYW5BZnRlciA9IGNsZWFuQWZ0ZXIucmVwbGFjZSgvXFwpWysqP10/LywgJycpXG4gICAgfVxuICAgIG5sQWZ0ZXIgPSBjbGVhbkFmdGVyXG5cbiAgICB2YXIgZG9sbGFyID0gJydcbiAgICBpZiAobmxBZnRlciA9PT0gJycgJiYgaXNTdWIgIT09IFNVQlBBUlNFKSB7XG4gICAgICBkb2xsYXIgPSAnJCdcbiAgICB9XG4gICAgdmFyIG5ld1JlID0gbmxCZWZvcmUgKyBubEZpcnN0ICsgbmxBZnRlciArIGRvbGxhciArIG5sTGFzdFxuICAgIHJlID0gbmV3UmVcbiAgfVxuXG4gIC8vIGlmIHRoZSByZSBpcyBub3QgXCJcIiBhdCB0aGlzIHBvaW50LCB0aGVuIHdlIG5lZWQgdG8gbWFrZSBzdXJlXG4gIC8vIGl0IGRvZXNuJ3QgbWF0Y2ggYWdhaW5zdCBhbiBlbXB0eSBwYXRoIHBhcnQuXG4gIC8vIE90aGVyd2lzZSBhLyogd2lsbCBtYXRjaCBhLywgd2hpY2ggaXQgc2hvdWxkIG5vdC5cbiAgaWYgKHJlICE9PSAnJyAmJiBoYXNNYWdpYykge1xuICAgIHJlID0gJyg/PS4pJyArIHJlXG4gIH1cblxuICBpZiAoYWRkUGF0dGVyblN0YXJ0KSB7XG4gICAgcmUgPSBwYXR0ZXJuU3RhcnQgKyByZVxuICB9XG5cbiAgLy8gcGFyc2luZyBqdXN0IGEgcGllY2Ugb2YgYSBsYXJnZXIgcGF0dGVybi5cbiAgaWYgKGlzU3ViID09PSBTVUJQQVJTRSkge1xuICAgIHJldHVybiBbcmUsIGhhc01hZ2ljXVxuICB9XG5cbiAgLy8gc2tpcCB0aGUgcmVnZXhwIGZvciBub24tbWFnaWNhbCBwYXR0ZXJuc1xuICAvLyB1bmVzY2FwZSBhbnl0aGluZyBpbiBpdCwgdGhvdWdoLCBzbyB0aGF0IGl0J2xsIGJlXG4gIC8vIGFuIGV4YWN0IG1hdGNoIGFnYWluc3QgYSBmaWxlIGV0Yy5cbiAgaWYgKCFoYXNNYWdpYykge1xuICAgIHJldHVybiBnbG9iVW5lc2NhcGUocGF0dGVybilcbiAgfVxuXG4gIHZhciBmbGFncyA9IG9wdGlvbnMubm9jYXNlID8gJ2knIDogJydcbiAgdHJ5IHtcbiAgICB2YXIgcmVnRXhwID0gbmV3IFJlZ0V4cCgnXicgKyByZSArICckJywgZmxhZ3MpXG4gIH0gY2F0Y2ggKGVyKSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIHNob3VsZCBiZSBpbXBvc3NpYmxlICovIHtcbiAgICAvLyBJZiBpdCB3YXMgYW4gaW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb24sIHRoZW4gaXQgY2FuJ3QgbWF0Y2hcbiAgICAvLyBhbnl0aGluZy4gIFRoaXMgdHJpY2sgbG9va3MgZm9yIGEgY2hhcmFjdGVyIGFmdGVyIHRoZSBlbmQgb2ZcbiAgICAvLyB0aGUgc3RyaW5nLCB3aGljaCBpcyBvZiBjb3Vyc2UgaW1wb3NzaWJsZSwgZXhjZXB0IGluIG11bHRpLWxpbmVcbiAgICAvLyBtb2RlLCBidXQgaXQncyBub3QgYSAvbSByZWdleC5cbiAgICByZXR1cm4gbmV3IFJlZ0V4cCgnJC4nKVxuICB9XG5cbiAgcmVnRXhwLl9nbG9iID0gcGF0dGVyblxuICByZWdFeHAuX3NyYyA9IHJlXG5cbiAgcmV0dXJuIHJlZ0V4cFxufVxuXG5taW5pbWF0Y2gubWFrZVJlID0gZnVuY3Rpb24gKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucyB8fCB7fSkubWFrZVJlKClcbn1cblxuTWluaW1hdGNoLnByb3RvdHlwZS5tYWtlUmUgPSBtYWtlUmVcbmZ1bmN0aW9uIG1ha2VSZSAoKSB7XG4gIGlmICh0aGlzLnJlZ2V4cCB8fCB0aGlzLnJlZ2V4cCA9PT0gZmFsc2UpIHJldHVybiB0aGlzLnJlZ2V4cFxuXG4gIC8vIGF0IHRoaXMgcG9pbnQsIHRoaXMuc2V0IGlzIGEgMmQgYXJyYXkgb2YgcGFydGlhbFxuICAvLyBwYXR0ZXJuIHN0cmluZ3MsIG9yIFwiKipcIi5cbiAgLy9cbiAgLy8gSXQncyBiZXR0ZXIgdG8gdXNlIC5tYXRjaCgpLiAgVGhpcyBmdW5jdGlvbiBzaG91bGRuJ3RcbiAgLy8gYmUgdXNlZCwgcmVhbGx5LCBidXQgaXQncyBwcmV0dHkgY29udmVuaWVudCBzb21ldGltZXMsXG4gIC8vIHdoZW4geW91IGp1c3Qgd2FudCB0byB3b3JrIHdpdGggYSByZWdleC5cbiAgdmFyIHNldCA9IHRoaXMuc2V0XG5cbiAgaWYgKCFzZXQubGVuZ3RoKSB7XG4gICAgdGhpcy5yZWdleHAgPSBmYWxzZVxuICAgIHJldHVybiB0aGlzLnJlZ2V4cFxuICB9XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zXG5cbiAgdmFyIHR3b1N0YXIgPSBvcHRpb25zLm5vZ2xvYnN0YXIgPyBzdGFyXG4gICAgOiBvcHRpb25zLmRvdCA/IHR3b1N0YXJEb3RcbiAgICA6IHR3b1N0YXJOb0RvdFxuICB2YXIgZmxhZ3MgPSBvcHRpb25zLm5vY2FzZSA/ICdpJyA6ICcnXG5cbiAgdmFyIHJlID0gc2V0Lm1hcChmdW5jdGlvbiAocGF0dGVybikge1xuICAgIHJldHVybiBwYXR0ZXJuLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIChwID09PSBHTE9CU1RBUikgPyB0d29TdGFyXG4gICAgICA6ICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpID8gcmVnRXhwRXNjYXBlKHApXG4gICAgICA6IHAuX3NyY1xuICAgIH0pLmpvaW4oJ1xcXFxcXC8nKVxuICB9KS5qb2luKCd8JylcblxuICAvLyBtdXN0IG1hdGNoIGVudGlyZSBwYXR0ZXJuXG4gIC8vIGVuZGluZyBpbiBhICogb3IgKiogd2lsbCBtYWtlIGl0IGxlc3Mgc3RyaWN0LlxuICByZSA9ICdeKD86JyArIHJlICsgJykkJ1xuXG4gIC8vIGNhbiBtYXRjaCBhbnl0aGluZywgYXMgbG9uZyBhcyBpdCdzIG5vdCB0aGlzLlxuICBpZiAodGhpcy5uZWdhdGUpIHJlID0gJ14oPyEnICsgcmUgKyAnKS4qJCdcblxuICB0cnkge1xuICAgIHRoaXMucmVnZXhwID0gbmV3IFJlZ0V4cChyZSwgZmxhZ3MpXG4gIH0gY2F0Y2ggKGV4KSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIHNob3VsZCBiZSBpbXBvc3NpYmxlICovIHtcbiAgICB0aGlzLnJlZ2V4cCA9IGZhbHNlXG4gIH1cbiAgcmV0dXJuIHRoaXMucmVnZXhwXG59XG5cbm1pbmltYXRjaC5tYXRjaCA9IGZ1bmN0aW9uIChsaXN0LCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIHZhciBtbSA9IG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucylcbiAgbGlzdCA9IGxpc3QuZmlsdGVyKGZ1bmN0aW9uIChmKSB7XG4gICAgcmV0dXJuIG1tLm1hdGNoKGYpXG4gIH0pXG4gIGlmIChtbS5vcHRpb25zLm5vbnVsbCAmJiAhbGlzdC5sZW5ndGgpIHtcbiAgICBsaXN0LnB1c2gocGF0dGVybilcbiAgfVxuICByZXR1cm4gbGlzdFxufVxuXG5NaW5pbWF0Y2gucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gbWF0Y2ggKGYsIHBhcnRpYWwpIHtcbiAgaWYgKHR5cGVvZiBwYXJ0aWFsID09PSAndW5kZWZpbmVkJykgcGFydGlhbCA9IHRoaXMucGFydGlhbFxuICB0aGlzLmRlYnVnKCdtYXRjaCcsIGYsIHRoaXMucGF0dGVybilcbiAgLy8gc2hvcnQtY2lyY3VpdCBpbiB0aGUgY2FzZSBvZiBidXN0ZWQgdGhpbmdzLlxuICAvLyBjb21tZW50cywgZXRjLlxuICBpZiAodGhpcy5jb21tZW50KSByZXR1cm4gZmFsc2VcbiAgaWYgKHRoaXMuZW1wdHkpIHJldHVybiBmID09PSAnJ1xuXG4gIGlmIChmID09PSAnLycgJiYgcGFydGlhbCkgcmV0dXJuIHRydWVcblxuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuXG4gIC8vIHdpbmRvd3M6IG5lZWQgdG8gdXNlIC8sIG5vdCBcXFxuICBpZiAocGF0aC5zZXAgIT09ICcvJykge1xuICAgIGYgPSBmLnNwbGl0KHBhdGguc2VwKS5qb2luKCcvJylcbiAgfVxuXG4gIC8vIHRyZWF0IHRoZSB0ZXN0IHBhdGggYXMgYSBzZXQgb2YgcGF0aHBhcnRzLlxuICBmID0gZi5zcGxpdChzbGFzaFNwbGl0KVxuICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgJ3NwbGl0JywgZilcblxuICAvLyBqdXN0IE9ORSBvZiB0aGUgcGF0dGVybiBzZXRzIGluIHRoaXMuc2V0IG5lZWRzIHRvIG1hdGNoXG4gIC8vIGluIG9yZGVyIGZvciBpdCB0byBiZSB2YWxpZC4gIElmIG5lZ2F0aW5nLCB0aGVuIGp1c3Qgb25lXG4gIC8vIG1hdGNoIG1lYW5zIHRoYXQgd2UgaGF2ZSBmYWlsZWQuXG4gIC8vIEVpdGhlciB3YXksIHJldHVybiBvbiB0aGUgZmlyc3QgaGl0LlxuXG4gIHZhciBzZXQgPSB0aGlzLnNldFxuICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgJ3NldCcsIHNldClcblxuICAvLyBGaW5kIHRoZSBiYXNlbmFtZSBvZiB0aGUgcGF0aCBieSBsb29raW5nIGZvciB0aGUgbGFzdCBub24tZW1wdHkgc2VnbWVudFxuICB2YXIgZmlsZW5hbWVcbiAgdmFyIGlcbiAgZm9yIChpID0gZi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGZpbGVuYW1lID0gZltpXVxuICAgIGlmIChmaWxlbmFtZSkgYnJlYWtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGF0dGVybiA9IHNldFtpXVxuICAgIHZhciBmaWxlID0gZlxuICAgIGlmIChvcHRpb25zLm1hdGNoQmFzZSAmJiBwYXR0ZXJuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZmlsZSA9IFtmaWxlbmFtZV1cbiAgICB9XG4gICAgdmFyIGhpdCA9IHRoaXMubWF0Y2hPbmUoZmlsZSwgcGF0dGVybiwgcGFydGlhbClcbiAgICBpZiAoaGl0KSB7XG4gICAgICBpZiAob3B0aW9ucy5mbGlwTmVnYXRlKSByZXR1cm4gdHJ1ZVxuICAgICAgcmV0dXJuICF0aGlzLm5lZ2F0ZVxuICAgIH1cbiAgfVxuXG4gIC8vIGRpZG4ndCBnZXQgYW55IGhpdHMuICB0aGlzIGlzIHN1Y2Nlc3MgaWYgaXQncyBhIG5lZ2F0aXZlXG4gIC8vIHBhdHRlcm4sIGZhaWx1cmUgb3RoZXJ3aXNlLlxuICBpZiAob3B0aW9ucy5mbGlwTmVnYXRlKSByZXR1cm4gZmFsc2VcbiAgcmV0dXJuIHRoaXMubmVnYXRlXG59XG5cbi8vIHNldCBwYXJ0aWFsIHRvIHRydWUgdG8gdGVzdCBpZiwgZm9yIGV4YW1wbGUsXG4vLyBcIi9hL2JcIiBtYXRjaGVzIHRoZSBzdGFydCBvZiBcIi8qL2IvKi9kXCJcbi8vIFBhcnRpYWwgbWVhbnMsIGlmIHlvdSBydW4gb3V0IG9mIGZpbGUgYmVmb3JlIHlvdSBydW5cbi8vIG91dCBvZiBwYXR0ZXJuLCB0aGVuIHRoYXQncyBmaW5lLCBhcyBsb25nIGFzIGFsbFxuLy8gdGhlIHBhcnRzIG1hdGNoLlxuTWluaW1hdGNoLnByb3RvdHlwZS5tYXRjaE9uZSA9IGZ1bmN0aW9uIChmaWxlLCBwYXR0ZXJuLCBwYXJ0aWFsKSB7XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zXG5cbiAgdGhpcy5kZWJ1ZygnbWF0Y2hPbmUnLFxuICAgIHsgJ3RoaXMnOiB0aGlzLCBmaWxlOiBmaWxlLCBwYXR0ZXJuOiBwYXR0ZXJuIH0pXG5cbiAgdGhpcy5kZWJ1ZygnbWF0Y2hPbmUnLCBmaWxlLmxlbmd0aCwgcGF0dGVybi5sZW5ndGgpXG5cbiAgZm9yICh2YXIgZmkgPSAwLFxuICAgICAgcGkgPSAwLFxuICAgICAgZmwgPSBmaWxlLmxlbmd0aCxcbiAgICAgIHBsID0gcGF0dGVybi5sZW5ndGhcbiAgICAgIDsgKGZpIDwgZmwpICYmIChwaSA8IHBsKVxuICAgICAgOyBmaSsrLCBwaSsrKSB7XG4gICAgdGhpcy5kZWJ1ZygnbWF0Y2hPbmUgbG9vcCcpXG4gICAgdmFyIHAgPSBwYXR0ZXJuW3BpXVxuICAgIHZhciBmID0gZmlsZVtmaV1cblxuICAgIHRoaXMuZGVidWcocGF0dGVybiwgcCwgZilcblxuICAgIC8vIHNob3VsZCBiZSBpbXBvc3NpYmxlLlxuICAgIC8vIHNvbWUgaW52YWxpZCByZWdleHAgc3R1ZmYgaW4gdGhlIHNldC5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocCA9PT0gZmFsc2UpIHJldHVybiBmYWxzZVxuXG4gICAgaWYgKHAgPT09IEdMT0JTVEFSKSB7XG4gICAgICB0aGlzLmRlYnVnKCdHTE9CU1RBUicsIFtwYXR0ZXJuLCBwLCBmXSlcblxuICAgICAgLy8gXCIqKlwiXG4gICAgICAvLyBhLyoqL2IvKiovYyB3b3VsZCBtYXRjaCB0aGUgZm9sbG93aW5nOlxuICAgICAgLy8gYS9iL3gveS96L2NcbiAgICAgIC8vIGEveC95L3ovYi9jXG4gICAgICAvLyBhL2IveC9iL3gvY1xuICAgICAgLy8gYS9iL2NcbiAgICAgIC8vIFRvIGRvIHRoaXMsIHRha2UgdGhlIHJlc3Qgb2YgdGhlIHBhdHRlcm4gYWZ0ZXJcbiAgICAgIC8vIHRoZSAqKiwgYW5kIHNlZSBpZiBpdCB3b3VsZCBtYXRjaCB0aGUgZmlsZSByZW1haW5kZXIuXG4gICAgICAvLyBJZiBzbywgcmV0dXJuIHN1Y2Nlc3MuXG4gICAgICAvLyBJZiBub3QsIHRoZSAqKiBcInN3YWxsb3dzXCIgYSBzZWdtZW50LCBhbmQgdHJ5IGFnYWluLlxuICAgICAgLy8gVGhpcyBpcyByZWN1cnNpdmVseSBhd2Z1bC5cbiAgICAgIC8vXG4gICAgICAvLyBhLyoqL2IvKiovYyBtYXRjaGluZyBhL2IveC95L3ovY1xuICAgICAgLy8gLSBhIG1hdGNoZXMgYVxuICAgICAgLy8gLSBkb3VibGVzdGFyXG4gICAgICAvLyAgIC0gbWF0Y2hPbmUoYi94L3kvei9jLCBiLyoqL2MpXG4gICAgICAvLyAgICAgLSBiIG1hdGNoZXMgYlxuICAgICAgLy8gICAgIC0gZG91Ymxlc3RhclxuICAgICAgLy8gICAgICAgLSBtYXRjaE9uZSh4L3kvei9jLCBjKSAtPiBub1xuICAgICAgLy8gICAgICAgLSBtYXRjaE9uZSh5L3ovYywgYykgLT4gbm9cbiAgICAgIC8vICAgICAgIC0gbWF0Y2hPbmUoei9jLCBjKSAtPiBub1xuICAgICAgLy8gICAgICAgLSBtYXRjaE9uZShjLCBjKSB5ZXMsIGhpdFxuICAgICAgdmFyIGZyID0gZmlcbiAgICAgIHZhciBwciA9IHBpICsgMVxuICAgICAgaWYgKHByID09PSBwbCkge1xuICAgICAgICB0aGlzLmRlYnVnKCcqKiBhdCB0aGUgZW5kJylcbiAgICAgICAgLy8gYSAqKiBhdCB0aGUgZW5kIHdpbGwganVzdCBzd2FsbG93IHRoZSByZXN0LlxuICAgICAgICAvLyBXZSBoYXZlIGZvdW5kIGEgbWF0Y2guXG4gICAgICAgIC8vIGhvd2V2ZXIsIGl0IHdpbGwgbm90IHN3YWxsb3cgLy54LCB1bmxlc3NcbiAgICAgICAgLy8gb3B0aW9ucy5kb3QgaXMgc2V0LlxuICAgICAgICAvLyAuIGFuZCAuLiBhcmUgKm5ldmVyKiBtYXRjaGVkIGJ5ICoqLCBmb3IgZXhwbG9zaXZlbHlcbiAgICAgICAgLy8gZXhwb25lbnRpYWwgcmVhc29ucy5cbiAgICAgICAgZm9yICg7IGZpIDwgZmw7IGZpKyspIHtcbiAgICAgICAgICBpZiAoZmlsZVtmaV0gPT09ICcuJyB8fCBmaWxlW2ZpXSA9PT0gJy4uJyB8fFxuICAgICAgICAgICAgKCFvcHRpb25zLmRvdCAmJiBmaWxlW2ZpXS5jaGFyQXQoMCkgPT09ICcuJykpIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG5cbiAgICAgIC8vIG9rLCBsZXQncyBzZWUgaWYgd2UgY2FuIHN3YWxsb3cgd2hhdGV2ZXIgd2UgY2FuLlxuICAgICAgd2hpbGUgKGZyIDwgZmwpIHtcbiAgICAgICAgdmFyIHN3YWxsb3dlZSA9IGZpbGVbZnJdXG5cbiAgICAgICAgdGhpcy5kZWJ1ZygnXFxuZ2xvYnN0YXIgd2hpbGUnLCBmaWxlLCBmciwgcGF0dGVybiwgcHIsIHN3YWxsb3dlZSlcblxuICAgICAgICAvLyBYWFggcmVtb3ZlIHRoaXMgc2xpY2UuICBKdXN0IHBhc3MgdGhlIHN0YXJ0IGluZGV4LlxuICAgICAgICBpZiAodGhpcy5tYXRjaE9uZShmaWxlLnNsaWNlKGZyKSwgcGF0dGVybi5zbGljZShwciksIHBhcnRpYWwpKSB7XG4gICAgICAgICAgdGhpcy5kZWJ1ZygnZ2xvYnN0YXIgZm91bmQgbWF0Y2ghJywgZnIsIGZsLCBzd2FsbG93ZWUpXG4gICAgICAgICAgLy8gZm91bmQgYSBtYXRjaC5cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNhbid0IHN3YWxsb3cgXCIuXCIgb3IgXCIuLlwiIGV2ZXIuXG4gICAgICAgICAgLy8gY2FuIG9ubHkgc3dhbGxvdyBcIi5mb29cIiB3aGVuIGV4cGxpY2l0bHkgYXNrZWQuXG4gICAgICAgICAgaWYgKHN3YWxsb3dlZSA9PT0gJy4nIHx8IHN3YWxsb3dlZSA9PT0gJy4uJyB8fFxuICAgICAgICAgICAgKCFvcHRpb25zLmRvdCAmJiBzd2FsbG93ZWUuY2hhckF0KDApID09PSAnLicpKSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnKCdkb3QgZGV0ZWN0ZWQhJywgZmlsZSwgZnIsIHBhdHRlcm4sIHByKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyAqKiBzd2FsbG93cyBhIHNlZ21lbnQsIGFuZCBjb250aW51ZS5cbiAgICAgICAgICB0aGlzLmRlYnVnKCdnbG9ic3RhciBzd2FsbG93IGEgc2VnbWVudCwgYW5kIGNvbnRpbnVlJylcbiAgICAgICAgICBmcisrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gbm8gbWF0Y2ggd2FzIGZvdW5kLlxuICAgICAgLy8gSG93ZXZlciwgaW4gcGFydGlhbCBtb2RlLCB3ZSBjYW4ndCBzYXkgdGhpcyBpcyBuZWNlc3NhcmlseSBvdmVyLlxuICAgICAgLy8gSWYgdGhlcmUncyBtb3JlICpwYXR0ZXJuKiBsZWZ0LCB0aGVuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwYXJ0aWFsKSB7XG4gICAgICAgIC8vIHJhbiBvdXQgb2YgZmlsZVxuICAgICAgICB0aGlzLmRlYnVnKCdcXG4+Pj4gbm8gbWF0Y2gsIHBhcnRpYWw/JywgZmlsZSwgZnIsIHBhdHRlcm4sIHByKVxuICAgICAgICBpZiAoZnIgPT09IGZsKSByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gc29tZXRoaW5nIG90aGVyIHRoYW4gKipcbiAgICAvLyBub24tbWFnaWMgcGF0dGVybnMganVzdCBoYXZlIHRvIG1hdGNoIGV4YWN0bHlcbiAgICAvLyBwYXR0ZXJucyB3aXRoIG1hZ2ljIGhhdmUgYmVlbiB0dXJuZWQgaW50byByZWdleHBzLlxuICAgIHZhciBoaXRcbiAgICBpZiAodHlwZW9mIHAgPT09ICdzdHJpbmcnKSB7XG4gICAgICBoaXQgPSBmID09PSBwXG4gICAgICB0aGlzLmRlYnVnKCdzdHJpbmcgbWF0Y2gnLCBwLCBmLCBoaXQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGhpdCA9IGYubWF0Y2gocClcbiAgICAgIHRoaXMuZGVidWcoJ3BhdHRlcm4gbWF0Y2gnLCBwLCBmLCBoaXQpXG4gICAgfVxuXG4gICAgaWYgKCFoaXQpIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gTm90ZTogZW5kaW5nIGluIC8gbWVhbnMgdGhhdCB3ZSdsbCBnZXQgYSBmaW5hbCBcIlwiXG4gIC8vIGF0IHRoZSBlbmQgb2YgdGhlIHBhdHRlcm4uICBUaGlzIGNhbiBvbmx5IG1hdGNoIGFcbiAgLy8gY29ycmVzcG9uZGluZyBcIlwiIGF0IHRoZSBlbmQgb2YgdGhlIGZpbGUuXG4gIC8vIElmIHRoZSBmaWxlIGVuZHMgaW4gLywgdGhlbiBpdCBjYW4gb25seSBtYXRjaCBhXG4gIC8vIGEgcGF0dGVybiB0aGF0IGVuZHMgaW4gLywgdW5sZXNzIHRoZSBwYXR0ZXJuIGp1c3RcbiAgLy8gZG9lc24ndCBoYXZlIGFueSBtb3JlIGZvciBpdC4gQnV0LCBhL2IvIHNob3VsZCAqbm90KlxuICAvLyBtYXRjaCBcImEvYi8qXCIsIGV2ZW4gdGhvdWdoIFwiXCIgbWF0Y2hlcyBhZ2FpbnN0IHRoZVxuICAvLyBbXi9dKj8gcGF0dGVybiwgZXhjZXB0IGluIHBhcnRpYWwgbW9kZSwgd2hlcmUgaXQgbWlnaHRcbiAgLy8gc2ltcGx5IG5vdCBiZSByZWFjaGVkIHlldC5cbiAgLy8gSG93ZXZlciwgYS9iLyBzaG91bGQgc3RpbGwgc2F0aXNmeSBhLypcblxuICAvLyBub3cgZWl0aGVyIHdlIGZlbGwgb2ZmIHRoZSBlbmQgb2YgdGhlIHBhdHRlcm4sIG9yIHdlJ3JlIGRvbmUuXG4gIGlmIChmaSA9PT0gZmwgJiYgcGkgPT09IHBsKSB7XG4gICAgLy8gcmFuIG91dCBvZiBwYXR0ZXJuIGFuZCBmaWxlbmFtZSBhdCB0aGUgc2FtZSB0aW1lLlxuICAgIC8vIGFuIGV4YWN0IGhpdCFcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGVsc2UgaWYgKGZpID09PSBmbCkge1xuICAgIC8vIHJhbiBvdXQgb2YgZmlsZSwgYnV0IHN0aWxsIGhhZCBwYXR0ZXJuIGxlZnQuXG4gICAgLy8gdGhpcyBpcyBvayBpZiB3ZSdyZSBkb2luZyB0aGUgbWF0Y2ggYXMgcGFydCBvZlxuICAgIC8vIGEgZ2xvYiBmcyB0cmF2ZXJzYWwuXG4gICAgcmV0dXJuIHBhcnRpYWxcbiAgfSBlbHNlIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovIGlmIChwaSA9PT0gcGwpIHtcbiAgICAvLyByYW4gb3V0IG9mIHBhdHRlcm4sIHN0aWxsIGhhdmUgZmlsZSBsZWZ0LlxuICAgIC8vIHRoaXMgaXMgb25seSBhY2NlcHRhYmxlIGlmIHdlJ3JlIG9uIHRoZSB2ZXJ5IGxhc3RcbiAgICAvLyBlbXB0eSBzZWdtZW50IG9mIGEgZmlsZSB3aXRoIGEgdHJhaWxpbmcgc2xhc2guXG4gICAgLy8gYS8qIHNob3VsZCBtYXRjaCBhL2IvXG4gICAgcmV0dXJuIChmaSA9PT0gZmwgLSAxKSAmJiAoZmlsZVtmaV0gPT09ICcnKVxuICB9XG5cbiAgLy8gc2hvdWxkIGJlIHVucmVhY2hhYmxlLlxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB0aHJvdyBuZXcgRXJyb3IoJ3d0Zj8nKVxufVxuXG4vLyByZXBsYWNlIHN0dWZmIGxpa2UgXFwqIHdpdGggKlxuZnVuY3Rpb24gZ2xvYlVuZXNjYXBlIChzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL1xcXFwoLikvZywgJyQxJylcbn1cblxuZnVuY3Rpb24gcmVnRXhwRXNjYXBlIChzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL1stW1xcXXt9KCkqKz8uLFxcXFxeJHwjXFxzXS9nLCAnXFxcXCQmJylc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