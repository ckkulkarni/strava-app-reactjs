e8cf855c73270f842d4380cf74557a1f
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
function _interopDefault(ex) {
  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;
}
var React = require('react');
var isEqual = _interopDefault(require('react-fast-compare'));
var deepmerge = _interopDefault(require('deepmerge'));
var isPlainObject = _interopDefault(require('lodash/isPlainObject'));
var clone = _interopDefault(require('lodash/clone'));
var toPath = _interopDefault(require('lodash/toPath'));
var invariant = _interopDefault(require('tiny-warning'));
var hoistNonReactStatics = _interopDefault(require('hoist-non-react-statics'));
var cloneDeep = _interopDefault(require('lodash/cloneDeep'));
function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}

/** @private is the value an empty array? */

var isEmptyArray = function isEmptyArray(value) {
  return Array.isArray(value) && value.length === 0;
};
/** @private is the given object a Function? */

var isFunction = function isFunction(obj) {
  return typeof obj === 'function';
};
/** @private is the given object an Object? */

var isObject = function isObject(obj) {
  return obj !== null && typeof obj === 'object';
};
/** @private is the given object an integer? */

var isInteger = function isInteger(obj) {
  return String(Math.floor(Number(obj))) === obj;
};
/** @private is the given object a string? */

var isString = function isString(obj) {
  return Object.prototype.toString.call(obj) === '[object String]';
};
/** @private is the given object a NaN? */
// eslint-disable-next-line no-self-compare

var isNaN$1 = function isNaN(obj) {
  return obj !== obj;
};
/** @private Does a React component have exactly 0 children? */

var isEmptyChildren = function isEmptyChildren(children) {
  return React.Children.count(children) === 0;
};
/** @private is the given object/value a promise? */

var isPromise = function isPromise(value) {
  return isObject(value) && isFunction(value.then);
};
/** @private is the given object/value a type of synthetic event? */

var isInputEvent = function isInputEvent(value) {
  return value && isObject(value) && isObject(value.target);
};
/**
 * Same as document.activeElement but wraps in a try-catch block. In IE it is
 * not safe to call document.activeElement if there is nothing focused.
 *
 * The activeElement will be null only if the document or document body is not
 * yet defined.
 *
 * @param {?Document} doc Defaults to current document.
 * @return {Element | null}
 * @see https://github.com/facebook/fbjs/blob/master/packages/fbjs/src/core/dom/getActiveElement.js
 */

function getActiveElement(doc) {
  doc = doc || (typeof document !== 'undefined' ? document : undefined);
  if (typeof doc === 'undefined') {
    return null;
  }
  try {
    return doc.activeElement || doc.body;
  } catch (e) {
    return doc.body;
  }
}
/**
 * Deeply get a value from an object via its path.
 */

function getIn(obj, key, def, p) {
  if (p === void 0) {
    p = 0;
  }
  var path = toPath(key);
  while (obj && p < path.length) {
    obj = obj[path[p++]];
  }
  return obj === undefined ? def : obj;
}
/**
 * Deeply set a value from in object via it's path. If the value at `path`
 * has changed, return a shallow copy of obj with `value` set at `path`.
 * If `value` has not changed, return the original `obj`.
 *
 * Existing objects / arrays along `path` are also shallow copied. Sibling
 * objects along path retain the same internal js reference. Since new
 * objects / arrays are only created along `path`, we can test if anything
 * changed in a nested structure by comparing the object's reference in
 * the old and new object, similar to how russian doll cache invalidation
 * works.
 *
 * In earlier versions of this function, which used cloneDeep, there were
 * issues whereby settings a nested value would mutate the parent
 * instead of creating a new object. `clone` avoids that bug making a
 * shallow copy of the objects along the update path
 * so no object is mutated in place.
 *
 * Before changing this function, please read through the following
 * discussions.
 *
 * @see https://github.com/developit/linkstate
 * @see https://github.com/jaredpalmer/formik/pull/123
 */

function setIn(obj, path, value) {
  var res = clone(obj); // this keeps inheritance when obj is a class

  var resVal = res;
  var i = 0;
  var pathArray = toPath(path);
  for (; i < pathArray.length - 1; i++) {
    var currentPath = pathArray[i];
    var currentObj = getIn(obj, pathArray.slice(0, i + 1));
    if (currentObj && (isObject(currentObj) || Array.isArray(currentObj))) {
      resVal = resVal[currentPath] = clone(currentObj);
    } else {
      var nextPath = pathArray[i + 1];
      resVal = resVal[currentPath] = isInteger(nextPath) && Number(nextPath) >= 0 ? [] : {};
    }
  } // Return original object if new value is the same as current

  if ((i === 0 ? obj : resVal)[pathArray[i]] === value) {
    return obj;
  }
  if (value === undefined) {
    delete resVal[pathArray[i]];
  } else {
    resVal[pathArray[i]] = value;
  } // If the path array has a single element, the loop did not run.
  // Deleting on `resVal` had no effect in this scenario, so we delete on the result instead.

  if (i === 0 && value === undefined) {
    delete res[pathArray[i]];
  }
  return res;
}
/**
 * Recursively a set the same value for all keys and arrays nested object, cloning
 * @param object
 * @param value
 * @param visited
 * @param response
 */

function setNestedObjectValues(object, value, visited, response) {
  if (visited === void 0) {
    visited = new WeakMap();
  }
  if (response === void 0) {
    response = {};
  }
  for (var _i = 0, _Object$keys = Object.keys(object); _i < _Object$keys.length; _i++) {
    var k = _Object$keys[_i];
    var val = object[k];
    if (isObject(val)) {
      if (!visited.get(val)) {
        visited.set(val, true); // In order to keep array values consistent for both dot path  and
        // bracket syntax, we need to check if this is an array so that
        // this will output  { friends: [true] } and not { friends: { "0": true } }

        response[k] = Array.isArray(val) ? [] : {};
        setNestedObjectValues(val, value, visited, response[k]);
      }
    } else {
      response[k] = value;
    }
  }
  return response;
}
var FormikContext = /*#__PURE__*/React.createContext(undefined);
FormikContext.displayName = 'FormikContext';
var FormikProvider = FormikContext.Provider;
var FormikConsumer = FormikContext.Consumer;
function useFormikContext() {
  var formik = React.useContext(FormikContext);
  !!!formik ? invariant(false, "Formik context is undefined, please verify you are calling useFormikContext() as child of a <Formik> component.") : void 0;
  return formik;
}
function formikReducer(state, msg) {
  switch (msg.type) {
    case 'SET_VALUES':
      return _extends({}, state, {
        values: msg.payload
      });
    case 'SET_TOUCHED':
      return _extends({}, state, {
        touched: msg.payload
      });
    case 'SET_ERRORS':
      if (isEqual(state.errors, msg.payload)) {
        return state;
      }
      return _extends({}, state, {
        errors: msg.payload
      });
    case 'SET_STATUS':
      return _extends({}, state, {
        status: msg.payload
      });
    case 'SET_ISSUBMITTING':
      return _extends({}, state, {
        isSubmitting: msg.payload
      });
    case 'SET_ISVALIDATING':
      return _extends({}, state, {
        isValidating: msg.payload
      });
    case 'SET_FIELD_VALUE':
      return _extends({}, state, {
        values: setIn(state.values, msg.payload.field, msg.payload.value)
      });
    case 'SET_FIELD_TOUCHED':
      return _extends({}, state, {
        touched: setIn(state.touched, msg.payload.field, msg.payload.value)
      });
    case 'SET_FIELD_ERROR':
      return _extends({}, state, {
        errors: setIn(state.errors, msg.payload.field, msg.payload.value)
      });
    case 'RESET_FORM':
      return _extends({}, state, msg.payload);
    case 'SET_FORMIK_STATE':
      return msg.payload(state);
    case 'SUBMIT_ATTEMPT':
      return _extends({}, state, {
        touched: setNestedObjectValues(state.values, true),
        isSubmitting: true,
        submitCount: state.submitCount + 1
      });
    case 'SUBMIT_FAILURE':
      return _extends({}, state, {
        isSubmitting: false
      });
    case 'SUBMIT_SUCCESS':
      return _extends({}, state, {
        isSubmitting: false
      });
    default:
      return state;
  }
} // Initial empty states // objects

var emptyErrors = {};
var emptyTouched = {};
function useFormik(_ref) {
  var _ref$validateOnChange = _ref.validateOnChange,
    validateOnChange = _ref$validateOnChange === void 0 ? true : _ref$validateOnChange,
    _ref$validateOnBlur = _ref.validateOnBlur,
    validateOnBlur = _ref$validateOnBlur === void 0 ? true : _ref$validateOnBlur,
    _ref$validateOnMount = _ref.validateOnMount,
    validateOnMount = _ref$validateOnMount === void 0 ? false : _ref$validateOnMount,
    isInitialValid = _ref.isInitialValid,
    _ref$enableReinitiali = _ref.enableReinitialize,
    enableReinitialize = _ref$enableReinitiali === void 0 ? false : _ref$enableReinitiali,
    onSubmit = _ref.onSubmit,
    rest = _objectWithoutPropertiesLoose(_ref, ["validateOnChange", "validateOnBlur", "validateOnMount", "isInitialValid", "enableReinitialize", "onSubmit"]);
  var props = _extends({
    validateOnChange: validateOnChange,
    validateOnBlur: validateOnBlur,
    validateOnMount: validateOnMount,
    onSubmit: onSubmit
  }, rest);
  var initialValues = React.useRef(props.initialValues);
  var initialErrors = React.useRef(props.initialErrors || emptyErrors);
  var initialTouched = React.useRef(props.initialTouched || emptyTouched);
  var initialStatus = React.useRef(props.initialStatus);
  var isMounted = React.useRef(false);
  var fieldRegistry = React.useRef({});
  {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    React.useEffect(function () {
      !(typeof isInitialValid === 'undefined') ? invariant(false, 'isInitialValid has been deprecated and will be removed in future versions of Formik. Please use initialErrors or validateOnMount instead.') : void 0; // eslint-disable-next-line
    }, []);
  }
  React.useEffect(function () {
    isMounted.current = true;
    return function () {
      isMounted.current = false;
    };
  }, []);
  var _React$useReducer = React.useReducer(formikReducer, {
      values: props.initialValues,
      errors: props.initialErrors || emptyErrors,
      touched: props.initialTouched || emptyTouched,
      status: props.initialStatus,
      isSubmitting: false,
      isValidating: false,
      submitCount: 0
    }),
    state = _React$useReducer[0],
    dispatch = _React$useReducer[1];
  var runValidateHandler = React.useCallback(function (values, field) {
    return new Promise(function (resolve, reject) {
      var maybePromisedErrors = props.validate(values, field);
      if (maybePromisedErrors == null) {
        // use loose null check here on purpose
        resolve(emptyErrors);
      } else if (isPromise(maybePromisedErrors)) {
        maybePromisedErrors.then(function (errors) {
          resolve(errors || emptyErrors);
        }, function (actualException) {
          {
            console.warn("Warning: An unhandled error was caught during validation in <Formik validate />", actualException);
          }
          reject(actualException);
        });
      } else {
        resolve(maybePromisedErrors);
      }
    });
  }, [props.validate]);
  /**
   * Run validation against a Yup schema and optionally run a function if successful
   */

  var runValidationSchema = React.useCallback(function (values, field) {
    var validationSchema = props.validationSchema;
    var schema = isFunction(validationSchema) ? validationSchema(field) : validationSchema;
    var promise = field && schema.validateAt ? schema.validateAt(field, values) : validateYupSchema(values, schema);
    return new Promise(function (resolve, reject) {
      promise.then(function () {
        resolve(emptyErrors);
      }, function (err) {
        // Yup will throw a validation error if validation fails. We catch those and
        // resolve them into Formik errors. We can sniff if something is a Yup error
        // by checking error.name.
        // @see https://github.com/jquense/yup#validationerrorerrors-string--arraystring-value-any-path-string
        if (err.name === 'ValidationError') {
          resolve(yupToFormErrors(err));
        } else {
          // We throw any other errors
          {
            console.warn("Warning: An unhandled error was caught during validation in <Formik validationSchema />", err);
          }
          reject(err);
        }
      });
    });
  }, [props.validationSchema]);
  var runSingleFieldLevelValidation = React.useCallback(function (field, value) {
    return new Promise(function (resolve) {
      return resolve(fieldRegistry.current[field].validate(value));
    });
  }, []);
  var runFieldLevelValidations = React.useCallback(function (values) {
    var fieldKeysWithValidation = Object.keys(fieldRegistry.current).filter(function (f) {
      return isFunction(fieldRegistry.current[f].validate);
    }); // Construct an array with all of the field validation functions

    var fieldValidations = fieldKeysWithValidation.length > 0 ? fieldKeysWithValidation.map(function (f) {
      return runSingleFieldLevelValidation(f, getIn(values, f));
    }) : [Promise.resolve('DO_NOT_DELETE_YOU_WILL_BE_FIRED')]; // use special case ;)

    return Promise.all(fieldValidations).then(function (fieldErrorsList) {
      return fieldErrorsList.reduce(function (prev, curr, index) {
        if (curr === 'DO_NOT_DELETE_YOU_WILL_BE_FIRED') {
          return prev;
        }
        if (curr) {
          prev = setIn(prev, fieldKeysWithValidation[index], curr);
        }
        return prev;
      }, {});
    });
  }, [runSingleFieldLevelValidation]); // Run all validations and return the result

  var runAllValidations = React.useCallback(function (values) {
    return Promise.all([runFieldLevelValidations(values), props.validationSchema ? runValidationSchema(values) : {}, props.validate ? runValidateHandler(values) : {}]).then(function (_ref2) {
      var fieldErrors = _ref2[0],
        schemaErrors = _ref2[1],
        validateErrors = _ref2[2];
      var combinedErrors = deepmerge.all([fieldErrors, schemaErrors, validateErrors], {
        arrayMerge: arrayMerge
      });
      return combinedErrors;
    });
  }, [props.validate, props.validationSchema, runFieldLevelValidations, runValidateHandler, runValidationSchema]); // Run all validations methods and update state accordingly

  var validateFormWithHighPriority = useEventCallback(function (values) {
    if (values === void 0) {
      values = state.values;
    }
    dispatch({
      type: 'SET_ISVALIDATING',
      payload: true
    });
    return runAllValidations(values).then(function (combinedErrors) {
      if (!!isMounted.current) {
        dispatch({
          type: 'SET_ISVALIDATING',
          payload: false
        });
        dispatch({
          type: 'SET_ERRORS',
          payload: combinedErrors
        });
      }
      return combinedErrors;
    });
  });
  React.useEffect(function () {
    if (validateOnMount && isMounted.current === true && isEqual(initialValues.current, props.initialValues)) {
      validateFormWithHighPriority(initialValues.current);
    }
  }, [validateOnMount, validateFormWithHighPriority]);
  var resetForm = React.useCallback(function (nextState) {
    var values = nextState && nextState.values ? nextState.values : initialValues.current;
    var errors = nextState && nextState.errors ? nextState.errors : initialErrors.current ? initialErrors.current : props.initialErrors || {};
    var touched = nextState && nextState.touched ? nextState.touched : initialTouched.current ? initialTouched.current : props.initialTouched || {};
    var status = nextState && nextState.status ? nextState.status : initialStatus.current ? initialStatus.current : props.initialStatus;
    initialValues.current = values;
    initialErrors.current = errors;
    initialTouched.current = touched;
    initialStatus.current = status;
    var dispatchFn = function dispatchFn() {
      dispatch({
        type: 'RESET_FORM',
        payload: {
          isSubmitting: !!nextState && !!nextState.isSubmitting,
          errors: errors,
          touched: touched,
          status: status,
          values: values,
          isValidating: !!nextState && !!nextState.isValidating,
          submitCount: !!nextState && !!nextState.submitCount && typeof nextState.submitCount === 'number' ? nextState.submitCount : 0
        }
      });
    };
    if (props.onReset) {
      var maybePromisedOnReset = props.onReset(state.values, imperativeMethods);
      if (isPromise(maybePromisedOnReset)) {
        maybePromisedOnReset.then(dispatchFn);
      } else {
        dispatchFn();
      }
    } else {
      dispatchFn();
    }
  }, [props.initialErrors, props.initialStatus, props.initialTouched]);
  React.useEffect(function () {
    if (isMounted.current === true && !isEqual(initialValues.current, props.initialValues)) {
      if (enableReinitialize) {
        initialValues.current = props.initialValues;
        resetForm();
      }
      if (validateOnMount) {
        validateFormWithHighPriority(initialValues.current);
      }
    }
  }, [enableReinitialize, props.initialValues, resetForm, validateOnMount, validateFormWithHighPriority]);
  React.useEffect(function () {
    if (enableReinitialize && isMounted.current === true && !isEqual(initialErrors.current, props.initialErrors)) {
      initialErrors.current = props.initialErrors || emptyErrors;
      dispatch({
        type: 'SET_ERRORS',
        payload: props.initialErrors || emptyErrors
      });
    }
  }, [enableReinitialize, props.initialErrors]);
  React.useEffect(function () {
    if (enableReinitialize && isMounted.current === true && !isEqual(initialTouched.current, props.initialTouched)) {
      initialTouched.current = props.initialTouched || emptyTouched;
      dispatch({
        type: 'SET_TOUCHED',
        payload: props.initialTouched || emptyTouched
      });
    }
  }, [enableReinitialize, props.initialTouched]);
  React.useEffect(function () {
    if (enableReinitialize && isMounted.current === true && !isEqual(initialStatus.current, props.initialStatus)) {
      initialStatus.current = props.initialStatus;
      dispatch({
        type: 'SET_STATUS',
        payload: props.initialStatus
      });
    }
  }, [enableReinitialize, props.initialStatus, props.initialTouched]);
  var validateField = useEventCallback(function (name) {
    // This will efficiently validate a single field by avoiding state
    // changes if the validation function is synchronous. It's different from
    // what is called when using validateForm.
    if (fieldRegistry.current[name] && isFunction(fieldRegistry.current[name].validate)) {
      var value = getIn(state.values, name);
      var maybePromise = fieldRegistry.current[name].validate(value);
      if (isPromise(maybePromise)) {
        // Only flip isValidating if the function is async.
        dispatch({
          type: 'SET_ISVALIDATING',
          payload: true
        });
        return maybePromise.then(function (x) {
          return x;
        }).then(function (error) {
          dispatch({
            type: 'SET_FIELD_ERROR',
            payload: {
              field: name,
              value: error
            }
          });
          dispatch({
            type: 'SET_ISVALIDATING',
            payload: false
          });
        });
      } else {
        dispatch({
          type: 'SET_FIELD_ERROR',
          payload: {
            field: name,
            value: maybePromise
          }
        });
        return Promise.resolve(maybePromise);
      }
    } else if (props.validationSchema) {
      dispatch({
        type: 'SET_ISVALIDATING',
        payload: true
      });
      return runValidationSchema(state.values, name).then(function (x) {
        return x;
      }).then(function (error) {
        dispatch({
          type: 'SET_FIELD_ERROR',
          payload: {
            field: name,
            value: error[name]
          }
        });
        dispatch({
          type: 'SET_ISVALIDATING',
          payload: false
        });
      });
    }
    return Promise.resolve();
  });
  var registerField = React.useCallback(function (name, _ref3) {
    var validate = _ref3.validate;
    fieldRegistry.current[name] = {
      validate: validate
    };
  }, []);
  var unregisterField = React.useCallback(function (name) {
    delete fieldRegistry.current[name];
  }, []);
  var setTouched = useEventCallback(function (touched, shouldValidate) {
    dispatch({
      type: 'SET_TOUCHED',
      payload: touched
    });
    var willValidate = shouldValidate === undefined ? validateOnBlur : shouldValidate;
    return willValidate ? validateFormWithHighPriority(state.values) : Promise.resolve();
  });
  var setErrors = React.useCallback(function (errors) {
    dispatch({
      type: 'SET_ERRORS',
      payload: errors
    });
  }, []);
  var setValues = useEventCallback(function (values, shouldValidate) {
    var resolvedValues = isFunction(values) ? values(state.values) : values;
    dispatch({
      type: 'SET_VALUES',
      payload: resolvedValues
    });
    var willValidate = shouldValidate === undefined ? validateOnChange : shouldValidate;
    return willValidate ? validateFormWithHighPriority(resolvedValues) : Promise.resolve();
  });
  var setFieldError = React.useCallback(function (field, value) {
    dispatch({
      type: 'SET_FIELD_ERROR',
      payload: {
        field: field,
        value: value
      }
    });
  }, []);
  var setFieldValue = useEventCallback(function (field, value, shouldValidate) {
    dispatch({
      type: 'SET_FIELD_VALUE',
      payload: {
        field: field,
        value: value
      }
    });
    var willValidate = shouldValidate === undefined ? validateOnChange : shouldValidate;
    return willValidate ? validateFormWithHighPriority(setIn(state.values, field, value)) : Promise.resolve();
  });
  var executeChange = React.useCallback(function (eventOrTextValue, maybePath) {
    // By default, assume that the first argument is a string. This allows us to use
    // handleChange with React Native and React Native Web's onChangeText prop which
    // provides just the value of the input.
    var field = maybePath;
    var val = eventOrTextValue;
    var parsed; // If the first argument is not a string though, it has to be a synthetic React Event (or a fake one),
    // so we handle like we would a normal HTML change event.

    if (!isString(eventOrTextValue)) {
      // If we can, persist the event
      // @see https://reactjs.org/docs/events.html#event-pooling
      if (eventOrTextValue.persist) {
        eventOrTextValue.persist();
      }
      var target = eventOrTextValue.target ? eventOrTextValue.target : eventOrTextValue.currentTarget;
      var type = target.type,
        name = target.name,
        id = target.id,
        value = target.value,
        checked = target.checked,
        outerHTML = target.outerHTML,
        options = target.options,
        multiple = target.multiple;
      field = maybePath ? maybePath : name ? name : id;
      if (!field && "development" !== "production") {
        warnAboutMissingIdentifier({
          htmlContent: outerHTML,
          documentationAnchorLink: 'handlechange-e-reactchangeeventany--void',
          handlerName: 'handleChange'
        });
      }
      val = /number|range/.test(type) ? (parsed = parseFloat(value), isNaN(parsed) ? '' : parsed) : /checkbox/.test(type) // checkboxes
      ? getValueForCheckbox(getIn(state.values, field), checked, value) : options && multiple // <select multiple>
      ? getSelectedValues(options) : value;
    }
    if (field) {
      // Set form fields by name
      setFieldValue(field, val);
    }
  }, [setFieldValue, state.values]);
  var handleChange = useEventCallback(function (eventOrPath) {
    if (isString(eventOrPath)) {
      return function (event) {
        return executeChange(event, eventOrPath);
      };
    } else {
      executeChange(eventOrPath);
    }
  });
  var setFieldTouched = useEventCallback(function (field, touched, shouldValidate) {
    if (touched === void 0) {
      touched = true;
    }
    dispatch({
      type: 'SET_FIELD_TOUCHED',
      payload: {
        field: field,
        value: touched
      }
    });
    var willValidate = shouldValidate === undefined ? validateOnBlur : shouldValidate;
    return willValidate ? validateFormWithHighPriority(state.values) : Promise.resolve();
  });
  var executeBlur = React.useCallback(function (e, path) {
    if (e.persist) {
      e.persist();
    }
    var _e$target = e.target,
      name = _e$target.name,
      id = _e$target.id,
      outerHTML = _e$target.outerHTML;
    var field = path ? path : name ? name : id;
    if (!field && "development" !== "production") {
      warnAboutMissingIdentifier({
        htmlContent: outerHTML,
        documentationAnchorLink: 'handleblur-e-any--void',
        handlerName: 'handleBlur'
      });
    }
    setFieldTouched(field, true);
  }, [setFieldTouched]);
  var handleBlur = useEventCallback(function (eventOrString) {
    if (isString(eventOrString)) {
      return function (event) {
        return executeBlur(event, eventOrString);
      };
    } else {
      executeBlur(eventOrString);
    }
  });
  var setFormikState = React.useCallback(function (stateOrCb) {
    if (isFunction(stateOrCb)) {
      dispatch({
        type: 'SET_FORMIK_STATE',
        payload: stateOrCb
      });
    } else {
      dispatch({
        type: 'SET_FORMIK_STATE',
        payload: function payload() {
          return stateOrCb;
        }
      });
    }
  }, []);
  var setStatus = React.useCallback(function (status) {
    dispatch({
      type: 'SET_STATUS',
      payload: status
    });
  }, []);
  var setSubmitting = React.useCallback(function (isSubmitting) {
    dispatch({
      type: 'SET_ISSUBMITTING',
      payload: isSubmitting
    });
  }, []);
  var submitForm = useEventCallback(function () {
    dispatch({
      type: 'SUBMIT_ATTEMPT'
    });
    return validateFormWithHighPriority().then(function (combinedErrors) {
      // In case an error was thrown and passed to the resolved Promise,
      // `combinedErrors` can be an instance of an Error. We need to check
      // that and abort the submit.
      // If we don't do that, calling `Object.keys(new Error())` yields an
      // empty array, which causes the validation to pass and the form
      // to be submitted.
      var isInstanceOfError = combinedErrors instanceof Error;
      var isActuallyValid = !isInstanceOfError && Object.keys(combinedErrors).length === 0;
      if (isActuallyValid) {
        // Proceed with submit...
        //
        // To respect sync submit fns, we can't simply wrap executeSubmit in a promise and
        // _always_ dispatch SUBMIT_SUCCESS because isSubmitting would then always be false.
        // This would be fine in simple cases, but make it impossible to disable submit
        // buttons where people use callbacks or promises as side effects (which is basically
        // all of v1 Formik code). Instead, recall that we are inside of a promise chain already,
        //  so we can try/catch executeSubmit(), if it returns undefined, then just bail.
        // If there are errors, throw em. Otherwise, wrap executeSubmit in a promise and handle
        // cleanup of isSubmitting on behalf of the consumer.
        var promiseOrUndefined;
        try {
          promiseOrUndefined = executeSubmit(); // Bail if it's sync, consumer is responsible for cleaning up
          // via setSubmitting(false)

          if (promiseOrUndefined === undefined) {
            return;
          }
        } catch (error) {
          throw error;
        }
        return Promise.resolve(promiseOrUndefined).then(function (result) {
          if (!!isMounted.current) {
            dispatch({
              type: 'SUBMIT_SUCCESS'
            });
          }
          return result;
        })["catch"](function (_errors) {
          if (!!isMounted.current) {
            dispatch({
              type: 'SUBMIT_FAILURE'
            }); // This is a legit error rejected by the onSubmit fn
            // so we don't want to break the promise chain

            throw _errors;
          }
        });
      } else if (!!isMounted.current) {
        // ^^^ Make sure Formik is still mounted before updating state
        dispatch({
          type: 'SUBMIT_FAILURE'
        }); // throw combinedErrors;

        if (isInstanceOfError) {
          throw combinedErrors;
        }
      }
      return;
    });
  });
  var handleSubmit = useEventCallback(function (e) {
    if (e && e.preventDefault && isFunction(e.preventDefault)) {
      e.preventDefault();
    }
    if (e && e.stopPropagation && isFunction(e.stopPropagation)) {
      e.stopPropagation();
    } // Warn if form submission is triggered by a <button> without a
    // specified `type` attribute during development. This mitigates
    // a common gotcha in forms with both reset and submit buttons,
    // where the dev forgets to add type="button" to the reset button.

    if (typeof document !== 'undefined') {
      // Safely get the active element (works with IE)
      var activeElement = getActiveElement();
      if (activeElement !== null && activeElement instanceof HTMLButtonElement) {
        !(activeElement.attributes && activeElement.attributes.getNamedItem('type')) ? invariant(false, 'You submitted a Formik form using a button with an unspecified `type` attribute.  Most browsers default button elements to `type="submit"`. If this is not a submit button, please add `type="button"`.') : void 0;
      }
    }
    submitForm()["catch"](function (reason) {
      console.warn("Warning: An unhandled error was caught from submitForm()", reason);
    });
  });
  var imperativeMethods = {
    resetForm: resetForm,
    validateForm: validateFormWithHighPriority,
    validateField: validateField,
    setErrors: setErrors,
    setFieldError: setFieldError,
    setFieldTouched: setFieldTouched,
    setFieldValue: setFieldValue,
    setStatus: setStatus,
    setSubmitting: setSubmitting,
    setTouched: setTouched,
    setValues: setValues,
    setFormikState: setFormikState,
    submitForm: submitForm
  };
  var executeSubmit = useEventCallback(function () {
    return onSubmit(state.values, imperativeMethods);
  });
  var handleReset = useEventCallback(function (e) {
    if (e && e.preventDefault && isFunction(e.preventDefault)) {
      e.preventDefault();
    }
    if (e && e.stopPropagation && isFunction(e.stopPropagation)) {
      e.stopPropagation();
    }
    resetForm();
  });
  var getFieldMeta = React.useCallback(function (name) {
    return {
      value: getIn(state.values, name),
      error: getIn(state.errors, name),
      touched: !!getIn(state.touched, name),
      initialValue: getIn(initialValues.current, name),
      initialTouched: !!getIn(initialTouched.current, name),
      initialError: getIn(initialErrors.current, name)
    };
  }, [state.errors, state.touched, state.values]);
  var getFieldHelpers = React.useCallback(function (name) {
    return {
      setValue: function setValue(value, shouldValidate) {
        return setFieldValue(name, value, shouldValidate);
      },
      setTouched: function setTouched(value, shouldValidate) {
        return setFieldTouched(name, value, shouldValidate);
      },
      setError: function setError(value) {
        return setFieldError(name, value);
      }
    };
  }, [setFieldValue, setFieldTouched, setFieldError]);
  var getFieldProps = React.useCallback(function (nameOrOptions) {
    var isAnObject = isObject(nameOrOptions);
    var name = isAnObject ? nameOrOptions.name : nameOrOptions;
    var valueState = getIn(state.values, name);
    var field = {
      name: name,
      value: valueState,
      onChange: handleChange,
      onBlur: handleBlur
    };
    if (isAnObject) {
      var type = nameOrOptions.type,
        valueProp = nameOrOptions.value,
        is = nameOrOptions.as,
        multiple = nameOrOptions.multiple;
      if (type === 'checkbox') {
        if (valueProp === undefined) {
          field.checked = !!valueState;
        } else {
          field.checked = !!(Array.isArray(valueState) && ~valueState.indexOf(valueProp));
          field.value = valueProp;
        }
      } else if (type === 'radio') {
        field.checked = valueState === valueProp;
        field.value = valueProp;
      } else if (is === 'select' && multiple) {
        field.value = field.value || [];
        field.multiple = true;
      }
    }
    return field;
  }, [handleBlur, handleChange, state.values]);
  var dirty = React.useMemo(function () {
    return !isEqual(initialValues.current, state.values);
  }, [initialValues.current, state.values]);
  var isValid = React.useMemo(function () {
    return typeof isInitialValid !== 'undefined' ? dirty ? state.errors && Object.keys(state.errors).length === 0 : isInitialValid !== false && isFunction(isInitialValid) ? isInitialValid(props) : isInitialValid : state.errors && Object.keys(state.errors).length === 0;
  }, [isInitialValid, dirty, state.errors, props]);
  var ctx = _extends({}, state, {
    initialValues: initialValues.current,
    initialErrors: initialErrors.current,
    initialTouched: initialTouched.current,
    initialStatus: initialStatus.current,
    handleBlur: handleBlur,
    handleChange: handleChange,
    handleReset: handleReset,
    handleSubmit: handleSubmit,
    resetForm: resetForm,
    setErrors: setErrors,
    setFormikState: setFormikState,
    setFieldTouched: setFieldTouched,
    setFieldValue: setFieldValue,
    setFieldError: setFieldError,
    setStatus: setStatus,
    setSubmitting: setSubmitting,
    setTouched: setTouched,
    setValues: setValues,
    submitForm: submitForm,
    validateForm: validateFormWithHighPriority,
    validateField: validateField,
    isValid: isValid,
    dirty: dirty,
    unregisterField: unregisterField,
    registerField: registerField,
    getFieldProps: getFieldProps,
    getFieldMeta: getFieldMeta,
    getFieldHelpers: getFieldHelpers,
    validateOnBlur: validateOnBlur,
    validateOnChange: validateOnChange,
    validateOnMount: validateOnMount
  });
  return ctx;
}
function Formik(props) {
  var formikbag = useFormik(props);
  var component = props.component,
    children = props.children,
    render = props.render,
    innerRef = props.innerRef; // This allows folks to pass a ref to <Formik />

  React.useImperativeHandle(innerRef, function () {
    return formikbag;
  });
  {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    React.useEffect(function () {
      !!props.render ? invariant(false, "<Formik render> has been deprecated and will be removed in future versions of Formik. Please use a child callback function instead. To get rid of this warning, replace <Formik render={(props) => ...} /> with <Formik>{(props) => ...}</Formik>") : void 0; // eslint-disable-next-line
    }, []);
  }
  return React.createElement(FormikProvider, {
    value: formikbag
  }, component ? React.createElement(component, formikbag) : render ? render(formikbag) : children // children come last, always called
  ? isFunction(children) ? children(formikbag) : !isEmptyChildren(children) ? React.Children.only(children) : null : null);
}
function warnAboutMissingIdentifier(_ref4) {
  var htmlContent = _ref4.htmlContent,
    documentationAnchorLink = _ref4.documentationAnchorLink,
    handlerName = _ref4.handlerName;
  console.warn("Warning: Formik called `" + handlerName + "`, but you forgot to pass an `id` or `name` attribute to your input:\n    " + htmlContent + "\n    Formik cannot determine which value to update. For more info see https://formik.org/docs/api/formik#" + documentationAnchorLink + "\n  ");
}
/**
 * Transform Yup ValidationError to a more usable object
 */

function yupToFormErrors(yupError) {
  var errors = {};
  if (yupError.inner) {
    if (yupError.inner.length === 0) {
      return setIn(errors, yupError.path, yupError.message);
    }
    for (var _iterator = yupError.inner, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref5;
      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref5 = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref5 = _i.value;
      }
      var err = _ref5;
      if (!getIn(errors, err.path)) {
        errors = setIn(errors, err.path, err.message);
      }
    }
  }
  return errors;
}
/**
 * Validate a yup schema.
 */

function validateYupSchema(values, schema, sync, context) {
  if (sync === void 0) {
    sync = false;
  }
  if (context === void 0) {
    context = {};
  }
  var validateData = prepareDataForValidation(values);
  return schema[sync ? 'validateSync' : 'validate'](validateData, {
    abortEarly: false,
    context: context
  });
}
/**
 * Recursively prepare values.
 */

function prepareDataForValidation(values) {
  var data = Array.isArray(values) ? [] : {};
  for (var k in values) {
    if (Object.prototype.hasOwnProperty.call(values, k)) {
      var key = String(k);
      if (Array.isArray(values[key]) === true) {
        data[key] = values[key].map(function (value) {
          if (Array.isArray(value) === true || isPlainObject(value)) {
            return prepareDataForValidation(value);
          } else {
            return value !== '' ? value : undefined;
          }
        });
      } else if (isPlainObject(values[key])) {
        data[key] = prepareDataForValidation(values[key]);
      } else {
        data[key] = values[key] !== '' ? values[key] : undefined;
      }
    }
  }
  return data;
}
/**
 * deepmerge array merging algorithm
 * https://github.com/KyleAMathews/deepmerge#combine-array
 */

function arrayMerge(target, source, options) {
  var destination = target.slice();
  source.forEach(function merge(e, i) {
    if (typeof destination[i] === 'undefined') {
      var cloneRequested = options.clone !== false;
      var shouldClone = cloneRequested && options.isMergeableObject(e);
      destination[i] = shouldClone ? deepmerge(Array.isArray(e) ? [] : {}, e, options) : e;
    } else if (options.isMergeableObject(e)) {
      destination[i] = deepmerge(target[i], e, options);
    } else if (target.indexOf(e) === -1) {
      destination.push(e);
    }
  });
  return destination;
}
/** Return multi select values based on an array of options */

function getSelectedValues(options) {
  return Array.from(options).filter(function (el) {
    return el.selected;
  }).map(function (el) {
    return el.value;
  });
}
/** Return the next value for a checkbox */

function getValueForCheckbox(currentValue, checked, valueProp) {
  // If the current value was a boolean, return a boolean
  if (typeof currentValue === 'boolean') {
    return Boolean(checked);
  } // If the currentValue was not a boolean we want to return an array

  var currentArrayOfValues = [];
  var isValueInArray = false;
  var index = -1;
  if (!Array.isArray(currentValue)) {
    // eslint-disable-next-line eqeqeq
    if (!valueProp || valueProp == 'true' || valueProp == 'false') {
      return Boolean(checked);
    }
  } else {
    // If the current value is already an array, use it
    currentArrayOfValues = currentValue;
    index = currentValue.indexOf(valueProp);
    isValueInArray = index >= 0;
  } // If the checkbox was checked and the value is not already present in the aray we want to add the new value to the array of values

  if (checked && valueProp && !isValueInArray) {
    return currentArrayOfValues.concat(valueProp);
  } // If the checkbox was unchecked and the value is not in the array, simply return the already existing array of values

  if (!isValueInArray) {
    return currentArrayOfValues;
  } // If the checkbox was unchecked and the value is in the array, remove the value and return the array

  return currentArrayOfValues.slice(0, index).concat(currentArrayOfValues.slice(index + 1));
} // React currently throws a warning when using useLayoutEffect on the server.
// To get around it, we can conditionally useEffect on the server (no-op) and
// useLayoutEffect in the browser.
// @see https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85

var useIsomorphicLayoutEffect = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined' ? React.useLayoutEffect : React.useEffect;
function useEventCallback(fn) {
  var ref = React.useRef(fn); // we copy a ref to the callback scoped to the current state/props on each render

  useIsomorphicLayoutEffect(function () {
    ref.current = fn;
  });
  return React.useCallback(function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return ref.current.apply(void 0, args);
  }, []);
}
function useField(propsOrFieldName) {
  var formik = useFormikContext();
  var getFieldProps = formik.getFieldProps,
    getFieldMeta = formik.getFieldMeta,
    getFieldHelpers = formik.getFieldHelpers,
    registerField = formik.registerField,
    unregisterField = formik.unregisterField;
  var isAnObject = isObject(propsOrFieldName); // Normalize propsOrFieldName to FieldHookConfig<Val>

  var props = isAnObject ? propsOrFieldName : {
    name: propsOrFieldName
  };
  var fieldName = props.name,
    validateFn = props.validate;
  React.useEffect(function () {
    if (fieldName) {
      registerField(fieldName, {
        validate: validateFn
      });
    }
    return function () {
      if (fieldName) {
        unregisterField(fieldName);
      }
    };
  }, [registerField, unregisterField, fieldName, validateFn]);
  {
    !formik ? invariant(false, 'useField() / <Field /> must be used underneath a <Formik> component or withFormik() higher order component') : void 0;
  }
  !fieldName ? invariant(false, 'Invalid field name. Either pass `useField` a string or an object containing a `name` key.') : void 0;
  return [getFieldProps(props), getFieldMeta(fieldName), getFieldHelpers(fieldName)];
}
function Field(_ref) {
  var validate = _ref.validate,
    name = _ref.name,
    render = _ref.render,
    children = _ref.children,
    is = _ref.as,
    component = _ref.component,
    props = _objectWithoutPropertiesLoose(_ref, ["validate", "name", "render", "children", "as", "component"]);
  var _useFormikContext = useFormikContext(),
    formik = _objectWithoutPropertiesLoose(_useFormikContext, ["validate", "validationSchema"]);
  {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    React.useEffect(function () {
      !!render ? invariant(false, "<Field render> has been deprecated and will be removed in future versions of Formik. Please use a child callback function instead. To get rid of this warning, replace <Field name=\"" + name + "\" render={({field, form}) => ...} /> with <Field name=\"" + name + "\">{({field, form, meta}) => ...}</Field>") : void 0;
      !!(is && children && isFunction(children)) ? invariant(false, 'You should not use <Field as> and <Field children> as a function in the same <Field> component; <Field as> will be ignored.') : void 0;
      !!(component && children && isFunction(children)) ? invariant(false, 'You should not use <Field component> and <Field children> as a function in the same <Field> component; <Field component> will be ignored.') : void 0;
      !!(render && children && !isEmptyChildren(children)) ? invariant(false, 'You should not use <Field render> and <Field children> in the same <Field> component; <Field children> will be ignored') : void 0; // eslint-disable-next-line
    }, []);
  } // Register field and field-level validation with parent <Formik>

  var registerField = formik.registerField,
    unregisterField = formik.unregisterField;
  React.useEffect(function () {
    registerField(name, {
      validate: validate
    });
    return function () {
      unregisterField(name);
    };
  }, [registerField, unregisterField, name, validate]);
  var field = formik.getFieldProps(_extends({
    name: name
  }, props));
  var meta = formik.getFieldMeta(name);
  var legacyBag = {
    field: field,
    form: formik
  };
  if (render) {
    return render(_extends({}, legacyBag, {
      meta: meta
    }));
  }
  if (isFunction(children)) {
    return children(_extends({}, legacyBag, {
      meta: meta
    }));
  }
  if (component) {
    // This behavior is backwards compat with earlier Formik 0.9 to 1.x
    if (typeof component === 'string') {
      var innerRef = props.innerRef,
        rest = _objectWithoutPropertiesLoose(props, ["innerRef"]);
      return React.createElement(component, _extends({
        ref: innerRef
      }, field, rest), children);
    } // We don't pass `meta` for backwards compat

    return React.createElement(component, _extends({
      field: field,
      form: formik
    }, props), children);
  } // default to input here so we can check for both `as` and `children` above

  var asElement = is || 'input';
  if (typeof asElement === 'string') {
    var _innerRef = props.innerRef,
      _rest = _objectWithoutPropertiesLoose(props, ["innerRef"]);
    return React.createElement(asElement, _extends({
      ref: _innerRef
    }, field, _rest), children);
  }
  return React.createElement(asElement, _extends({}, field, props), children);
}
var Form = /*#__PURE__*/React.forwardRef(function (props, ref) {
  // iOS needs an "action" attribute for nice input: https://stackoverflow.com/a/39485162/406725
  // We default the action to "#" in case the preventDefault fails (just updates the URL hash)
  var action = props.action,
    rest = _objectWithoutPropertiesLoose(props, ["action"]);
  var _action = action != null ? action : '#';
  var _useFormikContext = useFormikContext(),
    handleReset = _useFormikContext.handleReset,
    handleSubmit = _useFormikContext.handleSubmit;
  return React.createElement("form", Object.assign({
    onSubmit: handleSubmit,
    ref: ref,
    onReset: handleReset,
    action: _action
  }, rest));
});
Form.displayName = 'Form';

/**
 * A public higher-order component to access the imperative API
 */

function withFormik(_ref) {
  var _ref$mapPropsToValues = _ref.mapPropsToValues,
    mapPropsToValues = _ref$mapPropsToValues === void 0 ? function (vanillaProps) {
      var val = {};
      for (var k in vanillaProps) {
        if (vanillaProps.hasOwnProperty(k) && typeof vanillaProps[k] !== 'function') {
          // @todo TypeScript fix
          val[k] = vanillaProps[k];
        }
      }
      return val;
    } : _ref$mapPropsToValues,
    config = _objectWithoutPropertiesLoose(_ref, ["mapPropsToValues"]);
  return function createFormik(Component) {
    var componentDisplayName = Component.displayName || Component.name || Component.constructor && Component.constructor.name || 'Component';
    /**
     * We need to use closures here for to provide the wrapped component's props to
     * the respective withFormik config methods.
     */

    var C = /*#__PURE__*/function (_React$Component) {
      _inheritsLoose(C, _React$Component);
      function C() {
        var _this;
        _this = _React$Component.apply(this, arguments) || this;
        _this.validate = function (values) {
          return config.validate(values, _this.props);
        };
        _this.validationSchema = function () {
          return isFunction(config.validationSchema) ? config.validationSchema(_this.props) : config.validationSchema;
        };
        _this.handleSubmit = function (values, actions) {
          return config.handleSubmit(values, _extends({}, actions, {
            props: _this.props
          }));
        };
        /**
         * Just avoiding a render callback for perf here
         */

        _this.renderFormComponent = function (formikProps) {
          return React.createElement(Component, Object.assign({}, _this.props, formikProps));
        };
        return _this;
      }
      var _proto = C.prototype;
      _proto.render = function render() {
        var _this$props = this.props,
          props = _objectWithoutPropertiesLoose(_this$props, ["children"]);
        return React.createElement(Formik, Object.assign({}, props, config, {
          validate: config.validate && this.validate,
          validationSchema: config.validationSchema && this.validationSchema,
          initialValues: mapPropsToValues(this.props),
          initialStatus: config.mapPropsToStatus && config.mapPropsToStatus(this.props),
          initialErrors: config.mapPropsToErrors && config.mapPropsToErrors(this.props),
          initialTouched: config.mapPropsToTouched && config.mapPropsToTouched(this.props),
          onSubmit: this.handleSubmit,
          children: this.renderFormComponent
        }));
      };
      return C;
    }(React.Component);
    C.displayName = "WithFormik(" + componentDisplayName + ")";
    return hoistNonReactStatics(C, Component // cast type to ComponentClass (even if SFC)
    );
  };
}

/**
 * Connect any component to Formik context, and inject as a prop called `formik`;
 * @param Comp React Component
 */

function connect(Comp) {
  var C = function C(props) {
    return React.createElement(FormikConsumer, null, function (formik) {
      !!!formik ? invariant(false, "Formik context is undefined, please verify you are rendering <Form>, <Field>, <FastField>, <FieldArray>, or your custom context-using component as a child of a <Formik> component. Component name: " + Comp.name) : void 0;
      return React.createElement(Comp, Object.assign({}, props, {
        formik: formik
      }));
    });
  };
  var componentDisplayName = Comp.displayName || Comp.name || Comp.constructor && Comp.constructor.name || 'Component'; // Assign Comp to C.WrappedComponent so we can access the inner component in tests
  // For example, <Field.WrappedComponent /> gets us <FieldInner/>

  C.WrappedComponent = Comp;
  C.displayName = "FormikConnect(" + componentDisplayName + ")";
  return hoistNonReactStatics(C, Comp // cast type to ComponentClass (even if SFC)
  );
}

/**
 * Some array helpers!
 */

var move = function move(array, from, to) {
  var copy = copyArrayLike(array);
  var value = copy[from];
  copy.splice(from, 1);
  copy.splice(to, 0, value);
  return copy;
};
var swap = function swap(arrayLike, indexA, indexB) {
  var copy = copyArrayLike(arrayLike);
  var a = copy[indexA];
  copy[indexA] = copy[indexB];
  copy[indexB] = a;
  return copy;
};
var insert = function insert(arrayLike, index, value) {
  var copy = copyArrayLike(arrayLike);
  copy.splice(index, 0, value);
  return copy;
};
var replace = function replace(arrayLike, index, value) {
  var copy = copyArrayLike(arrayLike);
  copy[index] = value;
  return copy;
};
var copyArrayLike = function copyArrayLike(arrayLike) {
  if (!arrayLike) {
    return [];
  } else if (Array.isArray(arrayLike)) {
    return [].concat(arrayLike);
  } else {
    var maxIndex = Object.keys(arrayLike).map(function (key) {
      return parseInt(key);
    }).reduce(function (max, el) {
      return el > max ? el : max;
    }, 0);
    return Array.from(_extends({}, arrayLike, {
      length: maxIndex + 1
    }));
  }
};
var FieldArrayInner = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(FieldArrayInner, _React$Component);
  function FieldArrayInner(props) {
    var _this;
    _this = _React$Component.call(this, props) || this;
    _this.updateArrayField = function (fn, alterTouched, alterErrors) {
      var _this$props = _this.props,
        name = _this$props.name,
        setFormikState = _this$props.formik.setFormikState;
      setFormikState(function (prevState) {
        var updateErrors = typeof alterErrors === 'function' ? alterErrors : fn;
        var updateTouched = typeof alterTouched === 'function' ? alterTouched : fn; // values fn should be executed before updateErrors and updateTouched,
        // otherwise it causes an error with unshift.

        var values = setIn(prevState.values, name, fn(getIn(prevState.values, name)));
        var fieldError = alterErrors ? updateErrors(getIn(prevState.errors, name)) : undefined;
        var fieldTouched = alterTouched ? updateTouched(getIn(prevState.touched, name)) : undefined;
        if (isEmptyArray(fieldError)) {
          fieldError = undefined;
        }
        if (isEmptyArray(fieldTouched)) {
          fieldTouched = undefined;
        }
        return _extends({}, prevState, {
          values: values,
          errors: alterErrors ? setIn(prevState.errors, name, fieldError) : prevState.errors,
          touched: alterTouched ? setIn(prevState.touched, name, fieldTouched) : prevState.touched
        });
      });
    };
    _this.push = function (value) {
      return _this.updateArrayField(function (arrayLike) {
        return [].concat(copyArrayLike(arrayLike), [cloneDeep(value)]);
      }, false, false);
    };
    _this.handlePush = function (value) {
      return function () {
        return _this.push(value);
      };
    };
    _this.swap = function (indexA, indexB) {
      return _this.updateArrayField(function (array) {
        return swap(array, indexA, indexB);
      }, true, true);
    };
    _this.handleSwap = function (indexA, indexB) {
      return function () {
        return _this.swap(indexA, indexB);
      };
    };
    _this.move = function (from, to) {
      return _this.updateArrayField(function (array) {
        return move(array, from, to);
      }, true, true);
    };
    _this.handleMove = function (from, to) {
      return function () {
        return _this.move(from, to);
      };
    };
    _this.insert = function (index, value) {
      return _this.updateArrayField(function (array) {
        return insert(array, index, value);
      }, function (array) {
        return insert(array, index, null);
      }, function (array) {
        return insert(array, index, null);
      });
    };
    _this.handleInsert = function (index, value) {
      return function () {
        return _this.insert(index, value);
      };
    };
    _this.replace = function (index, value) {
      return _this.updateArrayField(function (array) {
        return replace(array, index, value);
      }, false, false);
    };
    _this.handleReplace = function (index, value) {
      return function () {
        return _this.replace(index, value);
      };
    };
    _this.unshift = function (value) {
      var length = -1;
      _this.updateArrayField(function (array) {
        var arr = array ? [value].concat(array) : [value];
        if (length < 0) {
          length = arr.length;
        }
        return arr;
      }, function (array) {
        var arr = array ? [null].concat(array) : [null];
        if (length < 0) {
          length = arr.length;
        }
        return arr;
      }, function (array) {
        var arr = array ? [null].concat(array) : [null];
        if (length < 0) {
          length = arr.length;
        }
        return arr;
      });
      return length;
    };
    _this.handleUnshift = function (value) {
      return function () {
        return _this.unshift(value);
      };
    };
    _this.handleRemove = function (index) {
      return function () {
        return _this.remove(index);
      };
    };
    _this.handlePop = function () {
      return function () {
        return _this.pop();
      };
    }; // We need TypeScript generics on these, so we'll bind them in the constructor
    // @todo Fix TS 3.2.1

    _this.remove = _this.remove.bind(_assertThisInitialized(_this));
    _this.pop = _this.pop.bind(_assertThisInitialized(_this));
    return _this;
  }
  var _proto = FieldArrayInner.prototype;
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (this.props.validateOnChange && this.props.formik.validateOnChange && !isEqual(getIn(prevProps.formik.values, prevProps.name), getIn(this.props.formik.values, this.props.name))) {
      this.props.formik.validateForm(this.props.formik.values);
    }
  };
  _proto.remove = function remove(index) {
    // We need to make sure we also remove relevant pieces of `touched` and `errors`
    var result;
    this.updateArrayField(
    // so this gets call 3 times
    function (array) {
      var copy = array ? copyArrayLike(array) : [];
      if (!result) {
        result = copy[index];
      }
      if (isFunction(copy.splice)) {
        copy.splice(index, 1);
      }
      return copy;
    }, true, true);
    return result;
  };
  _proto.pop = function pop() {
    // Remove relevant pieces of `touched` and `errors` too!
    var result;
    this.updateArrayField(
    // so this gets call 3 times
    function (array) {
      var tmp = array;
      if (!result) {
        result = tmp && tmp.pop && tmp.pop();
      }
      return tmp;
    }, true, true);
    return result;
  };
  _proto.render = function render() {
    var arrayHelpers = {
      push: this.push,
      pop: this.pop,
      swap: this.swap,
      move: this.move,
      insert: this.insert,
      replace: this.replace,
      unshift: this.unshift,
      remove: this.remove,
      handlePush: this.handlePush,
      handlePop: this.handlePop,
      handleSwap: this.handleSwap,
      handleMove: this.handleMove,
      handleInsert: this.handleInsert,
      handleReplace: this.handleReplace,
      handleUnshift: this.handleUnshift,
      handleRemove: this.handleRemove
    };
    var _this$props2 = this.props,
      component = _this$props2.component,
      render = _this$props2.render,
      children = _this$props2.children,
      name = _this$props2.name,
      _this$props2$formik = _this$props2.formik,
      restOfFormik = _objectWithoutPropertiesLoose(_this$props2$formik, ["validate", "validationSchema"]);
    var props = _extends({}, arrayHelpers, {
      form: restOfFormik,
      name: name
    });
    return component ? React.createElement(component, props) : render ? render(props) : children // children come last, always called
    ? typeof children === 'function' ? children(props) : !isEmptyChildren(children) ? React.Children.only(children) : null : null;
  };
  return FieldArrayInner;
}(React.Component);
FieldArrayInner.defaultProps = {
  validateOnChange: true
};
var FieldArray = /*#__PURE__*/connect(FieldArrayInner);
var ErrorMessageImpl = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(ErrorMessageImpl, _React$Component);
  function ErrorMessageImpl() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = ErrorMessageImpl.prototype;
  _proto.shouldComponentUpdate = function shouldComponentUpdate(props) {
    if (getIn(this.props.formik.errors, this.props.name) !== getIn(props.formik.errors, this.props.name) || getIn(this.props.formik.touched, this.props.name) !== getIn(props.formik.touched, this.props.name) || Object.keys(this.props).length !== Object.keys(props).length) {
      return true;
    } else {
      return false;
    }
  };
  _proto.render = function render() {
    var _this$props = this.props,
      component = _this$props.component,
      formik = _this$props.formik,
      render = _this$props.render,
      children = _this$props.children,
      name = _this$props.name,
      rest = _objectWithoutPropertiesLoose(_this$props, ["component", "formik", "render", "children", "name"]);
    var touch = getIn(formik.touched, name);
    var error = getIn(formik.errors, name);
    return !!touch && !!error ? render ? isFunction(render) ? render(error) : null : children ? isFunction(children) ? children(error) : null : component ? React.createElement(component, rest, error) : error : null;
  };
  return ErrorMessageImpl;
}(React.Component);
var ErrorMessage = /*#__PURE__*/connect(ErrorMessageImpl);

/**
 * Custom Field component for quickly hooking into Formik
 * context and wiring up forms.
 */

var FastFieldInner = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(FastFieldInner, _React$Component);
  function FastFieldInner(props) {
    var _this;
    _this = _React$Component.call(this, props) || this;
    var render = props.render,
      children = props.children,
      component = props.component,
      is = props.as,
      name = props.name;
    !!render ? invariant(false, "<FastField render> has been deprecated. Please use a child callback function instead: <FastField name={" + name + "}>{props => ...}</FastField> instead.") : void 0;
    !!(component && render) ? invariant(false, 'You should not use <FastField component> and <FastField render> in the same <FastField> component; <FastField component> will be ignored') : void 0;
    !!(is && children && isFunction(children)) ? invariant(false, 'You should not use <FastField as> and <FastField children> as a function in the same <FastField> component; <FastField as> will be ignored.') : void 0;
    !!(component && children && isFunction(children)) ? invariant(false, 'You should not use <FastField component> and <FastField children> as a function in the same <FastField> component; <FastField component> will be ignored.') : void 0;
    !!(render && children && !isEmptyChildren(children)) ? invariant(false, 'You should not use <FastField render> and <FastField children> in the same <FastField> component; <FastField children> will be ignored') : void 0;
    return _this;
  }
  var _proto = FastFieldInner.prototype;
  _proto.shouldComponentUpdate = function shouldComponentUpdate(props) {
    if (this.props.shouldUpdate) {
      return this.props.shouldUpdate(props, this.props);
    } else if (props.name !== this.props.name || getIn(props.formik.values, this.props.name) !== getIn(this.props.formik.values, this.props.name) || getIn(props.formik.errors, this.props.name) !== getIn(this.props.formik.errors, this.props.name) || getIn(props.formik.touched, this.props.name) !== getIn(this.props.formik.touched, this.props.name) || Object.keys(this.props).length !== Object.keys(props).length || props.formik.isSubmitting !== this.props.formik.isSubmitting) {
      return true;
    } else {
      return false;
    }
  };
  _proto.componentDidMount = function componentDidMount() {
    // Register the Field with the parent Formik. Parent will cycle through
    // registered Field's validate fns right prior to submit
    this.props.formik.registerField(this.props.name, {
      validate: this.props.validate
    });
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (this.props.name !== prevProps.name) {
      this.props.formik.unregisterField(prevProps.name);
      this.props.formik.registerField(this.props.name, {
        validate: this.props.validate
      });
    }
    if (this.props.validate !== prevProps.validate) {
      this.props.formik.registerField(this.props.name, {
        validate: this.props.validate
      });
    }
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.props.formik.unregisterField(this.props.name);
  };
  _proto.render = function render() {
    var _this$props = this.props,
      name = _this$props.name,
      render = _this$props.render,
      is = _this$props.as,
      children = _this$props.children,
      component = _this$props.component,
      formik = _this$props.formik,
      props = _objectWithoutPropertiesLoose(_this$props, ["validate", "name", "render", "as", "children", "component", "shouldUpdate", "formik"]);
    var restOfFormik = _objectWithoutPropertiesLoose(formik, ["validate", "validationSchema"]);
    var field = formik.getFieldProps(_extends({
      name: name
    }, props));
    var meta = {
      value: getIn(formik.values, name),
      error: getIn(formik.errors, name),
      touched: !!getIn(formik.touched, name),
      initialValue: getIn(formik.initialValues, name),
      initialTouched: !!getIn(formik.initialTouched, name),
      initialError: getIn(formik.initialErrors, name)
    };
    var bag = {
      field: field,
      meta: meta,
      form: restOfFormik
    };
    if (render) {
      return render(bag);
    }
    if (isFunction(children)) {
      return children(bag);
    }
    if (component) {
      // This behavior is backwards compat with earlier Formik 0.9 to 1.x
      if (typeof component === 'string') {
        var innerRef = props.innerRef,
          rest = _objectWithoutPropertiesLoose(props, ["innerRef"]);
        return React.createElement(component, _extends({
          ref: innerRef
        }, field, rest), children);
      } // We don't pass `meta` for backwards compat

      return React.createElement(component, _extends({
        field: field,
        form: formik
      }, props), children);
    } // default to input here so we can check for both `as` and `children` above

    var asElement = is || 'input';
    if (typeof asElement === 'string') {
      var _innerRef = props.innerRef,
        _rest = _objectWithoutPropertiesLoose(props, ["innerRef"]);
      return React.createElement(asElement, _extends({
        ref: _innerRef
      }, field, _rest), children);
    }
    return React.createElement(asElement, _extends({}, field, props), children);
  };
  return FastFieldInner;
}(React.Component);
var FastField = /*#__PURE__*/connect(FastFieldInner);
exports.ErrorMessage = ErrorMessage;
exports.FastField = FastField;
exports.Field = Field;
exports.FieldArray = FieldArray;
exports.Form = Form;
exports.Formik = Formik;
exports.FormikConsumer = FormikConsumer;
exports.FormikContext = FormikContext;
exports.FormikProvider = FormikProvider;
exports.connect = connect;
exports.getActiveElement = getActiveElement;
exports.getIn = getIn;
exports.insert = insert;
exports.isEmptyArray = isEmptyArray;
exports.isEmptyChildren = isEmptyChildren;
exports.isFunction = isFunction;
exports.isInputEvent = isInputEvent;
exports.isInteger = isInteger;
exports.isNaN = isNaN$1;
exports.isObject = isObject;
exports.isPromise = isPromise;
exports.isString = isString;
exports.move = move;
exports.prepareDataForValidation = prepareDataForValidation;
exports.replace = replace;
exports.setIn = setIn;
exports.setNestedObjectValues = setNestedObjectValues;
exports.swap = swap;
exports.useField = useField;
exports.useFormik = useFormik;
exports.useFormikContext = useFormikContext;
exports.validateYupSchema = validateYupSchema;
exports.withFormik = withFormik;
exports.yupToFormErrors = yupToFormErrors;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJpc0VtcHR5QXJyYXkiLCJ2YWx1ZSIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsImlzRnVuY3Rpb24iLCJvYmoiLCJpc09iamVjdCIsImlzSW50ZWdlciIsIlN0cmluZyIsIk1hdGgiLCJmbG9vciIsIk51bWJlciIsImlzU3RyaW5nIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwiaXNOYU4kMSIsImlzTmFOIiwiaXNFbXB0eUNoaWxkcmVuIiwiY2hpbGRyZW4iLCJSZWFjdCIsIkNoaWxkcmVuIiwiY291bnQiLCJpc1Byb21pc2UiLCJ0aGVuIiwiaXNJbnB1dEV2ZW50IiwidGFyZ2V0IiwiZ2V0QWN0aXZlRWxlbWVudCIsImRvYyIsImRvY3VtZW50IiwidW5kZWZpbmVkIiwiYWN0aXZlRWxlbWVudCIsImJvZHkiLCJlIiwiZ2V0SW4iLCJrZXkiLCJkZWYiLCJwIiwicGF0aCIsInRvUGF0aCIsInNldEluIiwicmVzIiwiY2xvbmUiLCJyZXNWYWwiLCJpIiwicGF0aEFycmF5IiwiY3VycmVudFBhdGgiLCJjdXJyZW50T2JqIiwic2xpY2UiLCJuZXh0UGF0aCIsInNldE5lc3RlZE9iamVjdFZhbHVlcyIsIm9iamVjdCIsInZpc2l0ZWQiLCJyZXNwb25zZSIsIldlYWtNYXAiLCJfaSIsIl9PYmplY3Qka2V5cyIsImtleXMiLCJrIiwidmFsIiwiZ2V0Iiwic2V0IiwiRm9ybWlrQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJkaXNwbGF5TmFtZSIsIkZvcm1pa1Byb3ZpZGVyIiwiUHJvdmlkZXIiLCJGb3JtaWtDb25zdW1lciIsIkNvbnN1bWVyIiwidXNlRm9ybWlrQ29udGV4dCIsImZvcm1payIsInVzZUNvbnRleHQiLCJpbnZhcmlhbnQiLCJmb3JtaWtSZWR1Y2VyIiwic3RhdGUiLCJtc2ciLCJ0eXBlIiwiX2V4dGVuZHMiLCJ2YWx1ZXMiLCJwYXlsb2FkIiwidG91Y2hlZCIsImlzRXF1YWwiLCJlcnJvcnMiLCJzdGF0dXMiLCJpc1N1Ym1pdHRpbmciLCJpc1ZhbGlkYXRpbmciLCJmaWVsZCIsInN1Ym1pdENvdW50IiwiZW1wdHlFcnJvcnMiLCJlbXB0eVRvdWNoZWQiLCJ1c2VGb3JtaWsiLCJfcmVmIiwidmFsaWRhdGVPbkNoYW5nZSIsIl9yZWYkdmFsaWRhdGVPbkNoYW5nZSIsInZhbGlkYXRlT25CbHVyIiwiX3JlZiR2YWxpZGF0ZU9uQmx1ciIsInZhbGlkYXRlT25Nb3VudCIsIl9yZWYkdmFsaWRhdGVPbk1vdW50IiwiaXNJbml0aWFsVmFsaWQiLCJlbmFibGVSZWluaXRpYWxpemUiLCJfcmVmJGVuYWJsZVJlaW5pdGlhbGkiLCJvblN1Ym1pdCIsInJlc3QiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsInByb3BzIiwiaW5pdGlhbFZhbHVlcyIsInVzZVJlZiIsImluaXRpYWxFcnJvcnMiLCJpbml0aWFsVG91Y2hlZCIsImluaXRpYWxTdGF0dXMiLCJpc01vdW50ZWQiLCJmaWVsZFJlZ2lzdHJ5IiwidXNlRWZmZWN0IiwiY3VycmVudCIsInVzZVJlZHVjZXIiLCJfUmVhY3QkdXNlUmVkdWNlciIsImRpc3BhdGNoIiwicnVuVmFsaWRhdGVIYW5kbGVyIiwidXNlQ2FsbGJhY2siLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIm1heWJlUHJvbWlzZWRFcnJvcnMiLCJ2YWxpZGF0ZSIsImFjdHVhbEV4Y2VwdGlvbiIsImNvbnNvbGUiLCJ3YXJuIiwicnVuVmFsaWRhdGlvblNjaGVtYSIsInZhbGlkYXRpb25TY2hlbWEiLCJzY2hlbWEiLCJwcm9taXNlIiwidmFsaWRhdGVBdCIsInZhbGlkYXRlWXVwU2NoZW1hIiwiZXJyIiwibmFtZSIsInl1cFRvRm9ybUVycm9ycyIsInJ1blNpbmdsZUZpZWxkTGV2ZWxWYWxpZGF0aW9uIiwicnVuRmllbGRMZXZlbFZhbGlkYXRpb25zIiwiZmllbGRLZXlzV2l0aFZhbGlkYXRpb24iLCJmaWx0ZXIiLCJmIiwiZmllbGRWYWxpZGF0aW9ucyIsIm1hcCIsImFsbCIsImZpZWxkRXJyb3JzTGlzdCIsInJlZHVjZSIsInByZXYiLCJjdXJyIiwiaW5kZXgiLCJydW5BbGxWYWxpZGF0aW9ucyIsIl9yZWYyIiwiZmllbGRFcnJvcnMiLCJzY2hlbWFFcnJvcnMiLCJ2YWxpZGF0ZUVycm9ycyIsImNvbWJpbmVkRXJyb3JzIiwiZGVlcG1lcmdlIiwiYXJyYXlNZXJnZSIsInZhbGlkYXRlRm9ybVdpdGhIaWdoUHJpb3JpdHkiLCJ1c2VFdmVudENhbGxiYWNrIiwicmVzZXRGb3JtIiwibmV4dFN0YXRlIiwiZGlzcGF0Y2hGbiIsIm9uUmVzZXQiLCJtYXliZVByb21pc2VkT25SZXNldCIsImltcGVyYXRpdmVNZXRob2RzIiwidmFsaWRhdGVGaWVsZCIsIm1heWJlUHJvbWlzZSIsIngiLCJlcnJvciIsInJlZ2lzdGVyRmllbGQiLCJfcmVmMyIsInVucmVnaXN0ZXJGaWVsZCIsInNldFRvdWNoZWQiLCJzaG91bGRWYWxpZGF0ZSIsIndpbGxWYWxpZGF0ZSIsInNldEVycm9ycyIsInNldFZhbHVlcyIsInJlc29sdmVkVmFsdWVzIiwic2V0RmllbGRFcnJvciIsInNldEZpZWxkVmFsdWUiLCJleGVjdXRlQ2hhbmdlIiwiZXZlbnRPclRleHRWYWx1ZSIsIm1heWJlUGF0aCIsInBhcnNlZCIsInBlcnNpc3QiLCJjdXJyZW50VGFyZ2V0IiwiaWQiLCJjaGVja2VkIiwib3V0ZXJIVE1MIiwib3B0aW9ucyIsIm11bHRpcGxlIiwid2FybkFib3V0TWlzc2luZ0lkZW50aWZpZXIiLCJodG1sQ29udGVudCIsImRvY3VtZW50YXRpb25BbmNob3JMaW5rIiwiaGFuZGxlck5hbWUiLCJ0ZXN0IiwicGFyc2VGbG9hdCIsImdldFZhbHVlRm9yQ2hlY2tib3giLCJnZXRTZWxlY3RlZFZhbHVlcyIsImhhbmRsZUNoYW5nZSIsImV2ZW50T3JQYXRoIiwiZXZlbnQiLCJzZXRGaWVsZFRvdWNoZWQiLCJleGVjdXRlQmx1ciIsIl9lJHRhcmdldCIsImhhbmRsZUJsdXIiLCJldmVudE9yU3RyaW5nIiwic2V0Rm9ybWlrU3RhdGUiLCJzdGF0ZU9yQ2IiLCJzZXRTdGF0dXMiLCJzZXRTdWJtaXR0aW5nIiwic3VibWl0Rm9ybSIsImlzSW5zdGFuY2VPZkVycm9yIiwiRXJyb3IiLCJpc0FjdHVhbGx5VmFsaWQiLCJwcm9taXNlT3JVbmRlZmluZWQiLCJleGVjdXRlU3VibWl0IiwicmVzdWx0IiwiX2Vycm9ycyIsImhhbmRsZVN1Ym1pdCIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwiSFRNTEJ1dHRvbkVsZW1lbnQiLCJhdHRyaWJ1dGVzIiwiZ2V0TmFtZWRJdGVtIiwicmVhc29uIiwidmFsaWRhdGVGb3JtIiwiaGFuZGxlUmVzZXQiLCJnZXRGaWVsZE1ldGEiLCJpbml0aWFsVmFsdWUiLCJpbml0aWFsRXJyb3IiLCJnZXRGaWVsZEhlbHBlcnMiLCJzZXRWYWx1ZSIsInNldEVycm9yIiwiZ2V0RmllbGRQcm9wcyIsIm5hbWVPck9wdGlvbnMiLCJpc0FuT2JqZWN0IiwidmFsdWVTdGF0ZSIsIm9uQ2hhbmdlIiwib25CbHVyIiwidmFsdWVQcm9wIiwiaXMiLCJhcyIsImluZGV4T2YiLCJkaXJ0eSIsInVzZU1lbW8iLCJpc1ZhbGlkIiwiY3R4IiwiRm9ybWlrIiwiZm9ybWlrYmFnIiwiY29tcG9uZW50IiwicmVuZGVyIiwiaW5uZXJSZWYiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwiY3JlYXRlRWxlbWVudCIsIm9ubHkiLCJfcmVmNCIsInl1cEVycm9yIiwiaW5uZXIiLCJtZXNzYWdlIiwiX2l0ZXJhdG9yIiwiX2lzQXJyYXkiLCJTeW1ib2wiLCJpdGVyYXRvciIsIl9yZWY1IiwibmV4dCIsImRvbmUiLCJzeW5jIiwiY29udGV4dCIsInZhbGlkYXRlRGF0YSIsInByZXBhcmVEYXRhRm9yVmFsaWRhdGlvbiIsImFib3J0RWFybHkiLCJkYXRhIiwiaGFzT3duUHJvcGVydHkiLCJpc1BsYWluT2JqZWN0Iiwic291cmNlIiwiZGVzdGluYXRpb24iLCJmb3JFYWNoIiwibWVyZ2UiLCJjbG9uZVJlcXVlc3RlZCIsInNob3VsZENsb25lIiwiaXNNZXJnZWFibGVPYmplY3QiLCJwdXNoIiwiZnJvbSIsImVsIiwic2VsZWN0ZWQiLCJjdXJyZW50VmFsdWUiLCJCb29sZWFuIiwiY3VycmVudEFycmF5T2ZWYWx1ZXMiLCJpc1ZhbHVlSW5BcnJheSIsImNvbmNhdCIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJ3aW5kb3ciLCJ1c2VMYXlvdXRFZmZlY3QiLCJmbiIsInJlZiIsIl9sZW4iLCJhcmd1bWVudHMiLCJhcmdzIiwiX2tleSIsImFwcGx5IiwidXNlRmllbGQiLCJwcm9wc09yRmllbGROYW1lIiwiZmllbGROYW1lIiwidmFsaWRhdGVGbiIsIkZpZWxkIiwiX3VzZUZvcm1pa0NvbnRleHQiLCJtZXRhIiwibGVnYWN5QmFnIiwiZm9ybSIsImFzRWxlbWVudCIsIl9pbm5lclJlZiIsIl9yZXN0IiwiRm9ybSIsImZvcndhcmRSZWYiLCJhY3Rpb24iLCJfYWN0aW9uIiwiYXNzaWduIiwid2l0aEZvcm1payIsIm1hcFByb3BzVG9WYWx1ZXMiLCJfcmVmJG1hcFByb3BzVG9WYWx1ZXMiLCJ2YW5pbGxhUHJvcHMiLCJjb25maWciLCJjcmVhdGVGb3JtaWsiLCJDb21wb25lbnQiLCJjb21wb25lbnREaXNwbGF5TmFtZSIsImNvbnN0cnVjdG9yIiwiQyIsIl9SZWFjdCRDb21wb25lbnQiLCJfdGhpcyIsImFjdGlvbnMiLCJyZW5kZXJGb3JtQ29tcG9uZW50IiwiZm9ybWlrUHJvcHMiLCJfdGhpcyRwcm9wcyIsIm1hcFByb3BzVG9TdGF0dXMiLCJtYXBQcm9wc1RvRXJyb3JzIiwibWFwUHJvcHNUb1RvdWNoZWQiLCJob2lzdE5vblJlYWN0U3RhdGljcyIsImNvbm5lY3QiLCJDb21wIiwiV3JhcHBlZENvbXBvbmVudCIsIm1vdmUiLCJhcnJheSIsInRvIiwiY29weSIsImNvcHlBcnJheUxpa2UiLCJzcGxpY2UiLCJzd2FwIiwiYXJyYXlMaWtlIiwiaW5kZXhBIiwiaW5kZXhCIiwiYSIsImluc2VydCIsInJlcGxhY2UiLCJtYXhJbmRleCIsInBhcnNlSW50IiwibWF4IiwiRmllbGRBcnJheUlubmVyIiwidXBkYXRlQXJyYXlGaWVsZCIsImFsdGVyVG91Y2hlZCIsImFsdGVyRXJyb3JzIiwicHJldlN0YXRlIiwidXBkYXRlRXJyb3JzIiwidXBkYXRlVG91Y2hlZCIsImZpZWxkRXJyb3IiLCJmaWVsZFRvdWNoZWQiLCJjbG9uZURlZXAiLCJoYW5kbGVQdXNoIiwiaGFuZGxlU3dhcCIsImhhbmRsZU1vdmUiLCJoYW5kbGVJbnNlcnQiLCJoYW5kbGVSZXBsYWNlIiwidW5zaGlmdCIsImFyciIsImhhbmRsZVVuc2hpZnQiLCJoYW5kbGVSZW1vdmUiLCJyZW1vdmUiLCJoYW5kbGVQb3AiLCJwb3AiLCJiaW5kIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsImNvbXBvbmVudERpZFVwZGF0ZSIsInByZXZQcm9wcyIsInRtcCIsImFycmF5SGVscGVycyIsIl90aGlzJHByb3BzMiIsInJlc3RPZkZvcm1payIsIl90aGlzJHByb3BzMiRmb3JtaWsiLCJkZWZhdWx0UHJvcHMiLCJGaWVsZEFycmF5IiwiRXJyb3JNZXNzYWdlSW1wbCIsInNob3VsZENvbXBvbmVudFVwZGF0ZSIsInRvdWNoIiwiRXJyb3JNZXNzYWdlIiwiRmFzdEZpZWxkSW5uZXIiLCJzaG91bGRVcGRhdGUiLCJjb21wb25lbnREaWRNb3VudCIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwiYmFnIiwiRmFzdEZpZWxkIl0sInNvdXJjZXMiOlsiLi4vc3JjL3V0aWxzLnRzIiwiLi4vc3JjL0Zvcm1pa0NvbnRleHQudHN4IiwiLi4vc3JjL0Zvcm1pay50c3giLCIuLi9zcmMvRmllbGQudHN4IiwiLi4vc3JjL0Zvcm0udHN4IiwiLi4vc3JjL3dpdGhGb3JtaWsudHN4IiwiLi4vc3JjL2Nvbm5lY3QudHN4IiwiLi4vc3JjL0ZpZWxkQXJyYXkudHN4IiwiLi4vc3JjL0Vycm9yTWVzc2FnZS50c3giLCIuLi9zcmMvRmFzdEZpZWxkLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY2xvbmUgZnJvbSAnbG9kYXNoL2Nsb25lJztcbmltcG9ydCB0b1BhdGggZnJvbSAnbG9kYXNoL3RvUGF0aCc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8vIEFzc2VydGlvbnNcblxuLyoqIEBwcml2YXRlIGlzIHRoZSB2YWx1ZSBhbiBlbXB0eSBhcnJheT8gKi9cbmV4cG9ydCBjb25zdCBpc0VtcHR5QXJyYXkgPSAodmFsdWU/OiBhbnkpID0+XG4gIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMDtcblxuLyoqIEBwcml2YXRlIGlzIHRoZSBnaXZlbiBvYmplY3QgYSBGdW5jdGlvbj8gKi9cbmV4cG9ydCBjb25zdCBpc0Z1bmN0aW9uID0gKG9iajogYW55KTogb2JqIGlzIEZ1bmN0aW9uID0+XG4gIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbic7XG5cbi8qKiBAcHJpdmF0ZSBpcyB0aGUgZ2l2ZW4gb2JqZWN0IGFuIE9iamVjdD8gKi9cbmV4cG9ydCBjb25zdCBpc09iamVjdCA9IChvYmo6IGFueSk6IG9iaiBpcyBPYmplY3QgPT5cbiAgb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnO1xuXG4vKiogQHByaXZhdGUgaXMgdGhlIGdpdmVuIG9iamVjdCBhbiBpbnRlZ2VyPyAqL1xuZXhwb3J0IGNvbnN0IGlzSW50ZWdlciA9IChvYmo6IGFueSk6IGJvb2xlYW4gPT5cbiAgU3RyaW5nKE1hdGguZmxvb3IoTnVtYmVyKG9iaikpKSA9PT0gb2JqO1xuXG4vKiogQHByaXZhdGUgaXMgdGhlIGdpdmVuIG9iamVjdCBhIHN0cmluZz8gKi9cbmV4cG9ydCBjb25zdCBpc1N0cmluZyA9IChvYmo6IGFueSk6IG9iaiBpcyBzdHJpbmcgPT5cbiAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xuXG4vKiogQHByaXZhdGUgaXMgdGhlIGdpdmVuIG9iamVjdCBhIE5hTj8gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbmV4cG9ydCBjb25zdCBpc05hTiA9IChvYmo6IGFueSk6IGJvb2xlYW4gPT4gb2JqICE9PSBvYmo7XG5cbi8qKiBAcHJpdmF0ZSBEb2VzIGEgUmVhY3QgY29tcG9uZW50IGhhdmUgZXhhY3RseSAwIGNoaWxkcmVuPyAqL1xuZXhwb3J0IGNvbnN0IGlzRW1wdHlDaGlsZHJlbiA9IChjaGlsZHJlbjogYW55KTogYm9vbGVhbiA9PlxuICBSZWFjdC5DaGlsZHJlbi5jb3VudChjaGlsZHJlbikgPT09IDA7XG5cbi8qKiBAcHJpdmF0ZSBpcyB0aGUgZ2l2ZW4gb2JqZWN0L3ZhbHVlIGEgcHJvbWlzZT8gKi9cbmV4cG9ydCBjb25zdCBpc1Byb21pc2UgPSAodmFsdWU6IGFueSk6IHZhbHVlIGlzIFByb21pc2VMaWtlPGFueT4gPT5cbiAgaXNPYmplY3QodmFsdWUpICYmIGlzRnVuY3Rpb24odmFsdWUudGhlbik7XG5cbi8qKiBAcHJpdmF0ZSBpcyB0aGUgZ2l2ZW4gb2JqZWN0L3ZhbHVlIGEgdHlwZSBvZiBzeW50aGV0aWMgZXZlbnQ/ICovXG5leHBvcnQgY29uc3QgaXNJbnB1dEV2ZW50ID0gKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBSZWFjdC5TeW50aGV0aWNFdmVudDxhbnk+ID0+XG4gIHZhbHVlICYmIGlzT2JqZWN0KHZhbHVlKSAmJiBpc09iamVjdCh2YWx1ZS50YXJnZXQpO1xuXG4vKipcbiAqIFNhbWUgYXMgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBidXQgd3JhcHMgaW4gYSB0cnktY2F0Y2ggYmxvY2suIEluIElFIGl0IGlzXG4gKiBub3Qgc2FmZSB0byBjYWxsIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaWYgdGhlcmUgaXMgbm90aGluZyBmb2N1c2VkLlxuICpcbiAqIFRoZSBhY3RpdmVFbGVtZW50IHdpbGwgYmUgbnVsbCBvbmx5IGlmIHRoZSBkb2N1bWVudCBvciBkb2N1bWVudCBib2R5IGlzIG5vdFxuICogeWV0IGRlZmluZWQuXG4gKlxuICogQHBhcmFtIHs/RG9jdW1lbnR9IGRvYyBEZWZhdWx0cyB0byBjdXJyZW50IGRvY3VtZW50LlxuICogQHJldHVybiB7RWxlbWVudCB8IG51bGx9XG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mYmpzL2Jsb2IvbWFzdGVyL3BhY2thZ2VzL2ZianMvc3JjL2NvcmUvZG9tL2dldEFjdGl2ZUVsZW1lbnQuanNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFjdGl2ZUVsZW1lbnQoZG9jPzogRG9jdW1lbnQpOiBFbGVtZW50IHwgbnVsbCB7XG4gIGRvYyA9IGRvYyB8fCAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDogdW5kZWZpbmVkKTtcbiAgaWYgKHR5cGVvZiBkb2MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gZG9jLmFjdGl2ZUVsZW1lbnQgfHwgZG9jLmJvZHk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZG9jLmJvZHk7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWVwbHkgZ2V0IGEgdmFsdWUgZnJvbSBhbiBvYmplY3QgdmlhIGl0cyBwYXRoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW4oXG4gIG9iajogYW55LFxuICBrZXk6IHN0cmluZyB8IHN0cmluZ1tdLFxuICBkZWY/OiBhbnksXG4gIHA6IG51bWJlciA9IDBcbikge1xuICBjb25zdCBwYXRoID0gdG9QYXRoKGtleSk7XG4gIHdoaWxlIChvYmogJiYgcCA8IHBhdGgubGVuZ3RoKSB7XG4gICAgb2JqID0gb2JqW3BhdGhbcCsrXV07XG4gIH1cbiAgcmV0dXJuIG9iaiA9PT0gdW5kZWZpbmVkID8gZGVmIDogb2JqO1xufVxuXG4vKipcbiAqIERlZXBseSBzZXQgYSB2YWx1ZSBmcm9tIGluIG9iamVjdCB2aWEgaXQncyBwYXRoLiBJZiB0aGUgdmFsdWUgYXQgYHBhdGhgXG4gKiBoYXMgY2hhbmdlZCwgcmV0dXJuIGEgc2hhbGxvdyBjb3B5IG9mIG9iaiB3aXRoIGB2YWx1ZWAgc2V0IGF0IGBwYXRoYC5cbiAqIElmIGB2YWx1ZWAgaGFzIG5vdCBjaGFuZ2VkLCByZXR1cm4gdGhlIG9yaWdpbmFsIGBvYmpgLlxuICpcbiAqIEV4aXN0aW5nIG9iamVjdHMgLyBhcnJheXMgYWxvbmcgYHBhdGhgIGFyZSBhbHNvIHNoYWxsb3cgY29waWVkLiBTaWJsaW5nXG4gKiBvYmplY3RzIGFsb25nIHBhdGggcmV0YWluIHRoZSBzYW1lIGludGVybmFsIGpzIHJlZmVyZW5jZS4gU2luY2UgbmV3XG4gKiBvYmplY3RzIC8gYXJyYXlzIGFyZSBvbmx5IGNyZWF0ZWQgYWxvbmcgYHBhdGhgLCB3ZSBjYW4gdGVzdCBpZiBhbnl0aGluZ1xuICogY2hhbmdlZCBpbiBhIG5lc3RlZCBzdHJ1Y3R1cmUgYnkgY29tcGFyaW5nIHRoZSBvYmplY3QncyByZWZlcmVuY2UgaW5cbiAqIHRoZSBvbGQgYW5kIG5ldyBvYmplY3QsIHNpbWlsYXIgdG8gaG93IHJ1c3NpYW4gZG9sbCBjYWNoZSBpbnZhbGlkYXRpb25cbiAqIHdvcmtzLlxuICpcbiAqIEluIGVhcmxpZXIgdmVyc2lvbnMgb2YgdGhpcyBmdW5jdGlvbiwgd2hpY2ggdXNlZCBjbG9uZURlZXAsIHRoZXJlIHdlcmVcbiAqIGlzc3VlcyB3aGVyZWJ5IHNldHRpbmdzIGEgbmVzdGVkIHZhbHVlIHdvdWxkIG11dGF0ZSB0aGUgcGFyZW50XG4gKiBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgbmV3IG9iamVjdC4gYGNsb25lYCBhdm9pZHMgdGhhdCBidWcgbWFraW5nIGFcbiAqIHNoYWxsb3cgY29weSBvZiB0aGUgb2JqZWN0cyBhbG9uZyB0aGUgdXBkYXRlIHBhdGhcbiAqIHNvIG5vIG9iamVjdCBpcyBtdXRhdGVkIGluIHBsYWNlLlxuICpcbiAqIEJlZm9yZSBjaGFuZ2luZyB0aGlzIGZ1bmN0aW9uLCBwbGVhc2UgcmVhZCB0aHJvdWdoIHRoZSBmb2xsb3dpbmdcbiAqIGRpc2N1c3Npb25zLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2RldmVsb3BpdC9saW5rc3RhdGVcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2phcmVkcGFsbWVyL2Zvcm1pay9wdWxsLzEyM1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0SW4ob2JqOiBhbnksIHBhdGg6IHN0cmluZywgdmFsdWU6IGFueSk6IGFueSB7XG4gIGxldCByZXM6IGFueSA9IGNsb25lKG9iaik7IC8vIHRoaXMga2VlcHMgaW5oZXJpdGFuY2Ugd2hlbiBvYmogaXMgYSBjbGFzc1xuICBsZXQgcmVzVmFsOiBhbnkgPSByZXM7XG4gIGxldCBpID0gMDtcbiAgbGV0IHBhdGhBcnJheSA9IHRvUGF0aChwYXRoKTtcblxuICBmb3IgKDsgaSA8IHBhdGhBcnJheS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBjb25zdCBjdXJyZW50UGF0aDogc3RyaW5nID0gcGF0aEFycmF5W2ldO1xuICAgIGxldCBjdXJyZW50T2JqOiBhbnkgPSBnZXRJbihvYmosIHBhdGhBcnJheS5zbGljZSgwLCBpICsgMSkpO1xuXG4gICAgaWYgKGN1cnJlbnRPYmogJiYgKGlzT2JqZWN0KGN1cnJlbnRPYmopIHx8IEFycmF5LmlzQXJyYXkoY3VycmVudE9iaikpKSB7XG4gICAgICByZXNWYWwgPSByZXNWYWxbY3VycmVudFBhdGhdID0gY2xvbmUoY3VycmVudE9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5leHRQYXRoOiBzdHJpbmcgPSBwYXRoQXJyYXlbaSArIDFdO1xuICAgICAgcmVzVmFsID0gcmVzVmFsW2N1cnJlbnRQYXRoXSA9XG4gICAgICAgIGlzSW50ZWdlcihuZXh0UGF0aCkgJiYgTnVtYmVyKG5leHRQYXRoKSA+PSAwID8gW10gOiB7fTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm4gb3JpZ2luYWwgb2JqZWN0IGlmIG5ldyB2YWx1ZSBpcyB0aGUgc2FtZSBhcyBjdXJyZW50XG4gIGlmICgoaSA9PT0gMCA/IG9iaiA6IHJlc1ZhbClbcGF0aEFycmF5W2ldXSA9PT0gdmFsdWUpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICBkZWxldGUgcmVzVmFsW3BhdGhBcnJheVtpXV07XG4gIH0gZWxzZSB7XG4gICAgcmVzVmFsW3BhdGhBcnJheVtpXV0gPSB2YWx1ZTtcbiAgfVxuXG4gIC8vIElmIHRoZSBwYXRoIGFycmF5IGhhcyBhIHNpbmdsZSBlbGVtZW50LCB0aGUgbG9vcCBkaWQgbm90IHJ1bi5cbiAgLy8gRGVsZXRpbmcgb24gYHJlc1ZhbGAgaGFkIG5vIGVmZmVjdCBpbiB0aGlzIHNjZW5hcmlvLCBzbyB3ZSBkZWxldGUgb24gdGhlIHJlc3VsdCBpbnN0ZWFkLlxuICBpZiAoaSA9PT0gMCAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZGVsZXRlIHJlc1twYXRoQXJyYXlbaV1dO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBSZWN1cnNpdmVseSBhIHNldCB0aGUgc2FtZSB2YWx1ZSBmb3IgYWxsIGtleXMgYW5kIGFycmF5cyBuZXN0ZWQgb2JqZWN0LCBjbG9uaW5nXG4gKiBAcGFyYW0gb2JqZWN0XG4gKiBAcGFyYW0gdmFsdWVcbiAqIEBwYXJhbSB2aXNpdGVkXG4gKiBAcGFyYW0gcmVzcG9uc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldE5lc3RlZE9iamVjdFZhbHVlczxUPihcbiAgb2JqZWN0OiBhbnksXG4gIHZhbHVlOiBhbnksXG4gIHZpc2l0ZWQ6IGFueSA9IG5ldyBXZWFrTWFwKCksXG4gIHJlc3BvbnNlOiBhbnkgPSB7fVxuKTogVCB7XG4gIGZvciAobGV0IGsgb2YgT2JqZWN0LmtleXMob2JqZWN0KSkge1xuICAgIGNvbnN0IHZhbCA9IG9iamVjdFtrXTtcbiAgICBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgICAgaWYgKCF2aXNpdGVkLmdldCh2YWwpKSB7XG4gICAgICAgIHZpc2l0ZWQuc2V0KHZhbCwgdHJ1ZSk7XG4gICAgICAgIC8vIEluIG9yZGVyIHRvIGtlZXAgYXJyYXkgdmFsdWVzIGNvbnNpc3RlbnQgZm9yIGJvdGggZG90IHBhdGggIGFuZFxuICAgICAgICAvLyBicmFja2V0IHN5bnRheCwgd2UgbmVlZCB0byBjaGVjayBpZiB0aGlzIGlzIGFuIGFycmF5IHNvIHRoYXRcbiAgICAgICAgLy8gdGhpcyB3aWxsIG91dHB1dCAgeyBmcmllbmRzOiBbdHJ1ZV0gfSBhbmQgbm90IHsgZnJpZW5kczogeyBcIjBcIjogdHJ1ZSB9IH1cbiAgICAgICAgcmVzcG9uc2Vba10gPSBBcnJheS5pc0FycmF5KHZhbCkgPyBbXSA6IHt9O1xuICAgICAgICBzZXROZXN0ZWRPYmplY3RWYWx1ZXModmFsLCB2YWx1ZSwgdmlzaXRlZCwgcmVzcG9uc2Vba10pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXNwb25zZVtrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXNwb25zZTtcbn1cbiIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEZvcm1pa0NvbnRleHRUeXBlIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ3Rpbnktd2FybmluZyc7XG5cbmV4cG9ydCBjb25zdCBGb3JtaWtDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxGb3JtaWtDb250ZXh0VHlwZTxhbnk+PihcbiAgdW5kZWZpbmVkIGFzIGFueVxuKTtcbkZvcm1pa0NvbnRleHQuZGlzcGxheU5hbWUgPSAnRm9ybWlrQ29udGV4dCc7XG5cbmV4cG9ydCBjb25zdCBGb3JtaWtQcm92aWRlciA9IEZvcm1pa0NvbnRleHQuUHJvdmlkZXI7XG5leHBvcnQgY29uc3QgRm9ybWlrQ29uc3VtZXIgPSBGb3JtaWtDb250ZXh0LkNvbnN1bWVyO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlRm9ybWlrQ29udGV4dDxWYWx1ZXM+KCkge1xuICBjb25zdCBmb3JtaWsgPSBSZWFjdC51c2VDb250ZXh0PEZvcm1pa0NvbnRleHRUeXBlPFZhbHVlcz4+KEZvcm1pa0NvbnRleHQpO1xuXG4gIGludmFyaWFudChcbiAgICAhIWZvcm1payxcbiAgICBgRm9ybWlrIGNvbnRleHQgaXMgdW5kZWZpbmVkLCBwbGVhc2UgdmVyaWZ5IHlvdSBhcmUgY2FsbGluZyB1c2VGb3JtaWtDb250ZXh0KCkgYXMgY2hpbGQgb2YgYSA8Rm9ybWlrPiBjb21wb25lbnQuYFxuICApO1xuXG4gIHJldHVybiBmb3JtaWs7XG59XG4iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgaXNFcXVhbCBmcm9tICdyZWFjdC1mYXN0LWNvbXBhcmUnO1xuaW1wb3J0IGRlZXBtZXJnZSBmcm9tICdkZWVwbWVyZ2UnO1xuaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnbG9kYXNoL2lzUGxhaW5PYmplY3QnO1xuaW1wb3J0IHtcbiAgRm9ybWlrQ29uZmlnLFxuICBGb3JtaWtFcnJvcnMsXG4gIEZvcm1pa1N0YXRlLFxuICBGb3JtaWtUb3VjaGVkLFxuICBGb3JtaWtWYWx1ZXMsXG4gIEZvcm1pa1Byb3BzLFxuICBGaWVsZE1ldGFQcm9wcyxcbiAgRmllbGRIZWxwZXJQcm9wcyxcbiAgRmllbGRJbnB1dFByb3BzLFxuICBGb3JtaWtIZWxwZXJzLFxuICBGb3JtaWtIYW5kbGVycyxcbn0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQge1xuICBpc0Z1bmN0aW9uLFxuICBpc1N0cmluZyxcbiAgc2V0SW4sXG4gIGlzRW1wdHlDaGlsZHJlbixcbiAgaXNQcm9taXNlLFxuICBzZXROZXN0ZWRPYmplY3RWYWx1ZXMsXG4gIGdldEFjdGl2ZUVsZW1lbnQsXG4gIGdldEluLFxuICBpc09iamVjdCxcbn0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBGb3JtaWtQcm92aWRlciB9IGZyb20gJy4vRm9ybWlrQ29udGV4dCc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ3Rpbnktd2FybmluZyc7XG5cbnR5cGUgRm9ybWlrTWVzc2FnZTxWYWx1ZXM+ID1cbiAgfCB7IHR5cGU6ICdTVUJNSVRfQVRURU1QVCcgfVxuICB8IHsgdHlwZTogJ1NVQk1JVF9GQUlMVVJFJyB9XG4gIHwgeyB0eXBlOiAnU1VCTUlUX1NVQ0NFU1MnIH1cbiAgfCB7IHR5cGU6ICdTRVRfSVNWQUxJREFUSU5HJzsgcGF5bG9hZDogYm9vbGVhbiB9XG4gIHwgeyB0eXBlOiAnU0VUX0lTU1VCTUlUVElORyc7IHBheWxvYWQ6IGJvb2xlYW4gfVxuICB8IHsgdHlwZTogJ1NFVF9WQUxVRVMnOyBwYXlsb2FkOiBWYWx1ZXMgfVxuICB8IHsgdHlwZTogJ1NFVF9GSUVMRF9WQUxVRSc7IHBheWxvYWQ6IHsgZmllbGQ6IHN0cmluZzsgdmFsdWU/OiBhbnkgfSB9XG4gIHwgeyB0eXBlOiAnU0VUX0ZJRUxEX1RPVUNIRUQnOyBwYXlsb2FkOiB7IGZpZWxkOiBzdHJpbmc7IHZhbHVlPzogYm9vbGVhbiB9IH1cbiAgfCB7IHR5cGU6ICdTRVRfRklFTERfRVJST1InOyBwYXlsb2FkOiB7IGZpZWxkOiBzdHJpbmc7IHZhbHVlPzogc3RyaW5nIH0gfVxuICB8IHsgdHlwZTogJ1NFVF9UT1VDSEVEJzsgcGF5bG9hZDogRm9ybWlrVG91Y2hlZDxWYWx1ZXM+IH1cbiAgfCB7IHR5cGU6ICdTRVRfRVJST1JTJzsgcGF5bG9hZDogRm9ybWlrRXJyb3JzPFZhbHVlcz4gfVxuICB8IHsgdHlwZTogJ1NFVF9TVEFUVVMnOyBwYXlsb2FkOiBhbnkgfVxuICB8IHtcbiAgICAgIHR5cGU6ICdTRVRfRk9STUlLX1NUQVRFJztcbiAgICAgIHBheWxvYWQ6IChzOiBGb3JtaWtTdGF0ZTxWYWx1ZXM+KSA9PiBGb3JtaWtTdGF0ZTxWYWx1ZXM+O1xuICAgIH1cbiAgfCB7XG4gICAgICB0eXBlOiAnUkVTRVRfRk9STSc7XG4gICAgICBwYXlsb2FkOiBGb3JtaWtTdGF0ZTxWYWx1ZXM+O1xuICAgIH07XG5cbi8vIFN0YXRlIHJlZHVjZXJcbmZ1bmN0aW9uIGZvcm1pa1JlZHVjZXI8VmFsdWVzPihcbiAgc3RhdGU6IEZvcm1pa1N0YXRlPFZhbHVlcz4sXG4gIG1zZzogRm9ybWlrTWVzc2FnZTxWYWx1ZXM+XG4pIHtcbiAgc3dpdGNoIChtc2cudHlwZSkge1xuICAgIGNhc2UgJ1NFVF9WQUxVRVMnOlxuICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsIHZhbHVlczogbXNnLnBheWxvYWQgfTtcbiAgICBjYXNlICdTRVRfVE9VQ0hFRCc6XG4gICAgICByZXR1cm4geyAuLi5zdGF0ZSwgdG91Y2hlZDogbXNnLnBheWxvYWQgfTtcbiAgICBjYXNlICdTRVRfRVJST1JTJzpcbiAgICAgIGlmIChpc0VxdWFsKHN0YXRlLmVycm9ycywgbXNnLnBheWxvYWQpKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsIGVycm9yczogbXNnLnBheWxvYWQgfTtcbiAgICBjYXNlICdTRVRfU1RBVFVTJzpcbiAgICAgIHJldHVybiB7IC4uLnN0YXRlLCBzdGF0dXM6IG1zZy5wYXlsb2FkIH07XG4gICAgY2FzZSAnU0VUX0lTU1VCTUlUVElORyc6XG4gICAgICByZXR1cm4geyAuLi5zdGF0ZSwgaXNTdWJtaXR0aW5nOiBtc2cucGF5bG9hZCB9O1xuICAgIGNhc2UgJ1NFVF9JU1ZBTElEQVRJTkcnOlxuICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsIGlzVmFsaWRhdGluZzogbXNnLnBheWxvYWQgfTtcbiAgICBjYXNlICdTRVRfRklFTERfVkFMVUUnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIHZhbHVlczogc2V0SW4oc3RhdGUudmFsdWVzLCBtc2cucGF5bG9hZC5maWVsZCwgbXNnLnBheWxvYWQudmFsdWUpLFxuICAgICAgfTtcbiAgICBjYXNlICdTRVRfRklFTERfVE9VQ0hFRCc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgdG91Y2hlZDogc2V0SW4oc3RhdGUudG91Y2hlZCwgbXNnLnBheWxvYWQuZmllbGQsIG1zZy5wYXlsb2FkLnZhbHVlKSxcbiAgICAgIH07XG4gICAgY2FzZSAnU0VUX0ZJRUxEX0VSUk9SJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBlcnJvcnM6IHNldEluKHN0YXRlLmVycm9ycywgbXNnLnBheWxvYWQuZmllbGQsIG1zZy5wYXlsb2FkLnZhbHVlKSxcbiAgICAgIH07XG4gICAgY2FzZSAnUkVTRVRfRk9STSc6XG4gICAgICByZXR1cm4geyAuLi5zdGF0ZSwgLi4ubXNnLnBheWxvYWQgfTtcbiAgICBjYXNlICdTRVRfRk9STUlLX1NUQVRFJzpcbiAgICAgIHJldHVybiBtc2cucGF5bG9hZChzdGF0ZSk7XG4gICAgY2FzZSAnU1VCTUlUX0FUVEVNUFQnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIHRvdWNoZWQ6IHNldE5lc3RlZE9iamVjdFZhbHVlczxGb3JtaWtUb3VjaGVkPFZhbHVlcz4+KFxuICAgICAgICAgIHN0YXRlLnZhbHVlcyxcbiAgICAgICAgICB0cnVlXG4gICAgICAgICksXG4gICAgICAgIGlzU3VibWl0dGluZzogdHJ1ZSxcbiAgICAgICAgc3VibWl0Q291bnQ6IHN0YXRlLnN1Ym1pdENvdW50ICsgMSxcbiAgICAgIH07XG4gICAgY2FzZSAnU1VCTUlUX0ZBSUxVUkUnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGlzU3VibWl0dGluZzogZmFsc2UsXG4gICAgICB9O1xuICAgIGNhc2UgJ1NVQk1JVF9TVUNDRVNTJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBpc1N1Ym1pdHRpbmc6IGZhbHNlLFxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbi8vIEluaXRpYWwgZW1wdHkgc3RhdGVzIC8vIG9iamVjdHNcbmNvbnN0IGVtcHR5RXJyb3JzOiBGb3JtaWtFcnJvcnM8dW5rbm93bj4gPSB7fTtcbmNvbnN0IGVtcHR5VG91Y2hlZDogRm9ybWlrVG91Y2hlZDx1bmtub3duPiA9IHt9O1xuXG4vLyBUaGlzIGlzIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgbWFwIG9mIGFsbCByZWdpc3RlcmVkIGZpZWxkc1xuLy8gYW5kIHRoZWlyIHZhbGlkYXRlIGZ1bmN0aW9uc1xuaW50ZXJmYWNlIEZpZWxkUmVnaXN0cnkge1xuICBbZmllbGQ6IHN0cmluZ106IHtcbiAgICB2YWxpZGF0ZTogKHZhbHVlOiBhbnkpID0+IHN0cmluZyB8IFByb21pc2U8c3RyaW5nPiB8IHVuZGVmaW5lZDtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUZvcm1pazxWYWx1ZXMgZXh0ZW5kcyBGb3JtaWtWYWx1ZXMgPSBGb3JtaWtWYWx1ZXM+KHtcbiAgdmFsaWRhdGVPbkNoYW5nZSA9IHRydWUsXG4gIHZhbGlkYXRlT25CbHVyID0gdHJ1ZSxcbiAgdmFsaWRhdGVPbk1vdW50ID0gZmFsc2UsXG4gIGlzSW5pdGlhbFZhbGlkLFxuICBlbmFibGVSZWluaXRpYWxpemUgPSBmYWxzZSxcbiAgb25TdWJtaXQsXG4gIC4uLnJlc3Rcbn06IEZvcm1pa0NvbmZpZzxWYWx1ZXM+KSB7XG4gIGNvbnN0IHByb3BzID0ge1xuICAgIHZhbGlkYXRlT25DaGFuZ2UsXG4gICAgdmFsaWRhdGVPbkJsdXIsXG4gICAgdmFsaWRhdGVPbk1vdW50LFxuICAgIG9uU3VibWl0LFxuICAgIC4uLnJlc3QsXG4gIH07XG4gIGNvbnN0IGluaXRpYWxWYWx1ZXMgPSBSZWFjdC51c2VSZWYocHJvcHMuaW5pdGlhbFZhbHVlcyk7XG4gIGNvbnN0IGluaXRpYWxFcnJvcnMgPSBSZWFjdC51c2VSZWYocHJvcHMuaW5pdGlhbEVycm9ycyB8fCBlbXB0eUVycm9ycyk7XG4gIGNvbnN0IGluaXRpYWxUb3VjaGVkID0gUmVhY3QudXNlUmVmKHByb3BzLmluaXRpYWxUb3VjaGVkIHx8IGVtcHR5VG91Y2hlZCk7XG4gIGNvbnN0IGluaXRpYWxTdGF0dXMgPSBSZWFjdC51c2VSZWYocHJvcHMuaW5pdGlhbFN0YXR1cyk7XG4gIGNvbnN0IGlzTW91bnRlZCA9IFJlYWN0LnVzZVJlZjxib29sZWFuPihmYWxzZSk7XG4gIGNvbnN0IGZpZWxkUmVnaXN0cnkgPSBSZWFjdC51c2VSZWY8RmllbGRSZWdpc3RyeT4oe30pO1xuICBpZiAoX19ERVZfXykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBpbnZhcmlhbnQoXG4gICAgICAgIHR5cGVvZiBpc0luaXRpYWxWYWxpZCA9PT0gJ3VuZGVmaW5lZCcsXG4gICAgICAgICdpc0luaXRpYWxWYWxpZCBoYXMgYmVlbiBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIHZlcnNpb25zIG9mIEZvcm1pay4gUGxlYXNlIHVzZSBpbml0aWFsRXJyb3JzIG9yIHZhbGlkYXRlT25Nb3VudCBpbnN0ZWFkLidcbiAgICAgICk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICB9LCBbXSk7XG4gIH1cblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlzTW91bnRlZC5jdXJyZW50ID0gdHJ1ZTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpc01vdW50ZWQuY3VycmVudCA9IGZhbHNlO1xuICAgIH07XG4gIH0sIFtdKTtcblxuICBjb25zdCBbc3RhdGUsIGRpc3BhdGNoXSA9IFJlYWN0LnVzZVJlZHVjZXI8XG4gICAgUmVhY3QuUmVkdWNlcjxGb3JtaWtTdGF0ZTxWYWx1ZXM+LCBGb3JtaWtNZXNzYWdlPFZhbHVlcz4+XG4gID4oZm9ybWlrUmVkdWNlciwge1xuICAgIHZhbHVlczogcHJvcHMuaW5pdGlhbFZhbHVlcyxcbiAgICBlcnJvcnM6IHByb3BzLmluaXRpYWxFcnJvcnMgfHwgZW1wdHlFcnJvcnMsXG4gICAgdG91Y2hlZDogcHJvcHMuaW5pdGlhbFRvdWNoZWQgfHwgZW1wdHlUb3VjaGVkLFxuICAgIHN0YXR1czogcHJvcHMuaW5pdGlhbFN0YXR1cyxcbiAgICBpc1N1Ym1pdHRpbmc6IGZhbHNlLFxuICAgIGlzVmFsaWRhdGluZzogZmFsc2UsXG4gICAgc3VibWl0Q291bnQ6IDAsXG4gIH0pO1xuXG4gIGNvbnN0IHJ1blZhbGlkYXRlSGFuZGxlciA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICh2YWx1ZXM6IFZhbHVlcywgZmllbGQ/OiBzdHJpbmcpOiBQcm9taXNlPEZvcm1pa0Vycm9yczxWYWx1ZXM+PiA9PiB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBtYXliZVByb21pc2VkRXJyb3JzID0gKHByb3BzLnZhbGlkYXRlIGFzIGFueSkodmFsdWVzLCBmaWVsZCk7XG4gICAgICAgIGlmIChtYXliZVByb21pc2VkRXJyb3JzID09IG51bGwpIHtcbiAgICAgICAgICAvLyB1c2UgbG9vc2UgbnVsbCBjaGVjayBoZXJlIG9uIHB1cnBvc2VcbiAgICAgICAgICByZXNvbHZlKGVtcHR5RXJyb3JzKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1Byb21pc2UobWF5YmVQcm9taXNlZEVycm9ycykpIHtcbiAgICAgICAgICAobWF5YmVQcm9taXNlZEVycm9ycyBhcyBQcm9taXNlPGFueT4pLnRoZW4oXG4gICAgICAgICAgICBlcnJvcnMgPT4ge1xuICAgICAgICAgICAgICByZXNvbHZlKGVycm9ycyB8fCBlbXB0eUVycm9ycyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWN0dWFsRXhjZXB0aW9uID0+IHtcbiAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICBgV2FybmluZzogQW4gdW5oYW5kbGVkIGVycm9yIHdhcyBjYXVnaHQgZHVyaW5nIHZhbGlkYXRpb24gaW4gPEZvcm1payB2YWxpZGF0ZSAvPmAsXG4gICAgICAgICAgICAgICAgICBhY3R1YWxFeGNlcHRpb25cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmVqZWN0KGFjdHVhbEV4Y2VwdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKG1heWJlUHJvbWlzZWRFcnJvcnMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIFtwcm9wcy52YWxpZGF0ZV1cbiAgKTtcblxuICAvKipcbiAgICogUnVuIHZhbGlkYXRpb24gYWdhaW5zdCBhIFl1cCBzY2hlbWEgYW5kIG9wdGlvbmFsbHkgcnVuIGEgZnVuY3Rpb24gaWYgc3VjY2Vzc2Z1bFxuICAgKi9cbiAgY29uc3QgcnVuVmFsaWRhdGlvblNjaGVtYSA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICh2YWx1ZXM6IFZhbHVlcywgZmllbGQ/OiBzdHJpbmcpOiBQcm9taXNlPEZvcm1pa0Vycm9yczxWYWx1ZXM+PiA9PiB7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uU2NoZW1hID0gcHJvcHMudmFsaWRhdGlvblNjaGVtYTtcbiAgICAgIGNvbnN0IHNjaGVtYSA9IGlzRnVuY3Rpb24odmFsaWRhdGlvblNjaGVtYSlcbiAgICAgICAgPyB2YWxpZGF0aW9uU2NoZW1hKGZpZWxkKVxuICAgICAgICA6IHZhbGlkYXRpb25TY2hlbWE7XG4gICAgICBjb25zdCBwcm9taXNlID1cbiAgICAgICAgZmllbGQgJiYgc2NoZW1hLnZhbGlkYXRlQXRcbiAgICAgICAgICA/IHNjaGVtYS52YWxpZGF0ZUF0KGZpZWxkLCB2YWx1ZXMpXG4gICAgICAgICAgOiB2YWxpZGF0ZVl1cFNjaGVtYSh2YWx1ZXMsIHNjaGVtYSk7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBwcm9taXNlLnRoZW4oXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZShlbXB0eUVycm9ycyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAoZXJyOiBhbnkpID0+IHtcbiAgICAgICAgICAgIC8vIFl1cCB3aWxsIHRocm93IGEgdmFsaWRhdGlvbiBlcnJvciBpZiB2YWxpZGF0aW9uIGZhaWxzLiBXZSBjYXRjaCB0aG9zZSBhbmRcbiAgICAgICAgICAgIC8vIHJlc29sdmUgdGhlbSBpbnRvIEZvcm1payBlcnJvcnMuIFdlIGNhbiBzbmlmZiBpZiBzb21ldGhpbmcgaXMgYSBZdXAgZXJyb3JcbiAgICAgICAgICAgIC8vIGJ5IGNoZWNraW5nIGVycm9yLm5hbWUuXG4gICAgICAgICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlbnNlL3l1cCN2YWxpZGF0aW9uZXJyb3JlcnJvcnMtc3RyaW5nLS1hcnJheXN0cmluZy12YWx1ZS1hbnktcGF0aC1zdHJpbmdcbiAgICAgICAgICAgIGlmIChlcnIubmFtZSA9PT0gJ1ZhbGlkYXRpb25FcnJvcicpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZSh5dXBUb0Zvcm1FcnJvcnMoZXJyKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBXZSB0aHJvdyBhbnkgb3RoZXIgZXJyb3JzXG4gICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgYFdhcm5pbmc6IEFuIHVuaGFuZGxlZCBlcnJvciB3YXMgY2F1Z2h0IGR1cmluZyB2YWxpZGF0aW9uIGluIDxGb3JtaWsgdmFsaWRhdGlvblNjaGVtYSAvPmAsXG4gICAgICAgICAgICAgICAgICBlcnJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBbcHJvcHMudmFsaWRhdGlvblNjaGVtYV1cbiAgKTtcblxuICBjb25zdCBydW5TaW5nbGVGaWVsZExldmVsVmFsaWRhdGlvbiA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgIChmaWVsZDogc3RyaW5nLCB2YWx1ZTogdm9pZCB8IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiA9PiB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PlxuICAgICAgICByZXNvbHZlKGZpZWxkUmVnaXN0cnkuY3VycmVudFtmaWVsZF0udmFsaWRhdGUodmFsdWUpIGFzIHN0cmluZylcbiAgICAgICk7XG4gICAgfSxcbiAgICBbXVxuICApO1xuXG4gIGNvbnN0IHJ1bkZpZWxkTGV2ZWxWYWxpZGF0aW9ucyA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICh2YWx1ZXM6IFZhbHVlcyk6IFByb21pc2U8Rm9ybWlrRXJyb3JzPFZhbHVlcz4+ID0+IHtcbiAgICAgIGNvbnN0IGZpZWxkS2V5c1dpdGhWYWxpZGF0aW9uOiBzdHJpbmdbXSA9IE9iamVjdC5rZXlzKFxuICAgICAgICBmaWVsZFJlZ2lzdHJ5LmN1cnJlbnRcbiAgICAgICkuZmlsdGVyKGYgPT4gaXNGdW5jdGlvbihmaWVsZFJlZ2lzdHJ5LmN1cnJlbnRbZl0udmFsaWRhdGUpKTtcblxuICAgICAgLy8gQ29uc3RydWN0IGFuIGFycmF5IHdpdGggYWxsIG9mIHRoZSBmaWVsZCB2YWxpZGF0aW9uIGZ1bmN0aW9uc1xuICAgICAgY29uc3QgZmllbGRWYWxpZGF0aW9uczogUHJvbWlzZTxzdHJpbmc+W10gPVxuICAgICAgICBmaWVsZEtleXNXaXRoVmFsaWRhdGlvbi5sZW5ndGggPiAwXG4gICAgICAgICAgPyBmaWVsZEtleXNXaXRoVmFsaWRhdGlvbi5tYXAoZiA9PlxuICAgICAgICAgICAgICBydW5TaW5nbGVGaWVsZExldmVsVmFsaWRhdGlvbihmLCBnZXRJbih2YWx1ZXMsIGYpKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogW1Byb21pc2UucmVzb2x2ZSgnRE9fTk9UX0RFTEVURV9ZT1VfV0lMTF9CRV9GSVJFRCcpXTsgLy8gdXNlIHNwZWNpYWwgY2FzZSA7KVxuXG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoZmllbGRWYWxpZGF0aW9ucykudGhlbigoZmllbGRFcnJvcnNMaXN0OiBzdHJpbmdbXSkgPT5cbiAgICAgICAgZmllbGRFcnJvcnNMaXN0LnJlZHVjZSgocHJldiwgY3VyciwgaW5kZXgpID0+IHtcbiAgICAgICAgICBpZiAoY3VyciA9PT0gJ0RPX05PVF9ERUxFVEVfWU9VX1dJTExfQkVfRklSRUQnKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGN1cnIpIHtcbiAgICAgICAgICAgIHByZXYgPSBzZXRJbihwcmV2LCBmaWVsZEtleXNXaXRoVmFsaWRhdGlvbltpbmRleF0sIGN1cnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgICAgfSwge30pXG4gICAgICApO1xuICAgIH0sXG4gICAgW3J1blNpbmdsZUZpZWxkTGV2ZWxWYWxpZGF0aW9uXVxuICApO1xuXG4gIC8vIFJ1biBhbGwgdmFsaWRhdGlvbnMgYW5kIHJldHVybiB0aGUgcmVzdWx0XG4gIGNvbnN0IHJ1bkFsbFZhbGlkYXRpb25zID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKHZhbHVlczogVmFsdWVzKSA9PiB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICBydW5GaWVsZExldmVsVmFsaWRhdGlvbnModmFsdWVzKSxcbiAgICAgICAgcHJvcHMudmFsaWRhdGlvblNjaGVtYSA/IHJ1blZhbGlkYXRpb25TY2hlbWEodmFsdWVzKSA6IHt9LFxuICAgICAgICBwcm9wcy52YWxpZGF0ZSA/IHJ1blZhbGlkYXRlSGFuZGxlcih2YWx1ZXMpIDoge30sXG4gICAgICBdKS50aGVuKChbZmllbGRFcnJvcnMsIHNjaGVtYUVycm9ycywgdmFsaWRhdGVFcnJvcnNdKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbWJpbmVkRXJyb3JzID0gZGVlcG1lcmdlLmFsbDxGb3JtaWtFcnJvcnM8VmFsdWVzPj4oXG4gICAgICAgICAgW2ZpZWxkRXJyb3JzLCBzY2hlbWFFcnJvcnMsIHZhbGlkYXRlRXJyb3JzXSxcbiAgICAgICAgICB7IGFycmF5TWVyZ2UgfVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gY29tYmluZWRFcnJvcnM7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIFtcbiAgICAgIHByb3BzLnZhbGlkYXRlLFxuICAgICAgcHJvcHMudmFsaWRhdGlvblNjaGVtYSxcbiAgICAgIHJ1bkZpZWxkTGV2ZWxWYWxpZGF0aW9ucyxcbiAgICAgIHJ1blZhbGlkYXRlSGFuZGxlcixcbiAgICAgIHJ1blZhbGlkYXRpb25TY2hlbWEsXG4gICAgXVxuICApO1xuXG4gIC8vIFJ1biBhbGwgdmFsaWRhdGlvbnMgbWV0aG9kcyBhbmQgdXBkYXRlIHN0YXRlIGFjY29yZGluZ2x5XG4gIGNvbnN0IHZhbGlkYXRlRm9ybVdpdGhIaWdoUHJpb3JpdHkgPSB1c2VFdmVudENhbGxiYWNrKFxuICAgICh2YWx1ZXM6IFZhbHVlcyA9IHN0YXRlLnZhbHVlcykgPT4ge1xuICAgICAgZGlzcGF0Y2goeyB0eXBlOiAnU0VUX0lTVkFMSURBVElORycsIHBheWxvYWQ6IHRydWUgfSk7XG4gICAgICByZXR1cm4gcnVuQWxsVmFsaWRhdGlvbnModmFsdWVzKS50aGVuKGNvbWJpbmVkRXJyb3JzID0+IHtcbiAgICAgICAgaWYgKCEhaXNNb3VudGVkLmN1cnJlbnQpIHtcbiAgICAgICAgICBkaXNwYXRjaCh7IHR5cGU6ICdTRVRfSVNWQUxJREFUSU5HJywgcGF5bG9hZDogZmFsc2UgfSk7XG4gICAgICAgICAgZGlzcGF0Y2goeyB0eXBlOiAnU0VUX0VSUk9SUycsIHBheWxvYWQ6IGNvbWJpbmVkRXJyb3JzIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21iaW5lZEVycm9ycztcbiAgICAgIH0pO1xuICAgIH1cbiAgKTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChcbiAgICAgIHZhbGlkYXRlT25Nb3VudCAmJlxuICAgICAgaXNNb3VudGVkLmN1cnJlbnQgPT09IHRydWUgJiZcbiAgICAgIGlzRXF1YWwoaW5pdGlhbFZhbHVlcy5jdXJyZW50LCBwcm9wcy5pbml0aWFsVmFsdWVzKVxuICAgICkge1xuICAgICAgdmFsaWRhdGVGb3JtV2l0aEhpZ2hQcmlvcml0eShpbml0aWFsVmFsdWVzLmN1cnJlbnQpO1xuICAgIH1cbiAgfSwgW3ZhbGlkYXRlT25Nb3VudCwgdmFsaWRhdGVGb3JtV2l0aEhpZ2hQcmlvcml0eV0pO1xuXG4gIGNvbnN0IHJlc2V0Rm9ybSA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgIChuZXh0U3RhdGU/OiBQYXJ0aWFsPEZvcm1pa1N0YXRlPFZhbHVlcz4+KSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZXMgPVxuICAgICAgICBuZXh0U3RhdGUgJiYgbmV4dFN0YXRlLnZhbHVlc1xuICAgICAgICAgID8gbmV4dFN0YXRlLnZhbHVlc1xuICAgICAgICAgIDogaW5pdGlhbFZhbHVlcy5jdXJyZW50O1xuICAgICAgY29uc3QgZXJyb3JzID1cbiAgICAgICAgbmV4dFN0YXRlICYmIG5leHRTdGF0ZS5lcnJvcnNcbiAgICAgICAgICA/IG5leHRTdGF0ZS5lcnJvcnNcbiAgICAgICAgICA6IGluaXRpYWxFcnJvcnMuY3VycmVudFxuICAgICAgICAgID8gaW5pdGlhbEVycm9ycy5jdXJyZW50XG4gICAgICAgICAgOiBwcm9wcy5pbml0aWFsRXJyb3JzIHx8IHt9O1xuICAgICAgY29uc3QgdG91Y2hlZCA9XG4gICAgICAgIG5leHRTdGF0ZSAmJiBuZXh0U3RhdGUudG91Y2hlZFxuICAgICAgICAgID8gbmV4dFN0YXRlLnRvdWNoZWRcbiAgICAgICAgICA6IGluaXRpYWxUb3VjaGVkLmN1cnJlbnRcbiAgICAgICAgICA/IGluaXRpYWxUb3VjaGVkLmN1cnJlbnRcbiAgICAgICAgICA6IHByb3BzLmluaXRpYWxUb3VjaGVkIHx8IHt9O1xuICAgICAgY29uc3Qgc3RhdHVzID1cbiAgICAgICAgbmV4dFN0YXRlICYmIG5leHRTdGF0ZS5zdGF0dXNcbiAgICAgICAgICA/IG5leHRTdGF0ZS5zdGF0dXNcbiAgICAgICAgICA6IGluaXRpYWxTdGF0dXMuY3VycmVudFxuICAgICAgICAgID8gaW5pdGlhbFN0YXR1cy5jdXJyZW50XG4gICAgICAgICAgOiBwcm9wcy5pbml0aWFsU3RhdHVzO1xuICAgICAgaW5pdGlhbFZhbHVlcy5jdXJyZW50ID0gdmFsdWVzO1xuICAgICAgaW5pdGlhbEVycm9ycy5jdXJyZW50ID0gZXJyb3JzO1xuICAgICAgaW5pdGlhbFRvdWNoZWQuY3VycmVudCA9IHRvdWNoZWQ7XG4gICAgICBpbml0aWFsU3RhdHVzLmN1cnJlbnQgPSBzdGF0dXM7XG5cbiAgICAgIGNvbnN0IGRpc3BhdGNoRm4gPSAoKSA9PiB7XG4gICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiAnUkVTRVRfRk9STScsXG4gICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgaXNTdWJtaXR0aW5nOiAhIW5leHRTdGF0ZSAmJiAhIW5leHRTdGF0ZS5pc1N1Ym1pdHRpbmcsXG4gICAgICAgICAgICBlcnJvcnMsXG4gICAgICAgICAgICB0b3VjaGVkLFxuICAgICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgICAgdmFsdWVzLFxuICAgICAgICAgICAgaXNWYWxpZGF0aW5nOiAhIW5leHRTdGF0ZSAmJiAhIW5leHRTdGF0ZS5pc1ZhbGlkYXRpbmcsXG4gICAgICAgICAgICBzdWJtaXRDb3VudDpcbiAgICAgICAgICAgICAgISFuZXh0U3RhdGUgJiZcbiAgICAgICAgICAgICAgISFuZXh0U3RhdGUuc3VibWl0Q291bnQgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIG5leHRTdGF0ZS5zdWJtaXRDb3VudCA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICA/IG5leHRTdGF0ZS5zdWJtaXRDb3VudFxuICAgICAgICAgICAgICAgIDogMCxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChwcm9wcy5vblJlc2V0KSB7XG4gICAgICAgIGNvbnN0IG1heWJlUHJvbWlzZWRPblJlc2V0ID0gKHByb3BzLm9uUmVzZXQgYXMgYW55KShcbiAgICAgICAgICBzdGF0ZS52YWx1ZXMsXG4gICAgICAgICAgaW1wZXJhdGl2ZU1ldGhvZHNcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoaXNQcm9taXNlKG1heWJlUHJvbWlzZWRPblJlc2V0KSkge1xuICAgICAgICAgIChtYXliZVByb21pc2VkT25SZXNldCBhcyBQcm9taXNlPGFueT4pLnRoZW4oZGlzcGF0Y2hGbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlzcGF0Y2hGbigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXNwYXRjaEZuKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbcHJvcHMuaW5pdGlhbEVycm9ycywgcHJvcHMuaW5pdGlhbFN0YXR1cywgcHJvcHMuaW5pdGlhbFRvdWNoZWRdXG4gICk7XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoXG4gICAgICBpc01vdW50ZWQuY3VycmVudCA9PT0gdHJ1ZSAmJlxuICAgICAgIWlzRXF1YWwoaW5pdGlhbFZhbHVlcy5jdXJyZW50LCBwcm9wcy5pbml0aWFsVmFsdWVzKVxuICAgICkge1xuICAgICAgaWYgKGVuYWJsZVJlaW5pdGlhbGl6ZSkge1xuICAgICAgICBpbml0aWFsVmFsdWVzLmN1cnJlbnQgPSBwcm9wcy5pbml0aWFsVmFsdWVzO1xuICAgICAgICByZXNldEZvcm0oKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbGlkYXRlT25Nb3VudCkge1xuICAgICAgICB2YWxpZGF0ZUZvcm1XaXRoSGlnaFByaW9yaXR5KGluaXRpYWxWYWx1ZXMuY3VycmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbXG4gICAgZW5hYmxlUmVpbml0aWFsaXplLFxuICAgIHByb3BzLmluaXRpYWxWYWx1ZXMsXG4gICAgcmVzZXRGb3JtLFxuICAgIHZhbGlkYXRlT25Nb3VudCxcbiAgICB2YWxpZGF0ZUZvcm1XaXRoSGlnaFByaW9yaXR5LFxuICBdKTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChcbiAgICAgIGVuYWJsZVJlaW5pdGlhbGl6ZSAmJlxuICAgICAgaXNNb3VudGVkLmN1cnJlbnQgPT09IHRydWUgJiZcbiAgICAgICFpc0VxdWFsKGluaXRpYWxFcnJvcnMuY3VycmVudCwgcHJvcHMuaW5pdGlhbEVycm9ycylcbiAgICApIHtcbiAgICAgIGluaXRpYWxFcnJvcnMuY3VycmVudCA9IHByb3BzLmluaXRpYWxFcnJvcnMgfHwgZW1wdHlFcnJvcnM7XG4gICAgICBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6ICdTRVRfRVJST1JTJyxcbiAgICAgICAgcGF5bG9hZDogcHJvcHMuaW5pdGlhbEVycm9ycyB8fCBlbXB0eUVycm9ycyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2VuYWJsZVJlaW5pdGlhbGl6ZSwgcHJvcHMuaW5pdGlhbEVycm9yc10pO1xuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKFxuICAgICAgZW5hYmxlUmVpbml0aWFsaXplICYmXG4gICAgICBpc01vdW50ZWQuY3VycmVudCA9PT0gdHJ1ZSAmJlxuICAgICAgIWlzRXF1YWwoaW5pdGlhbFRvdWNoZWQuY3VycmVudCwgcHJvcHMuaW5pdGlhbFRvdWNoZWQpXG4gICAgKSB7XG4gICAgICBpbml0aWFsVG91Y2hlZC5jdXJyZW50ID0gcHJvcHMuaW5pdGlhbFRvdWNoZWQgfHwgZW1wdHlUb3VjaGVkO1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiAnU0VUX1RPVUNIRUQnLFxuICAgICAgICBwYXlsb2FkOiBwcm9wcy5pbml0aWFsVG91Y2hlZCB8fCBlbXB0eVRvdWNoZWQsXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtlbmFibGVSZWluaXRpYWxpemUsIHByb3BzLmluaXRpYWxUb3VjaGVkXSk7XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoXG4gICAgICBlbmFibGVSZWluaXRpYWxpemUgJiZcbiAgICAgIGlzTW91bnRlZC5jdXJyZW50ID09PSB0cnVlICYmXG4gICAgICAhaXNFcXVhbChpbml0aWFsU3RhdHVzLmN1cnJlbnQsIHByb3BzLmluaXRpYWxTdGF0dXMpXG4gICAgKSB7XG4gICAgICBpbml0aWFsU3RhdHVzLmN1cnJlbnQgPSBwcm9wcy5pbml0aWFsU3RhdHVzO1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiAnU0VUX1NUQVRVUycsXG4gICAgICAgIHBheWxvYWQ6IHByb3BzLmluaXRpYWxTdGF0dXMsXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtlbmFibGVSZWluaXRpYWxpemUsIHByb3BzLmluaXRpYWxTdGF0dXMsIHByb3BzLmluaXRpYWxUb3VjaGVkXSk7XG5cbiAgY29uc3QgdmFsaWRhdGVGaWVsZCA9IHVzZUV2ZW50Q2FsbGJhY2soKG5hbWU6IHN0cmluZykgPT4ge1xuICAgIC8vIFRoaXMgd2lsbCBlZmZpY2llbnRseSB2YWxpZGF0ZSBhIHNpbmdsZSBmaWVsZCBieSBhdm9pZGluZyBzdGF0ZVxuICAgIC8vIGNoYW5nZXMgaWYgdGhlIHZhbGlkYXRpb24gZnVuY3Rpb24gaXMgc3luY2hyb25vdXMuIEl0J3MgZGlmZmVyZW50IGZyb21cbiAgICAvLyB3aGF0IGlzIGNhbGxlZCB3aGVuIHVzaW5nIHZhbGlkYXRlRm9ybS5cblxuICAgIGlmIChcbiAgICAgIGZpZWxkUmVnaXN0cnkuY3VycmVudFtuYW1lXSAmJlxuICAgICAgaXNGdW5jdGlvbihmaWVsZFJlZ2lzdHJ5LmN1cnJlbnRbbmFtZV0udmFsaWRhdGUpXG4gICAgKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGdldEluKHN0YXRlLnZhbHVlcywgbmFtZSk7XG4gICAgICBjb25zdCBtYXliZVByb21pc2UgPSBmaWVsZFJlZ2lzdHJ5LmN1cnJlbnRbbmFtZV0udmFsaWRhdGUodmFsdWUpO1xuICAgICAgaWYgKGlzUHJvbWlzZShtYXliZVByb21pc2UpKSB7XG4gICAgICAgIC8vIE9ubHkgZmxpcCBpc1ZhbGlkYXRpbmcgaWYgdGhlIGZ1bmN0aW9uIGlzIGFzeW5jLlxuICAgICAgICBkaXNwYXRjaCh7IHR5cGU6ICdTRVRfSVNWQUxJREFUSU5HJywgcGF5bG9hZDogdHJ1ZSB9KTtcbiAgICAgICAgcmV0dXJuIG1heWJlUHJvbWlzZVxuICAgICAgICAgIC50aGVuKCh4OiBhbnkpID0+IHgpXG4gICAgICAgICAgLnRoZW4oKGVycm9yOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgdHlwZTogJ1NFVF9GSUVMRF9FUlJPUicsXG4gICAgICAgICAgICAgIHBheWxvYWQ6IHsgZmllbGQ6IG5hbWUsIHZhbHVlOiBlcnJvciB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkaXNwYXRjaCh7IHR5cGU6ICdTRVRfSVNWQUxJREFUSU5HJywgcGF5bG9hZDogZmFsc2UgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogJ1NFVF9GSUVMRF9FUlJPUicsXG4gICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgZmllbGQ6IG5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogbWF5YmVQcm9taXNlIGFzIHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYXliZVByb21pc2UgYXMgc3RyaW5nIHwgdW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BzLnZhbGlkYXRpb25TY2hlbWEpIHtcbiAgICAgIGRpc3BhdGNoKHsgdHlwZTogJ1NFVF9JU1ZBTElEQVRJTkcnLCBwYXlsb2FkOiB0cnVlIH0pO1xuICAgICAgcmV0dXJuIHJ1blZhbGlkYXRpb25TY2hlbWEoc3RhdGUudmFsdWVzLCBuYW1lKVxuICAgICAgICAudGhlbigoeDogYW55KSA9PiB4KVxuICAgICAgICAudGhlbigoZXJyb3I6IGFueSkgPT4ge1xuICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdTRVRfRklFTERfRVJST1InLFxuICAgICAgICAgICAgcGF5bG9hZDogeyBmaWVsZDogbmFtZSwgdmFsdWU6IGVycm9yW25hbWVdIH0sXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGlzcGF0Y2goeyB0eXBlOiAnU0VUX0lTVkFMSURBVElORycsIHBheWxvYWQ6IGZhbHNlIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH0pO1xuXG4gIGNvbnN0IHJlZ2lzdGVyRmllbGQgPSBSZWFjdC51c2VDYWxsYmFjaygobmFtZTogc3RyaW5nLCB7IHZhbGlkYXRlIH06IGFueSkgPT4ge1xuICAgIGZpZWxkUmVnaXN0cnkuY3VycmVudFtuYW1lXSA9IHtcbiAgICAgIHZhbGlkYXRlLFxuICAgIH07XG4gIH0sIFtdKTtcblxuICBjb25zdCB1bnJlZ2lzdGVyRmllbGQgPSBSZWFjdC51c2VDYWxsYmFjaygobmFtZTogc3RyaW5nKSA9PiB7XG4gICAgZGVsZXRlIGZpZWxkUmVnaXN0cnkuY3VycmVudFtuYW1lXTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IHNldFRvdWNoZWQgPSB1c2VFdmVudENhbGxiYWNrKFxuICAgICh0b3VjaGVkOiBGb3JtaWtUb3VjaGVkPFZhbHVlcz4sIHNob3VsZFZhbGlkYXRlPzogYm9vbGVhbikgPT4ge1xuICAgICAgZGlzcGF0Y2goeyB0eXBlOiAnU0VUX1RPVUNIRUQnLCBwYXlsb2FkOiB0b3VjaGVkIH0pO1xuICAgICAgY29uc3Qgd2lsbFZhbGlkYXRlID1cbiAgICAgICAgc2hvdWxkVmFsaWRhdGUgPT09IHVuZGVmaW5lZCA/IHZhbGlkYXRlT25CbHVyIDogc2hvdWxkVmFsaWRhdGU7XG4gICAgICByZXR1cm4gd2lsbFZhbGlkYXRlXG4gICAgICAgID8gdmFsaWRhdGVGb3JtV2l0aEhpZ2hQcmlvcml0eShzdGF0ZS52YWx1ZXMpXG4gICAgICAgIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICApO1xuXG4gIGNvbnN0IHNldEVycm9ycyA9IFJlYWN0LnVzZUNhbGxiYWNrKChlcnJvcnM6IEZvcm1pa0Vycm9yczxWYWx1ZXM+KSA9PiB7XG4gICAgZGlzcGF0Y2goeyB0eXBlOiAnU0VUX0VSUk9SUycsIHBheWxvYWQ6IGVycm9ycyB9KTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IHNldFZhbHVlcyA9IHVzZUV2ZW50Q2FsbGJhY2soXG4gICAgKHZhbHVlczogUmVhY3QuU2V0U3RhdGVBY3Rpb248VmFsdWVzPiwgc2hvdWxkVmFsaWRhdGU/OiBib29sZWFuKSA9PiB7XG4gICAgICBjb25zdCByZXNvbHZlZFZhbHVlcyA9IGlzRnVuY3Rpb24odmFsdWVzKSA/IHZhbHVlcyhzdGF0ZS52YWx1ZXMpIDogdmFsdWVzO1xuXG4gICAgICBkaXNwYXRjaCh7IHR5cGU6ICdTRVRfVkFMVUVTJywgcGF5bG9hZDogcmVzb2x2ZWRWYWx1ZXMgfSk7XG4gICAgICBjb25zdCB3aWxsVmFsaWRhdGUgPVxuICAgICAgICBzaG91bGRWYWxpZGF0ZSA9PT0gdW5kZWZpbmVkID8gdmFsaWRhdGVPbkNoYW5nZSA6IHNob3VsZFZhbGlkYXRlO1xuICAgICAgcmV0dXJuIHdpbGxWYWxpZGF0ZVxuICAgICAgICA/IHZhbGlkYXRlRm9ybVdpdGhIaWdoUHJpb3JpdHkocmVzb2x2ZWRWYWx1ZXMpXG4gICAgICAgIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICApO1xuXG4gIGNvbnN0IHNldEZpZWxkRXJyb3IgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAoZmllbGQ6IHN0cmluZywgdmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZCkgPT4ge1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiAnU0VUX0ZJRUxEX0VSUk9SJyxcbiAgICAgICAgcGF5bG9hZDogeyBmaWVsZCwgdmFsdWUgfSxcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgW11cbiAgKTtcblxuICBjb25zdCBzZXRGaWVsZFZhbHVlID0gdXNlRXZlbnRDYWxsYmFjayhcbiAgICAoZmllbGQ6IHN0cmluZywgdmFsdWU6IGFueSwgc2hvdWxkVmFsaWRhdGU/OiBib29sZWFuKSA9PiB7XG4gICAgICBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6ICdTRVRfRklFTERfVkFMVUUnLFxuICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgZmllbGQsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHdpbGxWYWxpZGF0ZSA9XG4gICAgICAgIHNob3VsZFZhbGlkYXRlID09PSB1bmRlZmluZWQgPyB2YWxpZGF0ZU9uQ2hhbmdlIDogc2hvdWxkVmFsaWRhdGU7XG4gICAgICByZXR1cm4gd2lsbFZhbGlkYXRlXG4gICAgICAgID8gdmFsaWRhdGVGb3JtV2l0aEhpZ2hQcmlvcml0eShzZXRJbihzdGF0ZS52YWx1ZXMsIGZpZWxkLCB2YWx1ZSkpXG4gICAgICAgIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICApO1xuXG4gIGNvbnN0IGV4ZWN1dGVDaGFuZ2UgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAoZXZlbnRPclRleHRWYWx1ZTogc3RyaW5nIHwgUmVhY3QuQ2hhbmdlRXZlbnQ8YW55PiwgbWF5YmVQYXRoPzogc3RyaW5nKSA9PiB7XG4gICAgICAvLyBCeSBkZWZhdWx0LCBhc3N1bWUgdGhhdCB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBzdHJpbmcuIFRoaXMgYWxsb3dzIHVzIHRvIHVzZVxuICAgICAgLy8gaGFuZGxlQ2hhbmdlIHdpdGggUmVhY3QgTmF0aXZlIGFuZCBSZWFjdCBOYXRpdmUgV2ViJ3Mgb25DaGFuZ2VUZXh0IHByb3Agd2hpY2hcbiAgICAgIC8vIHByb3ZpZGVzIGp1c3QgdGhlIHZhbHVlIG9mIHRoZSBpbnB1dC5cbiAgICAgIGxldCBmaWVsZCA9IG1heWJlUGF0aDtcbiAgICAgIGxldCB2YWwgPSBldmVudE9yVGV4dFZhbHVlO1xuICAgICAgbGV0IHBhcnNlZDtcbiAgICAgIC8vIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBub3QgYSBzdHJpbmcgdGhvdWdoLCBpdCBoYXMgdG8gYmUgYSBzeW50aGV0aWMgUmVhY3QgRXZlbnQgKG9yIGEgZmFrZSBvbmUpLFxuICAgICAgLy8gc28gd2UgaGFuZGxlIGxpa2Ugd2Ugd291bGQgYSBub3JtYWwgSFRNTCBjaGFuZ2UgZXZlbnQuXG4gICAgICBpZiAoIWlzU3RyaW5nKGV2ZW50T3JUZXh0VmFsdWUpKSB7XG4gICAgICAgIC8vIElmIHdlIGNhbiwgcGVyc2lzdCB0aGUgZXZlbnRcbiAgICAgICAgLy8gQHNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvZXZlbnRzLmh0bWwjZXZlbnQtcG9vbGluZ1xuICAgICAgICBpZiAoKGV2ZW50T3JUZXh0VmFsdWUgYXMgYW55KS5wZXJzaXN0KSB7XG4gICAgICAgICAgKGV2ZW50T3JUZXh0VmFsdWUgYXMgUmVhY3QuQ2hhbmdlRXZlbnQ8YW55PikucGVyc2lzdCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50T3JUZXh0VmFsdWUudGFyZ2V0XG4gICAgICAgICAgPyAoZXZlbnRPclRleHRWYWx1ZSBhcyBSZWFjdC5DaGFuZ2VFdmVudDxhbnk+KS50YXJnZXRcbiAgICAgICAgICA6IChldmVudE9yVGV4dFZhbHVlIGFzIFJlYWN0LkNoYW5nZUV2ZW50PGFueT4pLmN1cnJlbnRUYXJnZXQ7XG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBjaGVja2VkLFxuICAgICAgICAgIG91dGVySFRNTCxcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIG11bHRpcGxlLFxuICAgICAgICB9ID0gdGFyZ2V0O1xuXG4gICAgICAgIGZpZWxkID0gbWF5YmVQYXRoID8gbWF5YmVQYXRoIDogbmFtZSA/IG5hbWUgOiBpZDtcbiAgICAgICAgaWYgKCFmaWVsZCAmJiBfX0RFVl9fKSB7XG4gICAgICAgICAgd2FybkFib3V0TWlzc2luZ0lkZW50aWZpZXIoe1xuICAgICAgICAgICAgaHRtbENvbnRlbnQ6IG91dGVySFRNTCxcbiAgICAgICAgICAgIGRvY3VtZW50YXRpb25BbmNob3JMaW5rOiAnaGFuZGxlY2hhbmdlLWUtcmVhY3RjaGFuZ2VldmVudGFueS0tdm9pZCcsXG4gICAgICAgICAgICBoYW5kbGVyTmFtZTogJ2hhbmRsZUNoYW5nZScsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsID0gL251bWJlcnxyYW5nZS8udGVzdCh0eXBlKVxuICAgICAgICAgID8gKChwYXJzZWQgPSBwYXJzZUZsb2F0KHZhbHVlKSksIGlzTmFOKHBhcnNlZCkgPyAnJyA6IHBhcnNlZClcbiAgICAgICAgICA6IC9jaGVja2JveC8udGVzdCh0eXBlKSAvLyBjaGVja2JveGVzXG4gICAgICAgICAgPyBnZXRWYWx1ZUZvckNoZWNrYm94KGdldEluKHN0YXRlLnZhbHVlcywgZmllbGQhKSwgY2hlY2tlZCwgdmFsdWUpXG4gICAgICAgICAgOiBvcHRpb25zICYmIG11bHRpcGxlIC8vIDxzZWxlY3QgbXVsdGlwbGU+XG4gICAgICAgICAgPyBnZXRTZWxlY3RlZFZhbHVlcyhvcHRpb25zKVxuICAgICAgICAgIDogdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAvLyBTZXQgZm9ybSBmaWVsZHMgYnkgbmFtZVxuICAgICAgICBzZXRGaWVsZFZhbHVlKGZpZWxkLCB2YWwpO1xuICAgICAgfVxuICAgIH0sXG4gICAgW3NldEZpZWxkVmFsdWUsIHN0YXRlLnZhbHVlc11cbiAgKTtcblxuICBjb25zdCBoYW5kbGVDaGFuZ2UgPSB1c2VFdmVudENhbGxiYWNrPEZvcm1pa0hhbmRsZXJzWydoYW5kbGVDaGFuZ2UnXT4oXG4gICAgKFxuICAgICAgZXZlbnRPclBhdGg6IHN0cmluZyB8IFJlYWN0LkNoYW5nZUV2ZW50PGFueT5cbiAgICApOiB2b2lkIHwgKChldmVudE9yVGV4dFZhbHVlOiBzdHJpbmcgfCBSZWFjdC5DaGFuZ2VFdmVudDxhbnk+KSA9PiB2b2lkKSA9PiB7XG4gICAgICBpZiAoaXNTdHJpbmcoZXZlbnRPclBhdGgpKSB7XG4gICAgICAgIHJldHVybiBldmVudCA9PiBleGVjdXRlQ2hhbmdlKGV2ZW50LCBldmVudE9yUGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGVjdXRlQ2hhbmdlKGV2ZW50T3JQYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG5cbiAgY29uc3Qgc2V0RmllbGRUb3VjaGVkID0gdXNlRXZlbnRDYWxsYmFjayhcbiAgICAoZmllbGQ6IHN0cmluZywgdG91Y2hlZDogYm9vbGVhbiA9IHRydWUsIHNob3VsZFZhbGlkYXRlPzogYm9vbGVhbikgPT4ge1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiAnU0VUX0ZJRUxEX1RPVUNIRUQnLFxuICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgZmllbGQsXG4gICAgICAgICAgdmFsdWU6IHRvdWNoZWQsXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHdpbGxWYWxpZGF0ZSA9XG4gICAgICAgIHNob3VsZFZhbGlkYXRlID09PSB1bmRlZmluZWQgPyB2YWxpZGF0ZU9uQmx1ciA6IHNob3VsZFZhbGlkYXRlO1xuICAgICAgcmV0dXJuIHdpbGxWYWxpZGF0ZVxuICAgICAgICA/IHZhbGlkYXRlRm9ybVdpdGhIaWdoUHJpb3JpdHkoc3RhdGUudmFsdWVzKVxuICAgICAgICA6IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgKTtcblxuICBjb25zdCBleGVjdXRlQmx1ciA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgIChlOiBhbnksIHBhdGg/OiBzdHJpbmcpID0+IHtcbiAgICAgIGlmIChlLnBlcnNpc3QpIHtcbiAgICAgICAgZS5wZXJzaXN0KCk7XG4gICAgICB9XG4gICAgICBjb25zdCB7IG5hbWUsIGlkLCBvdXRlckhUTUwgfSA9IGUudGFyZ2V0O1xuICAgICAgY29uc3QgZmllbGQgPSBwYXRoID8gcGF0aCA6IG5hbWUgPyBuYW1lIDogaWQ7XG5cbiAgICAgIGlmICghZmllbGQgJiYgX19ERVZfXykge1xuICAgICAgICB3YXJuQWJvdXRNaXNzaW5nSWRlbnRpZmllcih7XG4gICAgICAgICAgaHRtbENvbnRlbnQ6IG91dGVySFRNTCxcbiAgICAgICAgICBkb2N1bWVudGF0aW9uQW5jaG9yTGluazogJ2hhbmRsZWJsdXItZS1hbnktLXZvaWQnLFxuICAgICAgICAgIGhhbmRsZXJOYW1lOiAnaGFuZGxlQmx1cicsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBzZXRGaWVsZFRvdWNoZWQoZmllbGQsIHRydWUpO1xuICAgIH0sXG4gICAgW3NldEZpZWxkVG91Y2hlZF1cbiAgKTtcblxuICBjb25zdCBoYW5kbGVCbHVyID0gdXNlRXZlbnRDYWxsYmFjazxGb3JtaWtIYW5kbGVyc1snaGFuZGxlQmx1ciddPihcbiAgICAoZXZlbnRPclN0cmluZzogYW55KTogdm9pZCB8ICgoZTogYW55KSA9PiB2b2lkKSA9PiB7XG4gICAgICBpZiAoaXNTdHJpbmcoZXZlbnRPclN0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50ID0+IGV4ZWN1dGVCbHVyKGV2ZW50LCBldmVudE9yU3RyaW5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4ZWN1dGVCbHVyKGV2ZW50T3JTdHJpbmcpO1xuICAgICAgfVxuICAgIH1cbiAgKTtcblxuICBjb25zdCBzZXRGb3JtaWtTdGF0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgIChcbiAgICAgIHN0YXRlT3JDYjpcbiAgICAgICAgfCBGb3JtaWtTdGF0ZTxWYWx1ZXM+XG4gICAgICAgIHwgKChzdGF0ZTogRm9ybWlrU3RhdGU8VmFsdWVzPikgPT4gRm9ybWlrU3RhdGU8VmFsdWVzPilcbiAgICApOiB2b2lkID0+IHtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKHN0YXRlT3JDYikpIHtcbiAgICAgICAgZGlzcGF0Y2goeyB0eXBlOiAnU0VUX0ZPUk1JS19TVEFURScsIHBheWxvYWQ6IHN0YXRlT3JDYiB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpc3BhdGNoKHsgdHlwZTogJ1NFVF9GT1JNSUtfU1RBVEUnLCBwYXlsb2FkOiAoKSA9PiBzdGF0ZU9yQ2IgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbXVxuICApO1xuXG4gIGNvbnN0IHNldFN0YXR1cyA9IFJlYWN0LnVzZUNhbGxiYWNrKChzdGF0dXM6IGFueSkgPT4ge1xuICAgIGRpc3BhdGNoKHsgdHlwZTogJ1NFVF9TVEFUVVMnLCBwYXlsb2FkOiBzdGF0dXMgfSk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBzZXRTdWJtaXR0aW5nID0gUmVhY3QudXNlQ2FsbGJhY2soKGlzU3VibWl0dGluZzogYm9vbGVhbikgPT4ge1xuICAgIGRpc3BhdGNoKHsgdHlwZTogJ1NFVF9JU1NVQk1JVFRJTkcnLCBwYXlsb2FkOiBpc1N1Ym1pdHRpbmcgfSk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBzdWJtaXRGb3JtID0gdXNlRXZlbnRDYWxsYmFjaygoKSA9PiB7XG4gICAgZGlzcGF0Y2goeyB0eXBlOiAnU1VCTUlUX0FUVEVNUFQnIH0pO1xuICAgIHJldHVybiB2YWxpZGF0ZUZvcm1XaXRoSGlnaFByaW9yaXR5KCkudGhlbihcbiAgICAgIChjb21iaW5lZEVycm9yczogRm9ybWlrRXJyb3JzPFZhbHVlcz4pID0+IHtcbiAgICAgICAgLy8gSW4gY2FzZSBhbiBlcnJvciB3YXMgdGhyb3duIGFuZCBwYXNzZWQgdG8gdGhlIHJlc29sdmVkIFByb21pc2UsXG4gICAgICAgIC8vIGBjb21iaW5lZEVycm9yc2AgY2FuIGJlIGFuIGluc3RhbmNlIG9mIGFuIEVycm9yLiBXZSBuZWVkIHRvIGNoZWNrXG4gICAgICAgIC8vIHRoYXQgYW5kIGFib3J0IHRoZSBzdWJtaXQuXG4gICAgICAgIC8vIElmIHdlIGRvbid0IGRvIHRoYXQsIGNhbGxpbmcgYE9iamVjdC5rZXlzKG5ldyBFcnJvcigpKWAgeWllbGRzIGFuXG4gICAgICAgIC8vIGVtcHR5IGFycmF5LCB3aGljaCBjYXVzZXMgdGhlIHZhbGlkYXRpb24gdG8gcGFzcyBhbmQgdGhlIGZvcm1cbiAgICAgICAgLy8gdG8gYmUgc3VibWl0dGVkLlxuXG4gICAgICAgIGNvbnN0IGlzSW5zdGFuY2VPZkVycm9yID0gY29tYmluZWRFcnJvcnMgaW5zdGFuY2VvZiBFcnJvcjtcbiAgICAgICAgY29uc3QgaXNBY3R1YWxseVZhbGlkID1cbiAgICAgICAgICAhaXNJbnN0YW5jZU9mRXJyb3IgJiYgT2JqZWN0LmtleXMoY29tYmluZWRFcnJvcnMpLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgaWYgKGlzQWN0dWFsbHlWYWxpZCkge1xuICAgICAgICAgIC8vIFByb2NlZWQgd2l0aCBzdWJtaXQuLi5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFRvIHJlc3BlY3Qgc3luYyBzdWJtaXQgZm5zLCB3ZSBjYW4ndCBzaW1wbHkgd3JhcCBleGVjdXRlU3VibWl0IGluIGEgcHJvbWlzZSBhbmRcbiAgICAgICAgICAvLyBfYWx3YXlzXyBkaXNwYXRjaCBTVUJNSVRfU1VDQ0VTUyBiZWNhdXNlIGlzU3VibWl0dGluZyB3b3VsZCB0aGVuIGFsd2F5cyBiZSBmYWxzZS5cbiAgICAgICAgICAvLyBUaGlzIHdvdWxkIGJlIGZpbmUgaW4gc2ltcGxlIGNhc2VzLCBidXQgbWFrZSBpdCBpbXBvc3NpYmxlIHRvIGRpc2FibGUgc3VibWl0XG4gICAgICAgICAgLy8gYnV0dG9ucyB3aGVyZSBwZW9wbGUgdXNlIGNhbGxiYWNrcyBvciBwcm9taXNlcyBhcyBzaWRlIGVmZmVjdHMgKHdoaWNoIGlzIGJhc2ljYWxseVxuICAgICAgICAgIC8vIGFsbCBvZiB2MSBGb3JtaWsgY29kZSkuIEluc3RlYWQsIHJlY2FsbCB0aGF0IHdlIGFyZSBpbnNpZGUgb2YgYSBwcm9taXNlIGNoYWluIGFscmVhZHksXG4gICAgICAgICAgLy8gIHNvIHdlIGNhbiB0cnkvY2F0Y2ggZXhlY3V0ZVN1Ym1pdCgpLCBpZiBpdCByZXR1cm5zIHVuZGVmaW5lZCwgdGhlbiBqdXN0IGJhaWwuXG4gICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGVycm9ycywgdGhyb3cgZW0uIE90aGVyd2lzZSwgd3JhcCBleGVjdXRlU3VibWl0IGluIGEgcHJvbWlzZSBhbmQgaGFuZGxlXG4gICAgICAgICAgLy8gY2xlYW51cCBvZiBpc1N1Ym1pdHRpbmcgb24gYmVoYWxmIG9mIHRoZSBjb25zdW1lci5cbiAgICAgICAgICBsZXQgcHJvbWlzZU9yVW5kZWZpbmVkO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcm9taXNlT3JVbmRlZmluZWQgPSBleGVjdXRlU3VibWl0KCk7XG4gICAgICAgICAgICAvLyBCYWlsIGlmIGl0J3Mgc3luYywgY29uc3VtZXIgaXMgcmVzcG9uc2libGUgZm9yIGNsZWFuaW5nIHVwXG4gICAgICAgICAgICAvLyB2aWEgc2V0U3VibWl0dGluZyhmYWxzZSlcbiAgICAgICAgICAgIGlmIChwcm9taXNlT3JVbmRlZmluZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocHJvbWlzZU9yVW5kZWZpbmVkKVxuICAgICAgICAgICAgLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgaWYgKCEhaXNNb3VudGVkLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh7IHR5cGU6ICdTVUJNSVRfU1VDQ0VTUycgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goX2Vycm9ycyA9PiB7XG4gICAgICAgICAgICAgIGlmICghIWlzTW91bnRlZC5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goeyB0eXBlOiAnU1VCTUlUX0ZBSUxVUkUnIH0pO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBsZWdpdCBlcnJvciByZWplY3RlZCBieSB0aGUgb25TdWJtaXQgZm5cbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBkb24ndCB3YW50IHRvIGJyZWFrIHRoZSBwcm9taXNlIGNoYWluXG4gICAgICAgICAgICAgICAgdGhyb3cgX2Vycm9ycztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoISFpc01vdW50ZWQuY3VycmVudCkge1xuICAgICAgICAgIC8vIF5eXiBNYWtlIHN1cmUgRm9ybWlrIGlzIHN0aWxsIG1vdW50ZWQgYmVmb3JlIHVwZGF0aW5nIHN0YXRlXG4gICAgICAgICAgZGlzcGF0Y2goeyB0eXBlOiAnU1VCTUlUX0ZBSUxVUkUnIH0pO1xuICAgICAgICAgIC8vIHRocm93IGNvbWJpbmVkRXJyb3JzO1xuICAgICAgICAgIGlmIChpc0luc3RhbmNlT2ZFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgY29tYmluZWRFcnJvcnM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICApO1xuICB9KTtcblxuICBjb25zdCBoYW5kbGVTdWJtaXQgPSB1c2VFdmVudENhbGxiYWNrKFxuICAgIChlPzogUmVhY3QuRm9ybUV2ZW50PEhUTUxGb3JtRWxlbWVudD4pID0+IHtcbiAgICAgIGlmIChlICYmIGUucHJldmVudERlZmF1bHQgJiYgaXNGdW5jdGlvbihlLnByZXZlbnREZWZhdWx0KSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlICYmIGUuc3RvcFByb3BhZ2F0aW9uICYmIGlzRnVuY3Rpb24oZS5zdG9wUHJvcGFnYXRpb24pKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFdhcm4gaWYgZm9ybSBzdWJtaXNzaW9uIGlzIHRyaWdnZXJlZCBieSBhIDxidXR0b24+IHdpdGhvdXQgYVxuICAgICAgLy8gc3BlY2lmaWVkIGB0eXBlYCBhdHRyaWJ1dGUgZHVyaW5nIGRldmVsb3BtZW50LiBUaGlzIG1pdGlnYXRlc1xuICAgICAgLy8gYSBjb21tb24gZ290Y2hhIGluIGZvcm1zIHdpdGggYm90aCByZXNldCBhbmQgc3VibWl0IGJ1dHRvbnMsXG4gICAgICAvLyB3aGVyZSB0aGUgZGV2IGZvcmdldHMgdG8gYWRkIHR5cGU9XCJidXR0b25cIiB0byB0aGUgcmVzZXQgYnV0dG9uLlxuICAgICAgaWYgKF9fREVWX18gJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBTYWZlbHkgZ2V0IHRoZSBhY3RpdmUgZWxlbWVudCAod29ya3Mgd2l0aCBJRSlcbiAgICAgICAgY29uc3QgYWN0aXZlRWxlbWVudCA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGFjdGl2ZUVsZW1lbnQgIT09IG51bGwgJiZcbiAgICAgICAgICBhY3RpdmVFbGVtZW50IGluc3RhbmNlb2YgSFRNTEJ1dHRvbkVsZW1lbnRcbiAgICAgICAgKSB7XG4gICAgICAgICAgaW52YXJpYW50KFxuICAgICAgICAgICAgYWN0aXZlRWxlbWVudC5hdHRyaWJ1dGVzICYmXG4gICAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnQuYXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ3R5cGUnKSxcbiAgICAgICAgICAgICdZb3Ugc3VibWl0dGVkIGEgRm9ybWlrIGZvcm0gdXNpbmcgYSBidXR0b24gd2l0aCBhbiB1bnNwZWNpZmllZCBgdHlwZWAgYXR0cmlidXRlLiAgTW9zdCBicm93c2VycyBkZWZhdWx0IGJ1dHRvbiBlbGVtZW50cyB0byBgdHlwZT1cInN1Ym1pdFwiYC4gSWYgdGhpcyBpcyBub3QgYSBzdWJtaXQgYnV0dG9uLCBwbGVhc2UgYWRkIGB0eXBlPVwiYnV0dG9uXCJgLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN1Ym1pdEZvcm0oKS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgYFdhcm5pbmc6IEFuIHVuaGFuZGxlZCBlcnJvciB3YXMgY2F1Z2h0IGZyb20gc3VibWl0Rm9ybSgpYCxcbiAgICAgICAgICByZWFzb25cbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgKTtcblxuICBjb25zdCBpbXBlcmF0aXZlTWV0aG9kczogRm9ybWlrSGVscGVyczxWYWx1ZXM+ID0ge1xuICAgIHJlc2V0Rm9ybSxcbiAgICB2YWxpZGF0ZUZvcm06IHZhbGlkYXRlRm9ybVdpdGhIaWdoUHJpb3JpdHksXG4gICAgdmFsaWRhdGVGaWVsZCxcbiAgICBzZXRFcnJvcnMsXG4gICAgc2V0RmllbGRFcnJvcixcbiAgICBzZXRGaWVsZFRvdWNoZWQsXG4gICAgc2V0RmllbGRWYWx1ZSxcbiAgICBzZXRTdGF0dXMsXG4gICAgc2V0U3VibWl0dGluZyxcbiAgICBzZXRUb3VjaGVkLFxuICAgIHNldFZhbHVlcyxcbiAgICBzZXRGb3JtaWtTdGF0ZSxcbiAgICBzdWJtaXRGb3JtLFxuICB9O1xuXG4gIGNvbnN0IGV4ZWN1dGVTdWJtaXQgPSB1c2VFdmVudENhbGxiYWNrKCgpID0+IHtcbiAgICByZXR1cm4gb25TdWJtaXQoc3RhdGUudmFsdWVzLCBpbXBlcmF0aXZlTWV0aG9kcyk7XG4gIH0pO1xuXG4gIGNvbnN0IGhhbmRsZVJlc2V0ID0gdXNlRXZlbnRDYWxsYmFjayhlID0+IHtcbiAgICBpZiAoZSAmJiBlLnByZXZlbnREZWZhdWx0ICYmIGlzRnVuY3Rpb24oZS5wcmV2ZW50RGVmYXVsdCkpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBpZiAoZSAmJiBlLnN0b3BQcm9wYWdhdGlvbiAmJiBpc0Z1bmN0aW9uKGUuc3RvcFByb3BhZ2F0aW9uKSkge1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICByZXNldEZvcm0oKTtcbiAgfSk7XG5cbiAgY29uc3QgZ2V0RmllbGRNZXRhID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKG5hbWU6IHN0cmluZyk6IEZpZWxkTWV0YVByb3BzPGFueT4gPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IGdldEluKHN0YXRlLnZhbHVlcywgbmFtZSksXG4gICAgICAgIGVycm9yOiBnZXRJbihzdGF0ZS5lcnJvcnMsIG5hbWUpLFxuICAgICAgICB0b3VjaGVkOiAhIWdldEluKHN0YXRlLnRvdWNoZWQsIG5hbWUpLFxuICAgICAgICBpbml0aWFsVmFsdWU6IGdldEluKGluaXRpYWxWYWx1ZXMuY3VycmVudCwgbmFtZSksXG4gICAgICAgIGluaXRpYWxUb3VjaGVkOiAhIWdldEluKGluaXRpYWxUb3VjaGVkLmN1cnJlbnQsIG5hbWUpLFxuICAgICAgICBpbml0aWFsRXJyb3I6IGdldEluKGluaXRpYWxFcnJvcnMuY3VycmVudCwgbmFtZSksXG4gICAgICB9O1xuICAgIH0sXG4gICAgW3N0YXRlLmVycm9ycywgc3RhdGUudG91Y2hlZCwgc3RhdGUudmFsdWVzXVxuICApO1xuXG4gIGNvbnN0IGdldEZpZWxkSGVscGVycyA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgIChuYW1lOiBzdHJpbmcpOiBGaWVsZEhlbHBlclByb3BzPGFueT4gPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2V0VmFsdWU6ICh2YWx1ZTogYW55LCBzaG91bGRWYWxpZGF0ZT86IGJvb2xlYW4pID0+XG4gICAgICAgICAgc2V0RmllbGRWYWx1ZShuYW1lLCB2YWx1ZSwgc2hvdWxkVmFsaWRhdGUpLFxuICAgICAgICBzZXRUb3VjaGVkOiAodmFsdWU6IGJvb2xlYW4sIHNob3VsZFZhbGlkYXRlPzogYm9vbGVhbikgPT5cbiAgICAgICAgICBzZXRGaWVsZFRvdWNoZWQobmFtZSwgdmFsdWUsIHNob3VsZFZhbGlkYXRlKSxcbiAgICAgICAgc2V0RXJyb3I6ICh2YWx1ZTogYW55KSA9PiBzZXRGaWVsZEVycm9yKG5hbWUsIHZhbHVlKSxcbiAgICAgIH07XG4gICAgfSxcbiAgICBbc2V0RmllbGRWYWx1ZSwgc2V0RmllbGRUb3VjaGVkLCBzZXRGaWVsZEVycm9yXVxuICApO1xuXG4gIGNvbnN0IGdldEZpZWxkUHJvcHMgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAobmFtZU9yT3B0aW9ucyk6IEZpZWxkSW5wdXRQcm9wczxhbnk+ID0+IHtcbiAgICAgIGNvbnN0IGlzQW5PYmplY3QgPSBpc09iamVjdChuYW1lT3JPcHRpb25zKTtcbiAgICAgIGNvbnN0IG5hbWUgPSBpc0FuT2JqZWN0ID8gbmFtZU9yT3B0aW9ucy5uYW1lIDogbmFtZU9yT3B0aW9ucztcbiAgICAgIGNvbnN0IHZhbHVlU3RhdGUgPSBnZXRJbihzdGF0ZS52YWx1ZXMsIG5hbWUpO1xuXG4gICAgICBjb25zdCBmaWVsZDogRmllbGRJbnB1dFByb3BzPGFueT4gPSB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVN0YXRlLFxuICAgICAgICBvbkNoYW5nZTogaGFuZGxlQ2hhbmdlLFxuICAgICAgICBvbkJsdXI6IGhhbmRsZUJsdXIsXG4gICAgICB9O1xuICAgICAgaWYgKGlzQW5PYmplY3QpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlUHJvcCwgLy8gdmFsdWUgaXMgc3BlY2lhbCBmb3IgY2hlY2tib3hlc1xuICAgICAgICAgIGFzOiBpcyxcbiAgICAgICAgICBtdWx0aXBsZSxcbiAgICAgICAgfSA9IG5hbWVPck9wdGlvbnM7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICAgICAgICBpZiAodmFsdWVQcm9wID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZpZWxkLmNoZWNrZWQgPSAhIXZhbHVlU3RhdGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpZWxkLmNoZWNrZWQgPSAhIShcbiAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheSh2YWx1ZVN0YXRlKSAmJiB+dmFsdWVTdGF0ZS5pbmRleE9mKHZhbHVlUHJvcClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmaWVsZC52YWx1ZSA9IHZhbHVlUHJvcDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3JhZGlvJykge1xuICAgICAgICAgIGZpZWxkLmNoZWNrZWQgPSB2YWx1ZVN0YXRlID09PSB2YWx1ZVByb3A7XG4gICAgICAgICAgZmllbGQudmFsdWUgPSB2YWx1ZVByb3A7XG4gICAgICAgIH0gZWxzZSBpZiAoaXMgPT09ICdzZWxlY3QnICYmIG11bHRpcGxlKSB7XG4gICAgICAgICAgZmllbGQudmFsdWUgPSBmaWVsZC52YWx1ZSB8fCBbXTtcbiAgICAgICAgICBmaWVsZC5tdWx0aXBsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmaWVsZDtcbiAgICB9LFxuICAgIFtoYW5kbGVCbHVyLCBoYW5kbGVDaGFuZ2UsIHN0YXRlLnZhbHVlc11cbiAgKTtcblxuICBjb25zdCBkaXJ0eSA9IFJlYWN0LnVzZU1lbW8oXG4gICAgKCkgPT4gIWlzRXF1YWwoaW5pdGlhbFZhbHVlcy5jdXJyZW50LCBzdGF0ZS52YWx1ZXMpLFxuICAgIFtpbml0aWFsVmFsdWVzLmN1cnJlbnQsIHN0YXRlLnZhbHVlc11cbiAgKTtcblxuICBjb25zdCBpc1ZhbGlkID0gUmVhY3QudXNlTWVtbyhcbiAgICAoKSA9PlxuICAgICAgdHlwZW9mIGlzSW5pdGlhbFZhbGlkICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IGRpcnR5XG4gICAgICAgICAgPyBzdGF0ZS5lcnJvcnMgJiYgT2JqZWN0LmtleXMoc3RhdGUuZXJyb3JzKS5sZW5ndGggPT09IDBcbiAgICAgICAgICA6IGlzSW5pdGlhbFZhbGlkICE9PSBmYWxzZSAmJiBpc0Z1bmN0aW9uKGlzSW5pdGlhbFZhbGlkKVxuICAgICAgICAgID8gKGlzSW5pdGlhbFZhbGlkIGFzIChwcm9wczogRm9ybWlrQ29uZmlnPFZhbHVlcz4pID0+IGJvb2xlYW4pKHByb3BzKVxuICAgICAgICAgIDogKGlzSW5pdGlhbFZhbGlkIGFzIGJvb2xlYW4pXG4gICAgICAgIDogc3RhdGUuZXJyb3JzICYmIE9iamVjdC5rZXlzKHN0YXRlLmVycm9ycykubGVuZ3RoID09PSAwLFxuICAgIFtpc0luaXRpYWxWYWxpZCwgZGlydHksIHN0YXRlLmVycm9ycywgcHJvcHNdXG4gICk7XG5cbiAgY29uc3QgY3R4ID0ge1xuICAgIC4uLnN0YXRlLFxuICAgIGluaXRpYWxWYWx1ZXM6IGluaXRpYWxWYWx1ZXMuY3VycmVudCxcbiAgICBpbml0aWFsRXJyb3JzOiBpbml0aWFsRXJyb3JzLmN1cnJlbnQsXG4gICAgaW5pdGlhbFRvdWNoZWQ6IGluaXRpYWxUb3VjaGVkLmN1cnJlbnQsXG4gICAgaW5pdGlhbFN0YXR1czogaW5pdGlhbFN0YXR1cy5jdXJyZW50LFxuICAgIGhhbmRsZUJsdXIsXG4gICAgaGFuZGxlQ2hhbmdlLFxuICAgIGhhbmRsZVJlc2V0LFxuICAgIGhhbmRsZVN1Ym1pdCxcbiAgICByZXNldEZvcm0sXG4gICAgc2V0RXJyb3JzLFxuICAgIHNldEZvcm1pa1N0YXRlLFxuICAgIHNldEZpZWxkVG91Y2hlZCxcbiAgICBzZXRGaWVsZFZhbHVlLFxuICAgIHNldEZpZWxkRXJyb3IsXG4gICAgc2V0U3RhdHVzLFxuICAgIHNldFN1Ym1pdHRpbmcsXG4gICAgc2V0VG91Y2hlZCxcbiAgICBzZXRWYWx1ZXMsXG4gICAgc3VibWl0Rm9ybSxcbiAgICB2YWxpZGF0ZUZvcm06IHZhbGlkYXRlRm9ybVdpdGhIaWdoUHJpb3JpdHksXG4gICAgdmFsaWRhdGVGaWVsZCxcbiAgICBpc1ZhbGlkLFxuICAgIGRpcnR5LFxuICAgIHVucmVnaXN0ZXJGaWVsZCxcbiAgICByZWdpc3RlckZpZWxkLFxuICAgIGdldEZpZWxkUHJvcHMsXG4gICAgZ2V0RmllbGRNZXRhLFxuICAgIGdldEZpZWxkSGVscGVycyxcbiAgICB2YWxpZGF0ZU9uQmx1cixcbiAgICB2YWxpZGF0ZU9uQ2hhbmdlLFxuICAgIHZhbGlkYXRlT25Nb3VudCxcbiAgfTtcblxuICByZXR1cm4gY3R4O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gRm9ybWlrPFxuICBWYWx1ZXMgZXh0ZW5kcyBGb3JtaWtWYWx1ZXMgPSBGb3JtaWtWYWx1ZXMsXG4gIEV4dHJhUHJvcHMgPSB7fVxuPihwcm9wczogRm9ybWlrQ29uZmlnPFZhbHVlcz4gJiBFeHRyYVByb3BzKSB7XG4gIGNvbnN0IGZvcm1pa2JhZyA9IHVzZUZvcm1pazxWYWx1ZXM+KHByb3BzKTtcbiAgY29uc3QgeyBjb21wb25lbnQsIGNoaWxkcmVuLCByZW5kZXIsIGlubmVyUmVmIH0gPSBwcm9wcztcblxuICAvLyBUaGlzIGFsbG93cyBmb2xrcyB0byBwYXNzIGEgcmVmIHRvIDxGb3JtaWsgLz5cbiAgUmVhY3QudXNlSW1wZXJhdGl2ZUhhbmRsZShpbm5lclJlZiwgKCkgPT4gZm9ybWlrYmFnKTtcblxuICBpZiAoX19ERVZfXykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBpbnZhcmlhbnQoXG4gICAgICAgICFwcm9wcy5yZW5kZXIsXG4gICAgICAgIGA8Rm9ybWlrIHJlbmRlcj4gaGFzIGJlZW4gZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGZ1dHVyZSB2ZXJzaW9ucyBvZiBGb3JtaWsuIFBsZWFzZSB1c2UgYSBjaGlsZCBjYWxsYmFjayBmdW5jdGlvbiBpbnN0ZWFkLiBUbyBnZXQgcmlkIG9mIHRoaXMgd2FybmluZywgcmVwbGFjZSA8Rm9ybWlrIHJlbmRlcj17KHByb3BzKSA9PiAuLi59IC8+IHdpdGggPEZvcm1paz57KHByb3BzKSA9PiAuLi59PC9Gb3JtaWs+YFxuICAgICAgKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIH0sIFtdKTtcbiAgfVxuICByZXR1cm4gKFxuICAgIDxGb3JtaWtQcm92aWRlciB2YWx1ZT17Zm9ybWlrYmFnfT5cbiAgICAgIHtjb21wb25lbnRcbiAgICAgICAgPyBSZWFjdC5jcmVhdGVFbGVtZW50KGNvbXBvbmVudCBhcyBhbnksIGZvcm1pa2JhZylcbiAgICAgICAgOiByZW5kZXJcbiAgICAgICAgPyByZW5kZXIoZm9ybWlrYmFnKVxuICAgICAgICA6IGNoaWxkcmVuIC8vIGNoaWxkcmVuIGNvbWUgbGFzdCwgYWx3YXlzIGNhbGxlZFxuICAgICAgICA/IGlzRnVuY3Rpb24oY2hpbGRyZW4pXG4gICAgICAgICAgPyAoY2hpbGRyZW4gYXMgKGJhZzogRm9ybWlrUHJvcHM8VmFsdWVzPikgPT4gUmVhY3QuUmVhY3ROb2RlKShcbiAgICAgICAgICAgICAgZm9ybWlrYmFnIGFzIEZvcm1pa1Byb3BzPFZhbHVlcz5cbiAgICAgICAgICAgIClcbiAgICAgICAgICA6ICFpc0VtcHR5Q2hpbGRyZW4oY2hpbGRyZW4pXG4gICAgICAgICAgPyBSZWFjdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKVxuICAgICAgICAgIDogbnVsbFxuICAgICAgICA6IG51bGx9XG4gICAgPC9Gb3JtaWtQcm92aWRlcj5cbiAgKTtcbn1cblxuZnVuY3Rpb24gd2FybkFib3V0TWlzc2luZ0lkZW50aWZpZXIoe1xuICBodG1sQ29udGVudCxcbiAgZG9jdW1lbnRhdGlvbkFuY2hvckxpbmssXG4gIGhhbmRsZXJOYW1lLFxufToge1xuICBodG1sQ29udGVudDogc3RyaW5nO1xuICBkb2N1bWVudGF0aW9uQW5jaG9yTGluazogc3RyaW5nO1xuICBoYW5kbGVyTmFtZTogc3RyaW5nO1xufSkge1xuICBjb25zb2xlLndhcm4oXG4gICAgYFdhcm5pbmc6IEZvcm1payBjYWxsZWQgXFxgJHtoYW5kbGVyTmFtZX1cXGAsIGJ1dCB5b3UgZm9yZ290IHRvIHBhc3MgYW4gXFxgaWRcXGAgb3IgXFxgbmFtZVxcYCBhdHRyaWJ1dGUgdG8geW91ciBpbnB1dDpcbiAgICAke2h0bWxDb250ZW50fVxuICAgIEZvcm1payBjYW5ub3QgZGV0ZXJtaW5lIHdoaWNoIHZhbHVlIHRvIHVwZGF0ZS4gRm9yIG1vcmUgaW5mbyBzZWUgaHR0cHM6Ly9mb3JtaWsub3JnL2RvY3MvYXBpL2Zvcm1payMke2RvY3VtZW50YXRpb25BbmNob3JMaW5rfVxuICBgXG4gICk7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIFl1cCBWYWxpZGF0aW9uRXJyb3IgdG8gYSBtb3JlIHVzYWJsZSBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHl1cFRvRm9ybUVycm9yczxWYWx1ZXM+KHl1cEVycm9yOiBhbnkpOiBGb3JtaWtFcnJvcnM8VmFsdWVzPiB7XG4gIGxldCBlcnJvcnM6IEZvcm1pa0Vycm9yczxWYWx1ZXM+ID0ge307XG4gIGlmICh5dXBFcnJvci5pbm5lcikge1xuICAgIGlmICh5dXBFcnJvci5pbm5lci5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBzZXRJbihlcnJvcnMsIHl1cEVycm9yLnBhdGgsIHl1cEVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgICBmb3IgKGxldCBlcnIgb2YgeXVwRXJyb3IuaW5uZXIpIHtcbiAgICAgIGlmICghZ2V0SW4oZXJyb3JzLCBlcnIucGF0aCkpIHtcbiAgICAgICAgZXJyb3JzID0gc2V0SW4oZXJyb3JzLCBlcnIucGF0aCwgZXJyLm1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZXJyb3JzO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIGEgeXVwIHNjaGVtYS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlWXVwU2NoZW1hPFQgZXh0ZW5kcyBGb3JtaWtWYWx1ZXM+KFxuICB2YWx1ZXM6IFQsXG4gIHNjaGVtYTogYW55LFxuICBzeW5jOiBib29sZWFuID0gZmFsc2UsXG4gIGNvbnRleHQ6IGFueSA9IHt9XG4pOiBQcm9taXNlPFBhcnRpYWw8VD4+IHtcbiAgY29uc3QgdmFsaWRhdGVEYXRhOiBGb3JtaWtWYWx1ZXMgPSBwcmVwYXJlRGF0YUZvclZhbGlkYXRpb24odmFsdWVzKTtcbiAgcmV0dXJuIHNjaGVtYVtzeW5jID8gJ3ZhbGlkYXRlU3luYycgOiAndmFsaWRhdGUnXSh2YWxpZGF0ZURhdGEsIHtcbiAgICBhYm9ydEVhcmx5OiBmYWxzZSxcbiAgICBjb250ZXh0OiBjb250ZXh0LFxuICB9KTtcbn1cblxuLyoqXG4gKiBSZWN1cnNpdmVseSBwcmVwYXJlIHZhbHVlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZXBhcmVEYXRhRm9yVmFsaWRhdGlvbjxUIGV4dGVuZHMgRm9ybWlrVmFsdWVzPihcbiAgdmFsdWVzOiBUXG4pOiBGb3JtaWtWYWx1ZXMge1xuICBsZXQgZGF0YTogRm9ybWlrVmFsdWVzID0gQXJyYXkuaXNBcnJheSh2YWx1ZXMpID8gW10gOiB7fTtcbiAgZm9yIChsZXQgayBpbiB2YWx1ZXMpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlcywgaykpIHtcbiAgICAgIGNvbnN0IGtleSA9IFN0cmluZyhrKTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlc1trZXldKSA9PT0gdHJ1ZSkge1xuICAgICAgICBkYXRhW2tleV0gPSB2YWx1ZXNba2V5XS5tYXAoKHZhbHVlOiBhbnkpID0+IHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPT09IHRydWUgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmVwYXJlRGF0YUZvclZhbGlkYXRpb24odmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09ICcnID8gdmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZXNba2V5XSkpIHtcbiAgICAgICAgZGF0YVtrZXldID0gcHJlcGFyZURhdGFGb3JWYWxpZGF0aW9uKHZhbHVlc1trZXldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGFba2V5XSA9IHZhbHVlc1trZXldICE9PSAnJyA/IHZhbHVlc1trZXldIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBkZWVwbWVyZ2UgYXJyYXkgbWVyZ2luZyBhbGdvcml0aG1cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9LeWxlQU1hdGhld3MvZGVlcG1lcmdlI2NvbWJpbmUtYXJyYXlcbiAqL1xuZnVuY3Rpb24gYXJyYXlNZXJnZSh0YXJnZXQ6IGFueVtdLCBzb3VyY2U6IGFueVtdLCBvcHRpb25zOiBhbnkpOiBhbnlbXSB7XG4gIGNvbnN0IGRlc3RpbmF0aW9uID0gdGFyZ2V0LnNsaWNlKCk7XG5cbiAgc291cmNlLmZvckVhY2goZnVuY3Rpb24gbWVyZ2UoZTogYW55LCBpOiBudW1iZXIpIHtcbiAgICBpZiAodHlwZW9mIGRlc3RpbmF0aW9uW2ldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc3QgY2xvbmVSZXF1ZXN0ZWQgPSBvcHRpb25zLmNsb25lICE9PSBmYWxzZTtcbiAgICAgIGNvbnN0IHNob3VsZENsb25lID0gY2xvbmVSZXF1ZXN0ZWQgJiYgb3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdChlKTtcbiAgICAgIGRlc3RpbmF0aW9uW2ldID0gc2hvdWxkQ2xvbmVcbiAgICAgICAgPyBkZWVwbWVyZ2UoQXJyYXkuaXNBcnJheShlKSA/IFtdIDoge30sIGUsIG9wdGlvbnMpXG4gICAgICAgIDogZTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QoZSkpIHtcbiAgICAgIGRlc3RpbmF0aW9uW2ldID0gZGVlcG1lcmdlKHRhcmdldFtpXSwgZSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICh0YXJnZXQuaW5kZXhPZihlKSA9PT0gLTEpIHtcbiAgICAgIGRlc3RpbmF0aW9uLnB1c2goZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGRlc3RpbmF0aW9uO1xufVxuXG4vKiogUmV0dXJuIG11bHRpIHNlbGVjdCB2YWx1ZXMgYmFzZWQgb24gYW4gYXJyYXkgb2Ygb3B0aW9ucyAqL1xuZnVuY3Rpb24gZ2V0U2VsZWN0ZWRWYWx1ZXMob3B0aW9uczogYW55W10pIHtcbiAgcmV0dXJuIEFycmF5LmZyb20ob3B0aW9ucylcbiAgICAuZmlsdGVyKGVsID0+IGVsLnNlbGVjdGVkKVxuICAgIC5tYXAoZWwgPT4gZWwudmFsdWUpO1xufVxuXG4vKiogUmV0dXJuIHRoZSBuZXh0IHZhbHVlIGZvciBhIGNoZWNrYm94ICovXG5mdW5jdGlvbiBnZXRWYWx1ZUZvckNoZWNrYm94KFxuICBjdXJyZW50VmFsdWU6IHN0cmluZyB8IGFueVtdLFxuICBjaGVja2VkOiBib29sZWFuLFxuICB2YWx1ZVByb3A6IGFueVxuKSB7XG4gIC8vIElmIHRoZSBjdXJyZW50IHZhbHVlIHdhcyBhIGJvb2xlYW4sIHJldHVybiBhIGJvb2xlYW5cbiAgaWYgKHR5cGVvZiBjdXJyZW50VmFsdWUgPT09ICdib29sZWFuJykge1xuICAgIHJldHVybiBCb29sZWFuKGNoZWNrZWQpO1xuICB9XG5cbiAgLy8gSWYgdGhlIGN1cnJlbnRWYWx1ZSB3YXMgbm90IGEgYm9vbGVhbiB3ZSB3YW50IHRvIHJldHVybiBhbiBhcnJheVxuICBsZXQgY3VycmVudEFycmF5T2ZWYWx1ZXMgPSBbXTtcbiAgbGV0IGlzVmFsdWVJbkFycmF5ID0gZmFsc2U7XG4gIGxldCBpbmRleCA9IC0xO1xuXG4gIGlmICghQXJyYXkuaXNBcnJheShjdXJyZW50VmFsdWUpKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuICAgIGlmICghdmFsdWVQcm9wIHx8IHZhbHVlUHJvcCA9PSAndHJ1ZScgfHwgdmFsdWVQcm9wID09ICdmYWxzZScpIHtcbiAgICAgIHJldHVybiBCb29sZWFuKGNoZWNrZWQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJZiB0aGUgY3VycmVudCB2YWx1ZSBpcyBhbHJlYWR5IGFuIGFycmF5LCB1c2UgaXRcbiAgICBjdXJyZW50QXJyYXlPZlZhbHVlcyA9IGN1cnJlbnRWYWx1ZTtcbiAgICBpbmRleCA9IGN1cnJlbnRWYWx1ZS5pbmRleE9mKHZhbHVlUHJvcCk7XG4gICAgaXNWYWx1ZUluQXJyYXkgPSBpbmRleCA+PSAwO1xuICB9XG5cbiAgLy8gSWYgdGhlIGNoZWNrYm94IHdhcyBjaGVja2VkIGFuZCB0aGUgdmFsdWUgaXMgbm90IGFscmVhZHkgcHJlc2VudCBpbiB0aGUgYXJheSB3ZSB3YW50IHRvIGFkZCB0aGUgbmV3IHZhbHVlIHRvIHRoZSBhcnJheSBvZiB2YWx1ZXNcbiAgaWYgKGNoZWNrZWQgJiYgdmFsdWVQcm9wICYmICFpc1ZhbHVlSW5BcnJheSkge1xuICAgIHJldHVybiBjdXJyZW50QXJyYXlPZlZhbHVlcy5jb25jYXQodmFsdWVQcm9wKTtcbiAgfVxuXG4gIC8vIElmIHRoZSBjaGVja2JveCB3YXMgdW5jaGVja2VkIGFuZCB0aGUgdmFsdWUgaXMgbm90IGluIHRoZSBhcnJheSwgc2ltcGx5IHJldHVybiB0aGUgYWxyZWFkeSBleGlzdGluZyBhcnJheSBvZiB2YWx1ZXNcbiAgaWYgKCFpc1ZhbHVlSW5BcnJheSkge1xuICAgIHJldHVybiBjdXJyZW50QXJyYXlPZlZhbHVlcztcbiAgfVxuXG4gIC8vIElmIHRoZSBjaGVja2JveCB3YXMgdW5jaGVja2VkIGFuZCB0aGUgdmFsdWUgaXMgaW4gdGhlIGFycmF5LCByZW1vdmUgdGhlIHZhbHVlIGFuZCByZXR1cm4gdGhlIGFycmF5XG4gIHJldHVybiBjdXJyZW50QXJyYXlPZlZhbHVlc1xuICAgIC5zbGljZSgwLCBpbmRleClcbiAgICAuY29uY2F0KGN1cnJlbnRBcnJheU9mVmFsdWVzLnNsaWNlKGluZGV4ICsgMSkpO1xufVxuXG4vLyBSZWFjdCBjdXJyZW50bHkgdGhyb3dzIGEgd2FybmluZyB3aGVuIHVzaW5nIHVzZUxheW91dEVmZmVjdCBvbiB0aGUgc2VydmVyLlxuLy8gVG8gZ2V0IGFyb3VuZCBpdCwgd2UgY2FuIGNvbmRpdGlvbmFsbHkgdXNlRWZmZWN0IG9uIHRoZSBzZXJ2ZXIgKG5vLW9wKSBhbmRcbi8vIHVzZUxheW91dEVmZmVjdCBpbiB0aGUgYnJvd3Nlci5cbi8vIEBzZWUgaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZ2FlYXJvbi9lN2Q5N2NkZjM4YTI5MDc5MjRlYTEyZTRlYmRmM2M4NVxuY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9XG4gIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IFJlYWN0LnVzZUxheW91dEVmZmVjdFxuICAgIDogUmVhY3QudXNlRWZmZWN0O1xuXG5mdW5jdGlvbiB1c2VFdmVudENhbGxiYWNrPFQgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+IGFueT4oZm46IFQpOiBUIHtcbiAgY29uc3QgcmVmOiBhbnkgPSBSZWFjdC51c2VSZWYoZm4pO1xuXG4gIC8vIHdlIGNvcHkgYSByZWYgdG8gdGhlIGNhbGxiYWNrIHNjb3BlZCB0byB0aGUgY3VycmVudCBzdGF0ZS9wcm9wcyBvbiBlYWNoIHJlbmRlclxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IGZuO1xuICB9KTtcblxuICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKC4uLmFyZ3M6IGFueVtdKSA9PiByZWYuY3VycmVudC5hcHBseSh2b2lkIDAsIGFyZ3MpLFxuICAgIFtdXG4gICkgYXMgVDtcbn1cbiIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7XG4gIEZvcm1pa1Byb3BzLFxuICBHZW5lcmljRmllbGRIVE1MQXR0cmlidXRlcyxcbiAgRmllbGRNZXRhUHJvcHMsXG4gIEZpZWxkSGVscGVyUHJvcHMsXG4gIEZpZWxkSW5wdXRQcm9wcyxcbiAgRmllbGRWYWxpZGF0b3IsXG59IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgdXNlRm9ybWlrQ29udGV4dCB9IGZyb20gJy4vRm9ybWlrQ29udGV4dCc7XG5pbXBvcnQgeyBpc0Z1bmN0aW9uLCBpc0VtcHR5Q2hpbGRyZW4sIGlzT2JqZWN0IH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ3Rpbnktd2FybmluZyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmllbGRQcm9wczxWID0gYW55LCBGb3JtVmFsdWVzID0gYW55PiB7XG4gIGZpZWxkOiBGaWVsZElucHV0UHJvcHM8Vj47XG4gIGZvcm06IEZvcm1pa1Byb3BzPEZvcm1WYWx1ZXM+OyAvLyBpZiBwcGwgd2FudCB0byByZXN0cmljdCB0aGlzIGZvciBhIGdpdmVuIGZvcm0sIGxldCB0aGVtLlxuICBtZXRhOiBGaWVsZE1ldGFQcm9wczxWPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGaWVsZENvbmZpZzxWID0gYW55PiB7XG4gIC8qKlxuICAgKiBGaWVsZCBjb21wb25lbnQgdG8gcmVuZGVyLiBDYW4gZWl0aGVyIGJlIGEgc3RyaW5nIGxpa2UgJ3NlbGVjdCcgb3IgYSBjb21wb25lbnQuXG4gICAqL1xuICBjb21wb25lbnQ/OlxuICAgIHwgc3RyaW5nXG4gICAgfCBSZWFjdC5Db21wb25lbnRUeXBlPEZpZWxkUHJvcHM8Vj4+XG4gICAgfCBSZWFjdC5Db21wb25lbnRUeXBlXG4gICAgfCBSZWFjdC5Gb3J3YXJkUmVmRXhvdGljQ29tcG9uZW50PGFueT47XG5cbiAgLyoqXG4gICAqIENvbXBvbmVudCB0byByZW5kZXIuIENhbiBlaXRoZXIgYmUgYSBzdHJpbmcgZS5nLiAnc2VsZWN0JywgJ2lucHV0Jywgb3IgJ3RleHRhcmVhJywgb3IgYSBjb21wb25lbnQuXG4gICAqL1xuICBhcz86XG4gICAgfCBSZWFjdC5Db21wb25lbnRUeXBlPEZpZWxkUHJvcHM8Vj5bJ2ZpZWxkJ10+XG4gICAgfCBzdHJpbmdcbiAgICB8IFJlYWN0LkNvbXBvbmVudFR5cGVcbiAgICB8IFJlYWN0LkZvcndhcmRSZWZFeG90aWNDb21wb25lbnQ8YW55PjtcblxuICAvKipcbiAgICogUmVuZGVyIHByb3AgKHdvcmtzIGxpa2UgUmVhY3Qgcm91dGVyJ3MgPFJvdXRlIHJlbmRlcj17cHJvcHMgPT59IC8+KVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgcmVuZGVyPzogKHByb3BzOiBGaWVsZFByb3BzPFY+KSA9PiBSZWFjdC5SZWFjdE5vZGU7XG5cbiAgLyoqXG4gICAqIENoaWxkcmVuIHJlbmRlciBmdW5jdGlvbiA8RmllbGQgbmFtZT57cHJvcHMgPT4gLi4ufTwvRmllbGQ+KVxuICAgKi9cbiAgY2hpbGRyZW4/OiAoKHByb3BzOiBGaWVsZFByb3BzPFY+KSA9PiBSZWFjdC5SZWFjdE5vZGUpIHwgUmVhY3QuUmVhY3ROb2RlO1xuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBhIHNpbmdsZSBmaWVsZCB2YWx1ZSBpbmRlcGVuZGVudGx5XG4gICAqL1xuICB2YWxpZGF0ZT86IEZpZWxkVmFsaWRhdG9yO1xuXG4gIC8qKlxuICAgKiBGaWVsZCBuYW1lXG4gICAqL1xuICBuYW1lOiBzdHJpbmc7XG5cbiAgLyoqIEhUTUwgaW5wdXQgdHlwZSAqL1xuICB0eXBlPzogc3RyaW5nO1xuXG4gIC8qKiBGaWVsZCB2YWx1ZSAqL1xuICB2YWx1ZT86IGFueTtcblxuICAvKiogSW5uZXIgcmVmICovXG4gIGlubmVyUmVmPzogKGluc3RhbmNlOiBhbnkpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCB0eXBlIEZpZWxkQXR0cmlidXRlczxUPiA9IEdlbmVyaWNGaWVsZEhUTUxBdHRyaWJ1dGVzICZcbiAgRmllbGRDb25maWc8VD4gJlxuICBUICYgeyBuYW1lOiBzdHJpbmcgfTtcblxuZXhwb3J0IHR5cGUgRmllbGRIb29rQ29uZmlnPFQ+ID0gR2VuZXJpY0ZpZWxkSFRNTEF0dHJpYnV0ZXMgJiBGaWVsZENvbmZpZzxUPjtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUZpZWxkPFZhbCA9IGFueT4oXG4gIHByb3BzT3JGaWVsZE5hbWU6IHN0cmluZyB8IEZpZWxkSG9va0NvbmZpZzxWYWw+XG4pOiBbRmllbGRJbnB1dFByb3BzPFZhbD4sIEZpZWxkTWV0YVByb3BzPFZhbD4sIEZpZWxkSGVscGVyUHJvcHM8VmFsPl0ge1xuICBjb25zdCBmb3JtaWsgPSB1c2VGb3JtaWtDb250ZXh0KCk7XG4gIGNvbnN0IHtcbiAgICBnZXRGaWVsZFByb3BzLFxuICAgIGdldEZpZWxkTWV0YSxcbiAgICBnZXRGaWVsZEhlbHBlcnMsXG4gICAgcmVnaXN0ZXJGaWVsZCxcbiAgICB1bnJlZ2lzdGVyRmllbGQsXG4gIH0gPSBmb3JtaWs7XG5cbiAgY29uc3QgaXNBbk9iamVjdCA9IGlzT2JqZWN0KHByb3BzT3JGaWVsZE5hbWUpO1xuXG4gIC8vIE5vcm1hbGl6ZSBwcm9wc09yRmllbGROYW1lIHRvIEZpZWxkSG9va0NvbmZpZzxWYWw+XG4gIGNvbnN0IHByb3BzOiBGaWVsZEhvb2tDb25maWc8VmFsPiA9IGlzQW5PYmplY3RcbiAgICA/IChwcm9wc09yRmllbGROYW1lIGFzIEZpZWxkSG9va0NvbmZpZzxWYWw+KVxuICAgIDogeyBuYW1lOiBwcm9wc09yRmllbGROYW1lIGFzIHN0cmluZyB9O1xuXG4gIGNvbnN0IHsgbmFtZTogZmllbGROYW1lLCB2YWxpZGF0ZTogdmFsaWRhdGVGbiB9ID0gcHJvcHM7XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZmllbGROYW1lKSB7XG4gICAgICByZWdpc3RlckZpZWxkKGZpZWxkTmFtZSwge1xuICAgICAgICB2YWxpZGF0ZTogdmFsaWRhdGVGbixcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKGZpZWxkTmFtZSkge1xuICAgICAgICB1bnJlZ2lzdGVyRmllbGQoZmllbGROYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbcmVnaXN0ZXJGaWVsZCwgdW5yZWdpc3RlckZpZWxkLCBmaWVsZE5hbWUsIHZhbGlkYXRlRm5dKTtcblxuICBpZiAoX19ERVZfXykge1xuICAgIGludmFyaWFudChcbiAgICAgIGZvcm1payxcbiAgICAgICd1c2VGaWVsZCgpIC8gPEZpZWxkIC8+IG11c3QgYmUgdXNlZCB1bmRlcm5lYXRoIGEgPEZvcm1paz4gY29tcG9uZW50IG9yIHdpdGhGb3JtaWsoKSBoaWdoZXIgb3JkZXIgY29tcG9uZW50J1xuICAgICk7XG4gIH1cblxuICBpbnZhcmlhbnQoXG4gICAgZmllbGROYW1lLFxuICAgICdJbnZhbGlkIGZpZWxkIG5hbWUuIEVpdGhlciBwYXNzIGB1c2VGaWVsZGAgYSBzdHJpbmcgb3IgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYSBgbmFtZWAga2V5LidcbiAgKTtcblxuICByZXR1cm4gW1xuICAgIGdldEZpZWxkUHJvcHMocHJvcHMpLFxuICAgIGdldEZpZWxkTWV0YShmaWVsZE5hbWUpLFxuICAgIGdldEZpZWxkSGVscGVycyhmaWVsZE5hbWUpLFxuICBdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gRmllbGQoe1xuICB2YWxpZGF0ZSxcbiAgbmFtZSxcbiAgcmVuZGVyLFxuICBjaGlsZHJlbixcbiAgYXM6IGlzLCAvLyBgYXNgIGlzIHJlc2VydmVkIGluIHR5cGVzY3JpcHQgbG9sXG4gIGNvbXBvbmVudCxcbiAgLi4ucHJvcHNcbn06IEZpZWxkQXR0cmlidXRlczxhbnk+KSB7XG4gIGNvbnN0IHtcbiAgICB2YWxpZGF0ZTogX3ZhbGlkYXRlLFxuICAgIHZhbGlkYXRpb25TY2hlbWE6IF92YWxpZGF0aW9uU2NoZW1hLFxuXG4gICAgLi4uZm9ybWlrXG4gIH0gPSB1c2VGb3JtaWtDb250ZXh0KCk7XG5cbiAgaWYgKF9fREVWX18pIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICAhcmVuZGVyLFxuICAgICAgICBgPEZpZWxkIHJlbmRlcj4gaGFzIGJlZW4gZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGZ1dHVyZSB2ZXJzaW9ucyBvZiBGb3JtaWsuIFBsZWFzZSB1c2UgYSBjaGlsZCBjYWxsYmFjayBmdW5jdGlvbiBpbnN0ZWFkLiBUbyBnZXQgcmlkIG9mIHRoaXMgd2FybmluZywgcmVwbGFjZSA8RmllbGQgbmFtZT1cIiR7bmFtZX1cIiByZW5kZXI9eyh7ZmllbGQsIGZvcm19KSA9PiAuLi59IC8+IHdpdGggPEZpZWxkIG5hbWU9XCIke25hbWV9XCI+eyh7ZmllbGQsIGZvcm0sIG1ldGF9KSA9PiAuLi59PC9GaWVsZD5gXG4gICAgICApO1xuXG4gICAgICBpbnZhcmlhbnQoXG4gICAgICAgICEoaXMgJiYgY2hpbGRyZW4gJiYgaXNGdW5jdGlvbihjaGlsZHJlbikpLFxuICAgICAgICAnWW91IHNob3VsZCBub3QgdXNlIDxGaWVsZCBhcz4gYW5kIDxGaWVsZCBjaGlsZHJlbj4gYXMgYSBmdW5jdGlvbiBpbiB0aGUgc2FtZSA8RmllbGQ+IGNvbXBvbmVudDsgPEZpZWxkIGFzPiB3aWxsIGJlIGlnbm9yZWQuJ1xuICAgICAgKTtcblxuICAgICAgaW52YXJpYW50KFxuICAgICAgICAhKGNvbXBvbmVudCAmJiBjaGlsZHJlbiAmJiBpc0Z1bmN0aW9uKGNoaWxkcmVuKSksXG4gICAgICAgICdZb3Ugc2hvdWxkIG5vdCB1c2UgPEZpZWxkIGNvbXBvbmVudD4gYW5kIDxGaWVsZCBjaGlsZHJlbj4gYXMgYSBmdW5jdGlvbiBpbiB0aGUgc2FtZSA8RmllbGQ+IGNvbXBvbmVudDsgPEZpZWxkIGNvbXBvbmVudD4gd2lsbCBiZSBpZ25vcmVkLidcbiAgICAgICk7XG5cbiAgICAgIGludmFyaWFudChcbiAgICAgICAgIShyZW5kZXIgJiYgY2hpbGRyZW4gJiYgIWlzRW1wdHlDaGlsZHJlbihjaGlsZHJlbikpLFxuICAgICAgICAnWW91IHNob3VsZCBub3QgdXNlIDxGaWVsZCByZW5kZXI+IGFuZCA8RmllbGQgY2hpbGRyZW4+IGluIHRoZSBzYW1lIDxGaWVsZD4gY29tcG9uZW50OyA8RmllbGQgY2hpbGRyZW4+IHdpbGwgYmUgaWdub3JlZCdcbiAgICAgICk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICB9LCBbXSk7XG4gIH1cblxuICAvLyBSZWdpc3RlciBmaWVsZCBhbmQgZmllbGQtbGV2ZWwgdmFsaWRhdGlvbiB3aXRoIHBhcmVudCA8Rm9ybWlrPlxuICBjb25zdCB7IHJlZ2lzdGVyRmllbGQsIHVucmVnaXN0ZXJGaWVsZCB9ID0gZm9ybWlrO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJlZ2lzdGVyRmllbGQobmFtZSwge1xuICAgICAgdmFsaWRhdGU6IHZhbGlkYXRlLFxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB1bnJlZ2lzdGVyRmllbGQobmFtZSk7XG4gICAgfTtcbiAgfSwgW3JlZ2lzdGVyRmllbGQsIHVucmVnaXN0ZXJGaWVsZCwgbmFtZSwgdmFsaWRhdGVdKTtcbiAgY29uc3QgZmllbGQgPSBmb3JtaWsuZ2V0RmllbGRQcm9wcyh7IG5hbWUsIC4uLnByb3BzIH0pO1xuICBjb25zdCBtZXRhID0gZm9ybWlrLmdldEZpZWxkTWV0YShuYW1lKTtcbiAgY29uc3QgbGVnYWN5QmFnID0geyBmaWVsZCwgZm9ybTogZm9ybWlrIH07XG5cbiAgaWYgKHJlbmRlcikge1xuICAgIHJldHVybiByZW5kZXIoeyAuLi5sZWdhY3lCYWcsIG1ldGEgfSk7XG4gIH1cblxuICBpZiAoaXNGdW5jdGlvbihjaGlsZHJlbikpIHtcbiAgICByZXR1cm4gY2hpbGRyZW4oeyAuLi5sZWdhY3lCYWcsIG1ldGEgfSk7XG4gIH1cblxuICBpZiAoY29tcG9uZW50KSB7XG4gICAgLy8gVGhpcyBiZWhhdmlvciBpcyBiYWNrd2FyZHMgY29tcGF0IHdpdGggZWFybGllciBGb3JtaWsgMC45IHRvIDEueFxuICAgIGlmICh0eXBlb2YgY29tcG9uZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgeyBpbm5lclJlZiwgLi4ucmVzdCB9ID0gcHJvcHM7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgY29tcG9uZW50LFxuICAgICAgICB7IHJlZjogaW5uZXJSZWYsIC4uLmZpZWxkLCAuLi5yZXN0IH0sXG4gICAgICAgIGNoaWxkcmVuXG4gICAgICApO1xuICAgIH1cbiAgICAvLyBXZSBkb24ndCBwYXNzIGBtZXRhYCBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgY29tcG9uZW50LFxuICAgICAgeyBmaWVsZCwgZm9ybTogZm9ybWlrLCAuLi5wcm9wcyB9LFxuICAgICAgY2hpbGRyZW5cbiAgICApO1xuICB9XG5cbiAgLy8gZGVmYXVsdCB0byBpbnB1dCBoZXJlIHNvIHdlIGNhbiBjaGVjayBmb3IgYm90aCBgYXNgIGFuZCBgY2hpbGRyZW5gIGFib3ZlXG4gIGNvbnN0IGFzRWxlbWVudCA9IGlzIHx8ICdpbnB1dCc7XG5cbiAgaWYgKHR5cGVvZiBhc0VsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgeyBpbm5lclJlZiwgLi4ucmVzdCB9ID0gcHJvcHM7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBhc0VsZW1lbnQsXG4gICAgICB7IHJlZjogaW5uZXJSZWYsIC4uLmZpZWxkLCAuLi5yZXN0IH0sXG4gICAgICBjaGlsZHJlblxuICAgICk7XG4gIH1cblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChhc0VsZW1lbnQsIHsgLi4uZmllbGQsIC4uLnByb3BzIH0sIGNoaWxkcmVuKTtcbn1cbiIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUZvcm1pa0NvbnRleHQgfSBmcm9tICcuL0Zvcm1pa0NvbnRleHQnO1xuXG5leHBvcnQgdHlwZSBGb3JtaWtGb3JtUHJvcHMgPSBQaWNrPFxuICBSZWFjdC5Gb3JtSFRNTEF0dHJpYnV0ZXM8SFRNTEZvcm1FbGVtZW50PixcbiAgRXhjbHVkZTxcbiAgICBrZXlvZiBSZWFjdC5Gb3JtSFRNTEF0dHJpYnV0ZXM8SFRNTEZvcm1FbGVtZW50PixcbiAgICAnb25SZXNldCcgfCAnb25TdWJtaXQnXG4gID5cbj47XG5cbnR5cGUgRm9ybVByb3BzID0gUmVhY3QuQ29tcG9uZW50UHJvcHNXaXRob3V0UmVmPCdmb3JtJz47XG5cbi8vIEB0b2RvIHRlc3RzXG5leHBvcnQgY29uc3QgRm9ybSA9IFJlYWN0LmZvcndhcmRSZWY8SFRNTEZvcm1FbGVtZW50LCBGb3JtUHJvcHM+KFxuICAocHJvcHM6IEZvcm1pa0Zvcm1Qcm9wcywgcmVmKSA9PiB7XG4gICAgLy8gaU9TIG5lZWRzIGFuIFwiYWN0aW9uXCIgYXR0cmlidXRlIGZvciBuaWNlIGlucHV0OiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk0ODUxNjIvNDA2NzI1XG4gICAgLy8gV2UgZGVmYXVsdCB0aGUgYWN0aW9uIHRvIFwiI1wiIGluIGNhc2UgdGhlIHByZXZlbnREZWZhdWx0IGZhaWxzIChqdXN0IHVwZGF0ZXMgdGhlIFVSTCBoYXNoKVxuICAgIGNvbnN0IHsgYWN0aW9uLCAuLi5yZXN0IH0gPSBwcm9wcztcbiAgICBjb25zdCBfYWN0aW9uID0gYWN0aW9uID8/ICcjJztcbiAgICBjb25zdCB7IGhhbmRsZVJlc2V0LCBoYW5kbGVTdWJtaXQgfSA9IHVzZUZvcm1pa0NvbnRleHQoKTtcbiAgICByZXR1cm4gKFxuICAgICAgPGZvcm1cbiAgICAgICAgb25TdWJtaXQ9e2hhbmRsZVN1Ym1pdH1cbiAgICAgICAgcmVmPXtyZWZ9XG4gICAgICAgIG9uUmVzZXQ9e2hhbmRsZVJlc2V0fVxuICAgICAgICBhY3Rpb249e19hY3Rpb259XG4gICAgICAgIHsuLi5yZXN0fVxuICAgICAgLz5cbiAgICApO1xuICB9XG4pO1xuXG5Gb3JtLmRpc3BsYXlOYW1lID0gJ0Zvcm0nO1xuIiwiaW1wb3J0IGhvaXN0Tm9uUmVhY3RTdGF0aWNzIGZyb20gJ2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEZvcm1payB9IGZyb20gJy4vRm9ybWlrJztcbmltcG9ydCB7XG4gIEZvcm1pa0hlbHBlcnMsXG4gIEZvcm1pa1Byb3BzLFxuICBGb3JtaWtTaGFyZWRDb25maWcsXG4gIEZvcm1pa1ZhbHVlcyxcbiAgRm9ybWlrVG91Y2hlZCxcbiAgRm9ybWlrRXJyb3JzLFxufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICcuL3V0aWxzJztcblxuLyoqXG4gKiBTdGF0ZSwgaGFuZGxlcnMsIGFuZCBoZWxwZXJzIGluamVjdGVkIGFzIHByb3BzIGludG8gdGhlIHdyYXBwZWQgZm9ybSBjb21wb25lbnQuXG4gKiBVc2VkIHdpdGggd2l0aEZvcm1paygpXG4gKlxuICogQGRlcHJlY2F0ZWQgIFVzZSBgT3V0ZXJQcm9wcyAmIEZvcm1pa1Byb3BzPFZhbHVlcz5gIGluc3RlYWQuXG4gKi9cbmV4cG9ydCB0eXBlIEluamVjdGVkRm9ybWlrUHJvcHM8UHJvcHMsIFZhbHVlcz4gPSBQcm9wcyAmIEZvcm1pa1Byb3BzPFZhbHVlcz47XG5cbi8qKlxuICogRm9ybWlrIGhlbHBlcnMgKyB7IHByb3BzIH1cbiAqL1xuZXhwb3J0IHR5cGUgRm9ybWlrQmFnPFAsIFY+ID0geyBwcm9wczogUCB9ICYgRm9ybWlrSGVscGVyczxWPjtcblxuLyoqXG4gKiB3aXRoRm9ybWlrKCkgY29uZmlndXJhdGlvbiBvcHRpb25zLiBCYWNrd2FyZHMgY29tcGF0aWJsZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBXaXRoRm9ybWlrQ29uZmlnPFxuICBQcm9wcyxcbiAgVmFsdWVzIGV4dGVuZHMgRm9ybWlrVmFsdWVzID0gRm9ybWlrVmFsdWVzLFxuICBEZXByZWNhdGVkUGF5bG9hZCA9IFZhbHVlc1xuPiBleHRlbmRzIEZvcm1pa1NoYXJlZENvbmZpZzxQcm9wcz4ge1xuICAvKipcbiAgICogU2V0IHRoZSBkaXNwbGF5IG5hbWUgb2YgdGhlIGNvbXBvbmVudC4gVXNlZnVsIGZvciBSZWFjdCBEZXZUb29scy5cbiAgICovXG4gIGRpc3BsYXlOYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBTdWJtaXNzaW9uIGhhbmRsZXJcbiAgICovXG4gIGhhbmRsZVN1Ym1pdDogKHZhbHVlczogVmFsdWVzLCBmb3JtaWtCYWc6IEZvcm1pa0JhZzxQcm9wcywgVmFsdWVzPikgPT4gdm9pZDtcblxuICAvKipcbiAgICogTWFwIHByb3BzIHRvIHRoZSBmb3JtIHZhbHVlc1xuICAgKi9cbiAgbWFwUHJvcHNUb1ZhbHVlcz86IChwcm9wczogUHJvcHMpID0+IFZhbHVlcztcblxuICAvKipcbiAgICogTWFwIHByb3BzIHRvIHRoZSBmb3JtIHN0YXR1c1xuICAgKi9cbiAgbWFwUHJvcHNUb1N0YXR1cz86IChwcm9wczogUHJvcHMpID0+IGFueTtcblxuICAvKipcbiAgICogTWFwIHByb3BzIHRvIHRoZSBmb3JtIHRvdWNoZWQgc3RhdGVcbiAgICovXG4gIG1hcFByb3BzVG9Ub3VjaGVkPzogKHByb3BzOiBQcm9wcykgPT4gRm9ybWlrVG91Y2hlZDxWYWx1ZXM+O1xuXG4gIC8qKlxuICAgKiBNYXAgcHJvcHMgdG8gdGhlIGZvcm0gZXJyb3JzIHN0YXRlXG4gICAqL1xuICBtYXBQcm9wc1RvRXJyb3JzPzogKHByb3BzOiBQcm9wcykgPT4gRm9ybWlrRXJyb3JzPFZhbHVlcz47XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIGluIDAuOS4wIChidXQgbmVlZGVkIHRvIGJyZWFrIFRTIHR5cGVzKVxuICAgKi9cbiAgbWFwVmFsdWVzVG9QYXlsb2FkPzogKHZhbHVlczogVmFsdWVzKSA9PiBEZXByZWNhdGVkUGF5bG9hZDtcblxuICAvKipcbiAgICogQSBZdXAgU2NoZW1hIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgWXVwIHNjaGVtYVxuICAgKi9cbiAgdmFsaWRhdGlvblNjaGVtYT86IGFueSB8ICgocHJvcHM6IFByb3BzKSA9PiBhbnkpO1xuXG4gIC8qKlxuICAgKiBWYWxpZGF0aW9uIGZ1bmN0aW9uLiBNdXN0IHJldHVybiBhbiBlcnJvciBvYmplY3Qgb3IgcHJvbWlzZSB0aGF0XG4gICAqIHRocm93cyBhbiBlcnJvciBvYmplY3Qgd2hlcmUgdGhhdCBvYmplY3Qga2V5cyBtYXAgdG8gY29ycmVzcG9uZGluZyB2YWx1ZS5cbiAgICovXG4gIHZhbGlkYXRlPzogKHZhbHVlczogVmFsdWVzLCBwcm9wczogUHJvcHMpID0+IHZvaWQgfCBvYmplY3QgfCBQcm9taXNlPGFueT47XG59XG5cbmV4cG9ydCB0eXBlIENvbXBvc2l0ZUNvbXBvbmVudDxQPiA9XG4gIHwgUmVhY3QuQ29tcG9uZW50Q2xhc3M8UD5cbiAgfCBSZWFjdC5TdGF0ZWxlc3NDb21wb25lbnQ8UD47XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcG9uZW50RGVjb3JhdG9yPFRPd25Qcm9wcywgVE1lcmdlZFByb3BzPiB7XG4gIChjb21wb25lbnQ6IENvbXBvc2l0ZUNvbXBvbmVudDxUTWVyZ2VkUHJvcHM+KTogUmVhY3QuQ29tcG9uZW50VHlwZTxUT3duUHJvcHM+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEluZmVyYWJsZUNvbXBvbmVudERlY29yYXRvcjxUT3duUHJvcHM+IHtcbiAgPFQgZXh0ZW5kcyBDb21wb3NpdGVDb21wb25lbnQ8VE93blByb3BzPj4oY29tcG9uZW50OiBUKTogVDtcbn1cblxuLyoqXG4gKiBBIHB1YmxpYyBoaWdoZXItb3JkZXIgY29tcG9uZW50IHRvIGFjY2VzcyB0aGUgaW1wZXJhdGl2ZSBBUElcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdpdGhGb3JtaWs8XG4gIE91dGVyUHJvcHMgZXh0ZW5kcyBvYmplY3QsXG4gIFZhbHVlcyBleHRlbmRzIEZvcm1pa1ZhbHVlcyxcbiAgUGF5bG9hZCA9IFZhbHVlc1xuPih7XG4gIG1hcFByb3BzVG9WYWx1ZXMgPSAodmFuaWxsYVByb3BzOiBPdXRlclByb3BzKTogVmFsdWVzID0+IHtcbiAgICBsZXQgdmFsOiBWYWx1ZXMgPSB7fSBhcyBWYWx1ZXM7XG4gICAgZm9yIChsZXQgayBpbiB2YW5pbGxhUHJvcHMpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdmFuaWxsYVByb3BzLmhhc093blByb3BlcnR5KGspICYmXG4gICAgICAgIHR5cGVvZiB2YW5pbGxhUHJvcHNba10gIT09ICdmdW5jdGlvbidcbiAgICAgICkge1xuICAgICAgICAvLyBAdG9kbyBUeXBlU2NyaXB0IGZpeFxuICAgICAgICAodmFsIGFzIGFueSlba10gPSB2YW5pbGxhUHJvcHNba107XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWwgYXMgVmFsdWVzO1xuICB9LFxuICAuLi5jb25maWdcbn06IFdpdGhGb3JtaWtDb25maWc8T3V0ZXJQcm9wcywgVmFsdWVzLCBQYXlsb2FkPik6IENvbXBvbmVudERlY29yYXRvcjxcbiAgT3V0ZXJQcm9wcyxcbiAgT3V0ZXJQcm9wcyAmIEZvcm1pa1Byb3BzPFZhbHVlcz5cbj4ge1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlRm9ybWlrKFxuICAgIENvbXBvbmVudDogQ29tcG9zaXRlQ29tcG9uZW50PE91dGVyUHJvcHMgJiBGb3JtaWtQcm9wczxWYWx1ZXM+PlxuICApOiBSZWFjdC5Db21wb25lbnRDbGFzczxPdXRlclByb3BzPiB7XG4gICAgY29uc3QgY29tcG9uZW50RGlzcGxheU5hbWUgPVxuICAgICAgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8XG4gICAgICBDb21wb25lbnQubmFtZSB8fFxuICAgICAgKENvbXBvbmVudC5jb25zdHJ1Y3RvciAmJiBDb21wb25lbnQuY29uc3RydWN0b3IubmFtZSkgfHxcbiAgICAgICdDb21wb25lbnQnO1xuICAgIC8qKlxuICAgICAqIFdlIG5lZWQgdG8gdXNlIGNsb3N1cmVzIGhlcmUgZm9yIHRvIHByb3ZpZGUgdGhlIHdyYXBwZWQgY29tcG9uZW50J3MgcHJvcHMgdG9cbiAgICAgKiB0aGUgcmVzcGVjdGl2ZSB3aXRoRm9ybWlrIGNvbmZpZyBtZXRob2RzLlxuICAgICAqL1xuICAgIGNsYXNzIEMgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8T3V0ZXJQcm9wcywge30+IHtcbiAgICAgIHN0YXRpYyBkaXNwbGF5TmFtZSA9IGBXaXRoRm9ybWlrKCR7Y29tcG9uZW50RGlzcGxheU5hbWV9KWA7XG5cbiAgICAgIHZhbGlkYXRlID0gKHZhbHVlczogVmFsdWVzKTogdm9pZCB8IG9iamVjdCB8IFByb21pc2U8YW55PiA9PiB7XG4gICAgICAgIHJldHVybiBjb25maWcudmFsaWRhdGUhKHZhbHVlcywgdGhpcy5wcm9wcyk7XG4gICAgICB9O1xuXG4gICAgICB2YWxpZGF0aW9uU2NoZW1hID0gKCkgPT4ge1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihjb25maWcudmFsaWRhdGlvblNjaGVtYSlcbiAgICAgICAgICA/IGNvbmZpZy52YWxpZGF0aW9uU2NoZW1hISh0aGlzLnByb3BzKVxuICAgICAgICAgIDogY29uZmlnLnZhbGlkYXRpb25TY2hlbWE7XG4gICAgICB9O1xuXG4gICAgICBoYW5kbGVTdWJtaXQgPSAodmFsdWVzOiBWYWx1ZXMsIGFjdGlvbnM6IEZvcm1pa0hlbHBlcnM8VmFsdWVzPikgPT4ge1xuICAgICAgICByZXR1cm4gY29uZmlnLmhhbmRsZVN1Ym1pdCh2YWx1ZXMsIHtcbiAgICAgICAgICAuLi5hY3Rpb25zLFxuICAgICAgICAgIHByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogSnVzdCBhdm9pZGluZyBhIHJlbmRlciBjYWxsYmFjayBmb3IgcGVyZiBoZXJlXG4gICAgICAgKi9cbiAgICAgIHJlbmRlckZvcm1Db21wb25lbnQgPSAoZm9ybWlrUHJvcHM6IEZvcm1pa1Byb3BzPFZhbHVlcz4pID0+IHtcbiAgICAgICAgcmV0dXJuIDxDb21wb25lbnQgey4uLnRoaXMucHJvcHN9IHsuLi5mb3JtaWtQcm9wc30gLz47XG4gICAgICB9O1xuXG4gICAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgY2hpbGRyZW4sIC4uLnByb3BzIH0gPSB0aGlzLnByb3BzIGFzIGFueTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICA8Rm9ybWlrXG4gICAgICAgICAgICB7Li4ucHJvcHN9XG4gICAgICAgICAgICB7Li4uY29uZmlnfVxuICAgICAgICAgICAgdmFsaWRhdGU9e2NvbmZpZy52YWxpZGF0ZSAmJiB0aGlzLnZhbGlkYXRlfVxuICAgICAgICAgICAgdmFsaWRhdGlvblNjaGVtYT17Y29uZmlnLnZhbGlkYXRpb25TY2hlbWEgJiYgdGhpcy52YWxpZGF0aW9uU2NoZW1hfVxuICAgICAgICAgICAgaW5pdGlhbFZhbHVlcz17bWFwUHJvcHNUb1ZhbHVlcyh0aGlzLnByb3BzKX1cbiAgICAgICAgICAgIGluaXRpYWxTdGF0dXM9e1xuICAgICAgICAgICAgICBjb25maWcubWFwUHJvcHNUb1N0YXR1cyAmJiBjb25maWcubWFwUHJvcHNUb1N0YXR1cyh0aGlzLnByb3BzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5pdGlhbEVycm9ycz17XG4gICAgICAgICAgICAgIGNvbmZpZy5tYXBQcm9wc1RvRXJyb3JzICYmIGNvbmZpZy5tYXBQcm9wc1RvRXJyb3JzKHRoaXMucHJvcHMpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbml0aWFsVG91Y2hlZD17XG4gICAgICAgICAgICAgIGNvbmZpZy5tYXBQcm9wc1RvVG91Y2hlZCAmJiBjb25maWcubWFwUHJvcHNUb1RvdWNoZWQodGhpcy5wcm9wcylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uU3VibWl0PXt0aGlzLmhhbmRsZVN1Ym1pdCBhcyBhbnl9XG4gICAgICAgICAgICBjaGlsZHJlbj17dGhpcy5yZW5kZXJGb3JtQ29tcG9uZW50fVxuICAgICAgICAgIC8+XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKFxuICAgICAgQyxcbiAgICAgIENvbXBvbmVudCBhcyBSZWFjdC5Db21wb25lbnRDbGFzczxPdXRlclByb3BzICYgRm9ybWlrUHJvcHM8VmFsdWVzPj4gLy8gY2FzdCB0eXBlIHRvIENvbXBvbmVudENsYXNzIChldmVuIGlmIFNGQylcbiAgICApIGFzIFJlYWN0LkNvbXBvbmVudENsYXNzPE91dGVyUHJvcHM+O1xuICB9O1xufVxuIiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IGhvaXN0Tm9uUmVhY3RTdGF0aWNzIGZyb20gJ2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzJztcblxuaW1wb3J0IHsgRm9ybWlrQ29udGV4dFR5cGUgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IEZvcm1pa0NvbnN1bWVyIH0gZnJvbSAnLi9Gb3JtaWtDb250ZXh0JztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAndGlueS13YXJuaW5nJztcblxuLyoqXG4gKiBDb25uZWN0IGFueSBjb21wb25lbnQgdG8gRm9ybWlrIGNvbnRleHQsIGFuZCBpbmplY3QgYXMgYSBwcm9wIGNhbGxlZCBgZm9ybWlrYDtcbiAqIEBwYXJhbSBDb21wIFJlYWN0IENvbXBvbmVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29ubmVjdDxPdXRlclByb3BzLCBWYWx1ZXMgPSB7fT4oXG4gIENvbXA6IFJlYWN0LkNvbXBvbmVudFR5cGU8T3V0ZXJQcm9wcyAmIHsgZm9ybWlrOiBGb3JtaWtDb250ZXh0VHlwZTxWYWx1ZXM+IH0+XG4pIHtcbiAgY29uc3QgQzogUmVhY3QuRkM8T3V0ZXJQcm9wcz4gPSAocHJvcHM6IE91dGVyUHJvcHMpID0+IChcbiAgICA8Rm9ybWlrQ29uc3VtZXI+XG4gICAgICB7Zm9ybWlrID0+IHtcbiAgICAgICAgaW52YXJpYW50KFxuICAgICAgICAgICEhZm9ybWlrLFxuICAgICAgICAgIGBGb3JtaWsgY29udGV4dCBpcyB1bmRlZmluZWQsIHBsZWFzZSB2ZXJpZnkgeW91IGFyZSByZW5kZXJpbmcgPEZvcm0+LCA8RmllbGQ+LCA8RmFzdEZpZWxkPiwgPEZpZWxkQXJyYXk+LCBvciB5b3VyIGN1c3RvbSBjb250ZXh0LXVzaW5nIGNvbXBvbmVudCBhcyBhIGNoaWxkIG9mIGEgPEZvcm1paz4gY29tcG9uZW50LiBDb21wb25lbnQgbmFtZTogJHtDb21wLm5hbWV9YFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gPENvbXAgey4uLnByb3BzfSBmb3JtaWs9e2Zvcm1pa30gLz47XG4gICAgICB9fVxuICAgIDwvRm9ybWlrQ29uc3VtZXI+XG4gICk7XG4gIGNvbnN0IGNvbXBvbmVudERpc3BsYXlOYW1lID1cbiAgICBDb21wLmRpc3BsYXlOYW1lIHx8XG4gICAgQ29tcC5uYW1lIHx8XG4gICAgKENvbXAuY29uc3RydWN0b3IgJiYgQ29tcC5jb25zdHJ1Y3Rvci5uYW1lKSB8fFxuICAgICdDb21wb25lbnQnO1xuXG4gIC8vIEFzc2lnbiBDb21wIHRvIEMuV3JhcHBlZENvbXBvbmVudCBzbyB3ZSBjYW4gYWNjZXNzIHRoZSBpbm5lciBjb21wb25lbnQgaW4gdGVzdHNcbiAgLy8gRm9yIGV4YW1wbGUsIDxGaWVsZC5XcmFwcGVkQ29tcG9uZW50IC8+IGdldHMgdXMgPEZpZWxkSW5uZXIvPlxuICAoQyBhcyBSZWFjdC5GQzxPdXRlclByb3BzPiAmIHtcbiAgICBXcmFwcGVkQ29tcG9uZW50OiBSZWFjdC5SZWFjdE5vZGU7XG4gIH0pLldyYXBwZWRDb21wb25lbnQgPSBDb21wO1xuXG4gIEMuZGlzcGxheU5hbWUgPSBgRm9ybWlrQ29ubmVjdCgke2NvbXBvbmVudERpc3BsYXlOYW1lfSlgO1xuXG4gIHJldHVybiBob2lzdE5vblJlYWN0U3RhdGljcyhcbiAgICBDLFxuICAgIENvbXAgYXMgUmVhY3QuQ29tcG9uZW50Q2xhc3M8XG4gICAgICBPdXRlclByb3BzICYgeyBmb3JtaWs6IEZvcm1pa0NvbnRleHRUeXBlPFZhbHVlcz4gfVxuICAgID4gLy8gY2FzdCB0eXBlIHRvIENvbXBvbmVudENsYXNzIChldmVuIGlmIFNGQylcbiAgKSBhcyBSZWFjdC5Db21wb25lbnRUeXBlPE91dGVyUHJvcHM+O1xufVxuIiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IGNsb25lRGVlcCBmcm9tICdsb2Rhc2gvY2xvbmVEZWVwJztcbmltcG9ydCB7IGNvbm5lY3QgfSBmcm9tICcuL2Nvbm5lY3QnO1xuaW1wb3J0IHtcbiAgRm9ybWlrQ29udGV4dFR5cGUsXG4gIEZvcm1pa1N0YXRlLFxuICBTaGFyZWRSZW5kZXJQcm9wcyxcbiAgRm9ybWlrUHJvcHMsXG59IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHtcbiAgZ2V0SW4sXG4gIGlzRW1wdHlDaGlsZHJlbixcbiAgaXNGdW5jdGlvbixcbiAgc2V0SW4sXG4gIGlzRW1wdHlBcnJheSxcbn0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgaXNFcXVhbCBmcm9tICdyZWFjdC1mYXN0LWNvbXBhcmUnO1xuXG5leHBvcnQgdHlwZSBGaWVsZEFycmF5UmVuZGVyUHJvcHMgPSBBcnJheUhlbHBlcnMgJiB7XG4gIGZvcm06IEZvcm1pa1Byb3BzPGFueT47XG4gIG5hbWU6IHN0cmluZztcbn07XG5cbmV4cG9ydCB0eXBlIEZpZWxkQXJyYXlDb25maWcgPSB7XG4gIC8qKiBSZWFsbHkgdGhlIHBhdGggdG8gdGhlIGFycmF5IGZpZWxkIHRvIGJlIHVwZGF0ZWQgKi9cbiAgbmFtZTogc3RyaW5nO1xuICAvKiogU2hvdWxkIGZpZWxkIGFycmF5IHZhbGlkYXRlIHRoZSBmb3JtIEFGVEVSIGFycmF5IHVwZGF0ZXMvY2hhbmdlcz8gKi9cbiAgdmFsaWRhdGVPbkNoYW5nZT86IGJvb2xlYW47XG59ICYgU2hhcmVkUmVuZGVyUHJvcHM8RmllbGRBcnJheVJlbmRlclByb3BzPjtcbmV4cG9ydCBpbnRlcmZhY2UgQXJyYXlIZWxwZXJzIHtcbiAgLyoqIEltcGVyYXRpdmVseSBhZGQgYSB2YWx1ZSB0byB0aGUgZW5kIG9mIGFuIGFycmF5ICovXG4gIHB1c2g6IChvYmo6IGFueSkgPT4gdm9pZDtcbiAgLyoqIEN1cnJpZWQgZm4gdG8gYWRkIGEgdmFsdWUgdG8gdGhlIGVuZCBvZiBhbiBhcnJheSAqL1xuICBoYW5kbGVQdXNoOiAob2JqOiBhbnkpID0+ICgpID0+IHZvaWQ7XG4gIC8qKiBJbXBlcmF0aXZlbHkgc3dhcCB0d28gdmFsdWVzIGluIGFuIGFycmF5ICovXG4gIHN3YXA6IChpbmRleEE6IG51bWJlciwgaW5kZXhCOiBudW1iZXIpID0+IHZvaWQ7XG4gIC8qKiBDdXJyaWVkIGZuIHRvIHN3YXAgdHdvIHZhbHVlcyBpbiBhbiBhcnJheSAqL1xuICBoYW5kbGVTd2FwOiAoaW5kZXhBOiBudW1iZXIsIGluZGV4QjogbnVtYmVyKSA9PiAoKSA9PiB2b2lkO1xuICAvKiogSW1wZXJhdGl2ZWx5IG1vdmUgYW4gZWxlbWVudCBpbiBhbiBhcnJheSB0byBhbm90aGVyIGluZGV4ICovXG4gIG1vdmU6IChmcm9tOiBudW1iZXIsIHRvOiBudW1iZXIpID0+IHZvaWQ7XG4gIC8qKiBJbXBlcmF0aXZlbHkgbW92ZSBhbiBlbGVtZW50IGluIGFuIGFycmF5IHRvIGFub3RoZXIgaW5kZXggKi9cbiAgaGFuZGxlTW92ZTogKGZyb206IG51bWJlciwgdG86IG51bWJlcikgPT4gKCkgPT4gdm9pZDtcbiAgLyoqIEltcGVyYXRpdmVseSBpbnNlcnQgYW4gZWxlbWVudCBhdCBhIGdpdmVuIGluZGV4IGludG8gdGhlIGFycmF5ICovXG4gIGluc2VydDogKGluZGV4OiBudW1iZXIsIHZhbHVlOiBhbnkpID0+IHZvaWQ7XG4gIC8qKiBDdXJyaWVkIGZuIHRvIGluc2VydCBhbiBlbGVtZW50IGF0IGEgZ2l2ZW4gaW5kZXggaW50byB0aGUgYXJyYXkgKi9cbiAgaGFuZGxlSW5zZXJ0OiAoaW5kZXg6IG51bWJlciwgdmFsdWU6IGFueSkgPT4gKCkgPT4gdm9pZDtcbiAgLyoqIEltcGVyYXRpdmVseSByZXBsYWNlIGEgdmFsdWUgYXQgYW4gaW5kZXggb2YgYW4gYXJyYXkgICovXG4gIHJlcGxhY2U6IChpbmRleDogbnVtYmVyLCB2YWx1ZTogYW55KSA9PiB2b2lkO1xuICAvKiogQ3VycmllZCBmbiB0byByZXBsYWNlIGFuIGVsZW1lbnQgYXQgYSBnaXZlbiBpbmRleCBpbnRvIHRoZSBhcnJheSAqL1xuICBoYW5kbGVSZXBsYWNlOiAoaW5kZXg6IG51bWJlciwgdmFsdWU6IGFueSkgPT4gKCkgPT4gdm9pZDtcbiAgLyoqIEltcGVyYXRpdmVseSBhZGQgYW4gZWxlbWVudCB0byB0aGUgYmVnaW5uaW5nIG9mIGFuIGFycmF5IGFuZCByZXR1cm4gaXRzIGxlbmd0aCAqL1xuICB1bnNoaWZ0OiAodmFsdWU6IGFueSkgPT4gbnVtYmVyO1xuICAvKiogQ3VycmllZCBmbiB0byBhZGQgYW4gZWxlbWVudCB0byB0aGUgYmVnaW5uaW5nIG9mIGFuIGFycmF5ICovXG4gIGhhbmRsZVVuc2hpZnQ6ICh2YWx1ZTogYW55KSA9PiAoKSA9PiB2b2lkO1xuICAvKiogQ3VycmllZCBmbiB0byByZW1vdmUgYW4gZWxlbWVudCBhdCBhbiBpbmRleCBvZiBhbiBhcnJheSAqL1xuICBoYW5kbGVSZW1vdmU6IChpbmRleDogbnVtYmVyKSA9PiAoKSA9PiB2b2lkO1xuICAvKiogQ3VycmllZCBmbiB0byByZW1vdmUgYSB2YWx1ZSBmcm9tIHRoZSBlbmQgb2YgdGhlIGFycmF5ICovXG4gIGhhbmRsZVBvcDogKCkgPT4gKCkgPT4gdm9pZDtcbiAgLyoqIEltcGVyYXRpdmVseSByZW1vdmUgYW5kIGVsZW1lbnQgYXQgYW4gaW5kZXggb2YgYW4gYXJyYXkgKi9cbiAgcmVtb3ZlPFQ+KGluZGV4OiBudW1iZXIpOiBUIHwgdW5kZWZpbmVkO1xuICAvKiogSW1wZXJhdGl2ZWx5IHJlbW92ZSBhbmQgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGVuZCBvZiB0aGUgYXJyYXkgKi9cbiAgcG9wPFQ+KCk6IFQgfCB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogU29tZSBhcnJheSBoZWxwZXJzIVxuICovXG5leHBvcnQgY29uc3QgbW92ZSA9IChhcnJheTogYW55W10sIGZyb206IG51bWJlciwgdG86IG51bWJlcikgPT4ge1xuICBjb25zdCBjb3B5ID0gY29weUFycmF5TGlrZShhcnJheSk7XG4gIGNvbnN0IHZhbHVlID0gY29weVtmcm9tXTtcbiAgY29weS5zcGxpY2UoZnJvbSwgMSk7XG4gIGNvcHkuc3BsaWNlKHRvLCAwLCB2YWx1ZSk7XG4gIHJldHVybiBjb3B5O1xufTtcblxuZXhwb3J0IGNvbnN0IHN3YXAgPSAoXG4gIGFycmF5TGlrZTogQXJyYXlMaWtlPGFueT4sXG4gIGluZGV4QTogbnVtYmVyLFxuICBpbmRleEI6IG51bWJlclxuKSA9PiB7XG4gIGNvbnN0IGNvcHkgPSBjb3B5QXJyYXlMaWtlKGFycmF5TGlrZSk7XG4gIGNvbnN0IGEgPSBjb3B5W2luZGV4QV07XG4gIGNvcHlbaW5kZXhBXSA9IGNvcHlbaW5kZXhCXTtcbiAgY29weVtpbmRleEJdID0gYTtcbiAgcmV0dXJuIGNvcHk7XG59O1xuXG5leHBvcnQgY29uc3QgaW5zZXJ0ID0gKFxuICBhcnJheUxpa2U6IEFycmF5TGlrZTxhbnk+LFxuICBpbmRleDogbnVtYmVyLFxuICB2YWx1ZTogYW55XG4pID0+IHtcbiAgY29uc3QgY29weSA9IGNvcHlBcnJheUxpa2UoYXJyYXlMaWtlKTtcbiAgY29weS5zcGxpY2UoaW5kZXgsIDAsIHZhbHVlKTtcbiAgcmV0dXJuIGNvcHk7XG59O1xuXG5leHBvcnQgY29uc3QgcmVwbGFjZSA9IChcbiAgYXJyYXlMaWtlOiBBcnJheUxpa2U8YW55PixcbiAgaW5kZXg6IG51bWJlcixcbiAgdmFsdWU6IGFueVxuKSA9PiB7XG4gIGNvbnN0IGNvcHkgPSBjb3B5QXJyYXlMaWtlKGFycmF5TGlrZSk7XG4gIGNvcHlbaW5kZXhdID0gdmFsdWU7XG4gIHJldHVybiBjb3B5O1xufTtcblxuY29uc3QgY29weUFycmF5TGlrZSA9IChhcnJheUxpa2U6IEFycmF5TGlrZTxhbnk+KSA9PiB7XG4gIGlmICghYXJyYXlMaWtlKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXlMaWtlKSkge1xuICAgIHJldHVybiBbLi4uYXJyYXlMaWtlXTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBtYXhJbmRleCA9IE9iamVjdC5rZXlzKGFycmF5TGlrZSlcbiAgICAgIC5tYXAoa2V5ID0+IHBhcnNlSW50KGtleSkpXG4gICAgICAucmVkdWNlKChtYXgsIGVsKSA9PiAoZWwgPiBtYXggPyBlbCA6IG1heCksIDApO1xuICAgIHJldHVybiBBcnJheS5mcm9tKHsgLi4uYXJyYXlMaWtlLCBsZW5ndGg6IG1heEluZGV4ICsgMSB9KTtcbiAgfVxufTtcblxuY2xhc3MgRmllbGRBcnJheUlubmVyPFZhbHVlcyA9IHt9PiBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxcbiAgRmllbGRBcnJheUNvbmZpZyAmIHsgZm9ybWlrOiBGb3JtaWtDb250ZXh0VHlwZTxWYWx1ZXM+IH0sXG4gIHt9XG4+IHtcbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICB2YWxpZGF0ZU9uQ2hhbmdlOiB0cnVlLFxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBGaWVsZEFycmF5Q29uZmlnICYgeyBmb3JtaWs6IEZvcm1pa0NvbnRleHRUeXBlPFZhbHVlcz4gfSkge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICAvLyBXZSBuZWVkIFR5cGVTY3JpcHQgZ2VuZXJpY3Mgb24gdGhlc2UsIHNvIHdlJ2xsIGJpbmQgdGhlbSBpbiB0aGUgY29uc3RydWN0b3JcbiAgICAvLyBAdG9kbyBGaXggVFMgMy4yLjFcbiAgICB0aGlzLnJlbW92ZSA9IHRoaXMucmVtb3ZlLmJpbmQodGhpcykgYXMgYW55O1xuICAgIHRoaXMucG9wID0gdGhpcy5wb3AuYmluZCh0aGlzKSBhcyBhbnk7XG4gIH1cblxuICBjb21wb25lbnREaWRVcGRhdGUoXG4gICAgcHJldlByb3BzOiBGaWVsZEFycmF5Q29uZmlnICYgeyBmb3JtaWs6IEZvcm1pa0NvbnRleHRUeXBlPFZhbHVlcz4gfVxuICApIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLnByb3BzLnZhbGlkYXRlT25DaGFuZ2UgJiZcbiAgICAgIHRoaXMucHJvcHMuZm9ybWlrLnZhbGlkYXRlT25DaGFuZ2UgJiZcbiAgICAgICFpc0VxdWFsKFxuICAgICAgICBnZXRJbihwcmV2UHJvcHMuZm9ybWlrLnZhbHVlcywgcHJldlByb3BzLm5hbWUpLFxuICAgICAgICBnZXRJbih0aGlzLnByb3BzLmZvcm1pay52YWx1ZXMsIHRoaXMucHJvcHMubmFtZSlcbiAgICAgIClcbiAgICApIHtcbiAgICAgIHRoaXMucHJvcHMuZm9ybWlrLnZhbGlkYXRlRm9ybSh0aGlzLnByb3BzLmZvcm1pay52YWx1ZXMpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUFycmF5RmllbGQgPSAoXG4gICAgZm46IEZ1bmN0aW9uLFxuICAgIGFsdGVyVG91Y2hlZDogYm9vbGVhbiB8IEZ1bmN0aW9uLFxuICAgIGFsdGVyRXJyb3JzOiBib29sZWFuIHwgRnVuY3Rpb25cbiAgKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcblxuICAgICAgZm9ybWlrOiB7IHNldEZvcm1pa1N0YXRlIH0sXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgc2V0Rm9ybWlrU3RhdGUoKHByZXZTdGF0ZTogRm9ybWlrU3RhdGU8YW55PikgPT4ge1xuICAgICAgbGV0IHVwZGF0ZUVycm9ycyA9IHR5cGVvZiBhbHRlckVycm9ycyA9PT0gJ2Z1bmN0aW9uJyA/IGFsdGVyRXJyb3JzIDogZm47XG4gICAgICBsZXQgdXBkYXRlVG91Y2hlZCA9XG4gICAgICAgIHR5cGVvZiBhbHRlclRvdWNoZWQgPT09ICdmdW5jdGlvbicgPyBhbHRlclRvdWNoZWQgOiBmbjtcblxuICAgICAgLy8gdmFsdWVzIGZuIHNob3VsZCBiZSBleGVjdXRlZCBiZWZvcmUgdXBkYXRlRXJyb3JzIGFuZCB1cGRhdGVUb3VjaGVkLFxuICAgICAgLy8gb3RoZXJ3aXNlIGl0IGNhdXNlcyBhbiBlcnJvciB3aXRoIHVuc2hpZnQuXG4gICAgICBsZXQgdmFsdWVzID0gc2V0SW4oXG4gICAgICAgIHByZXZTdGF0ZS52YWx1ZXMsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGZuKGdldEluKHByZXZTdGF0ZS52YWx1ZXMsIG5hbWUpKVxuICAgICAgKTtcblxuICAgICAgbGV0IGZpZWxkRXJyb3IgPSBhbHRlckVycm9yc1xuICAgICAgICA/IHVwZGF0ZUVycm9ycyhnZXRJbihwcmV2U3RhdGUuZXJyb3JzLCBuYW1lKSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICBsZXQgZmllbGRUb3VjaGVkID0gYWx0ZXJUb3VjaGVkXG4gICAgICAgID8gdXBkYXRlVG91Y2hlZChnZXRJbihwcmV2U3RhdGUudG91Y2hlZCwgbmFtZSkpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoaXNFbXB0eUFycmF5KGZpZWxkRXJyb3IpKSB7XG4gICAgICAgIGZpZWxkRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoaXNFbXB0eUFycmF5KGZpZWxkVG91Y2hlZCkpIHtcbiAgICAgICAgZmllbGRUb3VjaGVkID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5wcmV2U3RhdGUsXG4gICAgICAgIHZhbHVlcyxcbiAgICAgICAgZXJyb3JzOiBhbHRlckVycm9yc1xuICAgICAgICAgID8gc2V0SW4ocHJldlN0YXRlLmVycm9ycywgbmFtZSwgZmllbGRFcnJvcilcbiAgICAgICAgICA6IHByZXZTdGF0ZS5lcnJvcnMsXG4gICAgICAgIHRvdWNoZWQ6IGFsdGVyVG91Y2hlZFxuICAgICAgICAgID8gc2V0SW4ocHJldlN0YXRlLnRvdWNoZWQsIG5hbWUsIGZpZWxkVG91Y2hlZClcbiAgICAgICAgICA6IHByZXZTdGF0ZS50b3VjaGVkLFxuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcblxuICBwdXNoID0gKHZhbHVlOiBhbnkpID0+XG4gICAgdGhpcy51cGRhdGVBcnJheUZpZWxkKFxuICAgICAgKGFycmF5TGlrZTogQXJyYXlMaWtlPGFueT4pID0+IFtcbiAgICAgICAgLi4uY29weUFycmF5TGlrZShhcnJheUxpa2UpLFxuICAgICAgICBjbG9uZURlZXAodmFsdWUpLFxuICAgICAgXSxcbiAgICAgIGZhbHNlLFxuICAgICAgZmFsc2VcbiAgICApO1xuXG4gIGhhbmRsZVB1c2ggPSAodmFsdWU6IGFueSkgPT4gKCkgPT4gdGhpcy5wdXNoKHZhbHVlKTtcblxuICBzd2FwID0gKGluZGV4QTogbnVtYmVyLCBpbmRleEI6IG51bWJlcikgPT5cbiAgICB0aGlzLnVwZGF0ZUFycmF5RmllbGQoXG4gICAgICAoYXJyYXk6IGFueVtdKSA9PiBzd2FwKGFycmF5LCBpbmRleEEsIGluZGV4QiksXG4gICAgICB0cnVlLFxuICAgICAgdHJ1ZVxuICAgICk7XG5cbiAgaGFuZGxlU3dhcCA9IChpbmRleEE6IG51bWJlciwgaW5kZXhCOiBudW1iZXIpID0+ICgpID0+XG4gICAgdGhpcy5zd2FwKGluZGV4QSwgaW5kZXhCKTtcblxuICBtb3ZlID0gKGZyb206IG51bWJlciwgdG86IG51bWJlcikgPT5cbiAgICB0aGlzLnVwZGF0ZUFycmF5RmllbGQoKGFycmF5OiBhbnlbXSkgPT4gbW92ZShhcnJheSwgZnJvbSwgdG8pLCB0cnVlLCB0cnVlKTtcblxuICBoYW5kbGVNb3ZlID0gKGZyb206IG51bWJlciwgdG86IG51bWJlcikgPT4gKCkgPT4gdGhpcy5tb3ZlKGZyb20sIHRvKTtcblxuICBpbnNlcnQgPSAoaW5kZXg6IG51bWJlciwgdmFsdWU6IGFueSkgPT5cbiAgICB0aGlzLnVwZGF0ZUFycmF5RmllbGQoXG4gICAgICAoYXJyYXk6IGFueVtdKSA9PiBpbnNlcnQoYXJyYXksIGluZGV4LCB2YWx1ZSksXG4gICAgICAoYXJyYXk6IGFueVtdKSA9PiBpbnNlcnQoYXJyYXksIGluZGV4LCBudWxsKSxcbiAgICAgIChhcnJheTogYW55W10pID0+IGluc2VydChhcnJheSwgaW5kZXgsIG51bGwpXG4gICAgKTtcblxuICBoYW5kbGVJbnNlcnQgPSAoaW5kZXg6IG51bWJlciwgdmFsdWU6IGFueSkgPT4gKCkgPT4gdGhpcy5pbnNlcnQoaW5kZXgsIHZhbHVlKTtcblxuICByZXBsYWNlID0gKGluZGV4OiBudW1iZXIsIHZhbHVlOiBhbnkpID0+XG4gICAgdGhpcy51cGRhdGVBcnJheUZpZWxkKFxuICAgICAgKGFycmF5OiBhbnlbXSkgPT4gcmVwbGFjZShhcnJheSwgaW5kZXgsIHZhbHVlKSxcbiAgICAgIGZhbHNlLFxuICAgICAgZmFsc2VcbiAgICApO1xuXG4gIGhhbmRsZVJlcGxhY2UgPSAoaW5kZXg6IG51bWJlciwgdmFsdWU6IGFueSkgPT4gKCkgPT5cbiAgICB0aGlzLnJlcGxhY2UoaW5kZXgsIHZhbHVlKTtcblxuICB1bnNoaWZ0ID0gKHZhbHVlOiBhbnkpID0+IHtcbiAgICBsZXQgbGVuZ3RoID0gLTE7XG4gICAgdGhpcy51cGRhdGVBcnJheUZpZWxkKFxuICAgICAgKGFycmF5OiBhbnlbXSkgPT4ge1xuICAgICAgICBjb25zdCBhcnIgPSBhcnJheSA/IFt2YWx1ZSwgLi4uYXJyYXldIDogW3ZhbHVlXTtcbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgICBsZW5ndGggPSBhcnIubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgICB9LFxuICAgICAgKGFycmF5OiBhbnlbXSkgPT4ge1xuICAgICAgICBjb25zdCBhcnIgPSBhcnJheSA/IFtudWxsLCAuLi5hcnJheV0gOiBbbnVsbF07XG4gICAgICAgIGlmIChsZW5ndGggPCAwKSB7XG4gICAgICAgICAgbGVuZ3RoID0gYXJyLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgfSxcbiAgICAgIChhcnJheTogYW55W10pID0+IHtcbiAgICAgICAgY29uc3QgYXJyID0gYXJyYXkgPyBbbnVsbCwgLi4uYXJyYXldIDogW251bGxdO1xuICAgICAgICBpZiAobGVuZ3RoIDwgMCkge1xuICAgICAgICAgIGxlbmd0aCA9IGFyci5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiBsZW5ndGg7XG4gIH07XG5cbiAgaGFuZGxlVW5zaGlmdCA9ICh2YWx1ZTogYW55KSA9PiAoKSA9PiB0aGlzLnVuc2hpZnQodmFsdWUpO1xuXG4gIHJlbW92ZTxUPihpbmRleDogbnVtYmVyKTogVCB7XG4gICAgLy8gV2UgbmVlZCB0byBtYWtlIHN1cmUgd2UgYWxzbyByZW1vdmUgcmVsZXZhbnQgcGllY2VzIG9mIGB0b3VjaGVkYCBhbmQgYGVycm9yc2BcbiAgICBsZXQgcmVzdWx0OiBhbnk7XG4gICAgdGhpcy51cGRhdGVBcnJheUZpZWxkKFxuICAgICAgLy8gc28gdGhpcyBnZXRzIGNhbGwgMyB0aW1lc1xuICAgICAgKGFycmF5PzogYW55W10pID0+IHtcbiAgICAgICAgY29uc3QgY29weSA9IGFycmF5ID8gY29weUFycmF5TGlrZShhcnJheSkgOiBbXTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQgPSBjb3B5W2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNGdW5jdGlvbihjb3B5LnNwbGljZSkpIHtcbiAgICAgICAgICBjb3B5LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgICB9LFxuICAgICAgdHJ1ZSxcbiAgICAgIHRydWVcbiAgICApO1xuXG4gICAgcmV0dXJuIHJlc3VsdCBhcyBUO1xuICB9XG5cbiAgaGFuZGxlUmVtb3ZlID0gKGluZGV4OiBudW1iZXIpID0+ICgpID0+IHRoaXMucmVtb3ZlPGFueT4oaW5kZXgpO1xuXG4gIHBvcDxUPigpOiBUIHtcbiAgICAvLyBSZW1vdmUgcmVsZXZhbnQgcGllY2VzIG9mIGB0b3VjaGVkYCBhbmQgYGVycm9yc2AgdG9vIVxuICAgIGxldCByZXN1bHQ6IGFueTtcbiAgICB0aGlzLnVwZGF0ZUFycmF5RmllbGQoXG4gICAgICAvLyBzbyB0aGlzIGdldHMgY2FsbCAzIHRpbWVzXG4gICAgICAoYXJyYXk6IGFueVtdKSA9PiB7XG4gICAgICAgIGNvbnN0IHRtcCA9IGFycmF5O1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHRtcCAmJiB0bXAucG9wICYmIHRtcC5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG1wO1xuICAgICAgfSxcbiAgICAgIHRydWUsXG4gICAgICB0cnVlXG4gICAgKTtcblxuICAgIHJldHVybiByZXN1bHQgYXMgVDtcbiAgfVxuXG4gIGhhbmRsZVBvcCA9ICgpID0+ICgpID0+IHRoaXMucG9wPGFueT4oKTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgYXJyYXlIZWxwZXJzOiBBcnJheUhlbHBlcnMgPSB7XG4gICAgICBwdXNoOiB0aGlzLnB1c2gsXG4gICAgICBwb3A6IHRoaXMucG9wLFxuICAgICAgc3dhcDogdGhpcy5zd2FwLFxuICAgICAgbW92ZTogdGhpcy5tb3ZlLFxuICAgICAgaW5zZXJ0OiB0aGlzLmluc2VydCxcbiAgICAgIHJlcGxhY2U6IHRoaXMucmVwbGFjZSxcbiAgICAgIHVuc2hpZnQ6IHRoaXMudW5zaGlmdCxcbiAgICAgIHJlbW92ZTogdGhpcy5yZW1vdmUsXG4gICAgICBoYW5kbGVQdXNoOiB0aGlzLmhhbmRsZVB1c2gsXG4gICAgICBoYW5kbGVQb3A6IHRoaXMuaGFuZGxlUG9wLFxuICAgICAgaGFuZGxlU3dhcDogdGhpcy5oYW5kbGVTd2FwLFxuICAgICAgaGFuZGxlTW92ZTogdGhpcy5oYW5kbGVNb3ZlLFxuICAgICAgaGFuZGxlSW5zZXJ0OiB0aGlzLmhhbmRsZUluc2VydCxcbiAgICAgIGhhbmRsZVJlcGxhY2U6IHRoaXMuaGFuZGxlUmVwbGFjZSxcbiAgICAgIGhhbmRsZVVuc2hpZnQ6IHRoaXMuaGFuZGxlVW5zaGlmdCxcbiAgICAgIGhhbmRsZVJlbW92ZTogdGhpcy5oYW5kbGVSZW1vdmUsXG4gICAgfTtcblxuICAgIGNvbnN0IHtcbiAgICAgIGNvbXBvbmVudCxcbiAgICAgIHJlbmRlcixcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgbmFtZSxcbiAgICAgIGZvcm1pazoge1xuICAgICAgICB2YWxpZGF0ZTogX3ZhbGlkYXRlLFxuICAgICAgICB2YWxpZGF0aW9uU2NoZW1hOiBfdmFsaWRhdGlvblNjaGVtYSxcbiAgICAgICAgLi4ucmVzdE9mRm9ybWlrXG4gICAgICB9LFxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3QgcHJvcHM6IEZpZWxkQXJyYXlSZW5kZXJQcm9wcyA9IHtcbiAgICAgIC4uLmFycmF5SGVscGVycyxcbiAgICAgIGZvcm06IHJlc3RPZkZvcm1payxcbiAgICAgIG5hbWUsXG4gICAgfTtcblxuICAgIHJldHVybiBjb21wb25lbnRcbiAgICAgID8gUmVhY3QuY3JlYXRlRWxlbWVudChjb21wb25lbnQgYXMgYW55LCBwcm9wcylcbiAgICAgIDogcmVuZGVyXG4gICAgICA/IChyZW5kZXIgYXMgYW55KShwcm9wcylcbiAgICAgIDogY2hpbGRyZW4gLy8gY2hpbGRyZW4gY29tZSBsYXN0LCBhbHdheXMgY2FsbGVkXG4gICAgICA/IHR5cGVvZiBjaGlsZHJlbiA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IChjaGlsZHJlbiBhcyBhbnkpKHByb3BzKVxuICAgICAgICA6ICFpc0VtcHR5Q2hpbGRyZW4oY2hpbGRyZW4pXG4gICAgICAgID8gUmVhY3QuQ2hpbGRyZW4ub25seShjaGlsZHJlbilcbiAgICAgICAgOiBudWxsXG4gICAgICA6IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IEZpZWxkQXJyYXkgPSBjb25uZWN0PEZpZWxkQXJyYXlDb25maWcsIGFueT4oRmllbGRBcnJheUlubmVyKTtcbiIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEZvcm1pa0NvbnRleHRUeXBlIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBnZXRJbiwgaXNGdW5jdGlvbiB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgY29ubmVjdCB9IGZyb20gJy4vY29ubmVjdCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXJyb3JNZXNzYWdlUHJvcHMge1xuICBuYW1lOiBzdHJpbmc7XG4gIGNsYXNzTmFtZT86IHN0cmluZztcbiAgY29tcG9uZW50Pzogc3RyaW5nIHwgUmVhY3QuQ29tcG9uZW50VHlwZTtcbiAgY2hpbGRyZW4/OiAoZXJyb3JNZXNzYWdlOiBzdHJpbmcpID0+IFJlYWN0LlJlYWN0Tm9kZTtcbiAgcmVuZGVyPzogKGVycm9yTWVzc2FnZTogc3RyaW5nKSA9PiBSZWFjdC5SZWFjdE5vZGU7XG59XG5cbmNsYXNzIEVycm9yTWVzc2FnZUltcGwgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8XG4gIEVycm9yTWVzc2FnZVByb3BzICYgeyBmb3JtaWs6IEZvcm1pa0NvbnRleHRUeXBlPGFueT4gfVxuPiB7XG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZShcbiAgICBwcm9wczogRXJyb3JNZXNzYWdlUHJvcHMgJiB7IGZvcm1pazogRm9ybWlrQ29udGV4dFR5cGU8YW55PiB9XG4gICkge1xuICAgIGlmIChcbiAgICAgIGdldEluKHRoaXMucHJvcHMuZm9ybWlrLmVycm9ycywgdGhpcy5wcm9wcy5uYW1lKSAhPT1cbiAgICAgICAgZ2V0SW4ocHJvcHMuZm9ybWlrLmVycm9ycywgdGhpcy5wcm9wcy5uYW1lKSB8fFxuICAgICAgZ2V0SW4odGhpcy5wcm9wcy5mb3JtaWsudG91Y2hlZCwgdGhpcy5wcm9wcy5uYW1lKSAhPT1cbiAgICAgICAgZ2V0SW4ocHJvcHMuZm9ybWlrLnRvdWNoZWQsIHRoaXMucHJvcHMubmFtZSkgfHxcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucHJvcHMpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMocHJvcHMpLmxlbmd0aFxuICAgICkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgY29tcG9uZW50LCBmb3JtaWssIHJlbmRlciwgY2hpbGRyZW4sIG5hbWUsIC4uLnJlc3QgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCB0b3VjaCA9IGdldEluKGZvcm1pay50b3VjaGVkLCBuYW1lKTtcbiAgICBjb25zdCBlcnJvciA9IGdldEluKGZvcm1pay5lcnJvcnMsIG5hbWUpO1xuXG4gICAgcmV0dXJuICEhdG91Y2ggJiYgISFlcnJvclxuICAgICAgPyByZW5kZXJcbiAgICAgICAgPyBpc0Z1bmN0aW9uKHJlbmRlcilcbiAgICAgICAgICA/IHJlbmRlcihlcnJvcilcbiAgICAgICAgICA6IG51bGxcbiAgICAgICAgOiBjaGlsZHJlblxuICAgICAgICA/IGlzRnVuY3Rpb24oY2hpbGRyZW4pXG4gICAgICAgICAgPyBjaGlsZHJlbihlcnJvcilcbiAgICAgICAgICA6IG51bGxcbiAgICAgICAgOiBjb21wb25lbnRcbiAgICAgICAgPyBSZWFjdC5jcmVhdGVFbGVtZW50KGNvbXBvbmVudCwgcmVzdCBhcyBhbnksIGVycm9yKVxuICAgICAgICA6IGVycm9yXG4gICAgICA6IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IEVycm9yTWVzc2FnZSA9IGNvbm5lY3Q8XG4gIEVycm9yTWVzc2FnZVByb3BzLFxuICBFcnJvck1lc3NhZ2VQcm9wcyAmIHsgZm9ybWlrOiBGb3JtaWtDb250ZXh0VHlwZTxhbnk+IH1cbj4oRXJyb3JNZXNzYWdlSW1wbCk7XG4iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7XG4gIEZvcm1pa1Byb3BzLFxuICBHZW5lcmljRmllbGRIVE1MQXR0cmlidXRlcyxcbiAgRm9ybWlrQ29udGV4dFR5cGUsXG4gIEZpZWxkTWV0YVByb3BzLFxuICBGaWVsZElucHV0UHJvcHMsXG59IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICd0aW55LXdhcm5pbmcnO1xuaW1wb3J0IHsgZ2V0SW4sIGlzRW1wdHlDaGlsZHJlbiwgaXNGdW5jdGlvbiB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgRmllbGRDb25maWcgfSBmcm9tICcuL0ZpZWxkJztcbmltcG9ydCB7IGNvbm5lY3QgfSBmcm9tICcuL2Nvbm5lY3QnO1xuXG50eXBlICRGaXhNZSA9IGFueTtcblxuZXhwb3J0IGludGVyZmFjZSBGYXN0RmllbGRQcm9wczxWID0gYW55PiB7XG4gIGZpZWxkOiBGaWVsZElucHV0UHJvcHM8Vj47XG4gIG1ldGE6IEZpZWxkTWV0YVByb3BzPFY+O1xuICBmb3JtOiBGb3JtaWtQcm9wczxWPjsgLy8gaWYgcHBsIHdhbnQgdG8gcmVzdHJpY3QgdGhpcyBmb3IgYSBnaXZlbiBmb3JtLCBsZXQgdGhlbS5cbn1cblxuZXhwb3J0IHR5cGUgRmFzdEZpZWxkQ29uZmlnPFQ+ID0gRmllbGRDb25maWcgJiB7XG4gIC8qKiBPdmVycmlkZSBGYXN0RmllbGQncyBkZWZhdWx0IHNob3VsZENvbXBvbmVudFVwZGF0ZSAqL1xuICBzaG91bGRVcGRhdGU/OiAoXG4gICAgbmV4dFByb3BzOiBUICYgR2VuZXJpY0ZpZWxkSFRNTEF0dHJpYnV0ZXMsXG4gICAgcHJvcHM6IHt9XG4gICkgPT4gYm9vbGVhbjtcbn07XG5cbmV4cG9ydCB0eXBlIEZhc3RGaWVsZEF0dHJpYnV0ZXM8VD4gPSBHZW5lcmljRmllbGRIVE1MQXR0cmlidXRlcyAmXG4gIEZhc3RGaWVsZENvbmZpZzxUPiAmXG4gIFQ7XG5cbnR5cGUgRmFzdEZpZWxkSW5uZXJQcm9wczxWYWx1ZXMgPSB7fSwgUHJvcHMgPSB7fT4gPSBGYXN0RmllbGRBdHRyaWJ1dGVzPFxuICBQcm9wc1xuPiAmIHsgZm9ybWlrOiBGb3JtaWtDb250ZXh0VHlwZTxWYWx1ZXM+IH07XG5cbi8qKlxuICogQ3VzdG9tIEZpZWxkIGNvbXBvbmVudCBmb3IgcXVpY2tseSBob29raW5nIGludG8gRm9ybWlrXG4gKiBjb250ZXh0IGFuZCB3aXJpbmcgdXAgZm9ybXMuXG4gKi9cbmNsYXNzIEZhc3RGaWVsZElubmVyPFZhbHVlcyA9IHt9LCBQcm9wcyA9IHt9PiBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxcbiAgRmFzdEZpZWxkSW5uZXJQcm9wczxWYWx1ZXMsIFByb3BzPixcbiAge31cbj4ge1xuICBjb25zdHJ1Y3Rvcihwcm9wczogRmFzdEZpZWxkSW5uZXJQcm9wczxWYWx1ZXMsIFByb3BzPikge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICBjb25zdCB7IHJlbmRlciwgY2hpbGRyZW4sIGNvbXBvbmVudCwgYXM6IGlzLCBuYW1lIH0gPSBwcm9wcztcbiAgICBpbnZhcmlhbnQoXG4gICAgICAhcmVuZGVyLFxuICAgICAgYDxGYXN0RmllbGQgcmVuZGVyPiBoYXMgYmVlbiBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIGEgY2hpbGQgY2FsbGJhY2sgZnVuY3Rpb24gaW5zdGVhZDogPEZhc3RGaWVsZCBuYW1lPXske25hbWV9fT57cHJvcHMgPT4gLi4ufTwvRmFzdEZpZWxkPiBpbnN0ZWFkLmBcbiAgICApO1xuICAgIGludmFyaWFudChcbiAgICAgICEoY29tcG9uZW50ICYmIHJlbmRlciksXG4gICAgICAnWW91IHNob3VsZCBub3QgdXNlIDxGYXN0RmllbGQgY29tcG9uZW50PiBhbmQgPEZhc3RGaWVsZCByZW5kZXI+IGluIHRoZSBzYW1lIDxGYXN0RmllbGQ+IGNvbXBvbmVudDsgPEZhc3RGaWVsZCBjb21wb25lbnQ+IHdpbGwgYmUgaWdub3JlZCdcbiAgICApO1xuXG4gICAgaW52YXJpYW50KFxuICAgICAgIShpcyAmJiBjaGlsZHJlbiAmJiBpc0Z1bmN0aW9uKGNoaWxkcmVuKSksXG4gICAgICAnWW91IHNob3VsZCBub3QgdXNlIDxGYXN0RmllbGQgYXM+IGFuZCA8RmFzdEZpZWxkIGNoaWxkcmVuPiBhcyBhIGZ1bmN0aW9uIGluIHRoZSBzYW1lIDxGYXN0RmllbGQ+IGNvbXBvbmVudDsgPEZhc3RGaWVsZCBhcz4gd2lsbCBiZSBpZ25vcmVkLidcbiAgICApO1xuXG4gICAgaW52YXJpYW50KFxuICAgICAgIShjb21wb25lbnQgJiYgY2hpbGRyZW4gJiYgaXNGdW5jdGlvbihjaGlsZHJlbikpLFxuICAgICAgJ1lvdSBzaG91bGQgbm90IHVzZSA8RmFzdEZpZWxkIGNvbXBvbmVudD4gYW5kIDxGYXN0RmllbGQgY2hpbGRyZW4+IGFzIGEgZnVuY3Rpb24gaW4gdGhlIHNhbWUgPEZhc3RGaWVsZD4gY29tcG9uZW50OyA8RmFzdEZpZWxkIGNvbXBvbmVudD4gd2lsbCBiZSBpZ25vcmVkLidcbiAgICApO1xuXG4gICAgaW52YXJpYW50KFxuICAgICAgIShyZW5kZXIgJiYgY2hpbGRyZW4gJiYgIWlzRW1wdHlDaGlsZHJlbihjaGlsZHJlbikpLFxuICAgICAgJ1lvdSBzaG91bGQgbm90IHVzZSA8RmFzdEZpZWxkIHJlbmRlcj4gYW5kIDxGYXN0RmllbGQgY2hpbGRyZW4+IGluIHRoZSBzYW1lIDxGYXN0RmllbGQ+IGNvbXBvbmVudDsgPEZhc3RGaWVsZCBjaGlsZHJlbj4gd2lsbCBiZSBpZ25vcmVkJ1xuICAgICk7XG4gIH1cblxuICBzaG91bGRDb21wb25lbnRVcGRhdGUocHJvcHM6IEZhc3RGaWVsZElubmVyUHJvcHM8VmFsdWVzLCBQcm9wcz4pIHtcbiAgICBpZiAodGhpcy5wcm9wcy5zaG91bGRVcGRhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3BzLnNob3VsZFVwZGF0ZShwcm9wcywgdGhpcy5wcm9wcyk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHByb3BzLm5hbWUgIT09IHRoaXMucHJvcHMubmFtZSB8fFxuICAgICAgZ2V0SW4ocHJvcHMuZm9ybWlrLnZhbHVlcywgdGhpcy5wcm9wcy5uYW1lKSAhPT1cbiAgICAgICAgZ2V0SW4odGhpcy5wcm9wcy5mb3JtaWsudmFsdWVzLCB0aGlzLnByb3BzLm5hbWUpIHx8XG4gICAgICBnZXRJbihwcm9wcy5mb3JtaWsuZXJyb3JzLCB0aGlzLnByb3BzLm5hbWUpICE9PVxuICAgICAgICBnZXRJbih0aGlzLnByb3BzLmZvcm1pay5lcnJvcnMsIHRoaXMucHJvcHMubmFtZSkgfHxcbiAgICAgIGdldEluKHByb3BzLmZvcm1pay50b3VjaGVkLCB0aGlzLnByb3BzLm5hbWUpICE9PVxuICAgICAgICBnZXRJbih0aGlzLnByb3BzLmZvcm1pay50b3VjaGVkLCB0aGlzLnByb3BzLm5hbWUpIHx8XG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnByb3BzKS5sZW5ndGggIT09IE9iamVjdC5rZXlzKHByb3BzKS5sZW5ndGggfHxcbiAgICAgIHByb3BzLmZvcm1pay5pc1N1Ym1pdHRpbmcgIT09IHRoaXMucHJvcHMuZm9ybWlrLmlzU3VibWl0dGluZ1xuICAgICkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAvLyBSZWdpc3RlciB0aGUgRmllbGQgd2l0aCB0aGUgcGFyZW50IEZvcm1pay4gUGFyZW50IHdpbGwgY3ljbGUgdGhyb3VnaFxuICAgIC8vIHJlZ2lzdGVyZWQgRmllbGQncyB2YWxpZGF0ZSBmbnMgcmlnaHQgcHJpb3IgdG8gc3VibWl0XG4gICAgdGhpcy5wcm9wcy5mb3JtaWsucmVnaXN0ZXJGaWVsZCh0aGlzLnByb3BzLm5hbWUsIHtcbiAgICAgIHZhbGlkYXRlOiB0aGlzLnByb3BzLnZhbGlkYXRlLFxuICAgIH0pO1xuICB9XG5cbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wczogRmFzdEZpZWxkQXR0cmlidXRlczxQcm9wcz4pIHtcbiAgICBpZiAodGhpcy5wcm9wcy5uYW1lICE9PSBwcmV2UHJvcHMubmFtZSkge1xuICAgICAgdGhpcy5wcm9wcy5mb3JtaWsudW5yZWdpc3RlckZpZWxkKHByZXZQcm9wcy5uYW1lKTtcbiAgICAgIHRoaXMucHJvcHMuZm9ybWlrLnJlZ2lzdGVyRmllbGQodGhpcy5wcm9wcy5uYW1lLCB7XG4gICAgICAgIHZhbGlkYXRlOiB0aGlzLnByb3BzLnZhbGlkYXRlLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucHJvcHMudmFsaWRhdGUgIT09IHByZXZQcm9wcy52YWxpZGF0ZSkge1xuICAgICAgdGhpcy5wcm9wcy5mb3JtaWsucmVnaXN0ZXJGaWVsZCh0aGlzLnByb3BzLm5hbWUsIHtcbiAgICAgICAgdmFsaWRhdGU6IHRoaXMucHJvcHMudmFsaWRhdGUsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLnByb3BzLmZvcm1pay51bnJlZ2lzdGVyRmllbGQodGhpcy5wcm9wcy5uYW1lKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICB2YWxpZGF0ZSxcbiAgICAgIG5hbWUsXG4gICAgICByZW5kZXIsXG4gICAgICBhczogaXMsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGNvbXBvbmVudCxcbiAgICAgIHNob3VsZFVwZGF0ZSxcbiAgICAgIGZvcm1payxcbiAgICAgIC4uLnByb3BzXG4gICAgfSA9IHRoaXMucHJvcHMgYXMgRmFzdEZpZWxkSW5uZXJQcm9wczxWYWx1ZXMsIFByb3BzPjtcblxuICAgIGNvbnN0IHtcbiAgICAgIHZhbGlkYXRlOiBfdmFsaWRhdGUsXG4gICAgICB2YWxpZGF0aW9uU2NoZW1hOiBfdmFsaWRhdGlvblNjaGVtYSxcbiAgICAgIC4uLnJlc3RPZkZvcm1pa1xuICAgIH0gPSBmb3JtaWs7XG4gICAgY29uc3QgZmllbGQgPSBmb3JtaWsuZ2V0RmllbGRQcm9wcyh7IG5hbWUsIC4uLnByb3BzIH0pO1xuICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICB2YWx1ZTogZ2V0SW4oZm9ybWlrLnZhbHVlcywgbmFtZSksXG4gICAgICBlcnJvcjogZ2V0SW4oZm9ybWlrLmVycm9ycywgbmFtZSksXG4gICAgICB0b3VjaGVkOiAhIWdldEluKGZvcm1pay50b3VjaGVkLCBuYW1lKSxcbiAgICAgIGluaXRpYWxWYWx1ZTogZ2V0SW4oZm9ybWlrLmluaXRpYWxWYWx1ZXMsIG5hbWUpLFxuICAgICAgaW5pdGlhbFRvdWNoZWQ6ICEhZ2V0SW4oZm9ybWlrLmluaXRpYWxUb3VjaGVkLCBuYW1lKSxcbiAgICAgIGluaXRpYWxFcnJvcjogZ2V0SW4oZm9ybWlrLmluaXRpYWxFcnJvcnMsIG5hbWUpLFxuICAgIH07XG5cbiAgICBjb25zdCBiYWcgPSB7IGZpZWxkLCBtZXRhLCBmb3JtOiByZXN0T2ZGb3JtaWsgfTtcblxuICAgIGlmIChyZW5kZXIpIHtcbiAgICAgIHJldHVybiAocmVuZGVyIGFzIGFueSkoYmFnKTtcbiAgICB9XG5cbiAgICBpZiAoaXNGdW5jdGlvbihjaGlsZHJlbikpIHtcbiAgICAgIHJldHVybiAoY2hpbGRyZW4gYXMgKHByb3BzOiBGYXN0RmllbGRQcm9wczxhbnk+KSA9PiBSZWFjdC5SZWFjdE5vZGUpKGJhZyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgLy8gVGhpcyBiZWhhdmlvciBpcyBiYWNrd2FyZHMgY29tcGF0IHdpdGggZWFybGllciBGb3JtaWsgMC45IHRvIDEueFxuICAgICAgaWYgKHR5cGVvZiBjb21wb25lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IHsgaW5uZXJSZWYsIC4uLnJlc3QgfSA9IHByb3BzO1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICBjb21wb25lbnQsXG4gICAgICAgICAgeyByZWY6IGlubmVyUmVmLCAuLi5maWVsZCwgLi4uKHJlc3QgYXMgJEZpeE1lKSB9LFxuICAgICAgICAgIGNoaWxkcmVuXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICAvLyBXZSBkb24ndCBwYXNzIGBtZXRhYCBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIGNvbXBvbmVudCBhcyBSZWFjdC5Db21wb25lbnRDbGFzczwkRml4TWU+LFxuICAgICAgICB7IGZpZWxkLCBmb3JtOiBmb3JtaWssIC4uLnByb3BzIH0sXG4gICAgICAgIGNoaWxkcmVuXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGRlZmF1bHQgdG8gaW5wdXQgaGVyZSBzbyB3ZSBjYW4gY2hlY2sgZm9yIGJvdGggYGFzYCBhbmQgYGNoaWxkcmVuYCBhYm92ZVxuICAgIGNvbnN0IGFzRWxlbWVudCA9IGlzIHx8ICdpbnB1dCc7XG5cbiAgICBpZiAodHlwZW9mIGFzRWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IHsgaW5uZXJSZWYsIC4uLnJlc3QgfSA9IHByb3BzO1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIGFzRWxlbWVudCxcbiAgICAgICAgeyByZWY6IGlubmVyUmVmLCAuLi5maWVsZCwgLi4uKHJlc3QgYXMgJEZpeE1lKSB9LFxuICAgICAgICBjaGlsZHJlblxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgIGFzRWxlbWVudCBhcyBSZWFjdC5Db21wb25lbnRDbGFzcyxcbiAgICAgIHsgLi4uZmllbGQsIC4uLnByb3BzIH0sXG4gICAgICBjaGlsZHJlblxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IEZhc3RGaWVsZCA9IGNvbm5lY3Q8RmFzdEZpZWxkQXR0cmlidXRlczxhbnk+LCBhbnk+KEZhc3RGaWVsZElubmVyKTtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU1BOztJQUNhQSxZQUFZLEdBQUcsU0FBZkEsWUFBZUEsQ0FBQ0MsS0FBRDtFQUFBLE9BQzFCQyxLQUFLLENBQUNDLE9BQU4sQ0FBY0YsS0FBZCxLQUF3QkEsS0FBSyxDQUFDRyxNQUFOLEtBQWlCLENBRGY7QUFBQTtBQUc1Qjs7SUFDYUMsVUFBVSxHQUFHLFNBQWJBLFVBQWFBLENBQUNDLEdBQUQ7RUFBQSxPQUN4QixPQUFPQSxHQUFQLEtBQWUsVUFEUztBQUFBO0FBRzFCOztJQUNhQyxRQUFRLEdBQUcsU0FBWEEsUUFBV0EsQ0FBQ0QsR0FBRDtFQUFBLE9BQ3RCQSxHQUFHLEtBQUssSUFBUixJQUFnQixPQUFPQSxHQUFQLEtBQWUsUUFEVDtBQUFBO0FBR3hCOztJQUNhRSxTQUFTLEdBQUcsU0FBWkEsU0FBWUEsQ0FBQ0YsR0FBRDtFQUFBLE9BQ3ZCRyxNQUFNLENBQUNDLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxNQUFNLENBQUNOLEdBQUQsQ0FBakIsQ0FBRCxDQUFOLEtBQW9DQSxHQURiO0FBQUE7QUFHekI7O0lBQ2FPLFFBQVEsR0FBRyxTQUFYQSxRQUFXQSxDQUFDUCxHQUFEO0VBQUEsT0FDdEJRLE1BQU0sQ0FBQ0MsU0FBUCxDQUFpQkMsUUFBakIsQ0FBMEJDLElBQTFCLENBQStCWCxHQUEvQixNQUF3QyxpQkFEbEI7QUFBQTtBQUd4QjtBQUNBOztJQUNhWSxPQUFLLEdBQUcsU0FBUkMsS0FBUUEsQ0FBQ2IsR0FB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