358b297f4d293f3817e33e103fa3a371
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  render: true,
  renderHook: true,
  cleanup: true,
  act: true,
  fireEvent: true
};
Object.defineProperty(exports, "act", {
  enumerable: true,
  get: function () {
    return _actCompat.default;
  }
});
exports.cleanup = cleanup;
Object.defineProperty(exports, "fireEvent", {
  enumerable: true,
  get: function () {
    return _fireEvent.fireEvent;
  }
});
exports.render = render;
exports.renderHook = renderHook;
var React = _interopRequireWildcard(require("react"));
var _reactDom = _interopRequireDefault(require("react-dom"));
var ReactDOMClient = _interopRequireWildcard(require("react-dom/client"));
var _dom = require("@testing-library/dom");
Object.keys(_dom).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _dom[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _dom[key];
    }
  });
});
var _actCompat = _interopRequireWildcard(require("./act-compat"));
var _fireEvent = require("./fire-event");
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
function jestFakeTimersAreEnabled() {
  /* istanbul ignore else */
  if (typeof jest !== 'undefined' && jest !== null) {
    return (
      // legacy timers
      setTimeout._isMockFunction === true ||
      // modern timers
      // eslint-disable-next-line prefer-object-has-own -- No Object.hasOwn in all target environments we support.
      Object.prototype.hasOwnProperty.call(setTimeout, 'clock')
    );
  } // istanbul ignore next

  return false;
}
(0, _dom.configure)({
  unstable_advanceTimersWrapper: cb => {
    return (0, _actCompat.default)(cb);
  },
  // We just want to run `waitFor` without IS_REACT_ACT_ENVIRONMENT
  // But that's not necessarily how `asyncWrapper` is used since it's a public method.
  // Let's just hope nobody else is using it.
  asyncWrapper: async cb => {
    const previousActEnvironment = (0, _actCompat.getIsReactActEnvironment)();
    (0, _actCompat.setReactActEnvironment)(false);
    try {
      const result = await cb();
      // Drain microtask queue.
      // Otherwise we'll restore the previous act() environment, before we resolve the `waitFor` call.
      // The caller would have no chance to wrap the in-flight Promises in `act()`
      await new Promise(resolve => {
        setTimeout(() => {
          resolve();
        }, 0);
        if (jestFakeTimersAreEnabled()) {
          jest.advanceTimersByTime(0);
        }
      });
      return result;
    } finally {
      (0, _actCompat.setReactActEnvironment)(previousActEnvironment);
    }
  },
  eventWrapper: cb => {
    let result;
    (0, _actCompat.default)(() => {
      result = cb();
    });
    return result;
  }
});

// Ideally we'd just use a WeakMap where containers are keys and roots are values.
// We use two variables so that we can bail out in constant time when we render with a new container (most common use case)
/**
 * @type {Set<import('react-dom').Container>}
 */
const mountedContainers = new Set();
/**
 * @type Array<{container: import('react-dom').Container, root: ReturnType<typeof createConcurrentRoot>}>
 */
const mountedRootEntries = [];
function createConcurrentRoot(container, {
  hydrate,
  ui,
  wrapper: WrapperComponent
}) {
  let root;
  if (hydrate) {
    (0, _actCompat.default)(() => {
      root = ReactDOMClient.hydrateRoot(container, WrapperComponent ? /*#__PURE__*/React.createElement(WrapperComponent, null, ui) : ui);
    });
  } else {
    root = ReactDOMClient.createRoot(container);
  }
  return {
    hydrate() {
      /* istanbul ignore if */
      if (!hydrate) {
        throw new Error('Attempted to hydrate a non-hydrateable root. This is a bug in `@testing-library/react`.');
      }
      // Nothing to do since hydration happens when creating the root object.
    },

    render(element) {
      root.render(element);
    },
    unmount() {
      root.unmount();
    }
  };
}
function createLegacyRoot(container) {
  return {
    hydrate(element) {
      _reactDom.default.hydrate(element, container);
    },
    render(element) {
      _reactDom.default.render(element, container);
    },
    unmount() {
      _reactDom.default.unmountComponentAtNode(container);
    }
  };
}
function renderRoot(ui, {
  baseElement,
  container,
  hydrate,
  queries,
  root,
  wrapper: WrapperComponent
}) {
  const wrapUiIfNeeded = innerElement => WrapperComponent ? /*#__PURE__*/React.createElement(WrapperComponent, null, innerElement) : innerElement;
  (0, _actCompat.default)(() => {
    if (hydrate) {
      root.hydrate(wrapUiIfNeeded(ui), container);
    } else {
      root.render(wrapUiIfNeeded(ui), container);
    }
  });
  return {
    container,
    baseElement,
    debug: (el = baseElement, maxLength, options) => Array.isArray(el) ?
    // eslint-disable-next-line no-console
    el.forEach(e => console.log((0, _dom.prettyDOM)(e, maxLength, options))) :
    // eslint-disable-next-line no-console,
    console.log((0, _dom.prettyDOM)(el, maxLength, options)),
    unmount: () => {
      (0, _actCompat.default)(() => {
        root.unmount();
      });
    },
    rerender: rerenderUi => {
      renderRoot(wrapUiIfNeeded(rerenderUi), {
        container,
        baseElement,
        root
      });
      // Intentionally do not return anything to avoid unnecessarily complicating the API.
      // folks can use all the same utilities we return in the first place that are bound to the container
    },

    asFragment: () => {
      /* istanbul ignore else (old jsdom limitation) */
      if (typeof document.createRange === 'function') {
        return document.createRange().createContextualFragment(container.innerHTML);
      } else {
        const template = document.createElement('template');
        template.innerHTML = container.innerHTML;
        return template.content;
      }
    },
    ...(0, _dom.getQueriesForElement)(baseElement, queries)
  };
}
function render(ui, {
  container,
  baseElement = container,
  legacyRoot = false,
  queries,
  hydrate = false,
  wrapper
} = {}) {
  if (!baseElement) {
    // default to document.body instead of documentElement to avoid output of potentially-large
    // head elements (such as JSS style blocks) in debug output
    baseElement = document.body;
  }
  if (!container) {
    container = baseElement.appendChild(document.createElement('div'));
  }
  let root;
  // eslint-disable-next-line no-negated-condition -- we want to map the evolution of this over time. The root is created first. Only later is it re-used so we don't want to read the case that happens later first.
  if (!mountedContainers.has(container)) {
    const createRootImpl = legacyRoot ? createLegacyRoot : createConcurrentRoot;
    root = createRootImpl(container, {
      hydrate,
      ui,
      wrapper
    });
    mountedRootEntries.push({
      container,
      root
    });
    // we'll add it to the mounted containers regardless of whether it's actually
    // added to document.body so the cleanup method works regardless of whether
    // they're passing us a custom container or not.
    mountedContainers.add(container);
  } else {
    mountedRootEntries.forEach(rootEntry => {
      // Else is unreachable since `mountedContainers` has the `container`.
      // Only reachable if one would accidentally add the container to `mountedContainers` but not the root to `mountedRootEntries`
      /* istanbul ignore else */
      if (rootEntry.container === container) {
        root = rootEntry.root;
      }
    });
  }
  return renderRoot(ui, {
    container,
    baseElement,
    queries,
    hydrate,
    wrapper,
    root
  });
}
function cleanup() {
  mountedRootEntries.forEach(({
    root,
    container
  }) => {
    (0, _actCompat.default)(() => {
      root.unmount();
    });
    if (container.parentNode === document.body) {
      document.body.removeChild(container);
    }
  });
  mountedRootEntries.length = 0;
  mountedContainers.clear();
}
function renderHook(renderCallback, options = {}) {
  const {
    initialProps,
    ...renderOptions
  } = options;
  const result = /*#__PURE__*/React.createRef();
  function TestComponent({
    renderCallbackProps
  }) {
    const pendingResult = renderCallback(renderCallbackProps);
    React.useEffect(() => {
      result.current = pendingResult;
    });
    return null;
  }
  const {
    rerender: baseRerender,
    unmount
  } = render( /*#__PURE__*/React.createElement(TestComponent, {
    renderCallbackProps: initialProps
  }), renderOptions);
  function rerender(rerenderCallbackProps) {
    return baseRerender( /*#__PURE__*/React.createElement(TestComponent, {
      renderCallbackProps: rerenderCallbackProps
    }));
  }
  return {
    result,
    rerender,
    unmount
  };
}

// just re-export everything from dom-testing-library

/* eslint func-name-matching:0 */
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiX2V4cG9ydE5hbWVzIiwicmVuZGVyIiwicmVuZGVySG9vayIsImNsZWFudXAiLCJhY3QiLCJmaXJlRXZlbnQiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX2FjdENvbXBhdCIsImRlZmF1bHQiLCJfZmlyZUV2ZW50IiwiUmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsIl9yZWFjdERvbSIsIlJlYWN0RE9NQ2xpZW50IiwiX2RvbSIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwibm9kZUludGVyb3AiLCJXZWFrTWFwIiwiY2FjaGVCYWJlbEludGVyb3AiLCJjYWNoZU5vZGVJbnRlcm9wIiwib2JqIiwiX19lc01vZHVsZSIsImNhY2hlIiwiaGFzIiwibmV3T2JqIiwiaGFzUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZGVzYyIsInNldCIsImplc3RGYWtlVGltZXJzQXJlRW5hYmxlZCIsImplc3QiLCJzZXRUaW1lb3V0IiwiX2lzTW9ja0Z1bmN0aW9uIiwiY29uZmlndXJlIiwidW5zdGFibGVfYWR2YW5jZVRpbWVyc1dyYXBwZXIiLCJjYiIsImFzeW5jV3JhcHBlciIsInByZXZpb3VzQWN0RW52aXJvbm1lbnQiLCJnZXRJc1JlYWN0QWN0RW52aXJvbm1lbnQiLCJzZXRSZWFjdEFjdEVudmlyb25tZW50IiwicmVzdWx0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJhZHZhbmNlVGltZXJzQnlUaW1lIiwiZXZlbnRXcmFwcGVyIiwibW91bnRlZENvbnRhaW5lcnMiLCJTZXQiLCJtb3VudGVkUm9vdEVudHJpZXMiLCJjcmVhdGVDb25jdXJyZW50Um9vdCIsImNvbnRhaW5lciIsImh5ZHJhdGUiLCJ1aSIsIndyYXBwZXIiLCJXcmFwcGVyQ29tcG9uZW50Iiwicm9vdCIsImh5ZHJhdGVSb290IiwiY3JlYXRlRWxlbWVudCIsImNyZWF0ZVJvb3QiLCJFcnJvciIsImVsZW1lbnQiLCJ1bm1vdW50IiwiY3JlYXRlTGVnYWN5Um9vdCIsInVubW91bnRDb21wb25lbnRBdE5vZGUiLCJyZW5kZXJSb290IiwiYmFzZUVsZW1lbnQiLCJxdWVyaWVzIiwid3JhcFVpSWZOZWVkZWQiLCJpbm5lckVsZW1lbnQiLCJkZWJ1ZyIsImVsIiwibWF4TGVuZ3RoIiwib3B0aW9ucyIsIkFycmF5IiwiaXNBcnJheSIsImUiLCJjb25zb2xlIiwibG9nIiwicHJldHR5RE9NIiwicmVyZW5kZXIiLCJyZXJlbmRlclVpIiwiYXNGcmFnbWVudCIsImRvY3VtZW50IiwiY3JlYXRlUmFuZ2UiLCJjcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQiLCJpbm5lckhUTUwiLCJ0ZW1wbGF0ZSIsImNvbnRlbnQiLCJnZXRRdWVyaWVzRm9yRWxlbWVudCIsImxlZ2FjeVJvb3QiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJjcmVhdGVSb290SW1wbCIsInB1c2giLCJhZGQiLCJyb290RW50cnkiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJsZW5ndGgiLCJjbGVhciIsInJlbmRlckNhbGxiYWNrIiwiaW5pdGlhbFByb3BzIiwicmVuZGVyT3B0aW9ucyIsImNyZWF0ZVJlZiIsIlRlc3RDb21wb25lbnQiLCJyZW5kZXJDYWxsYmFja1Byb3BzIiwicGVuZGluZ1Jlc3VsdCIsInVzZUVmZmVjdCIsImN1cnJlbnQiLCJiYXNlUmVyZW5kZXIiLCJyZXJlbmRlckNhbGxiYWNrUHJvcHMiXSwic291cmNlcyI6WyJwdXJlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgX2V4cG9ydE5hbWVzID0ge1xuICByZW5kZXI6IHRydWUsXG4gIHJlbmRlckhvb2s6IHRydWUsXG4gIGNsZWFudXA6IHRydWUsXG4gIGFjdDogdHJ1ZSxcbiAgZmlyZUV2ZW50OiB0cnVlXG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYWN0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9hY3RDb21wYXQuZGVmYXVsdDtcbiAgfVxufSk7XG5leHBvcnRzLmNsZWFudXAgPSBjbGVhbnVwO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZmlyZUV2ZW50XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9maXJlRXZlbnQuZmlyZUV2ZW50O1xuICB9XG59KTtcbmV4cG9ydHMucmVuZGVyID0gcmVuZGVyO1xuZXhwb3J0cy5yZW5kZXJIb29rID0gcmVuZGVySG9vaztcbnZhciBSZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX3JlYWN0RG9tID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3QtZG9tXCIpKTtcbnZhciBSZWFjdERPTUNsaWVudCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdC1kb20vY2xpZW50XCIpKTtcbnZhciBfZG9tID0gcmVxdWlyZShcIkB0ZXN0aW5nLWxpYnJhcnkvZG9tXCIpO1xuT2JqZWN0LmtleXMoX2RvbSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfZXhwb3J0TmFtZXMsIGtleSkpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2RvbVtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9kb21ba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG52YXIgX2FjdENvbXBhdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL2FjdC1jb21wYXRcIikpO1xudmFyIF9maXJlRXZlbnQgPSByZXF1aXJlKFwiLi9maXJlLWV2ZW50XCIpO1xuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlQmFiZWxJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgdmFyIGNhY2hlTm9kZUludGVyb3AgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIChub2RlSW50ZXJvcCkgeyByZXR1cm4gbm9kZUludGVyb3AgPyBjYWNoZU5vZGVJbnRlcm9wIDogY2FjaGVCYWJlbEludGVyb3A7IH0pKG5vZGVJbnRlcm9wKTsgfVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqLCBub2RlSW50ZXJvcCkgeyBpZiAoIW5vZGVJbnRlcm9wICYmIG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgZGVmYXVsdDogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoa2V5ICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5mdW5jdGlvbiBqZXN0RmFrZVRpbWVyc0FyZUVuYWJsZWQoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0eXBlb2YgamVzdCAhPT0gJ3VuZGVmaW5lZCcgJiYgamVzdCAhPT0gbnVsbCkge1xuICAgIHJldHVybiAoXG4gICAgICAvLyBsZWdhY3kgdGltZXJzXG4gICAgICBzZXRUaW1lb3V0Ll9pc01vY2tGdW5jdGlvbiA9PT0gdHJ1ZSB8fFxuICAgICAgLy8gbW9kZXJuIHRpbWVyc1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1vYmplY3QtaGFzLW93biAtLSBObyBPYmplY3QuaGFzT3duIGluIGFsbCB0YXJnZXQgZW52aXJvbm1lbnRzIHdlIHN1cHBvcnQuXG4gICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2V0VGltZW91dCwgJ2Nsb2NrJylcbiAgICApO1xuICB9IC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuKDAsIF9kb20uY29uZmlndXJlKSh7XG4gIHVuc3RhYmxlX2FkdmFuY2VUaW1lcnNXcmFwcGVyOiBjYiA9PiB7XG4gICAgcmV0dXJuICgwLCBfYWN0Q29tcGF0LmRlZmF1bHQpKGNiKTtcbiAgfSxcbiAgLy8gV2UganVzdCB3YW50IHRvIHJ1biBgd2FpdEZvcmAgd2l0aG91dCBJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlRcbiAgLy8gQnV0IHRoYXQncyBub3QgbmVjZXNzYXJpbHkgaG93IGBhc3luY1dyYXBwZXJgIGlzIHVzZWQgc2luY2UgaXQncyBhIHB1YmxpYyBtZXRob2QuXG4gIC8vIExldCdzIGp1c3QgaG9wZSBub2JvZHkgZWxzZSBpcyB1c2luZyBpdC5cbiAgYXN5bmNXcmFwcGVyOiBhc3luYyBjYiA9PiB7XG4gICAgY29uc3QgcHJldmlvdXNBY3RFbnZpcm9ubWVudCA9ICgwLCBfYWN0Q29tcGF0LmdldElzUmVhY3RBY3RFbnZpcm9ubWVudCkoKTtcbiAgICAoMCwgX2FjdENvbXBhdC5zZXRSZWFjdEFjdEVudmlyb25tZW50KShmYWxzZSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNiKCk7XG4gICAgICAvLyBEcmFpbiBtaWNyb3Rhc2sgcXVldWUuXG4gICAgICAvLyBPdGhlcndpc2Ugd2UnbGwgcmVzdG9yZSB0aGUgcHJldmlvdXMgYWN0KCkgZW52aXJvbm1lbnQsIGJlZm9yZSB3ZSByZXNvbHZlIHRoZSBgd2FpdEZvcmAgY2FsbC5cbiAgICAgIC8vIFRoZSBjYWxsZXIgd291bGQgaGF2ZSBubyBjaGFuY2UgdG8gd3JhcCB0aGUgaW4tZmxpZ2h0IFByb21pc2VzIGluIGBhY3QoKWBcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0sIDApO1xuICAgICAgICBpZiAoamVzdEZha2VUaW1lcnNBcmVFbmFibGVkKCkpIHtcbiAgICAgICAgICBqZXN0LmFkdmFuY2VUaW1lcnNCeVRpbWUoMCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgKDAsIF9hY3RDb21wYXQuc2V0UmVhY3RBY3RFbnZpcm9ubWVudCkocHJldmlvdXNBY3RFbnZpcm9ubWVudCk7XG4gICAgfVxuICB9LFxuICBldmVudFdyYXBwZXI6IGNiID0+IHtcbiAgICBsZXQgcmVzdWx0O1xuICAgICgwLCBfYWN0Q29tcGF0LmRlZmF1bHQpKCgpID0+IHtcbiAgICAgIHJlc3VsdCA9IGNiKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG5cbi8vIElkZWFsbHkgd2UnZCBqdXN0IHVzZSBhIFdlYWtNYXAgd2hlcmUgY29udGFpbmVycyBhcmUga2V5cyBhbmQgcm9vdHMgYXJlIHZhbHVlcy5cbi8vIFdlIHVzZSB0d28gdmFyaWFibGVzIHNvIHRoYXQgd2UgY2FuIGJhaWwgb3V0IGluIGNvbnN0YW50IHRpbWUgd2hlbiB3ZSByZW5kZXIgd2l0aCBhIG5ldyBjb250YWluZXIgKG1vc3QgY29tbW9uIHVzZSBjYXNlKVxuLyoqXG4gKiBAdHlwZSB7U2V0PGltcG9ydCgncmVhY3QtZG9tJykuQ29udGFpbmVyPn1cbiAqL1xuY29uc3QgbW91bnRlZENvbnRhaW5lcnMgPSBuZXcgU2V0KCk7XG4vKipcbiAqIEB0eXBlIEFycmF5PHtjb250YWluZXI6IGltcG9ydCgncmVhY3QtZG9tJykuQ29udGFpbmVyLCByb290OiBSZXR1cm5UeXBlPHR5cGVvZiBjcmVhdGVDb25jdXJyZW50Um9vdD59PlxuICovXG5jb25zdCBtb3VudGVkUm9vdEVudHJpZXMgPSBbXTtcbmZ1bmN0aW9uIGNyZWF0ZUNvbmN1cnJlbnRSb290KGNvbnRhaW5lciwge1xuICBoeWRyYXRlLFxuICB1aSxcbiAgd3JhcHBlcjogV3JhcHBlckNvbXBvbmVudFxufSkge1xuICBsZXQgcm9vdDtcbiAgaWYgKGh5ZHJhdGUpIHtcbiAgICAoMCwgX2FjdENvbXBhdC5kZWZhdWx0KSgoKSA9PiB7XG4gICAgICByb290ID0gUmVhY3RET01DbGllbnQuaHlkcmF0ZVJvb3QoY29udGFpbmVyLCBXcmFwcGVyQ29tcG9uZW50ID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoV3JhcHBlckNvbXBvbmVudCwgbnVsbCwgdWkpIDogdWkpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJvb3QgPSBSZWFjdERPTUNsaWVudC5jcmVhdGVSb290KGNvbnRhaW5lcik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBoeWRyYXRlKCkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIWh5ZHJhdGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0ZWQgdG8gaHlkcmF0ZSBhIG5vbi1oeWRyYXRlYWJsZSByb290LiBUaGlzIGlzIGEgYnVnIGluIGBAdGVzdGluZy1saWJyYXJ5L3JlYWN0YC4nKTtcbiAgICAgIH1cbiAgICAgIC8vIE5vdGhpbmcgdG8gZG8gc2luY2UgaHlkcmF0aW9uIGhhcHBlbnMgd2hlbiBjcmVhdGluZyB0aGUgcm9vdCBvYmplY3QuXG4gICAgfSxcblxuICAgIHJlbmRlcihlbGVtZW50KSB7XG4gICAgICByb290LnJlbmRlcihlbGVtZW50KTtcbiAgICB9LFxuICAgIHVubW91bnQoKSB7XG4gICAgICByb290LnVubW91bnQoKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVMZWdhY3lSb290KGNvbnRhaW5lcikge1xuICByZXR1cm4ge1xuICAgIGh5ZHJhdGUoZWxlbWVudCkge1xuICAgICAgX3JlYWN0RG9tLmRlZmF1bHQuaHlkcmF0ZShlbGVtZW50LCBjb250YWluZXIpO1xuICAgIH0sXG4gICAgcmVuZGVyKGVsZW1lbnQpIHtcbiAgICAgIF9yZWFjdERvbS5kZWZhdWx0LnJlbmRlcihlbGVtZW50LCBjb250YWluZXIpO1xuICAgIH0sXG4gICAgdW5tb3VudCgpIHtcbiAgICAgIF9yZWFjdERvbS5kZWZhdWx0LnVubW91bnRDb21wb25lbnRBdE5vZGUoY29udGFpbmVyKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiByZW5kZXJSb290KHVpLCB7XG4gIGJhc2VFbGVtZW50LFxuICBjb250YWluZXIsXG4gIGh5ZHJhdGUsXG4gIHF1ZXJpZXMsXG4gIHJvb3QsXG4gIHdyYXBwZXI6IFdyYXBwZXJDb21wb25lbnRcbn0pIHtcbiAgY29uc3Qgd3JhcFVpSWZOZWVkZWQgPSBpbm5lckVsZW1lbnQgPT4gV3JhcHBlckNvbXBvbmVudCA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFdyYXBwZXJDb21wb25lbnQsIG51bGwsIGlubmVyRWxlbWVudCkgOiBpbm5lckVsZW1lbnQ7XG4gICgwLCBfYWN0Q29tcGF0LmRlZmF1bHQpKCgpID0+IHtcbiAgICBpZiAoaHlkcmF0ZSkge1xuICAgICAgcm9vdC5oeWRyYXRlKHdyYXBVaUlmTmVlZGVkKHVpKSwgY29udGFpbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm9vdC5yZW5kZXIod3JhcFVpSWZOZWVkZWQodWkpLCBjb250YWluZXIpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgY29udGFpbmVyLFxuICAgIGJhc2VFbGVtZW50LFxuICAgIGRlYnVnOiAoZWwgPSBiYXNlRWxlbWVudCwgbWF4TGVuZ3RoLCBvcHRpb25zKSA9PiBBcnJheS5pc0FycmF5KGVsKSA/XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBlbC5mb3JFYWNoKGUgPT4gY29uc29sZS5sb2coKDAsIF9kb20ucHJldHR5RE9NKShlLCBtYXhMZW5ndGgsIG9wdGlvbnMpKSkgOlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlLFxuICAgIGNvbnNvbGUubG9nKCgwLCBfZG9tLnByZXR0eURPTSkoZWwsIG1heExlbmd0aCwgb3B0aW9ucykpLFxuICAgIHVubW91bnQ6ICgpID0+IHtcbiAgICAgICgwLCBfYWN0Q29tcGF0LmRlZmF1bHQpKCgpID0+IHtcbiAgICAgICAgcm9vdC51bm1vdW50KCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHJlcmVuZGVyOiByZXJlbmRlclVpID0+IHtcbiAgICAgIHJlbmRlclJvb3Qod3JhcFVpSWZOZWVkZWQocmVyZW5kZXJVaSksIHtcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBiYXNlRWxlbWVudCxcbiAgICAgICAgcm9vdFxuICAgICAgfSk7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGRvIG5vdCByZXR1cm4gYW55dGhpbmcgdG8gYXZvaWQgdW5uZWNlc3NhcmlseSBjb21wbGljYXRpbmcgdGhlIEFQSS5cbiAgICAgIC8vIGZvbGtzIGNhbiB1c2UgYWxsIHRoZSBzYW1lIHV0aWxpdGllcyB3ZSByZXR1cm4gaW4gdGhlIGZpcnN0IHBsYWNlIHRoYXQgYXJlIGJvdW5kIHRvIHRoZSBjb250YWluZXJcbiAgICB9LFxuXG4gICAgYXNGcmFnbWVudDogKCkgPT4ge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKG9sZCBqc2RvbSBsaW1pdGF0aW9uKSAqL1xuICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudC5jcmVhdGVSYW5nZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKS5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQoY29udGFpbmVyLmlubmVySFRNTCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IGNvbnRhaW5lci5pbm5lckhUTUw7XG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZS5jb250ZW50O1xuICAgICAgfVxuICAgIH0sXG4gICAgLi4uKDAsIF9kb20uZ2V0UXVlcmllc0ZvckVsZW1lbnQpKGJhc2VFbGVtZW50LCBxdWVyaWVzKVxuICB9O1xufVxuZnVuY3Rpb24gcmVuZGVyKHVpLCB7XG4gIGNvbnRhaW5lcixcbiAgYmFzZUVsZW1lbnQgPSBjb250YWluZXIsXG4gIGxlZ2FjeVJvb3QgPSBmYWxzZSxcbiAgcXVlcmllcyxcbiAgaHlkcmF0ZSA9IGZhbHNlLFxuICB3cmFwcGVyXG59ID0ge30pIHtcbiAgaWYgKCFiYXNlRWxlbWVudCkge1xuICAgIC8vIGRlZmF1bHQgdG8gZG9jdW1lbnQuYm9keSBpbnN0ZWFkIG9mIGRvY3VtZW50RWxlbWVudCB0byBhdm9pZCBvdXRwdXQgb2YgcG90ZW50aWFsbHktbGFyZ2VcbiAgICAvLyBoZWFkIGVsZW1lbnRzIChzdWNoIGFzIEpTUyBzdHlsZSBibG9ja3MpIGluIGRlYnVnIG91dHB1dFxuICAgIGJhc2VFbGVtZW50ID0gZG9jdW1lbnQuYm9keTtcbiAgfVxuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIGNvbnRhaW5lciA9IGJhc2VFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKTtcbiAgfVxuICBsZXQgcm9vdDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lZ2F0ZWQtY29uZGl0aW9uIC0tIHdlIHdhbnQgdG8gbWFwIHRoZSBldm9sdXRpb24gb2YgdGhpcyBvdmVyIHRpbWUuIFRoZSByb290IGlzIGNyZWF0ZWQgZmlyc3QuIE9ubHkgbGF0ZXIgaXMgaXQgcmUtdXNlZCBzbyB3ZSBkb24ndCB3YW50IHRvIHJlYWQgdGhlIGNhc2UgdGhhdCBoYXBwZW5zIGxhdGVyIGZpcnN0LlxuICBpZiAoIW1vdW50ZWRDb250YWluZXJzLmhhcyhjb250YWluZXIpKSB7XG4gICAgY29uc3QgY3JlYXRlUm9vdEltcGwgPSBsZWdhY3lSb290ID8gY3JlYXRlTGVnYWN5Um9vdCA6IGNyZWF0ZUNvbmN1cnJlbnRSb290O1xuICAgIHJvb3QgPSBjcmVhdGVSb290SW1wbChjb250YWluZXIsIHtcbiAgICAgIGh5ZHJhdGUsXG4gICAgICB1aSxcbiAgICAgIHdyYXBwZXJcbiAgICB9KTtcbiAgICBtb3VudGVkUm9vdEVudHJpZXMucHVzaCh7XG4gICAgICBjb250YWluZXIsXG4gICAgICByb290XG4gICAgfSk7XG4gICAgLy8gd2UnbGwgYWRkIGl0IHRvIHRoZSBtb3VudGVkIGNvbnRhaW5lcnMgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIGl0J3MgYWN0dWFsbHlcbiAgICAvLyBhZGRlZCB0byBkb2N1bWVudC5ib2R5IHNvIHRoZSBjbGVhbnVwIG1ldGhvZCB3b3JrcyByZWdhcmRsZXNzIG9mIHdoZXRoZXJcbiAgICAvLyB0aGV5J3JlIHBhc3NpbmcgdXMgYSBjdXN0b20gY29udGFpbmVyIG9yIG5vdC5cbiAgICBtb3VudGVkQ29udGFpbmVycy5hZGQoY29udGFpbmVyKTtcbiAgfSBlbHNlIHtcbiAgICBtb3VudGVkUm9vdEVudHJpZXMuZm9yRWFjaChyb290RW50cnkgPT4ge1xuICAgICAgLy8gRWxzZSBpcyB1bnJlYWNoYWJsZSBzaW5jZSBgbW91bnRlZENvbnRhaW5lcnNgIGhhcyB0aGUgYGNvbnRhaW5lcmAuXG4gICAgICAvLyBPbmx5IHJlYWNoYWJsZSBpZiBvbmUgd291bGQgYWNjaWRlbnRhbGx5IGFkZCB0aGUgY29udGFpbmVyIHRvIGBtb3VudGVkQ29udGFpbmVyc2AgYnV0IG5vdCB0aGUgcm9vdCB0byBgbW91bnRlZFJvb3RFbnRyaWVzYFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChyb290RW50cnkuY29udGFpbmVyID09PSBjb250YWluZXIpIHtcbiAgICAgICAgcm9vdCA9IHJvb3RFbnRyeS5yb290O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZW5kZXJSb290KHVpLCB7XG4gICAgY29udGFpbmVyLFxuICAgIGJhc2VFbGVtZW50LFxuICAgIHF1ZXJpZXMsXG4gICAgaHlkcmF0ZSxcbiAgICB3cmFwcGVyLFxuICAgIHJvb3RcbiAgfSk7XG59XG5mdW5jdGlvbiBjbGVhbnVwKCkge1xuICBtb3VudGVkUm9vdEVudHJpZXMuZm9yRWFjaCgoe1xuICAgIHJvb3QsXG4gICAgY29udGFpbmVyXG4gIH0pID0+IHtcbiAgICAoMCwgX2FjdENvbXBhdC5kZWZhdWx0KSgoKSA9PiB7XG4gICAgICByb290LnVubW91bnQoKTtcbiAgICB9KTtcbiAgICBpZiAoY29udGFpbmVyLnBhcmVudE5vZGUgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoY29udGFpbmVyKTtcbiAgICB9XG4gIH0pO1xuICBtb3VudGVkUm9vdEVudHJpZXMubGVuZ3RoID0gMDtcbiAgbW91bnRlZENvbnRhaW5lcnMuY2xlYXIoKTtcbn1cbmZ1bmN0aW9uIHJlbmRlckhvb2socmVuZGVyQ2FsbGJhY2ssIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgaW5pdGlhbFByb3BzLFxuICAgIC4uLnJlbmRlck9wdGlvbnNcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHJlc3VsdCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVSZWYoKTtcbiAgZnVuY3Rpb24gVGVzdENvbXBvbmVudCh7XG4gICAgcmVuZGVyQ2FsbGJhY2tQcm9wc1xuICB9KSB7XG4gICAgY29uc3QgcGVuZGluZ1Jlc3VsdCA9IHJlbmRlckNhbGxiYWNrKHJlbmRlckNhbGxiYWNrUHJvcHMpO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICByZXN1bHQuY3VycmVudCA9IHBlbmRpbmdSZXN1bHQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3Qge1xuICAgIHJlcmVuZGVyOiBiYXNlUmVyZW5kZXIsXG4gICAgdW5tb3VudFxuICB9ID0gcmVuZGVyKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChUZXN0Q29tcG9uZW50LCB7XG4gICAgcmVuZGVyQ2FsbGJhY2tQcm9wczogaW5pdGlhbFByb3BzXG4gIH0pLCByZW5kZXJPcHRpb25zKTtcbiAgZnVuY3Rpb24gcmVyZW5kZXIocmVyZW5kZXJDYWxsYmFja1Byb3BzKSB7XG4gICAgcmV0dXJuIGJhc2VSZXJlbmRlciggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVGVzdENvbXBvbmVudCwge1xuICAgICAgcmVuZGVyQ2FsbGJhY2tQcm9wczogcmVyZW5kZXJDYWxsYmFja1Byb3BzXG4gICAgfSkpO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmVzdWx0LFxuICAgIHJlcmVuZGVyLFxuICAgIHVubW91bnRcbiAgfTtcbn1cblxuLy8ganVzdCByZS1leHBvcnQgZXZlcnl0aGluZyBmcm9tIGRvbS10ZXN0aW5nLWxpYnJhcnlcblxuLyogZXNsaW50IGZ1bmMtbmFtZS1tYXRjaGluZzowICovIl0sIm1hcHBpbmdzIjoiQUFBQSxZQUFZOztBQUVaLElBQUlBLHNCQUFzQixHQUFHQyxPQUFPLENBQUMsOENBQThDLENBQUM7QUFDcEZDLE1BQU0sQ0FBQ0MsY0FBYyxDQUFDQyxPQUFPLEVBQUUsWUFBWSxFQUFFO0VBQzNDQyxLQUFLLEVBQUU7QUFDVCxDQUFDLENBQUM7QUFDRixJQUFJQyxZQUFZLEdBQUc7RUFDakJDLE1BQU0sRUFBRSxJQUFJO0VBQ1pDLFVBQVUsRUFBRSxJQUFJO0VBQ2hCQyxPQUFPLEVBQUUsSUFBSTtFQUNiQyxHQUFHLEVBQUUsSUFBSTtFQUNUQyxTQUFTLEVBQUU7QUFDYixDQUFDO0FBQ0RULE1BQU0sQ0FBQ0MsY0FBYyxDQUFDQyxPQUFPLEVBQUUsS0FBSyxFQUFFO0VBQ3BDUSxVQUFVLEVBQUUsSUFBSTtFQUNoQkMsR0FBRyxF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